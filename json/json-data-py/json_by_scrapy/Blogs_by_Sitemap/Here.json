[
{"website": "Here", "title": "HERE Studio 1.8.0 Launched", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-studio-1.8.0-launched", "abstract": "We’re excited to bring new features with the release of HERE Studio 1.8.0. This update extends support for the Data Hub Add-on feature we first announced back in March. Along with better support for our Data Hub Add-on feature set, general bugs and usability issues have been corrected. Let's take a quick look through the updates. Remember you can sign up for a free developer account and start playing with Studio immediately! Adding Data to Spaces You can now add data to an existing space in Studio. To do so, go into one of your projects and click the +Data link. In this view, you can click the \"+\" symbol under the data column to upload new information to the space: Using Add-on Features In the same area we just showed, take a gander at the \"Add On\" button. This lets you enable three incredible features if you've enabled this product. Click to open a new dialog: From this dialog you can enable three unique and powerful features. The first, Schema Validation , allows you to apply validation logic to your space. This ensures that any new data added follows a particular format. So, for example, if your space contains features describing stores, you may want to ensure that new features all have properties for the store's open hours, types of products sold, and so forth. JSON Schema is an advanced topic, but you can check out our docs for more information as well as checking out the tutorial we wrote that shows an example. The next feature, Activity Log , allows you to enable history tracking for your data. At this time, you cannot enable it for existing spaces, so you may need to create a copy of your space if you wish to enable this feature. For more information on working with the Activity Log, check the documentation . Note that working with your Activity Log will require custom programming outside of Studio itself. We'll have a blog post discussing this more later. The final new feature you can enable are Virtual Spaces . Virtual Spaces allow you to take multiple spaces and treat them as one. There's two ways of creating a virtual space. The \"Group\" option simply throws all the data into a bucket together, while \"Merge\" associates data in one space with another, much like a join operation on database tables. You can read more about it at the docs and read this tutorial for an example. Once a virtual space is created Studio can then make use of it and expose multiple different sets of data as one unified map! Note that - currently - you cannot use hexbins with virtual spaces. What Next? Studio is constantly updating and evolving, and we can always use your help. You can report an issue or send us a suggestion about what you think should be added next. If you create a beautiful map, be sure to tag us on Twitter at @heredev !", "date": "2020-08-05"},
{"website": "Here", "title": "How to use Geocoding in Java with the HERE Geocoding & Search API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/how-to-use-geocoding-in-java-with-the-here-geocoding-search-api", "abstract": "40.70714,-74.01086 Do you know what these two numbers are? These are the latitude and longitude of the famous Wall Street in New York. Do you know how I was able to get these? I used the HERE Geocoding & Search API . Geocoding is the process of converting a street address into geographic coordinates like latitude and longitude. Let’s see how we can write a Java application to do this! This blog post is about using the HERE Geocoding & Search API with Java. Specifically, we will be looking at forward Geocoding, which is the process of converting a street address into geographic coordinates (latitude and longitude). Let’s get started! The HERE Geocoding & Search API The HERE Geocoding & Search API is a REST API which returns a JSON response. For example, to geocode the street address “11 Wall St, New York, NY 10005” into geographic coordinates, we can use the following API call: https://geocode.search.hereapi.com/v1/geocode\n?apiKey=YOUR_API_KEY\n&q=11 Wall St, New York, NY 10005 The response will then look as follows. {\n    \"items\": [\n        {\n            \"title\": \"11 Wall St, New York, NY 10005-1916, United States\",\n            \"id\": \"here:af:streetsection:-7Fh2DzbEeXIadSOteSAOB:CggIBCCEwoHNAhABGgIxMShk\",\n            \"resultType\": \"houseNumber\",\n            \"houseNumberType\": \"PA\",\n            \"address\": {\n                \"label\": \"11 Wall St, New York, NY 10005-1916, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"New York\",\n                \"county\": \"New York\",\n                \"city\": \"New York\",\n                \"district\": \"Financial District\",\n                \"street\": \"Wall St\",\n                \"postalCode\": \"10005-1916\",\n                \"houseNumber\": \"11\"\n            },\n            \"position\": {\n                \"lat\": 40.70714,\n                \"lng\": -74.01086\n            },\n            \"access\": [\n                {\n                    \"lat\": 40.70721,\n                    \"lng\": -74.01079\n                }\n            ],\n            \"mapView\": {\n                \"west\": -74.01205,\n                \"south\": 40.70624,\n                \"east\": -74.00967,\n                \"north\": 40.70804\n            },\n            \"scoring\": {\n                \"queryScore\": 1.0,\n                \"fieldScore\": {\n                    \"state\": 1.0,\n                    \"city\": 1.0,\n                    \"streets\": [\n                        1.0\n                    ],\n                    \"houseNumber\": 1.0,\n                    \"postalCode\": 1.0\n                }\n            }\n        }\n    ]\n} As we can see, it contains the position of the address as a geocoordinates and it provides details about the address itself, like the full postal code and district name. Prerequisites To use this API in Java, we need to be able make HTTP calls to the Geocoding & Search API as well as parse the JSON response. To call the API, we will be using the HttpClient , which has been available since Java 11. Unfortunately, Java does not have built-in JSON support, so we will be using an external library called Jackson to parse the response. To include Jackson in our project, we add the following to the dependencies in our build.gradle file. dependencies {\n\timplementation 'com.fasterxml.jackson.core:jackson-databind:2.11.0'\n} If using Maven, we can include this dependency. com.fasterxml.jackson.core\n    jackson-databind\n    2.11.0 Calling the Geocoding & Search API (with HttpClient) The following example creates a class Geocoder with a method GeocodeSync . This method synchronously calls the Geocoding & Search API using an HttpClient . (We will look at an asynchronous example below.) import java.io.IOException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class Geocoder {\n\n    private static final String GEOCODING_RESOURCE = \"https://geocode.search.hereapi.com/v1/geocode\";\n    private static final String API_KEY = \"YOUR_API_KEY\";\n\n    public String GeocodeSync(String query) throws IOException, InterruptedException {\n\n        HttpClient httpClient = HttpClient.newHttpClient();\n\n        String encodedQuery = URLEncoder.encode(query,\"UTF-8\");\n        String requestUri = GEOCODING_RESOURCE + \"?apiKey=\" + API_KEY + \"&q=\" + encodedQuery;\n\n        HttpRequest geocodingRequest = HttpRequest.newBuilder().GET().uri(URI.create(requestUri))\n                .timeout(Duration.ofMillis(2000)).build();\n\n        HttpResponse geocodingResponse = httpClient.send(geocodingRequest,\n                HttpResponse.BodyHandlers.ofString());\n\n        return geocodingResponse.body();\n    }\n\n} Let’s walk through this code in detail. First, we need to create an HttpClient instance. You can use the class’s builder to set various options, but for us the default options are just fine. We can therefore use the default constructor HttpClient.newHttpClient() . Next, we need to create a URI to pass into an HttpRequest object. This URI is simply the REST API call from the first part of this blog post. It consists of a resource and various parameters. The minimum required parameters for a geocoding request are an apiKey (your credentials) and a query string q (the address you want to geocode). Note that there are additional parameters available, which you can check out in the API Reference . If you’re wondering where to get credentials, you can sign-up for our Freemium plan , which gives you 250.000 API transactions for free every month. Yes, that means 250.000 geocodes (or other API calls) for free, not even a credit card required. Note that the HttpClient does not provide a URI components builder, so we are concatenating the resource and parameters manually. Be sure to encode the query string correctly using URLEncode . Next, we create an HttpRequest object, which we build using our URI and a timeout (we should always provide a timeout, otherwise the request may wait forever). Note that a request is immutable once created and can be sent multiple times. We then pass our HttpRequest to the HttpClient and send() it. Using the appropriate BodyHandler we tell the HttpRequest to handle the response as a string. Finally, the .body() function of the HttpResponse instance will return the JSON response as a string. (Note that we are omitting error handling here but be sure to check geocodingResponse.statusCode() and handle any non-200 responses accordingly). Parsing the API Response In the following example we are using Jackson to parse the API response and log both the geocoordinates and the full address from the response. import java.io.IOException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class GeocodingExample {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        Geocoder geocoder = new Geocoder();\n\n        String response = geocoder.GeocodeSync(\"11 Wall St, New York, NY 10005\");\n        JsonNode responseJsonNode = mapper.readTree(response);\n\n        JsonNode items = responseJsonNode.get(\"items\");\n\n        for (JsonNode item : items) {\n            JsonNode address = item.get(\"address\");\n            String label = address.get(\"label\").asText();\n            JsonNode position = item.get(\"position\");\n\n            String lat = position.get(\"lat\").asText();\n            String lng = position.get(\"lng\").asText();\n            System.out.println(label + \" is located at \" + lat + \",\" + lng + \".\");\n        }\n    }\n} Once again, let’s look at this in more detail. Jackson provides a class called ObjectMapper which allows us to deserialize our JSON String into Java objects. We will use the method readTree() to convert our response into a tree structure of JsonNode objects. This tree will reflect the structure of our original JSON response. Using the method get() on a JsonNode instance allows us to get the value for a given key. Let’s look back at the example from the beginning of the blog post to understand how a response looks like. You will notice that the API returns not just one result, but a whole list of items . This is because the HERE Geocoding & Search API is capable of geocoding even incomplete or misspelled queries. These queries can be ambiguous, which means the API will return multiple matching results. (Try geocoding “11 Wall St, New York”, without the postal code to see an example of this.) We therefore need to iterate over all items in the response. Each item then contains an address and a position entry. From these we grab the label and lat , lng values, respectively. If we did everything correctly, our code should now log the following to the console. > Task :GeocodingExample.main()\n11 Wall St, New York, NY 10005-1916, United States is located at 40.70714,-74.01086. That’s it! We’ve successfully geocoded an address in Java.! Calling the Geocoding API Asynchronously In many cases you may not wish to call the API synchronously. [PS5] The example below achieves the same result as above but calls the API asynchronously. The main difference is that the GeocodeAsync function returns a CompletableFuture on which we can call join() to block and get the response. import java.io.IOException;\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class Geocoder {\n    \n    private static final String GEOCODING_RESOURCE = \"https://geocode.search.hereapi.com/v1/geocode\";\n    private static final String API_KEY = \"YOUR_API_KEY\";\n\n    public CompletableFuture<httpresponse> GeocodeAsync(String query) throws IOException, InterruptedException {\n\n        HttpClient httpClient = HttpClient.newHttpClient();\n\n        String encodedQuery = URLEncoder.encode(query,\"UTF-8\");\n        String REQUEST_URI = GEOCODING_RESOURCE + \"?apiKey=\" + API_KEY + \"&q=\" + encodedQuery;\n\n        HttpRequest geocodingRequest = HttpRequest.newBuilder().GET().uri(URI.create(REQUEST_URI))\n                .timeout(Duration.ofMillis(500)).build();\n\n        CompletableFuture<httpresponse> response = httpClient.sendAsync(geocodingRequest, HttpResponse.BodyHandlers.ofString());\n        return response;\n    }\n\n}\n</httpresponse</httpresponse import java.io.IOException;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class GeocodingExample {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n\n        ObjectMapper mapper = new ObjectMapper();\n        Geocoder geocoder = new Geocoder();\n\n        CompletableFuture<httpresponse> futureResponse = geocoder.GeocodeAsync(\"11 Wall St, New York, NY 10005\");\n        String response = futureResponse.join().body();\n        JsonNode responseJsonNode = mapper.readTree(response);\n\n        JsonNode items = responseJsonNode.get(\"items\");\n\n        for (JsonNode item : items) {\n            JsonNode address = item.get(\"address\");\n            String label = address.get(\"label\").asText();\n            JsonNode position = item.get(\"position\");\n\n            String lat = position.get(\"lat\").asText();\n            String lng = position.get(\"lng\").asText();\n            System.out.println(label + \" is located at \" + lat + \",\" + lng + \".\");\n        }\n    }\n}\n</httpresponse Please let us know in the comments if this was helpful to you and if you’d like more Java-specific content. Happy Coding", "date": "2020-08-10"},
{"website": "Here", "title": "Advanced Maps Data Sets: Display Road Names Within a Box", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/advanced-maps-data-sets-display-road-names-within-a-box", "abstract": "In the last blog post on the HERE Advanced Map Data Sets API I talked about displaying complete geometric layers on the map. In this blog post, I will discuss about applying spatial filters to these layers. Let's begin! From the first blog post about HERE Advanced Map Data Sets, we learned that map data is arranged in tiles and organized as attributes with key-value pairs. In the second post we found out that there are geometric layers and attribute layers. We then rendered a geometric layer on the map. This layer displayed all the public transport stations in the world. Now, let’s learn how to filter these layers to return map data within certain areas using spatial filters. Consider the following use-case: The user wants to draw a box on the map and get all road names within that box. Select a layer First you need to choose a suitable layer which has this information. A quick call to the list available attributes endpoint will tell you that road names are available in the layer ROAD_GEOM_FC1..5 . GET https://s.fleet.ls.hereapi.com/1/doc/attributes.json?apiKey={YOUR_API_KEY} ... \n    {\n        \"name\": \"NAME\",\n        \"description\": \"A name of this road line. Roads can have multiple names, in the same or multiple languages. This field contains any of those.\",\n        \"layers\": [\n            \"ROAD_GEOM_FC1\",\n            \"ROAD_GEOM_FC2\",\n            \"ROAD_GEOM_FC3\",\n            \"ROAD_GEOM_FC4\",\n            \"ROAD_GEOM_FC5\"\n        ]\n    },\n    ... Once you get details about this layer, you will learn that the numbers at the end of the layer name, correspond to the road functional classes. So, ROAD_GEOM_FC1 has names of all the major national roads (roads that allow for high volume, maximum speed traffic movement between and through major metropolitan areas). While ROAD_GEOM_FC5 holds the details of the tiny roads with the least volume and traffic (walkways, emergency vehicle only roads, access roads, parking lanes, etc.). Depending on the road names you need, you will need to query one or all the layers. Filtering Depending on your use-case, you can apply 4 types of spatial filters to the geometric data sets. Bounding Box- search within a box Corridor- search along a corridor/ road Proximity- search within a circle Quad Key- search through the grid location of a map tile which combines the zoom level, column and row information for a tile in a one value. For this use-case, we will use the bounding box search . To define the bounding box, use the same convention that you would use for drawing the map object rectangle. This means, you need the top-left latitude, top-left longitude, bottom-right latitude and bottom-right longitude of this box. The main parameter here is the layer_id . For bounding box search, you can specify only a single layer name at a time. As we want to get all road names within the box, we will loop this request for all 5 ROAD_GEOM_FC layers. However, for corridor search and proximity search, you can specify multiple layers under layer_ids. function printRoadNames(){\n\n        for(i=1; i<=5; i++){\n\n\n            var url = `https://s.fleet.ls.hereapi.com/1/search/bbox.json?`+\n            `apiKey=YOUR_API_KEY`+\n            `&layer_id=ROAD_GEOM_FC`+`${i}`+\n            `&key_attribute=NAME`+\n            `&bbox=${rectTopLeft.lat}`+`,`+`${rectTopLeft.lng}`+`;`+\n            `${rectBottomRight.lat}`+`,`+`${rectBottomRight.lng}`+\n            // `&bbox=52.45583,13.38771;52.45248,13.39629`+\n            `&geom=local`;\n\n\n            fetch(url)\n            .then(result => result.json())\n            .then(result => {\n\n                result.geometries.forEach(road => {\n                    if(road.attributes.NAME!=null){\n                        document.getElementById(\"panel\").innerHTML+=` `+road.attributes.NAME;\n                    }\n                    \n                    \n                });\n            })\n            .catch(error =>{\n                console.error(error);\n            })\n        \n        }\n    } While handling the results, I have just printed the road names. You can use the other return parameters of the layer to form your result. Conclusion So, in just 2 steps you can use the HERE Advanced Map Data Sets to display data within a given area. The recommended way to use Fleet Telematics Advanced Data Sets is the tile interface, with caching on the client side. If you want an example that filters the Advanced Data Set along a road (corridor), check out the code snippet from day 85 of 100DaysOfCode with HERE . Also, if you haven’t done it yet, get your freemium apikeys form developer.here.com .", "date": "2020-08-12"},
{"website": "Here", "title": "Visual Recognition with IBM Watson, HERE and Python - Part 2", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/visual-recognition-with-ibm-watson-here-and-python-part-2", "abstract": "This is the second blog post in a two - part blog series about application of visual recognition using Python. In part one , we acquired credentials from IBM Cloud and detected food images using visual recognition service of IBM Watson . Now we will learn how to integrate location services to find the places which offer the type of food we recognized . Architecture Here’s the big picture for how the different components interact: First the user passes an image and location (latitude and longitude information) to the Python application Watson Visual Recognition’s food detection model returns its predict ed food name as a string Python application quer ies the HERE Discover API with the food name and location Prerequisites The requirements are same as for the Part 1 : An IBM Cloud account (you can sign up here ) Python 3.8 and pip A Freemium account on the HERE Developer Portal When it comes to testing your application, y ou will also need a food image . If you’d like to use the image below, feel free to download and save it as ‘test.png’ for this blog we will be using below given image, save it as ‘test.png’. Integrating Flask in the visual recognition Python code With the help of code created in part 1 , we are able to recognize an image of food and get a match as ‘Pizza’. Save the below code as ‘my_code.py’ in a folder with ‘test.png’ import json \nfrom ibm_watson import VisualRecognitionV3 \nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator \n\n# Passing API KEY and URL to the Visual Recognition \nauthenticator = IAMAuthenticator('IBM_API_KEY') \n\nvisual_recognition = VisualRecognitionV3( \n    version='2018-03-19', \n    authenticator=authenticator) \n\nvisual_recognition.set_service_url('IBM_URL')  \n\n# Running the Visual Recognition on test.img file \nwith open('./test.jpg', 'rb') as image:  \n    classes = visual_recognition.classify(images_file=image,threshold='0.6',classifier_ids='food').get_result() \n\noutput_query = classes['images'][0]['classifiers'][0]['classes'][1]['class'] \nprint(output_query) When the above code is executed, it will recognize the image and print ‘pizza’ ( f or details on how this code work s check out Part 1 ) Next, we have to pass the acquired string (pizza) to a F lask code along with the location (latitude and longitude)  data. To work with Flask, which is a micro web framework for creating web applications, run an installation command: pip install Flask from flask import Flask,render_template  \n\n#Somewhere in Bangalore, India \nlatitude = 12.959111 \nlongitude = 77.732022 \n\napp = Flask(__name__) \n\n@app.route('/') \n\ndef map_func(): \n    return render_template('map.html', \n                            latitude = latitude, \n                            longitude = longitude, \n                            output_query=output_query \n                            ) \n\nif __name__ == '__main__': \n    app.run(debug = True) The above code represents a simple F lask template in which we have imported two sub-packages of F lask, viz., Flask and render_template . Also, we have created a function called the “map_func”. This function returns a jinga2 html page and passes the output_query(pizza), latitude and longitude to our HTML code (yes, we will need HTML too). Showing your location on a map as an icon Now l et’s create an HTML file and call it “map.html” to display the results on a map. <html>   \n<head>   \n<meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" />\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> \n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/> \n</head> \n\n<body style='margin: 0'> \n<div id=\"mapContainer\" style=\"width: 90vw; height: 80vh; display: block; margin: 0 auto; border: solid 2px black; margin-top: 10px;\" >\n</div> \n <div style=\"width: 100vw; height: 40px; margin-top: 30px;\"> \n <input type=\"button\" onclick=\"showRestaurants()\" value = \"Show Restaurants\" style=\"width: 200px; height: 30px; border: 2px solid black; display: block; margin: 0 auto; margin-top: 20px;\"> \n </div>\n</body> \n\n<script>    \n    const lat = {{latitude}}; \n    const lng = {{longitude}}; \n    var query = \"{{output_query}}\"; \n\n    //Initialise communication with backend services \n     var platform = new H.service.Platform({ \n            apikey: \"JS_API_KEY\"    \n        }); \n\n    // Obtain the default map types from the platform object: \n    var defaultLayers = platform.createDefaultLayers(); \n\n    // Get your current position from wego.here.com \n    var myPosition = {lat: lat, lng: lng}; \n\n    // Instantiate (and display) a map object: \n    var map = new H.Map( \n        document.getElementById('mapContainer'), \n        defaultLayers.vector.normal.map, \n        { \n            zoom: 15, \n            center: myPosition \n        }); \n\n    //zoom and view controls \n    var ui = H.ui.UI.createDefault(map, defaultLayers, 'en-US'); \n\n    //Move around the map \n    var mapEvents = new H.mapevents.MapEvents(map); \n    var behavior = new H.mapevents.Behavior(mapEvents); \n\n    // create an icon for the marker. Choose any image you want. \n    var homeIcon = new H.map.Icon('/static/YOUR_IMAGE');  \n\n    // Create a marker using the previously instantiated icon: \n    var posMarker = new H.map.Marker(myPosition,{icon:homeIcon}); \n\n    // Add the marker to the map  \n    map.addObject(posMarker);    \n</script>\n</html> The above code when executed will show a map with an icon at the center showing your location and a button, which will not work right now since we have not written code for it. You will need to replace JS_API_KEY with the JavaScript API Key value acquired from HERE. You can get the value by signing up on Freemium account. Place an image you want to show as your location in a folder named “static”. Replace the name of image in code from YOUR_IMAGE to the name of image you pasted (for example home.png) Showing pizza serving places on map Next, we want to fetch the places which serves pizza around you and display them on the map. All this with a click of a button (Show Restaurants) Firstly, we will have to fetch all the pizza places near the provided location, for that we need an instance of the Geocoding and Search service. var service = platform.getSearchService(); Then, we need to put a logic in button click method function showRestaurants(){ \n            let param = { \n                at : myPosition.lat+','+myPosition.lng, \n                q: query, \n                limit:10 \n            };  \n            service.browse(param,displayRestaurants,alert); \n        } In the above code, ‘param’ is storing all the parameter we require to pass to our Discover endpoint of Geocoding and Search API. at – Your location query – Value passed from Python code (pizza) limit – Limiting our result to 10 values Note: If you run the code now it will show an error since we have not defined ‘displayRestaurants’ Lastly, we need to show the pizza places as a clickable icon on the map. function displayRestaurants(response){ \n            var restaurantIcon = new H.map.Icon('/static/PIZZA_IMAGE'); \n\n            // A group that can hold map objects: \n            var restGroup = new H.map.Group(); \n\n            for(let i = 0; i<response.items.length; i++){ \n                let restPosition = response.items[i].position; \n                let address = response.items[i].address.label; \n                 \n                let restMarker = new H.map.Marker(restPosition,{icon: restaurantIcon} ); \n                 \n                restMarker.setData(\"<p>\" + address + \"</p>\"); \n                 \n                restMarker.addEventListener('tap', function(evt){ \n                    var bubble =  new H.ui.InfoBubble(evt.target.getGeometry(), { \n\n                    // read custom data \n                    content: evt.target.getData() \n                }); \n\n                ui.addBubble(bubble); \n                }, false); \n\n                // Add the marker to the group (which causes it to be displayed on the map) \n                restGroup.addObject(restMarker); \n                } \n\n            // Add the group to the map object \n            map.addObject(restGroup); \n    } In the above code, you will have to place an image for pizza icon in the ‘static’ folder and replace the name PIZZA_IMAGE with your image name (like pizzaIcon.png). Complete HTML code <html>   \n<head>   \n<meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" />\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script> \n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> \n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/> \n</head> \n\n<body style='margin: 0'> \n<div id=\"mapContainer\" style=\"width: 90vw; height: 80vh; display: block; margin: 0 auto; border: solid 2px black; margin-top: 10px;\" >\n</div> \n <div style=\"width: 100vw; height: 40px; margin-top: 30px;\"> \n <input type=\"button\" onclick=\"showRestaurants()\" value = \"Show Restaurants\" style=\"width: 200px; height: 30px; border: 2px solid black; display: block; margin: 0 auto; margin-top: 20px;\"> \n </div>\n</body> \n\n<script>\n\tconst lat = {{latitude}};\n\tconst lng = {{longitude}};\n\tvar query = \"{{output_query}}\";\n\t\n\t//Initialise communication with backend services\n\t var platform = new H.service.Platform({\n            apikey: \"JS_HERE_API\"   \n        });\n\n\t// Obtain the default map types from the platform object:\n\tvar defaultLayers = platform.createDefaultLayers();\n\n\t// Get your current position from wego.here.com\n\tvar myPosition = {lat: lat, lng: lng};\n\n\t// Instantiate (and display) a map object:\n\tvar map = new H.Map(\n\t\tdocument.getElementById('mapContainer'),\n\t\tdefaultLayers.vector.normal.map,\n\t\t{\n\t\t\tzoom: 15,\n\t\t\tcenter: myPosition\n\t\t});\n\n\t//zoom and view controls\n\tvar ui = H.ui.UI.createDefault(map, defaultLayers, 'en-US');\n\n\t//Move around the map\n\tvar mapEvents = new H.mapevents.MapEvents(map);\n\tvar behavior = new H.mapevents.Behavior(mapEvents);\n\n\t// Get an instance of the geocoding and search service:\n\tvar service = platform.getSearchService();\n\t\n\t// create an icon for the marker. Choose any image you want.\n\tvar homeIcon = new H.map.Icon('/static/home.png'); \n\t\t\n\t// Create a marker using the previously instantiated icon:\n\tvar posMarker = new H.map.Marker(myPosition,{icon:homeIcon});\n\t\t\t\n\t// Add the marker to the map \n\tmap.addObject(posMarker);\n\t\n\tfunction showRestaurants(){\n\t\t\tlet param = {\n\t\t\t\tat : myPosition.lat+','+myPosition.lng,\n\t\t\t\tq: query,\n\t\t\t\tlimit:10\n\t\t\t}; \n\n\t\t\tservice.browse(param,displayRestaurants,alert);\n\t\t}\n\tfunction displayRestaurants(response){\n\t\t\tvar restaurantIcon = new H.map.Icon('/static/pizzaIcon.png');\n\n\t\t\t// A group that can hold map objects:\n\t\t\tvar restGroup = new H.map.Group();\n\n\t\t\tfor(let i = 0; i<response.items.length; i++){\n\t\t\t\tlet restPosition = response.items[i].position;\n\t\t\t\tlet address = response.items[i].address.label;\n\t\t\t\t\n\t\t\t\tlet restMarker = new H.map.Marker(restPosition,{icon: restaurantIcon} );\n\t\t\t\t\n\t\t\t\trestMarker.setData(\"<p>\" + address + \"</p>\");\n\t\t\t\t\n\t\t\t\trestMarker.addEventListener('tap', function(evt){\n\t\t\t\t\tvar bubble =  new H.ui.InfoBubble(evt.target.getGeometry(), {\n                      // read custom data\n      \t\t\t\tcontent: evt.target.getData()\n\t\t\t\t});\n\t\t\t\tui.addBubble(bubble);\n\t\t\t\t}, false);\n              \n\t\t\t\t// Add the marker to the group (which causes it to be displayed on the map)\n\t\t\t\trestGroup.addObject(restMarker);\n\t\t\t\t}\n\n\t\t\t// Add the group to the map object\n\t\t\tmap.addObject(restGroup);\n\t}\t\t\n</script>\n</html> Running the code Open command prompt or terminal and run the Python code (as shown in image below). An IP address will appear, http://127.0.0.1:5000 (see in the above image). Copy this address and paste it in your browser . In response you will get the map image showing a marker and a button. Click on the button and you will get all the Pizza places near you! Visual Recognition is a subset of Artificial Intelligence meant to make machine intelligent like humans and there cant be anything more human than recognizing food by an image, and craving for it. For more details on how make this code work on IBM Cloud and code related resources, visit GitHub link . Happy Learning!", "date": "2020-08-07"},
{"website": "Here", "title": "Create a Web Map Application in Under 6 Minutes", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/create-a-web-map-application-in-under-6-minutes", "abstract": "I've recently written a series of blog posts on how to quickly add a map to your mobile applications. Today, we’re going to do the same for web applications, using the HERE JavaScript API . Start your stopwatches, here we go! Adding a map to your web application is a six-step process. Each of these steps can be completed in a minute or less. Get your API key Load the SDK Library and Style Sheet Create a div for the Map Create a Platform Instance Initialize the Map Enable Map Interaction and the Default UI Let me quickly(!) walk through all of these steps. Step 1: Get Your Credentials First you need to sign up on the developer portal and generate an API Key! Just click on \"Sign up\" on the top-right of this page and follow the process. My colleague Michael has made a video in case you need help. (Which you don’t. Go ahead, you got this.) Once you've signed up, you will be taken to your project page. There, find the “JavaScript” section and click on “Generate App”. Once your app has been created, click “Create API key”.  Copy and store the key that will be created, as we will need it in Step 4. Tip: If you want to beat the clock, you can just skip ahead to the bottom of the blog post and copy-paste the final app. Just add your credentials where we instantiate the Platform object. That should give you a sweet, full-screen map app and 4 minutes of your life back! Step 2: Load the SDK Library and Style Sheet Add the following to the <head> tag of your application, to the load the SDK libraries for the map as well as the CSS style for the default user interface. <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> Step 3: Create a div for the Map Add a <div> tag to the body of your application. This element is where your map will live. Give it a good, solid name. Like “map”. Or “herbert”. Your choice. <div id=\"map\"></div> Step 4: Create an Instance of the H.service.Platform Object H.service.Platform is the central class of the HERE JavaScript API. Among other things it holds the credentials, which we generated in Step 1. So , grab your apiKey and create a Platform instance as follows. var platform = new H.service.Platform({      \n      apikey: 'YOUR_API_KEY_HERE'\n    }); Step 5: Initialize the Map To initialize the map itself, we first need to create a set of default layers. These are the various layers available on the map, such as satellite imagery and traffic information. Then we need to create an instance of H.Map (which you’ve probably guessed is our actual map object) and pass it the div and the the default layers we’ve created. We can also pass in additional parameters, such as a location to center the map on (in latitude and longitude format) and a zoom level. Copy and paste the following code into your app. var defaultLayers = platform.createDefaultLayers();\n    var map = new H.Map(document.getElementById('map'),\n      defaultLayers.vector.normal.map, {\n      center: { lat: 40.71, lng: -74.01 },\n      zoom: 15\n    }); Step 6: Enable Map Interaction and the Default UI To be honest, we’re already done. If you run your app, you should see a map! Congrats. However, the map will be static (that is you can’t move it, zoom or interact in any way with it) and there won’t be any user interface buttons (for example to change map layers) either. That’s not cool, so let’s quickly enable interaction on the map and add a nice default user interface with two quick lines of code. var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n    var ui = H.ui.UI.createDefault(map, defaultLayers); Bonus Round Let’s be honest, some of these steps took a lot less time than a minute. In fact, I estimate that step 3 took you about 7.3 seconds. So, let’s use our remaining time for some optional tips and clean-up. First, if you change the size of your browser windows, you might notice that the size of the map doesn’t change with it. Sometimes that’s cool, but usually we want the map to play along. By adding the following line of code, we can ensure that the map plays nice. window.addEventListener('resize', () => map.getViewPort().resize()); Second, you can change the size of the map by styling your div. Here’s an example of a style that gives you a proper full screen map with no borders or weird padding. body,\n    html {\n      border: 0;\n      padding: 0;\n      margin: 0;\n    }\n\n    #map {\n      width: 100vw;\n      height: 100vh;\n    } The Complete Code Whether you skipped ahead or not, here’s the full code of a simple web app displaying a full-size map. Just copy-paste, add your apiKey to the Platform object instantiation and you’re good to go! <!DOCTYPE html>\n<html>\n\n<head>\n  <title>Create a Web Map Application with JavaScript in Under 5 Minutes</title>\n<!-- Step 2: Load the SDK library and style sheet -->\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script>\n<!--Bonus Round: this styling will result in a full screen map --><!--Step 3: Create a div for the map-->\n<div id=\"map\">&nbsp;</div>\n<script>\n    // Step 4: initialize the HERE map platform    \n    var platform = new H.service.Platform({\n      // Use the apiKey you generated in Step 1 here\n      apikey: 'YOUR_API_KEY_HERE'\n    });\n\n    // Step 5: Initialize the map in the \"map\" div\n    // This map is centered on New York, using the default map style\n    var defaultLayers = platform.createDefaultLayers();\n    var map = new H.Map(document.getElementById('map'),\n      defaultLayers.vector.normal.map, {\n      center: { lat: 40.71, lng: -74.01 },\n      zoom: 15\n    });\n\n    // Step 6: Enable the event system and add default interactions (e.g., zoom)\n    // Create the default UI components (e.g., zoom buttons)\n    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n    var ui = H.ui.UI.createDefault(map, defaultLayers);\n\n    // Bonus Round: add a resize listener to make sure that the map occupies the whole container\n    window.addEventListener('resize', () => map.getViewPort().resize());\n  </script>    \n</body>\n\n</html> Finally, here's a look at the result in action!", "date": "2020-08-14"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.18 release", "author": ["Jeanus Ko"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.18-release", "abstract": "Highlights Ensure business continuity with Multi-region setup for Pipelines For a pipeline that requires minimum downtime, use the Multi-region option while creating the pipeline version so that when the primary region fails, the pipeline version gets automatically transferred to the secondary region. Just switch on the Multi-region option within the Web Portal or use the \"--multi-region\" flag via the CLI. Note : For a pipeline to work successfully in the secondary region, the input and output catalogs used by the pipeline should be available in the secondary region. Note : For a Stream pipeline to successfully utilize the multi-region option, it's important to enable Checkpointing within the code to allow Flink to take a periodic Savepoint while running the pipeline in the primary region. When the primary region fails, the last available Savepoint is used to restart the pipeline in the secondary region. Note : For a Batch pipeline, the Spark History details are also transferred during a region failure. Note : The state of an on-demand Batch pipeline is not transferred and it will need to be manually re-activated. Use locally-stored data to speed up development and testing cycles while reducing cost Workspace now makes it easy to develop and test your applications with local data. Using either the platform CLI or a new feature of the Data Client Library, you will be able to run a local instance of the Data API, and copy data from the cloud Data API to this local instance. Via the CLI, you can also visually inspect the local data in the same way as in the portal. (The latter feature will not be available in China.) This will make your development cycles faster and automated tests independent from one another as each test can easily run against its own copy of the same data set. Also, you will save cost during the development and testing phase. To learn more have a look at the tutorial on local development and testing . Note: Local catalogs are intended for development and test purposes, production use-cases are not supported. Customize GeoJSON rendering plugins for Here Map Content and Traffic layers to visualize what you care about most for your use cases The Schemas for HERE Map Content layers Topology & Geometry , Cartography , and Building Footprints , as well as the HERE Real Time Traffic Flow layer now include a GeoJSON rendering plugin. As with all other Schemas that contain such a plugin, you can edit the plugin in the browser to change the data visualization to highlight aspects that you care about as part of your development work. To learn more on writing GeoJSON plugins see our developer guide . Use a new GeoJSON property called 'featureTag' to provide custom data filters to your visualization Although catalog layers typically contain only one specific category of data this often fall into different sub categories. For example, cartographic data contains parks, rivers, woodland and many other things. Data Filters enable you to deselect those categories that are not relevant for your use case oriented assessment of a dataset. The Data Inspector will automatically show a 'Data Filters' panel, if the selected tile has GeoJSON features with a property named 'featureTag'. For each unique 'featureTag'-value a toggle will be shown that controls the visibility of the features with that tag value. This works for GeoJSON layers as well as protobuf layers that have been transformed via a GeoJSON plugin. Check out the Cartography layer of the HERE Map Content to see this in action. To learn how to apply 'featureTag' to enable 'Data Filters' for your data, please refer to the Data Inspector’s Developer Guide . New Services added to status.here.com System status for Read Schemas, Write Schemas, and HERE Dynamic Content Services including On-Street Parking, Off-Street Parking, Fuel Prices, Safety Cameras and Traffic Connected Client (TPEG) are now accessible on status.here.com . (Traffic Connected Client (TPEG) status is also added for China and South Korea) Compact Index layer data to save storage cost and to query indexed data more efficiently A new \"Index Compaction Library\" has been added to the Index storage tool set and is available in the HERE Data SDK for Java and Scala. Continually indexing data from small stream messages leads to the creation of metadata references to many tiny files, growing the size of Index storage and adversely impacting query performance. With the release of this library, you can compact your Index layer metadata and data to greatly reduce your index storage size, improve query performance and optimize big data processing by working with larger files. Further, you can use RSQL queries to submit criteria to compact your data within certain time windows or by other attributes you've defined to optimize the compaction process all while you continue to index incoming data. Learn more about the Index Compaction Library here . Backup region support on status.here.com Events on the status page now include the region impacted in the outage details view. This is to support Data API users who are replicating data in a backup region. Events from 13 August forward will include the region field. Use Map Creator with platform credentials Platform Credentials can now be used to access Map Creator. Login to platform.here.com and you'll see the link in the launcher. With Map Creator you can edit the HERE map and help keep the world up to date. This includes editing places of interest, updating addresses and their exact location, updating roads, cycle paths and walkways. Existing Map Creator users should note that when logging in with platform credentials, edits and feedback from previous accounts disassociated from your platform organization, will not carry over. (Not available on the Platform in China.) Changes, Additions and Known Issues SDKs and tools Go to the HERE platform changelog to see details of all changes to our CLI , the Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library . Web & Portal Changed: Support portal and documentation links have been removed from the launcher and now reside in the support menu designated with the icon. Changed: Links to documentation can be found within the top navigation each module of the platform portal, data, pipeline, marketplace, access manager. These links were previously found in the launcher menu. Changed: The profile menu has been updated, the menu found in the top right of the the portal navigation with an icon or initials. Links to apps and keys and the plugin installer have been removed from this menu. A link to notification preferences has been added. Account settings have also been consolidated into one page: https://platform.here.com/admin/users/me, eliminating the previous profile page. Changed: For the custom run-time configuration of a Pipeline Version, the character limit for the property name has been increased to 256 and the character limit for the property value has been increased to 1024. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: A finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a group, user or app has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until October 30, 2020 . Referencing old Schema HRNs is not broken and will work in perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Fixed: For Stream pipeline versions activated with the high-availability mode, the failure in selecting the primary Job Manager is now fixed with the Stream-3.0.0 run-time environment. Deprecated: pipeline_jobs_canceled metric used within the Pipeline Status Dashboard is now deprecated. See the details in the Deprecation table at the bottom of this page. Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same group (pipeline permissions are managed via a group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Map Content A dditions to existing layers in the HERE Map Content catalog: Added AffiliationAttribute and OfficeTypeAttribute to the \" Places-All Categories \" layer Added new fields for elevation (elevation_value) and curvature (curvature_value) in the \"Roads-ADAS Attributes\" layer. These attributes are nullable. ADAS coverage in HMC is now global, which in total includes: Eastern Europe Western Europe North America South America Middle East, Africa APAC Australia India Taiwan Hong Kong. Marketplace (Not available in China) Issue: There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, service will slow down across the board for all consumers who are reading from the External Service Gateway. Workaround: Contact HERE technical support for help. Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 October 30, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after October 30, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after October 30, 2020, Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before October 30, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after October 30, 2020. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 3 Spark-ds-connector replaced by SDK for Java and Scala Spark Connector 2.12 February 2020 August 19, 2020 Deprecation Summary: The spark-ds-connector will be deprecated (6) months from this release on August 19, 2020. Please upgrade to the latest SDK for Python version before then to get the latest SDK for Java and Scala Spark Connector. 4 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. Existing Batch pipelines that use the Batch-2.0.0 run-time environment will continue to operate normally until August 19, 2020. During this period, Batch-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-2.0.0 environment, please use OLP SDK 2.11 or older. After August 19, 2020 we will remove the Batch-2.0.0 run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. 5 Schema validation to be added 2.13 March 2020 November 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of November 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, any attempt to update any configurations of that layer will fail until the schema association or permissions are corrected. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before November 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 6 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020. 7 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing Stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this period, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, please use Platform SDK 2.16 or older. After February 1, 2021 the Stream-2.0.0 run-time environment will be removed and the pipelines still using it will be canceled. We recommend that you migrate your Stream Pipelines to the new Stream-3.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For more details about our general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 8 pipeline_jobs_canceled metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 Deprecation Summary: pipeline_jobs_canceled metric used within the Pipeline Status Dashboard is now deprecated because it was tied to the Pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. After that date, the metric will be removed.", "date": "2020-08-27"},
{"website": "Here", "title": "An Update to Working with GeoJSON in the Browser", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/an-update-to-working-with-geojson-in-the-browser", "abstract": "A few weeks ago, I wrote a blog post about working with GeoJSON entirely within the browser ( Working with GeoJSON in the Browser ). In that article, I presented the different ways of working with GeoJSON using JavaScript in the browser. In the second example, I demonstrate how to load data from a GeoJSON file and display it using our JavaScript Maps API . As it turns out, learning never ends and I discovered there was an even easier way. Let me show you how! So for reference, here's the approach I took in that first post: var icon = new H.map.Icon('park.png');\n\nlet resp = await fetch('./national-parks.geojson');\nlet data = await resp.json();\n\ndata.features.forEach(f => {\n    map.addObject(new H.map.Marker({lat:f.geometry.coordinates[1], lng:f.geometry.coordinates[0]}, { icon:icon}));\n}); One of the engineers on the MapsJS product reached out and they shared that I had missed out on a featured called the GeoJSON Reader . Let's make sure that you don’t miss out on this feature like I did as it provides a great shortcut. It lets you add a layer of GeoJSON data in three simple lines: let reader = new H.data.geojson.Reader('/path/to/geojson/file.json');\nreader.parse();\nmap.addLayer(reader.getLayer()); While not much shorter than before, it's certainly a bit simpler. One possible issue with this code block is that uses the default the marker object icons. If you remember, my demo had a custom park icon. Luckily that's also pretty easy to implement. The Reader constructor supports an options object that lets you pass a styling function. Here's an example of that: var icon = new H.map.Icon('park.png');\nlet reader = new H.data.geojson.Reader('./national-parks.geojson', {\n    style(mapObject) {\n        if(mapObject instanceof H.map.Marker) {\n            mapObject.setIcon(icon);\n        }\n    }, disableLegacyMode: true\n});\n\nreader.parse();\nmap.addLayer(reader.getLayer()); The styling function is passed every object that's created on this particular layer, so you'll notice a bit of code that checks to ensure the object is a marker first. Certainly, more could be done here than just setting an icon. The data from your features will be available via mapObject.getData() letting you inspect and react to different values set within them. You can see another example of the GeoJSON reader in our examples and don't forget you can peruse the entire JavaScript Maps API Reference to find cool features like this. The complete source code for this demo may be found here: https://github.com/cfjedimaster/heredemos/blob/master/mapsjs/test_markers_from_geojson2.html You can run this demo in your browser here: https://cfjedimaster.github.io/heredemos/mapsjs/test_markers_from_geojson2.html Don't forget you can sign up for a free developer account and begin building your own maps today!", "date": "2020-08-18"},
{"website": "Here", "title": "July 2020 Release Notes", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/july-2020-release-notes-0", "abstract": "Welcome to the latest release notes for the HERE Location Services. This post covers the D119 release of HERE Location Services. These releases includes updates of: Routing API, Geocoder and Search API, Fleet Telematics API and HERE SDK for Android, iOS and Flutter. You will find all API documentation and release notes on the Developer Portal . Routing (Versions 8.3.3 – 8.6.4) Added length to OffsetAction Added support for traffic incidents in sections and spans. Added floating point pedestrian[speed] parameter. Added support for all parameters from /routes for /routes/{routeHandle} endpoint, except for parameters origin, destination, via, alternatives, and routingMode. Added boolean passThrough parameter via waypoints. Geocoding and Search (Version 7.0.50) All endpoints: primary category flag for all place results with multiple categories Discover, Browse, Lookup: Place results contact information (phone, mail, web, fax) Discover, Browse, Lookup: Place results opening hours with isOpen flag Autosuggest query terms completion and termsLimit filter HERE SDK for Android, iOS and Flutter Lite Edition (Version 4.4.2.0) Added Place.getGeoCoordinates() method to get the GeoCoordinates of a Place. Added departure/arrival information to the Section of a Route: waypointIndex originalCoordinates mapMatchedCoordinates waypointIndex originalCoordinates mapMatchedCoordinates Added Departure class with the following fields: Added Arrival class with the following fields: Added Section.get_departure() method. Added Section.get_arrival() method. Added Suggestion.getType() to get the new SuggestionType enum that indicates whether this Suggestion is a place, a chain like a store, restaurant or bussiness chain - or a category . HERE SDK for Android, iOS and Flutter Explore Edition (Version 4.4.2.0) Same new features as Lite edition HERE SDK for Android and iOS (Navigate Edition) (Version 4.4.2.0) Added a new NavigatorProtocol which describes the main turn-by-turn functionality of a Navigator. Plus, same new features as the Lite and Explore versions. Fleet Telematics API (Version 3.0.32) New Custom Routing feature: Avoid Unpaved roads User can specify whether and how strict unpaved roads shall be avoided New Custom Routing feature: Choose Speed Category Now it is also possible to overrule the automatically determined speed profile and use a specific one. New Custom Routing Feature: Modify all roads within a polygonal area The \"Area Override\" overlay upload operation modifies the attributes of all links    of the given LINK_ATTRIBUTE_FCN layer(s) More granular axle weight restrictions in  Advanced Datasets The \"Area Override\" overlay upload operation modifies the attributes of all links of the given LINK_ATTRIBUTE_FCN layers Important: Link IDs will exceed 32 bits soon, PLEASE PREPARE YOUR APPLICATIONS TO HANDLE LINK_ID VALUES > 4 BILLION! IMPORTANT INFORMATION regarding new license terms for Location Services on Platform*: For some of our new Location Services made available on Platform, we have changed the transaction definitions in your current contract with HERE. This will impact all existing Location Services users that have a contract with a license term based on Transactions such as Location Mapping when they start using Location Services on Platform. The changes are the following: Category Feature Definition Previous Geocoder Autocomplete or Places Autosuggest No Charge New Geocoding and Search Autosuggest or Autocomplete One Transaction is counted for every 10 Requests Previous Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal max parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal alternative ’ parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Vector Tiles One Transaction is counted for every 5 Requests Previous Isoline Routing One Transaction means one Request New Isoline Routing One Transaction equals each individual Isoline within an Isoline Request Large Scale Matrix Routing and Matrix Routing included in Routing API will be merged into Matrix Routing API V8 Previous Large Scale Matrix Routing One Transaction is counted for every 20 Elements in a Large-scale Matrix Routing API Request. The number of Elements equals the number of start points times the number of destination points. Large-Scale Matrix Routing Requests generating less than 100,000 individual elements are always counted as 5,000 Transactions New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more , the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 Previous Matrix Routing One Transaction is counted for each start point Request New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 *Location Services on Platform are the latest major releases such as Geocoding and Search API V7, Routing, Matrix Routing, Isoline Routing, Transit and Intermodal API´s V8 and Vector Tile API V2", "date": "2020-08-17"},
{"website": "Here", "title": "Super Spatial Search Options with Data Hub", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/super-spatial-search-options-with-data-hub", "abstract": "Last year, we introduced a powerful new search feature to Data Hub (back then the product was still known as XYZ). Data Hub is our geospatial data storage system with powerful APIs and integration with HERE Studio. This new feature let you search against properties in your spaces and joined the already powerful spatial search features provided by the APIs. As I've not yet written about the ways you can perform spatial searches with your Data Hub features, I thought an overview would be useful. These search features would all be useful to help direct your users to the resources they need based on their location. Before I begin, lets take a look at the data. I'm using data from the American National Parks Service. They provide a GeoJSON file ( https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson ) that I've enhanced with calls to their API to add more data. I spoke more about this here: Using HERE Studio to Map National Parks The end result is a GeoJSON file with near 400 features covering America's national parks. Here's one as an example: {\n    \"type\": \"Feature\",\n    \"id\": 0,\n    \"properties\": {\n        \"phoneNumber\": \"6175661689\",\n        \"emailAddress\": \"frla_interpretation@nps.gov\",\n        \"activities\": \"Guided Tours,Junior Ranger Program,Museum Exhibits,Self-Guided Tours - Walking\",\n        \"directionsInfo\": \"Site is located on the southwest corner of Warren and Dudley Streets in Brookline, south of Route 9, near the Brookline Reservoir.\\n\\nSite is 0.7 miles from the Brookline Hills MBTA stop on the Green Line, D Branch.\",\n        \"directionsUrl\": \"http://www.nps.gov/frla/planyourvisit/directions.htm\",\n        \"url\": \"https://www.nps.gov/frla/index.htm\",\n        \"weatherInfo\": \"Summer: Warm temperatures, average high temperature around 80 degrees Fahrenheit, often with humidity. July and August bring the hottest temperatures.\\nFall: Cooler temperatures, mean temperatures between 45 and 65 degrees Fahrenheit, sometimes rainy. Peak fall foliage is in mid-October.\\nWinter: Cold, with snow, average low temperature around 25 degrees Fahrenheit. \\nSpring: Cold to cool temperatures, average mean temperatures between 40 and 60 degrees Fahrenheit.\",\n        \"name\": \"Frederick Law Olmsted\",\n        \"topics\": \"Civil War,Landscape Design,Schools and Education,Wars and Conflicts\",\n        \"description\": \"Frederick Law Olmsted (1822-1903) is recognized as the founder of American landscape architecture and the nation's foremost parkmaker. Olmsted moved his home to suburban Boston in 1883 and established the world's first full-scale professional office for the practice of landscape design. During the next century, his sons and successors perpetuated Olmsted's design ideals, philosophy, and influence.\",\n        \"image\": \"https://www.nps.gov/common/uploads/structured_data/3C853BE9-1DD8-B71B-0B625B6B8B89F1A0.jpg\",\n        \"designation\": \"National Historic Site\",\n        \"parkCode\": \"frla\",\n        \"fullName\": \"Frederick Law Olmsted National Historic Site\"\n    },\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n            -71.13112956925647,\n            42.32550867371509\n        ]\n    }\n}, You can view the raw file on GitHub if you wish: https://github.com/cfjedimaster/heredemos/blob/master/misc_related/national-parks-studio.geojson . So now that you have an idea of the data, let's talk about the different ways you can search. The API All the examples will be making use of the Data Hub REST APIs. You can find the latest reference documentation at https://xyz.api.here.com/hub/static/swagger/ . They will all use one particular space that contains the data described above. I'm also going to use a key generated by our token manager that provides read only access to my spaces (making it safe to share here). Find Features in a Circle The first spatial search we'll demonstrate is a simple \"everything in a circle\" filter. Given a center point, and a radius, what features exist within it? The endpoint for this search looks like this: https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&lat=${LAT}&lon=-${LON}&radius=${RADIUS} You pass in a location ( lat and lon ) and a radius in meters. Here's a concrete example that searches for parks around a point centered in Lafayette, Louisiana: https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&lat=30.22478&lon=-92.02402&radius=300000 This should roughly correspond to the map below (generated using our awesome Map Image API ): The result is a GeoJSON object which means you can access any results in the features key: If you modify the radius to make it larger or smaller then the number of results change accordingly. Here's a complete script written in Node.js. require('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\n\nconst SPACE_ID = 'ylfzY538';\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&lat=30.22478&lon=-92.02402&radius=300000`)\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    // show one sample\n    if (res.features.length >= 1) console.log(JSON.stringify(res.features[0].properties, null, '\\t'));\n    console.log(res.features.length + ' results\\n\\n');\n})\n.catch(e => {\n    console.error(e);    \n}); To keep the output a bit simpler, the script only displays the first result and the total found. Find Features in a Bounding Box The next way to search for features is via a bounding box. As you can imagine, this is literally creating a box on a map and returning features inside that box. To use this feature you need four parameters: west - the longitude of the western (or left) side of the box north - the latitude of the northern (or top) side of the box east - the longitude of the eastern (or right) side of the box south - the latitude of the southern (or bottom) side of the box In order to get some values for a test, I opened HERE WeGo and selected two locations, one to the northwest of Lafayette and one to the southwest. I then used the \"See more info\" box to grab the longitude and latitude of those selections. This gave me two coordinates: 32.82697, -94.24928 and 29.9372, -90.11567. I can take these values and use them to perform my API call with the following URL: https://xyz.api.here.com/hub/spaces/${SPACE_ID}/bbox?access_token=${ACCESS_TOKEN}&west=-94.24928&north=32.82697&east=-90.11567&south=29.9372 The API supports more options (all my examples today are just that, examples of what can be done, so be sure to check the docs for full listings of features) but one in particular may interest you. Any feature that's \"clipped\" by the box, i.e. a park that may be part in and part out, will be included in the result. You can disable this by passing clip=false in your call. Here's another Node.js script (and remember, it's a REST API so you can use any darn language you prefer!) that performs a bounding box search: require('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\n\nconst SPACE_ID = 'ylfzY538';\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/bbox?access_token=${ACCESS_TOKEN}&west=-94.24928&north=32.82697&east=-90.11567&south=29.9372`)\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    // show one sample\n    if (res.features.length >= 1) console.log(JSON.stringify(res.features[0].properties, null, '\\t'));\n    console.log(res.features.length + ' results\\n\\n');\n})\n.catch(e => {\n    console.error(e);    \n}); For our space, this returns four features, and like before, if you expand or shrink the box your total number of results will change. Find Features in Geometric Shapes If a bounding box isn't quite specific enough, you can create a more detailed search area by defining multiple different geometric shapes. GeoJSON supports different ways of defining the location of an object, and each of those ways can also be used to find features in Data Hub. In case you aren't up to date with all the various capabilities of GeoJSON, here's what's supported, and what it means for searching. Point and MultiPoint: Lets you match against features that intersect with the point or points. Line and MultiLine: This lets you create a line and determine if items are found along that line. The radius value becomes important here as you can create \"thicker\" lines that let you search for features along a route. So imagine a line geometry that follows a road. By using a thick radius, you could find features that are near the road. Polygon and MultiPolygon: Given a polygon, find features inside it. While it isn't necessarily light reading, I do encourage folks to read the GeoJSON specification , as it contains full details on how these geometries are formed. In order to use this feature you'll use the spatial endpoint from the first example, but with POST instead of GET. You'll use the post body to pass in your geometry to search. Let's consider an example. Using HERE WeGo again, I clicked 4 times around the state of Louisiana to create a basic (and crude) polygon for the state. Every time I clicked I made note of the latitude and longitude. Next - I checked the GeoJSON spec for polygons and saw it had this basic form: {\n    \"type\":\"Polygon\",\n    \"coordinates\":[\n        [ \n            [lon1, lat1], \n            [lon2, lat2],\n            [lon3, lat3],\n            [lon4, lat4]\n            [lon1, lat1],\n        ]\n    ]\n} The coordinates aspect is a bit complex. First, it's an array of arrays where the first item in the array is the polygon and items 2 through N would be \"exclusions\" or holes in the polygon. Since my polygon doesn't have holes, I only have the first item. Next, notice that in GeoJSON, the first item in a coordinate is the longitude, not the latitude. Most people right locations in longitude,latitude format. Finally I had to be sure to \"close\" the polygon by including the first point as the last point. In the script below, I've modified my previous search against the spatial endpoint to use POST, specify the right content header, and pass my data as the body of the call: require('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\n\nconst SPACE_ID = 'ylfzY538';\n\nlet body = {\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n        [\n            [-94.0565, 33.0183],\n            [-91.1669, 32.9510],\n            [-89.0984,29.1543],\n            [-93.8898, 29.7350],\n            [-94.0565, 33.0183]\n        ]\n    ]\n}\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}`, {\n    method:'POST',\n    body:JSON.stringify(body),\n    headers: {\n        'Content-Type':'application/geo+json'\n    }\n})\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    if (res.features.length >= 1) {\n        res.features.forEach(f => console.log(f.properties.fullName));\n    }\n    console.log(res.features.length + ' results\\n\\n');\n})\n.catch(e => {\n    console.error(e);    \n}); When run, I see parks that roughly match what I expected: As you can imagine, it can be somewhat complex to get this exactly right. If you do screw up, the API generally responds well, as an example: {\n  type: 'ErrorResponse',\n  error: 'IllegalArgument',\n  errorMessage: \"Geometry isn't valid!\",\n  streamId: '50ab3d1f-7494-497a-b3c2-e5d2c3fab329'\n} Find Features based on Other Features For the final form of search, we'll look at today, here's a fascinating one that may be of use to folks dealing with multiple spaces. Spatial search can be told to use the geometry of a feature from a completely separate space as a center point. This can be pretty powerful. If the other space has data that moves on a regular basis, code that performs searches based on it wouldn't have to be updated. To test this, I created a new space with a grand total of one feature - a point in New Orleans. I then did a search against the space we've been using and passed both the ID of the new space and the ID of the feature. This is done using refSpaceId and refFeatureId values. Here's an updated Node script that shows this: require('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\n\nconst SPACE_ID = 'ylfzY538';\n\nconst NOLA_SPACE = '4N1J3TtN';\nconst NOLA_FEATURE = 'wSxVVnDD1YLcNCHa';\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&refSpaceId=${NOLA_SPACE}&refFeatureId=${NOLA_FEATURE}&radius=3000`)\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    // show one sample\n    if (res.features.length >= 1) console.log(JSON.stringify(res.features[0].properties, null, '\\t'));\n    console.log(res.features.length + ' results\\n\\n');\n})\n.catch(e => {\n    console.error(e);    \n}); This correctly returns one park that's within the circle defined by the other's spaces geometry. Wrap Up I hope this tour of spatial search options for Data Hub was exciting for you as it was for me! Remember to consult the Swagger docs for full details on additional arguments and features not covered here and to check out HERE Studio for mapping your data.", "date": "2020-08-24"},
{"website": "Here", "title": "Getting Started with AWS & HERE in the Supply Chain", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/aws-supply-chain-here-maps", "abstract": "A core aspect of a supply chain is the transportation of parts or completed product from one location to another. As a leading location platform, HERE Technologies is committed to providing routing intelligence to improve the overall efficiency of a supply chain. Supply chains can be very complex. In this post, we want to introduce a simple scenario that centers around the “last mile” – a term that typically refers to the journey of a deliverable on it’s final leg of the journey. Last Mile Scenario To help developers understand the technologies and services that can enable location intelligence in supply chains, we have created a simple scenario to showcase methods of implementation. It all centers around a company that offers delivery of goods ultimately to the consumer’s address. Here is a list of the roles that will be involved: Retailer – Provider of product Distribution Center – Where product is located Consumer – The one who orders product and is last destination of supply chain Delivery Company – Company that delivers products from many retailers Delivery Operator – An individual delivery operator/vehicle of the delivery company The interaction of the above roles form the basis of our “last mile” scenario. When a consumer orders a product from the retailer , the retailer engages with the delivery company to have the product shipped to the consumer. The retailer provides the delivery company the address of where to pick up the product (the distribution center ) and the address of the consumer. The delivery company determines the most efficient option among available delivery operators and commissions transport to pick up product and deliver to consumer. Location Services by HERE The scenario will be implemented in a series of apps – all which will be web based. For apps that use interactive maps, we will use Maps API for JavaScript 3.1 . To enable location intelligence, we will incorporate RESTful APIs delivered via serverless architecture (see below) Developer Resources by AWS The AWS Serverless Application Repository houses many of HERE Technologies’ core location service APIs – such as routing, map images, and isolines. AWS IoT will be used to provide MQTT communications among the various roles implemented in the supply chain. AWS Connections – Supply Chain series We are excited to announce we are providing a series of episodes that will walk through each aspect of the scenario! You can join us at http://twitch.tv/heredev to watch live episodes or stay tuned to this blog for a detailed blog on each episode. The first episode is available to watch below!", "date": "2020-09-14"},
{"website": "Here", "title": "Adding Maps to Your Site", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/adding-maps-to-your-site", "abstract": "A few weeks ago I showed live on Twitch how to add maps and map data to an existing ecommerce site I created as a demo. My thinking was to create a real-world situation (a company with stores) that wanted to use maps to provide a better experience to their users. In the stream, I went through a couple of different iterations to create better and better results. Let's get started! Let's begin by looking at our ecommerce site. Before I begin, note that all of the code I'm sharing below can all be found on my GitHub repository at https://github.com/cfjedimaster/adding-maps . The Cat and Sasquatch Boutique ( https://cfjedimaster.github.io/adding-maps/v1/ ) is a well-known shop providing grooming and other services to felines and members of the Bigfoot family (Sasquatch, Abominable Snowman, Yeti, and so forth). Located in southern Louisiana, they've been providing services to their community for years now but have been working to improve their online presence to help bring in new customers. None of the links actually work, but you can click on Locations to see a static list of shops and their locations: The HTML behind this is a simple unordered list: <p>\n<ul>\n<li>2133 Kaliste Saloom Rd, Lafayette, LA 70508</li>\n<li>301 Verot School Rd, Lafayette, LA 70508</li>\n<li>4311 Johnston St, Lafayette, LA 70503</li>\n<li>1812 W Pinhook Rd, Lafayette, LA 70508</li>\n<li>600 E Kaliste Saloom Rd, Lafayette, LA 70508</li>\n</ul>\n</p> This \"works\" in terms of the bare minimum. If I live in the area, I'll probably know those streets and know how to get there. But I have to be honest. I got these addresses from a list of local gas stations. I know each of these streets. I've lived here for twenty years. But I'd still check a map before I went to one of them. How can we make this better for our visitors? For a first attempt, and one that can be done very quickly, let's use the Map Image API . This is less of an API and more of a super-powered image service. By simply crafting the right URL and putting it in an <img> tag, you get custom maps to use in your HTML. The URL can load a map based on a precise location, or via searching by passing in geographic values. We have a street, city, and zip, and in order to render them, we can construct a URL like so: https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey={KEY}&n={STREET NUMBER}&s={STREET}&ci={CITY}&zi={ZIP} So, given our first location of \"2133 Kaliste Saloom Rd, Lafayette, LA 70508\", our URL could look like so (notice I've also specified a height and width): https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey={KEY}&n=2133&s=Kaliste+Saloom+Rd&ci=Lafayette&zi=70508&w=300&h=300 And then to use it, literally just put that in an img tag: <img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey={KEY}&n=2133&s=Kaliste+Saloom+Rd&ci=Lafayette&zi=70508&w=300&h=300\"> You will want to replace {KEY} with your key, and in case you're wondering, yes, it is safe to include the keys in your HTML. In the HERE Developer Portal, you can add domain restrictions to your keys so that can only be used on certain domains: To update our rather boring list of locations we can simply add the images to our list: <p>\n<img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw&n=2133&s=Kaliste+Saloom+Rd&ci=Lafayette&zi=70508&w=300&h=300\">\n2133 Kaliste Saloom Rd, Lafayette, LA 70508\n</p>\n\n<p>\n<img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw&n=301&s=Verot+School+Rd&ci=Lafayette&zi=70508&w=300&h=300\">\n301 Verot School Rd, Lafayette, LA 70508\n</p>\n\n<p>\n<img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw&n=4311&s=Johnston+St&ci=Lafayette&zi=70503&w=300&h=300\">\n4311 Johnston St, Lafayette, LA 70503\n</p>\n\n<p>\n<img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw&n=1812&s=W+Pinhook+Rd&ci=Lafayette&zi=70508&w=300&h=300\">\n1812 W Pinhook Rd, Lafayette, LA 70508\n</p>\n\n<p>\n<img src=\"https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw&n=600&s=E+Kaliste+Saloom+Rd&ci=Lafayette&zi=70508&w=300&h=300\">\n600 E Kaliste Saloom Rd, Lafayette, LA 70508\n</p> Here's the result. Note that I could absolutely lay this out a bit nicer! You can try this online at https://cfjedimaster.github.io/adding-maps/v2/locations.html . Alright, that's cool and all, but what if we want a more dynamic map? I mean, one that would allow the user to pan and zoom so they could plan out a route to the store. For that, we need HERE's JavaScript Maps library . Adding a map to our HTML page is relatively straightforward. First, we include the required libraries: <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" /> Next, I removed my previous hard coded list of locations and included an empty div for the map: <div id=\"mapContainer\"></div> I used a bit of CSS to make the container sized in a nice manner: <style>\n#mapContainer {\n    width: 100%;\n    height: 700px;\n}\n</style> Now we need to use some JavaScript. We'll begin by adding the map: const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\nvar platform = new H.service.Platform({\n    'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n    document.getElementById('mapContainer'),\n    defaultLayers.vector.normal.map,\n    {\n        zoom: 12,\n        center: { lat: 30.22, lng: -92.02 },\n        pixelRatio: window.devicePixelRatio || 1\n    }\n);\n\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n    // Create the default UI:\nvar ui = H.ui.UI.createDefault(map, defaultLayers); This is fairly boilerplate except for the center value. As my stores are in the Lafayette, LA region I've focused the map there. Now we need to add markers for our stores. Currently we only have addresses for our stores, not longitude and latitude values. The JavaScript Maps library support our Geocoding APIs but I chose to instead use HERE WeGo . It lets you search for an address and get longitude and latitude information. With those values, the API to add a marker is incredibly simple. Here's all the locations: map.addObject(new H.map.Marker({lat:30.164709, lng:-92.039268}));\nmap.addObject(new H.map.Marker({lat:30.174879, lng:-92.00705}));\nmap.addObject(new H.map.Marker({lat:30.194481, lng:-92.057503}));\nmap.addObject(new H.map.Marker({lat:30.19084, lng:-92.016212}));\nmap.addObject(new H.map.Marker({lat:30.19569, lng:-92.00473})); And the result: Now you can pan around, zoom in, and so forth, to get a better idea of the store's location. You can demo this yourself here: https://cfjedimaster.github.io/adding-maps/v3/locations.html There still leaves a lot to be desired though. The map has a problem I've seen on many web sites. While you can zoom in and see a precise location of a store, we've lost the street names. Consider this location: Is that on Rena Drive or Johnston Street? Also, what if our stores had different opening hours, or contact information? It would be nice to be able to get this information, perhaps on clicking those markers? Luckily the HERE Maps library provides an excellent way of doing that - Infobubbles . An infobubble is a small bubble (like speech in a comic book) that you can populate with HTML. Let's look at an updated version of our code that set the markers. First, we'll create a group. Groups in our Maps library let you associate UI items together that share some common code. You'll see how this is used later: var group = new H.map.Group(); Now let's make our markers. Previous our markers were just that - a marker on the map. Now we're going to associate some data with them. Markers can have any data associated with them. I chose to use HTML that included the street address as well as hours. let marker = new H.map.Marker({lat:30.164709, lng:-92.039268});\nmarker.setData(`\n<p class='infoBubble'>\n<b>Location:</b> 2133 Kaliste Saloom Rd, Lafayette, LA 70508<br/>\n<b>Hours:</b> 8AM-10PM\n</p>\n`);\n\ngroup.addObject(marker); Notice that I also added it to my group. I repeated this for all 4 locations and then simply added the group itself to the map: map.addObject(group); Ok, so the last bit is adding support for showing the infobubble. Luckily the API is really simple to use. Since all our markers are in one group, we can add an event listener to it directly like so: group.addEventListener('tap', evt => {\n    // event target is the marker itself, group is a parent event target\n    // for all objects that it contains\n    var bubble =  new H.ui.InfoBubble(evt.target.getGeometry(), {\n        // read custom data\n        content: evt.target.getData()\n    });\n    // show info bubble\n    ui.addBubble(bubble);\n}, false); When anything in the group is tapped, a new infobubble is opened and the content from the markers data is used to render the content. And that's literally it. Now when you click, you'll see information about the location: You can play around with this yourself at https://cfjedimaster.github.io/adding-maps/v4/locations.html . Let's recap. We began with a bulleted list of street addresses for our locations. Next, we changed them into small static maps showing the location in context of other streets in the city. The third version switched to a dynamic map with markers, but no other information was visible. The fourth version added the ability to click on a marker to see an infobubble containing the store address as well as it's open hours. For our final version, I'm really going to kick it up a notch. Let me share a picture of what we're building and then I'll explain how it was done. What you see above is the map figuring out where I am, calculating the routes to different stores based on current conditions, and then rendering a route to the 'best' location for me if I were to hop in the car with my sasquatch for a good grooming. So how was this done? I wrote one main function to handle this process. async function getRoutes() {\n    let myLocation = await getLocation();\n    let lowest = Number.POSITIVE_INFINITY;\n    let chosenRoute;\n\n    // draw routes from me to all locations\n\n    for(l of locations) {\n        let result = await getRoute({lat:myLocation.latitude, lng:myLocation.longitude}, l.position);\n        let totalTime = result.routes[0].sections[0].travelSummary.duration;\n        if(totalTime < lowest) {\n            lowest = totalTime;\n            chosenRoute = result.routes[0];\n        }\n    }\n\n    if(chosenRoute) {\n        drawRouteOnMap(chosenRoute);\n        document.querySelector('#routeContainer').innerHTML = `\n        <p>\n        <b>New Feature!</b> The closest location (based on time to arrive) is now highlighted on the map. The home icon represents your location.\n        </p>\n        `;\n    }\n} The function begins by firing off a request to getLocation , which uses the browsers geolocation API to get my position. Once it has it, it can then fire off multiple requests to our routing API. Here's getRoute : async function getRoute(from, to) {\n    var routingParameters = {\n        'routingMode': 'fast',\n        'transportMode': 'car',\n        // The start point of the route:\n        'origin': `${from.lat},${from.lng}`,\n        // The end point of the route:\n        'destination': `${to.lat},${to.lng}`,\n        // Include the route shape in the response\n        'return': 'polyline,travelSummary'\n    };\n\n    return new Promise((resolve, reject) => {\n        router.calculateRoute(routingParameters, r => resolve(r), e => reject(e));\n    });\n} Each call to getRoute returns route data that includes the duration of the route. By looping over the results, I can then figure out the quickest one. I update the HTML and call drawRouteOnMap to render the route data returned by the call. Here's that function: function drawRouteOnMap(route) {\n    route.sections.forEach((section) => {\n        // Create a linestring to use as a point source for the route line\n        let linestring = H.geo.LineString.fromFlexiblePolyline(section.polyline);\n\n        // Create a polyline to display the route:\n        let routeLine = new H.map.Polyline(linestring, {\n            style: { strokeColor: 'blue', lineWidth: 3 }\n        });\n\n        var icon = new H.map.Icon('img/home.png');\n\n        // Create a marker for the start point:\n        let startMarker = new H.map.Marker(section.departure.place.location, { icon:icon});\n\n\n        // Add the route polyline and the two markers to the map:\n        map.addObjects([routeLine, startMarker]);\n\n    });\n} The combination of the routing result data and the power JavaScript library makes this all rather simple. Note that this approach wouldn't be sensible if you had a large number of stores. With a few locations though it runs quick enough to be near instantaneous. You can try this yourself but be prepared for slightly longer routes. Our code could actually handle using a \"sanity check\" where if your location was more than one or two hundred miles away the routing isn't displayed. Here's the demo: https://cfjedimaster.github.io/adding-maps/v5/locations.html I hope you found this walkthrough interesting. The entire repo can be found here: https://github.com/cfjedimaster/adding-maps . Don't forget to sign up for a free developer account and reach out to us on Twitter if you have any questions about this code.", "date": "2020-08-27"},
{"website": "Here", "title": "HERE Data Layers: Map content now part of Freemium", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-data-layers-map-content-now-part-of-freemium", "abstract": "In August 2018, we launched our Freemium plan to bring location services to the developer community . David Chura , for example, used HERE Location Services to reimagine how we queue and Raxel Telematics combines our SDK and location services with raw telematics data to ensure driver safety. Today, we are adding even more power to Freemium: HERE Data Layers . Now you can explore, visualize, and download the map data you need to build solutions for cities with ease. HERE has been the leading global B2B mapmaker for decades and we want to share the enterprise-grade maps with you, our developer community. HERE Data Layers are standalone geospatial representations of the world’s road networks, pathways, buildings, structures, places, land use and land cover. They serve as a menu for developers and data scientists to select the datasets needed to power today’s location-based functions, applications and customer experiences. The offering consists of urban geospatial data sets in GeoJSON format and can be used in a range of use cases from map display, spatial analytics, business intelligence to AI/ML analysis. HERE Data Layers by the numbers: You get to choose from 70 cities, with 10 data layers each and over 500 attributes for the richest map data available in a Freemium account. To learn more about the technical specifications, read Ray’s blog post that takes you on a technical deep dive. Get started with HERE Data Layers today via the HERE Developer Portal and start building with our enterprise-grade map data. As always, you can reach out to us via Twitter to tell us what you think. I can’t wait to see what you create!", "date": "2020-09-16"},
{"website": "Here", "title": "August 2020 Release Notes", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/august-2020-release-notes-0-0", "abstract": "Welcome to the latest release notes for the HERE Location Services. These releases include updates of: Routing API, Fleet Telematics API and HERE SDK for Android, iOS and Flutter . For more detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation and release notes on the Developer Portal For some of our new Location Services made available on Platform, we have changed the Transaction definitions in your current contract with HERE. This will impact all existing Location Services customers that have a contract with a license term based on Transactions such as Location Mapping when they start using Location Services on Platform. By continuing to use the Location Services on Platform, you accept the new terms. The changes are the following: Category Feature Definition Previous Geocoder Autocomplete or Places Autosuggest No Charge New Geocoding and Search Autosuggest or Autocomplete One Transaction is counted for every 10 Requests Previous Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal max parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal alternative ’ parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Vector Tiles One Transaction is counted for every 5 Requests Previous Isoline Routing One Transaction means one Request New Isoline Routing One Transaction equals each individual Isoline within an Isoline Request Large Scale Matrix Routing and Matrix Routing included in Routing API will be merged into Matrix Routing API V8 Previous Large Scale Matrix Routing One Transaction is counted for every 20 Elements in a Large-scale Matrix Routing API Request. The number of Elements equals the number of start points times the number of destination points. Large-Scale Matrix Routing Requests generating less than 100,000 individual elements are always counted as 5,000 Transactions New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more , the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 Previous Matrix Routing One Transaction is counted for each start point Request New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 HERE Location Services on Platform Routing ( Versions 8.7.0 - 8.8.0) Added truck[type] and truck[trailerCount] parameters. Added new notice code violatedTimeDependentRestriction Introducing bicycle routing mode HERE SDK for Android and iOS Lite Edition ( Version 4.4.3.0) Certain areas can now be excluded from route calculation with AvoidanceOptions that contain an avoidAreas list holding GeoBox items which routes should not cross. Added optional Suggestion.getHref() to get a direct link to discover more details. It is available when the suggestion result type is category or chain . Added RoadFeatures.DIFFICULT_TURNS enum value. Note that it is valid only for truck transport mode. Added a new GeoCorridor constructor with radiusInMeters as integer type - as replacement for the deprecated constructor with radiusInMeters as double type. HERE SDK for Android, iOS and Flutter (beta) Explore Edition ( Version 4.4.3.0) Kinetic map panning behavior was greatly improved. Now, when swiping the map moves slower which results in a more natural feel. Certain areas can now be excluded from route calculation with AvoidanceOptions that contain an avoidAreas list holding GeoBox items which routes should not cross. Added optional Suggestion.getHref() to get a direct link to discover more details. It is available when the suggestion result type is category or chain . Added RoadFeatures.DIFFICULT_TURNS enum value. Note that it is valid only for truck transport mode. Added MapError.INVALID_STATE enum value which can be raised when a map scene is in an invalid state after a MapView was destroyed. Added a new GeoCorridor constructor with radiusInMeters as integer type - as replacement for the deprecated constructor with radiusInMeters as double type. HERE SDK for Android and iOS and Flutter (beta) Navigate Edition ( Version 4.4.3.0) Same new features as the Lite and Explore versions. HERE Location Services Fleet Telematics API ( Version 3.0.34) Waypoints Sequence now supports bicycle mode. Following vehicle types are now permitted: car, truck, pedestrian, bicycle. New toll cost feature: Hourly price cap in Oslo. AutoPASS owners in Oslo pay only for one toll point within an hour. Use &tollPass=AutoPass . Routing response's maneuver object now contains RoadName and nextRoadName. Activate by & maneuverAttributes=RN,NR Important: Link IDs will exceed 32 bits soon, PLEASE PREPARE YOUR APPLICATIONS TO HANDLE LINK_ID VALUES > 4 BILLION!", "date": "2020-09-21"},
{"website": "Here", "title": "CNN's London Olympics Coverage", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/london-olympics-coverage", "abstract": "CNN used HERE's photorealistic 3D Maps technology to create stunning 3D views and flyovers of Olympic venues and London Olympic village sites. HERE's highly customizable 3D technology allowed CNN to create unique overlays and views that resulted in amazing 3D showcases covering Olympic marathon route, Wimbledon Tennis Club, Olympic Village and Hyde Park.", "date": "2016-01-20"},
{"website": "Here", "title": "Introducing the new HERE Isoline API v8", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/introducing-the-new-here-isoline-api", "abstract": "The Isoline endpoint is now its own API and I can't wait to talk about it. In this post, I will take you through the brand-new feature packed HERE Isoline API v8. I will cover the features common with the isoline endpoint in Routing v7 API and talk about additional features in this one. Let's begin! The HERE Isoline API v8 is an answer to the question- 'How far can I reach in X minutes?' or 'Where can I reach by driving/walking for Y meters?'. And this API happens to be available under the freemium plan . Some of the use-cases when you would ask these questions are: I am looking for a house which has a grocery store within 10 minutes of walking distance. I am looking for schools that are a maximum of 5Km driving distance from my house. I am a restaurant that needs to deliver pizzas within 30 minutes and thus need to define my delivery radius. Now you may wonder for case no 2, we can just draw a circle of 5km radius on the map and all the places within it are reachable, right? Absolutely not! If you get a route from the center of this circle to a place along the circumference, the distance can often be more than 5km. If you don't believe me, why don't you check out this example . Now that you're with me, let's take a look at how the HERE Isoline API v8 can help you with this. Consider the third use case - I need to find all the places that I can drive to in 30 minutes. let url = `https://isoline.router.hereapi.com/v8/isolines?`+\n            `apiKey=${window.apiKey}`+\n            `&range[type]=time`+\n            `&range[values]=1800`+ // 30 min x 60 sec\n            `&origin=52.5308,13.3847`;\n\n    fetch(url)\n    .then(result => result.json())\n    .then(result=>{\n        console.log(result);\n    })\n    .catch(error =>{\n        console.log(error);\n    }) What I have above is the HERE Isoline endpoint and my apikey . If you haven't got one, get it from developer.here.com . Next, we have range - type and value. Range type asks you whether you want to calculate the isoline w.r.t time or distance . If your choice is time , the range value is defined in seconds. If the range type is distance , the value will be in meters. And finally, we have the origin of this isoline, a location point. In this case, it is the location of this pizza restaurant. What you get in response is a flexible polyline that encodes all the points where you can reach from the origin by driving for 30 minutes. It looks something like this. {\n        \"departure\": {\n            \"place\": {\n                \"type\": \"place\",\n                \"location\": {\n                    \"lat\": 52.5309837,\n                    \"lng\": 13.384567\n                },\n                \"originalLocation\": {\n                    \"lat\": 52.5307999,\n                    \"lng\": 13.3847\n                }\n            }\n        },\n        \"isolines\": [\n            {\n                \"range\": {\n                    \"type\": \"time\",\n                    \"value\": 1800\n                },\n                \"polygons\": [\n                    {\n                        \"outer\": \"BG6lm9jD2z1_Y61Cy2G0rF2rF81CwhI71CuhIzrF2rF51CwhIAq3K61CwhIq6aq6a61CwhIAq3K61CwhI2rFA61CvhIAz01B61CvhIs3Kp3KuhI51Cs3KAwhI61C61CwhIAq9qB61CuhI2rF2rF61CwhIAq3K61CwhI2rFA0rF_iQs3Kp3KuhI51CwhI61Cs3Kq3K61CwhIA0uV61CwhI2rF2rF61CwhIA0uV51CwhI1rF2rFA0rFgjQgjQ0rFgjQ2uV0uVwhI61CuhI51C81CvhI71CvhI9iQ_iQ71CthIApjrC81CthI-iQ1rFA1rFzrFzrF51CvhIA_lgB61CthIgjQ1rF0rF1rFwhI51CgmgBAuhI51C2rF1rFwhI51CwhI61CgjQgjQ0rFAgjQ_iQwhI51CwhI61C0rFgjQ2rF2rF0rF-iQ2rF2rF61CwhIA-lgB81CwhI-iQgjQ81CwhIAq3K61CwhIq3Kq3K2rFA0rF1rFgjQzrF2rF1rFuhI51Cs3KAuhI51CgjQ_iQwhI51Cq9qBAwhI61C0rF0rF2rFA-iQ9iQwhI71CwhI81CgjQ-iQ2rFA61CthIAz61C61CvhIq3Kp3KwhI51CwhI61Cq3Kq3K81CwhIAyg2D61CwhIwhI61CwhI51C-iQ_iQwhI51CwhI61Cq3Kq3K61CwhIAgmgB51CwhIp3Kq3K_iQ0rF51CwhIAq3K51CwhIp3Kq3K1rFA_iQ9iQvhI71CvhI81CA0rF2rF2rF61CwhIA-rgC51CwhI1rF0rF51CwhIAgmgB51CuhI1rF2rF51CwhIAq3K51CwhI1rF0rF51CwhI61CwhI2rFA0rFzrFwhI71CwhI81Cq3Kq3K2rFgjQ0rF0rF81CwhIA0uV71CwhIp3Kq3KvhI81CzuVAvhI61Cp3Kq3K1rFgjQzrF0rF51CwhIAq3K61CwhI0rF2rF2rFgjQgjQ0rFq3Kq3K61CwhIA2uV51CuhIp3Ks3K_iQ0rFA2rF2rF0rF61CwhI51CwhI1rF2rF1rF-iQzrF2rF51CwhI61CwhI0rF0rF81CwhI71CwhIzrF2rF1rF-iQvhI81Cp3KAvhI71CzrFzrF1rFA51CwhIAq3K51CwhIvhI61Cp3KAvhI61C1rF2rF_iQ2rFA0rF2rF2rF2rF-iQuhI81Cs3KAuhI61C2rF2rF2rFA0rF1rFwhI51Cq3KAwhI61Cq3Kq3K81CwhIA0uV71CwhI_iQ2rFzrF0rFvhI81Cp9qBAthI71C1rFzrFvhI51CzuVAvhI61C51CwhIA0uV71CwhIzrF2rF71CuhIAgmgB51CwhI_iQ0rFzxlB0xlBvhI81Cp3KAvhI71C51CthIA_lgB61CvhI2rFzrFA1rF_iQ1rFzrF9iQ1rFA1rF-iQzrF2rF51CwhIA001B71CwhIvhI61Cp3KAvhI51Cp3Kr3K51CthIAr3K51CvhIr3Kp3KzrFA1rFgjQzrF2rF71CwhIAq3K51CwhIzrF0rF71CwhIAq3K51CwhIvhI61Cp3KAvhI51C1rF_iQzrFzrF51CvhIAz01B71CvhIzrFzrF1rF_iQ_iQ1rFp3Kp3K51CvhIA9lgB51CvhIp3Kp3K_iQ1rF_iQ_iQvhI51CvhI61CzrF2rFvhI61CvhI51Cp3Kp3K1rF_iQzuVzuVvhI71CvhI81Cp3Kq3K1rFgjQp3Kq3KvhI61CzuVAvhI51C51CvhIA_lgB61CthIq6ap6a61CvhIA1uV81CthIq3Kr3KwhI51Cq3KAwhI51C0rF_iQ2rF1rF61CthIA1uV61CvhI2rFzrFA1rF_iQ_iQ51CthIA_lgB61CvhI2rFzrFA1rF_iQzrF51CvhIA_lgB61CvhI2rFzrF61CvhIA_lgB51CvhI_iQ9iQ51CvhI61CvhI2rF1rF0rF9iQgjQ_iQ61CvhIAzuV51CvhI1rF1rF51CvhIAnjrC61CvhIgjQzrFq3Kp3K61CvhIA1uV51CthIvhI71CzuVAvhI51CzrF1rF_iQzrF51CvhIAz01B61CvhI0rFzrFA1rFthI51CvhI61C1rF2rFvhI61CvhI51Cp3Kr3K51CthIA1uV51CvhIvhI51Cp3KAvhI51C1rF1rF_iQzrFp3Kr3K51CthIAp9qB61CvhIq3Kp3K2rFAgjQgjQ0rFA2rF1rFgjQ1rFq3Kp3K61CvhIAp3K61CvhIwhI51Cq3KAwhI-qB81C4gEAy2G\"\n                    }\n                ]\n            }\n        ]\n    } You can use the H.map.Polygon object to render this polyline and display this on your map let sizeIcon = new H.map.Icon(\"assets/pizza.png\",{size:{\n        h:45, \n        w:45}\n    }); \n    let isolineGroups = new H.map.Group();\n    let centerMarker = new H.map.Marker(result.departure.place.location, {icon:sizeIcon});\n    isolineGroups.addObject(centerMarker);\n\n    result.isolines.forEach(isoline=>{\n\n        isoline.polygons.forEach(polygon=>{\n\n            let linestring = H.geo.LineString.fromFlexiblePolyline(polygon.outer);\n\n            let count= result.isolines.indexOf(isoline);\n\n            // Create a polyline to display the route:\n            let routePolygon = new H.map.Polygon(linestring,{\n            style: { \n                strokeColor: lineColor[count],\n                fillColor:fillColor[count],\n                lineWidth: 3 \n            }\n            });\n\n            isolineGroups.addObject(routePolygon);\n        });\n\n    });\n    \n\n    map.addObject(isolineGroups);\n    // Set the map's viewport to make the whole route visible:\n    map.getViewModel().setLookAtData({bounds: isolineGroups.getBoundingBox()}); Now let's say your car broke down and you call your friends to come and get you. Your friends are debating over, who can get to you the fastest. The reverse isoline endpoint can help your friends do just that. Instead of the origin, mention the destination location and you're all set. This feature is popular among ride sharing and fleet management applications. let url = `https://isoline.router.hereapi.com/v8/isolines?`+\n    `apiKey=${window.apiKey}`+\n    `&range[type]=time`+\n    `&range[values]=600`+ // 10 min x 60 sec\n    `&destination=52.5308,13.3847`;\n\n    fetch(url)\n    .then(result => result.json())\n    .then(result=>{\n    console.log(result);\n    })\n    .catch(error =>{\n    console.log(error);\n    }) These were some of the features that the HERE Isoline API v8 shares with the isoline endpoint from the HERE Routing v7 API. Let's talk about what's new. We know that the same car route from A to B can look different depending on the traffic at the time of the day. While the routing API takes care of this, the HERE Isoline API also lets us define departureTime to combat this difference. Below is an example of two isolines with identical parameters except for the departure time. One is &departureTime=2020-07-31T06:30:00 and the other is &departureTime=2020-07-31T18:30:00 The second exciting new feature is that with the HERE Isoline API v8, you can define multiple range values to get multiple isolines. Let's say I want to look at all the places I can drive to which are within the 1Km, 2Km and 5Km range. To do this, you can simply define the 3 range values separated by a comma. What you will get are 3 distinct isolines in the same response object. let url = `https://isoline.router.hereapi.com/v8/isolines?`+\n    `apiKey=${window.apiKey}`+\n    `&range[type]=distance`+\n    `&range[values]=1000,2000,3000`+ //distance in meters\n    `&origin=52.5308,13.3847`;\n\n    fetch(url)\n    .then(result => result.json())\n    .then(result=>{\n    console.log(result);\n    })\n    .catch(error =>{\n    console.log(error);\n    }) This was just a part of what the HERE Isoline API v8 can do. Did you know it can avoid tunnels? Did you know it can optimize the isoline shape to give you fewer points in return? Head over to the documentation to check out all the features of the HERE Isoline API v8. Meanwhile, feel free to share your cool isoline projects with us and stay tuned for blog posts on other cool HERE APIs.", "date": "2020-09-17"},
{"website": "Here", "title": "Render HERE Map in IBM Node RED - Part 1", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/render-here-map-in-ibm-node-red-part-1", "abstract": "Prototyping plays a big role in Internet of Things , where you would want to try out combination of different components before creating a product . One of the best most popular tools for prototyping is Node RED by IBM and it works wonders when combined with Location Services. Node RED is a flow-based development tool for visual programming developed originally by IBM for wiring together hardware devices, APIs and online services as part of the Internet of Things. Below, I will show you how to set up get started in Node RED with HERE Maps. Let’s get started. Prerequisites To start with Node RED and integrate HERE map , you will need – An IBM Cloud account (you can sign up here ) Freemium account on HERE Developer portal From IBM Cloud, you need to access Node RED and create a Node RED application . You will also need an API key from the HERE Developer Portal (which we will use in the code). Simply sign up for your free account and generate API key on your account page. Creating Node RED Application After logging into your IBM Cloud account, you will be on the dashboard page. You need to create a service by clicking on 'Create resource' (as shown in the image below). This will take you to the IBM Product Catalog page. There, search for 'Node RED' (as shown below) and select the first option. You will reach a page where you will be prompted to give it a name and link it to a Cloudant instance. If you already have a Cloudant DB, you can link it from the drop down menu or create a new instance. Then click on 'Create' to move to the next step. Then you will be redirected to an overview page of the application. In order to use the application, you will need to deploy it on Cloud Foundry. To do so, click on \"Deploy your app\" button. The Node-RED Starter kit only supports deployment to the Cloud Foundry space of IBM Cloud. Select the region to deploy your application to. This should match the region you created your Cloudant instance in. Lite users might only be able to deploy to your default region. Click Next to continue. Configure the DevOps tool-chain by selecting the region it should be created in, try to match the region you selected previously. Click Create. This will take you back to the application details page. Deploying the application will take few minutes. After it's done deploying, you will notice the application details have been updated and now you can access the Node-RED Application from App URL. When you click on the click, you will be prompted to configure your Node-RED application. Once you are done, you will be redirected to a new page. Click on \"Go to your Node-RED flow editor\" to open Node-RED. The Node-RED editor page will open with a bunch of controls and information. Conclusion In this part, w e completed the initial setup and are now ready to get started with Node RED. Next, I will introduce HERE Maps and add a node to show the map in your browser.", "date": "2020-09-15"},
{"website": "Here", "title": "BING Maps", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/bing-maps", "abstract": "Microsoft uses HERE Platform APIs for Traffic and Geocoding, leveraging HERE’s global coverage to bring its leading maps offering to countries around the world.", "date": "2016-01-06"},
{"website": "Here", "title": "HERE Data Layers At a Glance", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-data-layers-at-a-glance", "abstract": "If you have been following HERE Directions closely, or have read the announcement , you already know that we just announced HERE Data Layers as part of our Freemium plan on the HERE Developer Portal. In a nutshell, HERE Data Layers are an incredibly rich set of map data that you can download - right now - and analyze to your heart's content. In this post I'm going to explain what this means for developers, how you can get started, and share a simple demonstration of how the data could be used. I'll clearly spell out what the limits there are and what's available at the paid tier. Let's get started. What Exactly Is It? HERE Data Layers is map data. This map data is available for nearly seventy cities around the world including 10 data layers and over 500 different attributes per city . Th e map data is provided as GeoJSON format layers that are high quality and based on HERE’s globally consistent specification . These layers can be used individually or combined for multiple use cases ranging from map display, s patial analytics, business intelligence and machine learning. We are providing these data layers via HERE Studio and Data Hub , making it easy to visualize and analyze . For folks new to GeoJSON , you can check out my introduction to it for a good introduction . What's in the Layers? As I mentioned , the data covers a very extensive range of information. Users can customize the data and select which layers to work with. You can find a good overview of the layers in the documentation , but here's a quick overview : Navigable Roads: Information about drivable roads that includes things like driving direction and speed limits. Traffic Restrictions: Information related to things that impact drivers, like turn restrictions. Land Use and Land Cover: Land use describes how people use a particular section of land (stadium, park, etc.) while land cover describes the nature of the area (forest, swampland, etc.). Hydrography: Everything related to water - lakes, rivers, and more. Buildings: You get one guess as to what this includes. Administrative Divisions: Political organization data like postal zones and information related to currency, language, time zones and more. Traffic and Destination signs: Layers related to things like stop signs and signs you see from the highway telling you what's coming up down the road. Places: POIs (Points of Interest) with additional data related to open hours, contact information, and more. As you can image, this all gets rather detailed. You can bookmark the Schema Definition for particulars on each layer and values returned. You'll be seeing a few below as well. What do I get? Ok, let's talk turkey. At the F reemium level, you get access to one city, and all its layers. Note that the data is centered on a city area but not necessarily equal to the city's boundaries. You then get new updates every couple of weeks for six months for those layers. At the Pro level, you get access to two cities and all the layers, with no expiration of updates for new data sets. The Pro account gives you even more of course. As always, you can see details about our different pricing levels and current costs on our Pricing page. How do I get started? To get started, you'll need a HERE developer account (you get access to HERE Data Layers in Freemium already ) and at least one project defined for your account. Login to your account, select your project, and then scroll down to the bottom of the page. Here you will see a button to get started with Data Layers: After clicking the \"Get Started\" button, you will see an expanded set of options: From here you can decide which layers you're interested in as well as which city. For my test, I selected all the layers and Houston, Texas as the location: Now you can save your data, but before doing so you'll need to enter a valid credit card. As the popup says, you will NOT be charged if you stay within the limits , and you will not need to enter this again. After you've finished entering your billing information you will be brought back and can then click \"Save to Data Hub\" again. You'll get one last confirmation to ensure you are satisfied with your selection: Finally, you'll get a notice that your data is being uploaded: When you dismiss that, you'll be presented with three options for viewing your data: HERE Studio, the Data Hub command line, and a GeoJSON viewer. As the data is GeoJSON itself, once you have the data itself locally you can use any viewer to work with it. For a quick and easy way to see your data, select the Studio option. This brings you to the Data tab of Studio itself where you can see your new layers: At this point if all you want is the raw data, figure the layer you want (the names should clue you in to what they contain), click the three dot menu on the right and select download: Remember that you can also use the Data Hub CLI to get the contents of the layer. To give you an idea of how this data looks, here is one feature from Houston and the traffic sign layer: {\n    \"id\": \"703813335\",\n    \"type\": \"Feature\",\n    \"properties\": {\n        \"category\": \"REGULATING\",\n        \"signType\": \"Stop\",\n        \"endOfLink\": \"NON_REF_END_OF_LINK\",\n        \"references\": [\n            {\n            \"ids\": [\n                \"17925105\"\n            ],\n            \"layerId\": \"navigable-roads\"\n            }\n        ],\n        \"featureType\": \"RoadSign\",\n        \"isoCountryCode\": \"USA\",\n        \"@ns:com:here:xyz\": {\n            \"tags\": [],\n            \"space\": \"qxuxftIl\",\n            \"createdAt\": 1599146275352,\n            \"updatedAt\": 1599146275352\n        },\n        \"@ns:com:here:mom:meta\": {\n            \"layerId\": \"traffic-signs\",\n            \"sourceId\": \"here-product-primitives-traffic-signs-geojson-ext-v1\",\n            \"modelVersion\": \"1.0.0\",\n            \"catalogVersion\": 33\n        }\n    },\n    \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n        -95.37185,\n        29.78791,\n        0\n    ]\n    }\n}, You can see that this one is a stop sign. In case you're curious, there's 5987 stop signs in the Houston area covered by Data Layers. Let's actually see if we can map that ! In HERE Studio, create a new project and include the traffic signs data. Out of the box, Studio will render all the signs available from the layer: Studio supports conditional styling, so let's actually build a new rule that calls out those stop signs: I did some updating to the default colors and sizes HERE Studio picked and crafted a map where the stop signs are shown by red boxes: What Next? In the next few weeks, we'll have more hands-on examples related to Data Layers coming out. Be sure to sign up for a free developer account and find us on Twitter and Slack for more help!", "date": "2020-09-16"},
{"website": "Here", "title": "Build your own fitness app with the HERE Android SDK", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/build-your-own-fitness-app-with-the-here-android-sdk", "abstract": "A few weeks ago, my fiancé gave me a fitness tracker as a present. I'm guessing she did so, because I love gadgets and had been thinking about getting one for a while. She may also have been trying to send me a not-so-subtle message. Let's be honest, I haven't really been keeping up with my fitness program since moving to Berlin, and it's starting to show. The key thing my shiny new toy does, is to try and encourage me to take at least 10.000 steps a day. I'm not entirely sold on the science behind it, but apparently that's the threshold where you start to see tangible health benefits. The device can track how many steps I take and as it turns out, I walk about 8.000 steps on a normal workday. Not bad, but not quite enough to hit that magic number of 10.000. Worse, on weekends I usually manage even fewer steps, which drags down my average. My first attempt at getting more steps out of a day, involved leaving the S-Bahn a station too early on my way home, and taking a stroll along the East Side Gallery . This worked, but it quickly got boring, not to mention that I've probably ended up in the background of hundreds of tourist selfies. (Look for me on the Instagram feed of your Japanese friends on their tour of Europe!). I needed a better way. I needed an app. To be more precise, I needed an app that could find interesting destinations within a certain number of steps from my current position. For example, let's say I want to take a walk on my lunch break and get about 4.000 steps done. Our office is in the middle of Berlin, so there should be plenty of interesting locations about 2.000 steps away. If I had an app that could find these locations and show me a pedestrian-friendly route to them, I would probably take more (and more interesting) walks. Well, this sounded like a job for the HERE Android Premium SDK and so I decided to build it myself. As it turns out, you can build your own simple fitness app in less time than it takes to walk 10.000 steps! Let's have a look at how I did it. If you follow along, you will learn about displaying a map in your app, finding interesting places, displaying markers, using routing, and more. Setting up the map The obvious first step towards our app is to display a map. Fortunately, this is already covered in our quick start guide . Just follow the instructions in the quick start and you'll have working map in your app in no time. There's also an even faster way. The SDK download already contains a project called BasicMapSolution in the tutorials folder.  You can use this as your starting point. Some quick tips: Remember that you need to use your own credentials in order to access the map services from your app.  If you don't have credentials yet, don't worry! We've got you covered with a free 90-day trial . Also, when you create your app during signup, remember the namespace you've chosen (or look it up in your account). Your credentials are tied to that namespaces, so make sure to use it for your app. If something doesn't work, this is the first thing to check. In addition, verify that your credentials are correctly set in AndroidManifest.xml . With that out of the way, let's get started. Here's how the end result should look. Getting our location Now that your basic app is working and displaying a map, the next step is to figure out what where we are and to show this location. The PositioningManager and PositionIndicator classes will help us get this done. PositionManager provides you with information about the device's geographical location, such as current position and average speed. The PositionIndicator is a special map marker that allows you to show the current position on the map. Every map object has this indicator, but it is set invisible by default. Go ahead and create a PositioningManager object, start it and then set the PositionIndicator for our map to visible. You should do this after the map fragment has been initialized. Have a look at the code below or check out the positioning user guide for more details. private PositioningManager posManager; ... private void onMapFragmentInitializationCompleted() { // retrieve a reference of the map from the map fragment map = mapFragment . getMap(); // start the position manager posManager = PositioningManager . getInstance(); PositioningManager . getInstance(); posManager . start( PositioningManager . LocationMethod . GPS_NETWORK ); // Display position indicator map . getPositionIndicator() . setVisible( true ); ... } view raw fitness-app-1.java hosted with ❤ by GitHub Finding interesting places Now that we know where we are, it's to find some interesting places to walk to. The Places features of the SDK will help us do just that. Among other things, Places allows us to search for points of interest, which happens to be exactly what we're looking for. To perform a search, we must first create a new ExploreRequest and set the options we want. public void findPlaces( View view) { // collect data to set options GeoCoordinate myLocation = posManager . getPosition() . getCoordinate(); EditText editSteps = ( EditText )findViewById( R . id . editSteps); int noOfSteps; try { noOfSteps = Integer . valueOf(editSteps . getText() . toString()); } catch ( NumberFormatException e) { // if input is not a number set to default of 2500 noOfSteps = 2500 ; } range = ((noOfSteps * 0.762f ) / 2 ); // create an exploreRequest and set options ExploreRequest request = new ExploreRequest (); request . setSearchArea(myLocation, ( int )range); request . setCollectionSize( 50 ); request . setCategoryFilter( new CategoryFilter () . add( Category . Global . SIGHTS_MUSEUMS )); try { ErrorCode error = request . execute( new SearchRequestListener ()); if ( error != ErrorCode . NONE ) { // Handle request error } } catch ( IllegalArgumentException ex) { // Handle invalid create search request parameters } } view raw fitness-app-2.java hosted with ❤ by GitHub Let's have a look at the options in more detail. The search area defines the space in which we are looking for points of interest. It is defined by our current location and a range. We can easily get our current location using the PositioningManager, but the range should be based on the number of steps the user wants to walk. In this case we use an EditBox to let user input that information into the app. However, since the range is set in meters, we also need to convert the number of steps into meters. There are various formulas available to this, some of which involve measuring your step length, but we are using a simple version, where we simply multiply the number of steps with 0.762. I have found this to be surprisingly accurate in practice. The collection size determines how many results we want to receive per result page. We're only going to be using one page and set this to a value of 20. That should offer plenty of choices, but feel free to experiment. More important is the CategoryFilter, which allows us to select the type of results we want to get. In our case we're looking for interesting places to walk to, so \"sight & museums\" looks like a good choice. Feel free to experiment here as well, for example by using \"leisure & outdoor\". You can have a look at the search & discovery guide for more details. Now that we created the request and set its options, we can start the search. Note that we need to provide a ResultListener, whose onCompleted() callback will be executed when the request has finished. This looks as follows. class SearchRequestListener implements ResultListener< DiscoveryResultPage > { @Override public void onCompleted ( DiscoveryResultPage data , ErrorCode error ) { if (error != ErrorCode . NONE ) { // Handle error } else { // results can be of different types // we are only interested in PlaceLinks List< PlaceLink > results = data . getPlaceLinks(); if (results . size() > 0 ) { for ( PlaceLink result : results) { // get all results that are far away enough to be a good candidate if (result . getDistance() < range && result . getDistance() > (range * 0.7f )) { GeoCoordinate c = result . getPosition(); com.here.android.mpa.common . Image img = new com.here.android.mpa.common . Image (); try { img . setImageAsset( \" pin.png \" ); } catch ( IOException e) { // handle exception } MapMarker marker = new MapMarker (c, img); marker . setTitle(result . getTitle()); // using a container to group the markers placesContainer . addMapObject(marker); } } } else { // handle empty result case } } } } view raw fitness-app-3.java hosted with ❤ by GitHub As you can see, the search returns us a list of PlaceLinks. However, these aren't quite the results we are looking for yet. Remember, we asked for all sights & museums within a certain range around the user. That also includes places right next to him or her. So we still need to filter the results to only show those that are far away enough to meet the user's step goal.  We can use result.getDistance() to do this. For each remaining result, we then create a MapMarker object. MapMarkers allow you to display an icon on the map. Note two things. First, we place the markers in a MapContainer object called placesContainer. MapContainer are useful for grouping other MapObjects (like MapMarkers) and also help determine the stacking order of objects on the map. Second, in addition to setting an icon for each marker, we also give them titles based on the name of the result. We are using this later when displaying the route. Now all we need to do is to add a button to our app, make it call the findPlaces() function and we should see our potential walking destinations displayed on the map. Selecting a destination and calculating a route The next step is to make it possible to select our markers. We do this by creating an OnGestureListener and overriding its onMapObjectsSelected() method. This allows us to react whenever the user taps on any map object. MapGesture . OnGestureListener listener = new MapGesture . OnGestureListener . OnGestureListenerAdapter () { @Override public boolean onMapObjectsSelected ( List< ViewObject > objects ) { // There are various types of map objects, but we only want // to handle the MapMarkers we have added for ( ViewObject viewObj : objects) { if (viewObj . getBaseType() == ViewObject . Type . USER_OBJECT ) { if ((( MapObject )viewObj) . getType() == MapObject . Type . MARKER ) { // save the selected marker to use during route calculation selectedMapMarker = (( MapMarker ) viewObj); // Create the RoutePlan and add two waypoints RoutePlan routePlan = new RoutePlan (); // Use our current position as the first waypoint routePlan . addWaypoint( new GeoCoordinate ( posManager . getPosition() . getCoordinate())); // Use the marker's position as the second waypoint routePlan . addWaypoint( new GeoCoordinate ( (( MapMarker ) viewObj) . getCoordinate())); // Create RouteOptions and set to fastest & pedestrian mode RouteOptions routeOptions = new RouteOptions (); routeOptions . setTransportMode( RouteOptions . TransportMode . PEDESTRIAN ); routeOptions . setRouteType( RouteOptions . Type . SHORTEST ); routePlan . setRouteOptions(routeOptions); // Create a RouteManager and calculate the route RouteManager rm = new RouteManager (); rm . calculateRoute(routePlan, new RouteListener ()); // Remove all other markers from the map for ( MapObject mapObject : placesContainer . getAllMapObjects()) { if ( ! mapObject . equals(viewObj)) { placesContainer . removeMapObject(mapObject); } } // If user has tapped multiple markers, just display one route break ; } } } // return false to allow the map to handle this callback as well return false ; } }; view raw fitness-app-3.java hosted with ❤ by GitHub When a user taps the map, the OnGestureListener gives us a list of all ViewObjects that were touched. In order to make sure we only consider our markers, we only look at objects that are of type MARKER. Using the selected marker, we can now start our route calculation. Routing is done via the RouteManager class, which calculates a route based on the waypoints and RouteOptions that have been set in a RoutePlan. We thus create RoutePlan object and add two waypoints to it: our current location, and the location of the selected marker. We also set some appropriate options, in particular the transport mode. This should be set to PEDESTRIAN, as we are looking for a walkable route. Once we have finished route plan, we can create a RouteManager and start calculating the route. You can check out the Routing Calculation guide for more details. Now that our OnGestureListener is finished, it's important that we don't forget to add it to the map. We do this in onCreate, after onEngineInitializationCompleted. Displaying a route We have now started our route calculation and the only thing that remains is to display the result on the map. As you will have noticed, the RouteManager calls a Listener when the route calculation is complete, so this is the perfect place to implement this. private class RouteListener implements RouteManager . Listener { public void onProgress ( int percentage ) { // You can use this to display the progress of the route calculation } public void onCalculateRouteFinished ( RouteManager . Error error , List< RouteResult > routeResult ) { // If the route was calculated successfully if (error == RouteManager . Error . NONE ) { // Render the route on the map mapRoute = new MapRoute (routeResult . get( 0 ) . getRoute()); map . addMapObject(mapRoute); int routeLength = routeResult . get( 0 ) . getRoute() . getLength(); float steps = 2 * (routeLength / 0.8f ); String title = selectedMapMarker . getTitle(); title = String . format( Locale . ENGLISH , \" It's %d steps to %s and back! \" , (( int )steps), title); selectedMapMarker . setTitle(title); selectedMapMarker . showInfoBubble(); } else { // Display a message indicating route calculation failure } } } view raw fitness-app-5.java hosted with ❤ by GitHub The result of the route calculation is a MapRoute. This is just another map object, similar to our MapMarkers, which means we can display it by simply adding it to the map using map.addMapObject(mapRoute). Finally, we determine the step count (based on the actual length of the route), update the title of the MapMarker with that information and call showInfoBubble() on the marker. This displays its title in, you guessed it, an info bubble! And that's it! You can now determine how many steps you want to take, find an interesting place in just the right distance, and get a pedestrian friendly route to it. It's not quite ready to top the Google Play charts for fitness apps, but it's good enough that I use it almost every day. This app has taken me places I wouldn't have otherwise discovered, including lots of cool street art here in Berlin. More importantly, my fitness tracker is happy: I always get my 10.000 steps now. You can check out a Gist of the complete code here , and get started with your free trial right here .", "date": "2016-04-27"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 2: Geolocation)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-2-geolocation", "abstract": "Who wants ice cream?! — In this series of tutorial blog posts we are going to develop a small web application called “Gelary” using the HERE Maps API for JavaScript. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will be a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualise a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain JavaScript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous and very first post in our series we've learned how to acquire credentials for HERE's API services, render a basic map view, control the maps basic functionality through code and how to place a marker with a custom icon. If you haven't read it — we'd recommend to check it out before moving on. In this post we will request the user's current physical location via his or her web browser's geolocation API and update the map accordingly. Sounds good? Let's get to it! Browser Geolocation API The Geolocation API has been supported by browsers for quite some time. Even Internet Explorer has enabled its use since version 9. The API may be accessed from within our JavaScript code using the global navigator.geolocation object. Before we start using this API in our little app, let's take a look at some of its methods. Them method names give a good idea as to what they do: Method Description getCurrentPosition() Obtain the user's current location. watchPosition() Watch the user's location and trigger a callback every time it changes. clearWatch() Stop watching a user's location. Let's start by looking at getCurrentPosition . This method gives us the current geolocation of a device. It takes three arguments: The success callback function which takes a position object as input parameter. The error callback function which takes an error object as input parameter. And an options object for further configuration options . navigator . geolocation . getCurrentPosition (success[, error[, options]]); view raw gelary-part2-1.js hosted with ❤ by GitHub However, the getCurrentPosition will give only give you a user's location once. This won't do for our little ice cream delivery application — we want to know where we are at all times while we're racing to deliver the cold goods! This is where watchPosition comes into play. This method takes exactly the same arguments as getCurrentPosition but the success function will be called every time the position of the device changes. Great! Let's start using this handy API in our application. In scripts/app.js add the following lines at the bottom: function updatePosition ( event ) { var HEREHQcoordinates = { lat : event . coords . latitude , lng : event . coords . longitude }; var marker = new H.map.Marker (HEREHQcoordinates); map . addObject (marker); map . setCenter (HEREHQcoordinates); } navigator . geolocation . watchPosition (updatePosition); view raw gelary-part2-2.js hosted with ❤ by GitHub It's really that simple! This short piece of code will re-center the map every time the user's position changes and render a marker for the new location. Excellent! When you go and refresh your browser you will likely be asked for permission to use your location via a small dialog in order to protect your privacy: Note: We recommend to use Firefox for this tutorial as Google Chrome restricts the use of the Geolocation API if requested from a file:/// URI. If you'd like to continue to use Chrome for we recommend to use a small development server locally. Pro tip: watchPosition returns an id which may be used to call clearWatch later in order to stop watching for location updates: var watchID = navigator . geolocation . watchPosition ( function ( position ) { // Do something interesting here }); // … later navigator . geolocation . clearWatch (watchID); view raw gelary-part2-3.js hosted with ❤ by GitHub Wrapping up Today we have learned to create another important piece of our ice cream delivery app: figuring out where we. A few small lines in our code, a giant leap towards am ice cream-driven economy. In the next post we are going to explore how to navigate on a map and how to find routes. Stay tuned!", "date": "2016-10-18"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 1: Basic Map Set-up)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-1-basic-map-set-up", "abstract": "Who wants ice cream?! — In this series of tutorial blog posts we are going to develop a small web application called “Gelary” using the HERE Maps API for JavaScript. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will be a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualise a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain JavaScript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In this first post we'll setup our work environment and acquire credentials for the HERE APIs. Once everything is up and running we'll learn how to render a basic map view, control the map's basic functionality through code and how to place a marker with a custom icon. Acquiring credentials for the HERE API The very first thing we need is to create a HERE account and register our application — no worries, this will just take a moment. Our 90-day free trial will do nicely for this tutorial (and a lot more). After signing up for our account we create a new application and select a name for it. Once that's done, we'll receive two important pieces of information: An \"app ID\" and an \"app code\". (You can always looks these up in your account.) Setting up the skeleton of our app Once we are all done registering our application, we can finally get our hands dirty and start building our app. (By the way, all the source code is available on GitHub to follow along easily. The HERE Maps API for JavaScript is split into multiple modules. This allows us to only include in our project what we actually need. Here are the different modules we will use in our application: File(s) Description mapsjs-core.js Core API, provides core functionality for rendering maps, map layers and map objects. mapsjs-service.js Provides tile retrieval, routing and geocoding. mapsjs-mapevents.js Provides functionality for user interaction. mapsjs-ui.js + mapsjs-ui.css Provides user interface for e.g. map settings, zooming and so on. Let's get coding! We start out by creating an index.html file with a simple HTML structure including script and style tags for the HERE Javascript SDK modules within the <head> tag: < link rel = \" stylesheet \" type = \" text/css \" href = \" https://js.api.here.com/v3/3.0/mapsjs-ui.css \" /> < script type = \" text/javascript \" charset = \" UTF-8 \" src = \" https://js.api.here.com/v3/3.0/mapsjs-core.js \" ></ script > < script type = \" text/javascript \" charset = \" UTF-8 \" src = \" https://js.api.here.com/v3/3.0/mapsjs-service.js \" ></ script > < script type = \" text/javascript \" charset = \" UTF-8 \" src = \" https://js.api.here.com/v3/3.0/mapsjs-ui.js \" ></ script > < script type = \" text/javascript \" charset = \" UTF-8 \" src = \" https://js.api.here.com/v3/3.0/mapsjs-mapevents.js \" ></ script > view raw gelary-part1-1.html hosted with ❤ by GitHub In the <body> tag we then add a container for the map — a <div> tag — into which the map will be embedded. < div id = \" map-container” class= \" map \" ></div> view raw gelary-part1-2.html hosted with ❤ by GitHub Pro tip: In this example we use script tags and static <div> placeholders within our index.html file but the same approach applies if you want to use a JavaScript framework. Displaying a basic map Once you open index.html in your browser you will notice that so far we're stuck with an empty white page — let's change that! We proceed by creating a folder called scripts and a file app.js inside this folder. We then add the code to initialise our map to this file: var platform = new H.service.Platform ({ app_id : ' {YOUR_APP_ID} ' , // // <-- ENTER YOUR APP ID HERE app_code : ' {YOUR_APP_CODE} ' , // <-- ENTER YOUR APP CODE HERE }); var defaultLayers = platform . createDefaultLayers (); var mapPlaceholder = document . getElementById ( ' map-container ' ); var map = new H.Map ( mapContainer, defaultLayers . normal . map ); view raw gelary-part1-3.js hosted with ❤ by GitHub Let's also make sure that the map reacts properly when the window is resized. For this purpose we add the following event listener below our map initialisation. window . addEventListener ( ' resize ' , function () { map . getViewPort (). resize (); }); view raw gelary-part1-4.js hosted with ❤ by GitHub Going further, we include the newly created file in our index.html just before the closing </body> tag: < script src = \" scripts/app.js \" ></ script > view raw gelary-part1-5.html hosted with ❤ by GitHub In order to control the visual appearance of the map, let's also add a dash of CSS. Go ahead and create a folder styles and a file main.css with the following content inside this folder: .map { width : 100 vw ; height : 100 vh ; position : relative ; } view raw gelary-part1-6.css hosted with ❤ by GitHub This piece of code will ensure that the map always fills the viewport completely. Now go and refresh your browser window and you should see your beautiful map. Well done! Interacting with the map While certainly pretty, our map is frankly not very useful yet. Furthermore, the map center seems fairly randomly selected and zooming in or out is not possible either. Let's add some interactivity by enabling the event system. In order to do so, add following line just after the initialization of the map inside scripts/app.js . var behavior = new H.mapevents.Behavior ( new H.mapevents.MapEvents (map)); view raw gelary-part1-7.js hosted with ❤ by GitHub And that's it. Now we can at least move around the map as well as zoom in and out. Let's adjust the center point of the map and the initial zoom level of the map as well. This can be done by passing a options object to the constructor H.Map when initialising the map. var coordinates = { lat : 52.530974 , // HERE HQ in Berlin, Germany lng : 13.384944 }; var mapOptions = { center : coordinates, zoom : 14 } var map = new H.Map ( mapContainer, defaultLayers . normal . map , mapOptions); view raw gelary-part1-8.js hosted with ❤ by GitHub Alright, things are starting to shape up nicely! Pro tip: You can set the map's center pointer and zoom level using map.setCenter and map.setZoom methods at any point in your code. Adding markers to the map In the future we will want to highlight locations such as customers or deliveries on the map using place markers. This is easily done using HERE maps. All we have to do is instantiate a new Marker object by passing in the appropriate coordinates and calling map.addObject . Let's try it in our scripts/app.js file: var marker = new H.map.Marker (coordinates); map . addObject (marker); view raw gelary-part1-9.js hosted with ❤ by GitHub After refreshing the browser window you should see a marker marking in the middle of the map. Pro tip: While map.addObject adds new markers, you can remove them again using map.removeObject . Custom icons for markers Gelary's designers have done an amazing job with the user interface, but they want us to display customer marker icons. As it turns out, that's not a problem. The Marker constructor takes an options object as a second argument. This allows us to define a custom icon, using the H.map.Icon class: var iconUrl = ‘. / images / marker - gelato . svg ’; var iconOptions = { // The icon's size in pixel: size : new H.math.Size ( 26 , 34 ), // The anchorage point in pixel, // defaults to bottom-center anchor : new H.math.Point ( 14 , 34 ) }; var markerOptions = { icon : new H.map.Icon (iconUrl, iconOptions) }; var marker = new H.map.Marker (coordinates, markerOptions); map . addObject (marker); view raw gelary-part1-10.js hosted with ❤ by GitHub Looks great! Wrapping up For now we have set up a very basic interactive map sporting a marker with a custom icon. This work will be the foundation of our amazing ice cream delivery platform. In the next post we are going to integrate with the browser's geolocation API to keep the delivery drivers updated. Stay tuned!", "date": "2016-10-05"},
{"website": "Here", "title": "Yahoo Search, Mail and Flickr", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/yahoo-search-mail-and-flickr", "abstract": "Yahoo uses HERE’s location services to provide its users with highly personalized experiences that keep them connected to the things they care for the most. Yahoo Search leverages HERE’s Maps, Geocoding, Traffic and Routing services to give users the right level of location information such as the surrounding traffic and parking locations, or the appropriate transit and pedestrian directions, when searching for a place. With HERE Maps and Geocoding, Yahoo Mail lets its users map their daily activities and whereabouts while providing them with a history of all visited locations. Flickr leverages the same services to make it easy for users to add, share and discover billions of photos on the map.", "date": "2015-12-01"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 6: Reacting to outside influences)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-6-reacting-to-outside-influences", "abstract": "Who wants ice cream?! — In this series of blog posts we are going to develop a small web application called \"Gelary\"; using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualize a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain JavaScript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we did a fair bit of refactoring, if you haven't read it yet, you might want to take a look at it first before going on . In order to make our application actually useful, we will have to provide our trusty delivery drivers an easy and convenient way to locate an ice-cream shop along their way to the customer. Once the driver has selected a route, we will use the Places API to search for ice-cream parlours in the vicinity of the route and display them on the map. We will further enable the driver then to select a shop and add it as waypoint to the selected route. Sound good? — Let's dive in and get those drivers on the road! Places API Onwards and upwards! At the core of our new feature you‘ll find yet another awesome data API called \"Places\";. The Places API allows us to request Points of Interest (POI) using a search query string and formatted location information. Here's an example from the developer documentation : var search = new H.places.Search ( platform . getPlacesService ()); function onResult ( data ) { // Do something with data … } function onError ( data ) { // Handle an error } // Search for hotels in Chinatown, San Francisco var params = { ' q ' : ' hotel ' , ' at ' : ' 37.7942,-122.4070 ' }; search . request (params, {}, onResult, onError); view raw gelary-part6-1.js hosted with ❤ by GitHub Looks easy enough, right? Indeed it is! — Let's start by wrapping this functionality in our own class. First we create as usual a new file called places.js in our scripts folder and include a reference in index.html somewhere before app.js : < script src = \" scripts/places.js \" ></ script > view raw gelary-part6-2.html hosted with ❤ by GitHub Then we move on to defining our class. Here's our constructor: function HEREPlaces ( map , platform , onClickPlace ) { this . map = map; this . onClickPlace = onClickPlace; this . placeSearch = new H.places.Search ( platform . getPlacesService ()); this . searchResults = []; } view raw gelary-part6-3.js hosted with ❤ by GitHub So far so simple. First we assign a bunch of instance variables including a callback called onClickPlace , grab an instance of H.places.Search and create an array which will eventually hold our search results. Let's continue by defining our instance methods: searchPlaces : HEREPlaces . prototype . searchPlaces = function ( query ) { this . getPlaces (query, function ( places ) { this . updatePlaces (places); }. bind ( this )); }; view raw gelary-part6-4.js hosted with ❤ by GitHub The first obvious candidate is the method used to search for places by providing a query object — most likely the most used instance method on this class. This method in turn refers to a second method called getPlaces which again handles the actual request and iterates over the result. Let's take a look under the hood: getPlaces : HEREPlaces . prototype . getPlaces = function ( query , onSuccessCallback ) { var onSuccess, onError; onSuccess = function ( data ) { if ( data . results && data . results . items ) { var places = data . results . items . map ( function ( place ) { place . coordinates = { lat : place . position [ 0 ], lng : place . position [ 1 ] }; return place; }); onSuccessCallback ( data . results . items ); } else { onError (data); } }; onError = function ( error ) { console . error ( ' Error happened when fetching places! ' , error); }; this . placeSearch . request (query, {}, onSuccess, onError); }; view raw gelary-part6-5.js hosted with ❤ by GitHub The structure of this method looks a bit familiar, doesn't it? Essentially we're defining simply the two required callbacks for our request and submit it to the API. In the case of a successful query we iterate over the response set and formate the coordinates of each POI for ease of use before passing the result on to the function defined as onSuccessCallback parameter. Nice! clearSearch : In addition to our search method we add a way to clear the results and remove markers added to the map. HEREPlaces . prototype . clearSearch = function () { this . searchResults . forEach ( function ( marker ) { this . map . removeObject (marker); }. bind ( this )); this . searchResults = []; }; view raw gelary-part6-6.js hosted with ❤ by GitHub updatePlaces : HEREPlaces . prototype . updatePlaces = function ( places ) { var markerOptions = { icon : new H.map.Icon ( Utils . icons . iceCream . url , Utils . icons . iceCream . options ) }; this . clearSearch (); this . searchResults = places . map ( function ( place ) { var marker = new H.map.Marker ( place . coordinates , markerOptions); this . map . addObject (marker); marker . addEventListener ( ' tap ' , this . onClickPlace ); return marker; }. bind ( this )); }; view raw gelary-part6-7.js hosted with ❤ by GitHub Finally we need a way to actually create the markers representing the result of a successful query and render them on the map. To ensure a clean slate, let's also call clearSearch before doing so. As we are planning on enabling the user to select a shop via it's marker in order to add it to the route by clicking it, this is also the place where we bind the onClickPlace callback to the tap event handler for each marker. That's it! Our HEREPlaces class is all done — you can check it out in it's entirety on GitHub . So far so good but we are not yet triggering any searches anyhow. Let's change that! Map In the constructor for our HEREMap class we're also instantiatiating our shiny new class HEREPlaces class: this.places = new HEREPlaces(this.map, this.platform, this.onChangeViaPoint.bind(this)); As you can see we are referencing a new method called onChangeViaPoint as callback. Let's define that next: HEREMap . prototype . onChangeViaPoint = function ( reroutePoint ) { var viaPoint = reroutePoint . target . getPosition (); this . drawRoute ( this . position , HEREHQcoordinates, viaPoint); }; view raw gelary-part6-9.js hosted with ❤ by GitHub Here we grab the position of the provided reroutePoint and pass it onto our draw method as third parameter. So far, so mysterious. Let's take a look at the updated this.drawRoute method to understand what's going on here: HEREMap . prototype . drawRoute = function ( fromCoordinates , toCoordinates , reroutePoint ) { var startPoint = Utils . locationToWaypointString (fromCoordinates); var endPoint = Utils . locationToWaypointString (toCoordinates); var viaPoint = reroutePoint && Utils . locationToWaypointString (reroutePoint); var routeOptions = { mode : ' fastest;car ' , representation : ' display ' , routeattributes : ' waypoints,summary,shape,legs ' , waypoint0 : startPoint, }; if (viaPoint) { this . updateMarker ( ' viaPoint ' , reroutePoint); routeOptions . waypoint1 = viaPoint; routeOptions . waypoint2 = endPoint; } else { routeOptions . alternatives = 2 ; routeOptions . waypoint1 = endPoint; } this . updateMarker ( ' origin ' , fromCoordinates); this . updateMarker ( ' destination ' , toCoordinates); this . router . drawRoute (routeOptions); this . places . clearSearch (); }; view raw gelary-part6-10.js hosted with ❤ by GitHub We have extended the signature of our method to accept an additional parameter — reroutePoint . That's going to be our waypoint for the selected ice-cream parlour.  Obviously this point won't always be available so we have to check for it's existence and update the route options conditionally. The Route API won't accept the alternatives option if more than two waypoints are defined. Once the route is drawn we clear the places search to reset it. If you take a close look at our constructor you'll notice that we have updated also the signature of our HERERouter initialiser to accept a third parameter: this . router = new HERERouter ( this . map , this . platform , this . onChangeSelectedRoute . bind ( this )); view raw gelary-part6-11.js hosted with ❤ by GitHub Looks like we'll still have to define another method before heading over there, though — onChangeSelectedRoute : HEREMap . prototype . onChangeSelectedRoute = function ( route ) { var middlePointOfTheRoute = Utils . locationToString ( route . routeLine . getBounds (). getCenter ()); this . searchForIcecreamShop (middlePointOfTheRoute); }; view raw gelary-part6-12.js hosted with ❤ by GitHub Aha! This new method is called when the route selection changes and is passed the newly selected route as parameter. Using the getBounds() and getCenter() methods we extract the center point for the route and use it to search for ice-cream parlours close by. searchForIcecreamShop sounds pretty promising but looks like we're still one method short: HEREMap . prototype . searchForIcecreamShop = function ( coordinates ) { var query = { ' q ' : ' ice cream ' , ' at ' : coordinates }; this . places . searchPlaces (query); } view raw gelary-part6-13.js hosted with ❤ by GitHub At last! This is the place where we're passing our query onto our very own HEREPlaces class — looking for some sweet delight! Router Remember that we had changed the signature of our HERERouter constructor? Seems like we're not quite done yet. Let's now head over there and update that class as well to suit our new requirements. As we already know, the constructor now accepts a third parameter called onRouteChange . The passed function is assigned to an instance variable: this . onRouteChange = onRouteChange; view raw gelary-part6-14.js hosted with ❤ by GitHub The place to trigger this callback is clearly the onRouteSelection method: HERERouter . prototype . onRouteSelection = function ( route ) { if ( this . selectedRoute ) { this . selectedRoute . routeLine . setStyle ( this . routeLineStyles . normal ). setZIndex ( 1 ); } route . routeLine . setStyle ( this . routeLineStyles . selected ). setZIndex ( 10 ); this . selectedRoute = route; this . map . setViewBounds ( route . routeLine . getBounds ()); this . onRouteChange (route); }; view raw gelary-part6-15.js hosted with ❤ by GitHub Once a route has been selected we'll trigger the callback. Oh, and while we're at it we'll also adjust the view bounds of the map to suit the selected route. The time has come to try what we have created. Refresh your browser and select a route. If everything works as it should you should see a whole bunch of ice-cream cones along the selected route. Click one and watch your route adjust to include the selected location. Awesome! You'll notice that we're now using ice-cream cone icons for both your location and the ice-cream parlours. That's very confusing. Let's start the next post with a few visual tweaks, shall we? Wrapping up Wow, it's been a wild ride but the hard work has paid off. Our application is actually starting to be useful. In the next post we'll bring Traffic data into our app for an even better routing solution. Stay tuned!", "date": "2016-11-15"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 5: Refactoring)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-5-refactoring", "abstract": "Who wants ice cream?! — In this series of blog posts we are going to develop a small web application called \"Gelary\" using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start -up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualise a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice-cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain Javascript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we had learned how to display multiple routes as well some detail information for each and enable the user to select the best one. If you haven't read it yet, you might want to take a look at it first before going on . Since the last part was so long, we're going to take it easy this time and just do some refactoring to get our code ready for the next set of features. Let's get going. Router As already indicated in the last post, it's time to clean-up our route.js . Let's get to it before we dive into new features! The first thing you might have been wondering about is actually the name. As we're now dealing with multiple routes and related functionality the singular Route is simply no longer appropriate. Let's change it from route.js to router.js and rename the contained class to HERERouter . This should cover our new scope nicely. Let's keep going! Currently our class is a really just one constructor function which in turn contains a bunch of local functions. Let's make better use of JavaScript's prototypical inheritance model and move some functionality into actual instance methods. In this sense we'll introduce three new methods: getRoutes will contain all code needed to retrieve the routes from the API: HERERouter . prototype . getRoutes = function ( options , onSuccessCallback ) { var onSuccess, onError; onSuccess = function ( result ) { if ( result . response . route ) { var routeLineGroup = new H.map.Group (); var routes = result . response . route . map ( function ( route ) { var routeLine = this . getRouteLine (route); routeLineGroup . addObject (routeLine); return { route : route, routeLine : routeLine }; }. bind ( this )); onSuccessCallback (routes, routeLineGroup); } else { onError ( result . response . details ); } }; onError = function ( error ) { console . error ( ' Oh no! There was some communication error! ' , error); }; this . router . calculateRoute (options, onSuccess . bind ( this ), onError); } view raw gelary-part5-1.js hosted with ❤ by GitHub getRouteLine will hold the code necessary to create the visual representation of the route and return a PolyLine instance: HERERouter . prototype . getRouteLine = function ( route ) { var routeShape = route . shape ; // Create a strip to use as a point source for the route line var strip = new H.geo.Strip (); // Push all the points in the shape into the strip: routeShape . forEach ( function ( point ) { var parts = point . split ( ' , ' ); strip . pushLatLngAlt (parts[ 0 ], parts[ 1 ]); }); // Create a polyline to display the route: var routeLine = new H.map.Polyline (strip, { style : this . routeLineStyles . normal } ); return routeLine; }; view raw gelary-part5-2.js hosted with ❤ by GitHub onRouteSelection will define the piece of code called once a route has been selected, e.g. via the panel: HERERouter . prototype . onRouteSelection = function ( route ) { if ( this . selectedRoute ) { this . selectedRoute . routeLine . setStyle ( this . routeLineStyles . normal ). setZIndex ( 1 ); } route . routeLine . setStyle ( this . routeLineStyles . selected ). setZIndex ( 10 ); this . selectedRoute = route; }; view raw gelary-part5-3.js hosted with ❤ by GitHub With this change in place our constructor shrinks quite significantly in size: function HERERouter ( map , platform ) { this . map = map; this . router = platform . getRoutingService (); this . routePanel = null ; this . selectedRoute = null ; this . routeLineGroup = null ; this . routeLineStyles = { normal : { strokeColor : ' rgba(0, 85, 170, 0.5) ' , lineWidth : 3 }, selected : { strokeColor : ' rgba(255, 0, 0, 0.7) ' , lineWidth : 7 } }; var panelElement = document . querySelector ( ' #route-panel ' ); var routePanelOptions = { onRouteSelection : this . onRouteSelection . bind ( this ) }; this . routePanel = new HERERoutesPanel (panelElement, routePanelOptions); } view raw gelary-part5-4.js hosted with ❤ by GitHub As you can see we had to make a few formerly local variables available across the instance for this update to work. Furthermore we have opted to create a routePanelOptions for readability instead of passing it into the HERERoutesPanel constructor inline. Looks like a lot has changed but we really have just split our code into more digestible chunks which makes the end result right away a lot more maintainable. — Nice! Map With our new HERERouter class in place we'll need to update also the HEREMap class which relies on the routing functionality. In the constructor we instantiate the new class: this . router = new HERERouter ( this . map , this . platform ); view raw gelary-part5-5.js hosted with ❤ by GitHub With the router variable available across the instance we can also update the drawRoutes method and replace this . route = new HERERoute ( this . map , this . platform , routeOptions); view raw gelary-part5-6.js hosted with ❤ by GitHub with the following: this . router . drawRoute (routeOptions); view raw gelary-part5-7.js hosted with ❤ by GitHub In the last installment of this series we had also hinted that the marker handling might require a bit of refactoring. It might make sense to extract the marker-related functionality at some point into its own class but for now we can get by by cleaning things up a bit. Let's start by creating a markers instance variable in the constructor to hold information on all of our markers: this . markers = { myLocation : null , origin : null , destination : null }; view raw gelary-part5-8.js hosted with ❤ by GitHub With this change in place we can now simplify the updateMyPosition method: HEREMap . prototype . updateMyPosition = function ( event ) { this . position = { lat : event . coords . latitude , lng : event . coords . longitude }; // Remove old location marker if it exists this . updateMarker ( ' myLocation ' , this . position ) // Draw the route from current location to HERE HQ if not yet drawn this . drawRoute ( this . position , HEREHQcoordinates); this . map . setCenter ( this . position ); }; view raw gelary-part5-9.js hosted with ❤ by GitHub As you can see we have introduced a new updateMarker method to help us with moving markers after they have been created. It takes the name of the marker (a key used with the aforementioned markers container object) and a coordinate pair as parameters. HEREMap . prototype . updateMarker = function ( markerName , coordinates ) { if ( this . markers [markerName]) { this . removeMarker ( this . markers [markerName]); } this . markers [markerName] = this . addMarker (coordinates, markerName); } view raw gelary-part5-10.js hosted with ❤ by GitHub Finally we will make use of our new router variable in the drawRoute method by replacing this . route = new HERERoute ( this . map , this . platform , routeOptions); view raw gelary-part5-11.js hosted with ❤ by GitHub with this . router . drawRoute (routeOptions); view raw gelary-part5-12.js hosted with ❤ by GitHub Wrapping up House keeping isn't exciting work but it sure feels good once it's done! We can now feel a lot more comfortable moving forward and introducing new functionality and are fully set to continue on to the next part: Reacting to outside influences.", "date": "2016-11-08"},
{"website": "Here", "title": "Join HERE at the Lady Problems Hackathon in Berlin", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/join-here-at-the-lady-problems-hackathon-in-berlin", "abstract": "Following on from successful events in Vancouver and Boston, this weekend (Jan 28-29) HERE is proud to sponsor the Berlin edition of the Lady Problems Hackathon series. The Lady Problems Hackathons focus on four challenges that address the key barriers preventing female entrepreneurship: health and access to healthcare; making sure women feel safe when they go to, are at, and come home from work; economic empowerment to maximize the resources women need to grow their business; and helping women gain the support they need from their families, communities, coworkers, and employers. We believe our maps and location services can be a great asset while addressing these challenges and so we are posing a special HERE challenge: we want you to join us in Berlin this weekend and use any of our APIs or SDKs in your hacks! We’re looking for practical and/or creative applications of our maps and location services to any of the Lady Problems challenges. Hacking for a cause is of course its own reward, but we will also be giving away a small herd of Cozmo robots as prizes to the winning team! So what are you waiting for? Sign up here and see you this weekend!", "date": "2017-01-23"},
{"website": "Here", "title": "New Usage Dashboard launched", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/new-usage-dashboard-launched", "abstract": "As you might have already noticed, we implemented a few improvements to our usage dashboard last week. What has changed? We now show data for 23 categories compared to 7 We show combined data for Production and CIT environments by default All options are ticked by default We plan to add even greater granularity on the CSV download (eg. to break Geocoding down into Forward and Reverse requests), so stay tuned for further improvements!", "date": "2017-03-06"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 3: Basic Routing)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-3-basic-routing", "abstract": "Who wants ice cream?! - In this series of blog posts we are going to develop a small web application called \"Gelary\" using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualize a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain JavaScript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we've learned how to request the user's physical location via his or her web browser's geolocation API and update the map accordingly. If you haven't read it - we'd recommend to check it out before moving on. Now it's time to jump into the deep end and get familiar with the routing API. We will start by calculating a route between two locations and draw the result as polyline onto our map. - Ready? Let's dive right in! Using the RoutingService HERE's map API provides a class called Platform to facilitate API calls from the client. We've learned how to instantiate it in our first post by passing our API credentials: var platform = new H.service.Platform ({ app_id : ' [YOUR APP ID HERE] ' , app_code : ' [YOUR APP CODE HERE] ' }); view raw gelary-part3-1.js hosted with ❤ by GitHub In this example we're also able to utilise our platform instance to access the routing service by calling getRoutingService() . var router = platform . getRoutingService (); view raw gelary-part3-2.js hosted with ❤ by GitHub Yon can find more information on the routing API in the documentation . The RoutingService object provides two methods - configure and calculateRoute , the latter being the method we're primarily interested in here. Let's take a closer look! calculateRoute takes three parameters: Parameter Description calculateRouteParams An object containing search parameters required to query the HERE API for a route, including a list of waypoints and the desired routing mode. onSuccess Callback triggered once a route has been successfully returned from HERE’s service. onError Callback for the case that the request wasn’t completed successfully. Requesting a route To request a simple route we must first define a start and end point. This information will be passed as WayPointParameterType objects (more information in the documentation ). We also need to decide on a routing mode. As our delivery drivers are experts and ice cream doesn't like to stay in the sun too long, let's go with fastest;car in this case. Additionally we use the representation key to define that the response shall be formatted for the use with our map by setting it to display . Finally we'll need to implement our callbacks - let's start simple by logging the result to the browser's console: router . calculateRoute ({ // calculateRouteParams object ' mode ' : ' fastest;car ' , // Start and end point ' waypoint0 ' : ' geo!52.530974,13.384944 ' , // HERE HQ in Berlin, Germany ' waypoint1 ' : ' geo!52.5206,13.3862 ' , // Friedrichstraße Railway Station in Berlin, Germany // response formatting ' representation ' : ' display ' }, // onSuccess callback function ( result ) { console . log ( ' Route found! ' , result); }, // onError callback function ( error ) { console . error ( ' Oh no! There was some communication error! ' , error); } ); view raw gelary-part3-3.js hosted with ❤ by GitHub Refresh your browser window and check the console - you should see an entry looking something like this: Awesome! We're a good step closer to getting our route printed onto the map. Let's keep going! Refactoring Keeping our code clean is key to a maintainable codebase. So let's give the routing functionality a bit of structure and move it into it's own file called route.js , located in the scripts folder. Don't forget to include the newly created file in your index.html at the very bottom, just before app.js : < script src = \" scripts/route.js”></script> view raw gelary-part3-4.html hosted with ❤ by GitHub To make things even cleaner, let's also structure our code a bit better. Inside our new route.js we will define a single function called HERERoute which will take the map and platform objects as parameters. function HERERoute ( map , platform , routeOptions ) { var router = platform . getRoutingService (); var onSuccess = function ( result ) { console . log ( ' Route found! ' , result); }; var onError = function ( error ) { console . error ( ' Oh no! There was some communication error! ' , error); } router . calculateRoute (routeOptions, onSuccess, onError); } view raw gelary-part3-5.js hosted with ❤ by GitHub (By the way, you really should implement your own error handling in the onError callback. Simply printing the error to the console won't really cut it in the long run.) Now we can call the function from within app.js : var route = new HERERoute (map, platform, { mode : ' fastest;car ' , representation : ' display ' , ' waypoint0 ' : ' geo!52.530974,13.384944 ' , // HERE HQ in Berlin, Germany, ' waypoint1 ' : ' geo!52.5206,13.3862 ' // Friedrichstraße Railway Station }); view raw gelary-part3-6.js hosted with ❤ by GitHub A lot cleaner but the outcome hasn't really changed. Let's do something a bit more interesting, shall we? Drawing the route In order to make the route visible on the map, we need to implement the drawing mechanism within our onSuccess callback: var onSuccess = function ( result ) { var route, routeShape, startPoint, endPoint, strip; if ( result . response . route ) { route = result . response . route [ 0 ]; routeShape = route . shape ; strip = new H.geo.Strip (); routeShape . forEach ( function ( point ) { var parts = point . split ( ' , ' ); strip . pushLatLngAlt (parts[ 0 ], parts[ 1 ]); }); var routeLine = new H.map.Polyline (strip, { style : { strokeColor : ' blue ' , lineWidth : 10 } }); map . addObject (routeLine); map . setViewBounds ( routeLine . getBounds ()); } }; view raw gelary-part3-7.js hosted with ❤ by GitHub That's a lot of new code - let's step through some of the important parts: First we have to check whether the request has actually returned a route at all. Assuming that's the case we will have to decide which routing option we want to use, as the API will return several routes. For simplicity's sake we'll use the first result. if ( result . response . route ) { route = result . response . route [ 0 ]; routeShape = route . shape ; // … } view raw gelary-part3-8.js hosted with ❤ by GitHub With a route object at hand, we have to extract some data which we can pass onto the map's rendering mechanism. Remember how we have requested the response in display format? This decision will pay off now as we can simply grab the shape property for our route in order to draw it: routeShape = route . shape ; view raw gelary-part3-9.js hosted with ❤ by GitHub We still need do to a bit formatting nonetheless and we'll use one of our data types for that purpose. H.geo.Strip is an ordered, flat list of latitude and longitude pairs - perfect for us! strip = new H.geo.Strip (); routeShape . forEach ( function ( point ) { var parts = point . split ( ' , ' ); strip . pushLatLngAlt (parts[ 0 ], parts[ 1 ]); }); view raw gelary-part3-10.js hosted with ❤ by GitHub Finally we get to draw our route! For this purpose we'll utilize the map's polyline class H.map.Polyline . We even have control over the appearance of our route on the map - let's draw a nice, blue line between the start and end point: var routeLine = new H.map.Polyline (strip, { style : { strokeColor : ' blue ' , lineWidth : 10 } }); map . addObject (routeLine); view raw gelary-part3-11.js hosted with ❤ by GitHub One last thing: In order to ensure that the route is always fully visible let's update the map by matching the map bounds to the bounds of our route: map . setViewBounds ( routeLine . getBounds ()); view raw gelary-part3-12.js hosted with ❤ by GitHub The time has come! Go and refresh your browser window and you should see a big, fat, blue route rendered onto your map. Well done! Putting the pieces together In the previous post of this series we've requested the user's geolocation and then placed a marker accordingly on the map. Let's use our current location as the origin for our route and place a marker. As the waypoints have to be defined as a string in a predefined format, let's start by writing a small helper which converts a location into a waypoint: function locationToWaypointString ( coordinates ) { return ' geo! ' + coordinates . lat + ' , ' + coordinates . lng ; } view raw gelary-part3-13.js hosted with ❤ by GitHub Next we request the user's current location using navigator.watchPosition . For now we'll set a flag called isRouteRendered to ensure that the route is only rendered the first time - we will implement a more sophisticated solution later. // HERE HQ in Berlin, Germany: var HEREHQcoordinates = { lat : 52.530974 , lng : 13.384944 }; var routeRendered = false ; function updatePosition ( event ) { var coordinates = { lat : event . coords . latitude , lng : event . coords . longitude }; var marker = new H.map.Marker (coordinates); map . addObject (marker); // If the route has not been rendered yet, // calculate and render it if ( ! routeRendered) { var route = new HERERoute (map, platform, { mode : ' fastest;car ' , representation : ' display ' , waypoint0 : locationToWaypointString (coordinates), waypoint1 : locationToWaypointString (HEREHQcoordinates) }); routeRendered = true ; } } navigator . geolocation . watchPosition (updatePosition); view raw gelary-part3-14.js hosted with ❤ by GitHub Refresh your browser once more and there you have it - a route calculated from your current position to HERE's HQ in Berlin. Nicely done! Wrapping up Today we have learned to request routing information for two locations and render the result onto our map. In the next post we are going to start with some more refactoring and then take a closer look at some more advanced routing features of the HERE APIs. Stay tuned!", "date": "2016-10-18"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 7: Traffic)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-7-traffic", "abstract": "Who wants ice cream?! — In this series of blog posts we are going to develop a small web application called \"Gelary\" using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualise a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain Javascript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we learnt how to react to outside influences, if you haven't read it yet, you might want to take a look at it first before going on . In order to give our drivers more accurate delivery times, we need to know if there are any issues along their route that might affect their delivery. For this, we will have a look at traffic and incident data, create a new class HERETrafficPanel to encapsulate it and then introduce layers to show the issues on the map. Sounds cool? — It is! Let's find those problem areas! Traffic API Due to our earlier hard work, displaying traffic and incidents on our map is going to be really easy. Actually, we already have all the required pieces for displaying the data! With the HERE Traffic API we treat these visualizations as layers on the map, so all we have to do is to retrieve those layers and insert them on the map, easy right? Our map tiles already come from a default layer instance, the instance that we previously received from the platform object. Default layers also contain traffic and incident tiles, so we can simply get them from there. Simple! var defaultLayers = platform . createDefaultLayers (); var trafficLayer = defaultLayers . normal . traffic ; var incidentsLayer = defaultLayers . incidents ; view raw gelary-part7-1.js hosted with ❤ by GitHub All that we need to do is place these layers on our map. For adding and removing layers the map instance provides methods addLayer and removeLayer . For adding layers: this . map . addLayer (trafficLayer); this . map . addLayer (incidentsLayer); view raw gelary-part7-2.js hosted with ❤ by GitHub And for removing them: this . map . removeLayer (trafficLayer); this . map . removeLayer (incidentsLayer); view raw gelary-part7-3.js hosted with ❤ by GitHub You can read up more about the Traffic API in the documentation . Traffic panel Now we have learned the fundamentals for handling traffic and incident data layers. That's all good, but next we have to think how we want our users to interact with these layers. We also want to encapsulate the logic somehow so that our code stays clean and doesn't get too bloated. To solve both of these issues let's create a new class which renders buttons for the user interaction and holds the state of the displayed layers. Let's call it HERETrafficPanel . Let's start by creating a constructor for HERETrafficPanel . It takes the traffic and incident layers and also a placeholder DOM element where we will insert the panel. function HERETrafficPanel ( element , map , options ) { this . element = element; this . map = map; this . trafficLayer = options . trafficLayer ; this . incidentsLayer = options . incidentsLayer ; this . state = { showTraffic : false , showIncidents : false }; this . updatePanel (); } view raw gelary-part7-4.js hosted with ❤ by GitHub The HERETrafficPanel panel also takes care of rendering the panel with toggle buttons for both layers. Then we only have to hook the buttons to call the addLayer / removeLayer methods. Let's write a simple click handler for toggling the traffic and incident data: HERETrafficPanel . prototype . toggleTrafficData = function () { if ( this . state . showTraffic ) { this . map . removeLayer ( this . trafficLayer ); } else { this . map . addLayer ( this . trafficLayer ); } this . state . showTraffic = ! this . state . showTraffic ; this . updatePanel (); }; view raw gelary-part7-5.js hosted with ❤ by GitHub We can apply the same logic with the incidents layer. Next we are going to instantiate our traffic panel inside of the HEREMap class so that we can easily provide layers to our new panel object. Let's instantiate our newly created panel in the HEREMap constructor. var trafficPanelOptions = { trafficLayer : defaultLayers . normal . traffic , incidentsLayer : defaultLayers . incidents }; var trafficPanelElement = document . querySelector ( ' #traffic-panel ' ); this . trafficPanel = new HERETrafficPanel (trafficPanelElement, this . map , trafficPanelOptions); view raw gelary-part7-7.js hosted with ❤ by GitHub Now the HERETrafficPanel is a stand alone object that handles rendering and user interaction with traffic and incident layers. Cool! Wrapping up We can now see the realtime traffic and incident data in our app and our ice cream drivers can select their route accordingly. Great! Ice cream can now be deliverd without delay! In the next post we'll wrap up what we have learned so far and give some tips and ideas on how you can utilize HERE APIs even further. — Stay tuned!", "date": "2016-11-22"},
{"website": "Here", "title": "March 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services-4", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Batch Geocoder API, Geocoder API, Geocoder Autocomplete API, HLP Routing API, Traffic API, Public Transit API, Positioning API, Custom Location Extension, Geofencing Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension and Toll Cost Extension. Summary of enhancements: Improved house number and street name matches for specific formats in Geocoder API Geocoder Autocomplete API: added unit numbers support for complex addresses; added support of preferred response language for suggestions Increased the maximum number of WLAN access points in a request from 64 to 128 in Positioning API Proximity search now returns the matches sorted by distance in Custom Location Extension API Introducing Average ferry costs in Toll Cost Extension API Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Batch Geocoder API Version 6.2.53 Added support for the parameter minResults when making Reverse Geocode requests with mode=retrieveAddresses. The minResults parameter was only supported in requests with mode=retrieveAreas previously. The specified radius is ignored until the results exceed the value set in minResults. Geocoder API Version 6.2.131 Corrected country shapes with respect to disputed areas for India and Crimea. Improved house number and street name matches for specific formats in Portland, OR (USA), Mannheim (Germany), and Estonia. Geocoder Autocomplete API Version 6.2.131 A new language parameter allows client applications to specify their preferred response language for suggestions. Added recognition of unit numbers for address queries in Australia, New Zealand and Canada where prefixing house numbers with a unit is common. Public Transit API Version 2.3.0 The Earlier/Later journey endpoint (.../metarouter/rest/routeservice/v2/mroute) is now being deprecated Positioning API Version 1.3.1 We increased the maximum number of WLAN access points in a request from 64 to 128. We renamed frequency to the more descriptive and precise channel in the CDMA neighbor object parameters. We added the new optional parameters channel and pnoffset to CDMA serving cell object. We added support for Content-Encoding: gzip in request headers. Custom Location Extension API Version 2.0.10 Proximity search now returns the matches sorted by distance - closest geometry first. The all.txt and all.json attribute based search functions can now be applied to multiple layers within one request. Toll Cost Extension API Version 2.4.7 Introducing Average ferry costs For cost optimized routing, ferries now get penalized by an average cost, to avoid that ferry lines are used to create the cost optimized route although they also add cost. The average ferry cost values currently only distinguish between the vehicle type categories car, light truck and heavy truck. This will be refined in future versions. Since the ferry costs are not accurate, they get considered for route optimization, but are not returned explicitly as cost items. The following services had new releases with minor changes: HLP Routing API (Version 7.2.78) Traffic API (Version 6.0.61.0) Geofencing Extension API (Version 1.2) Fleet Connectivity Extension API (Version 1.2.9) Platform Data Extension API (Version 1.6.8) Route Match Extension (Version 2.1.12)", "date": "2017-03-06"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 8: Wrapping Up)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-8-wrapping-up", "abstract": "Who wants ice cream?! — In this series of blog posts we are going to develop a small web application called \"Gelary\" using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualise a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers. The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain Javascript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we learnt how to add traffic and incident data into our map, if you haven't read it yet, you might want to take a look at it first before going on . It's been quite a journey for our ice cream men and now it's time to wrap things up. In this chapter we will recap the API features we've used and what we have learned so far. Let's go! Basic setup In the first chapter we went over the basics so we can utilize HERE API's. HERE provides comprehensive APIs for mapping, routing, places and traffic data and much more, so in order to use them in our application, we needed to set them up. The first thing we did was set up a basic structure and took the first steps with HERE's APIs. We registered our app to obtain API keys and we learned how to place markers on the map and how to set custom SVG icons. The end result was a very simple interactive map with custom icons. A good foundation to build upon and spread the word of ice cream! You can refresh your memory with the basic setup post here . Geolocation In this chapter we demonstrated how to use the browsers geolocation API with HERE maps. It's was pretty simple and it connected us to the real world and gave us some ideas how to move forward with our application. You can read the geolocation post here . Routing Routing API is one of the interesting features provided by HERE. It comes handy in many cases, also in context of delivering ice cream! At this point our application had the ability to draw a map and a marker to our location. We extended this by adding routing from location A to location B and placing markers to the locations. Routing is perhaps the most used feature in our upcoming ice cream delivereries. We made this feature a little bit more practical by adding an interface component for rendering different route options so that our user can select the route that they would prefer. You can find the basic routing post here and the post on advanced routing here . If you're looking for more information on the routing API, you can check the documentation . Places Along routing another great feature provided by HERE is the so called Places API. As the name implies, this API helps us to find places and businesses from a certain geolocation. For our use this comes handy when our ice cream deliverers want to refill their ice cream storages. The Places API is also very easy to use since it takes simply a search term and location and returns all the places found with those criterias. You can the post on how to use the Places API here . Also you can find more information on the Places API in the documentation . Traffic & incidents The last API feature that we covered was HERE's traffic and incident data API. This provides us realtime information about traffic conditions and incidents happening in a certain area. The feature is really easy to use and drawing the data to the map was simply done by just placing traffic and incidents layers on our map. For our ice cream delivery company this was a very useful API since now our deliverers can navigate around the worst traffic jams and incidents. No more melting ice cream and more precise delivery times! We also built a small user interface for the traffic and incidents data. With this our users could toggle data layers on and off. We implemented the interface using pure JavaScript, but of course, in the real world you would probably use a JavaScript framework of your choice. You can find the traffic and incidents post here . Also you can read up more about the Traffic API in the documentation . Wrapping up Whew! We have come a long way with our ice cream delivery application. We built a basic application for delivering ice cream and we are ready to launch up our business! Of course our app is very simple but it demostrates how easy it is to build applications that uses maps and location data - from idea to reality - with help from HERE APIs. Thanks for reading and stay tuned for the next series!", "date": "2016-11-29"},
{"website": "Here", "title": "Who wants ice cream!? — A HERE Maps API for JavaScript Tutorial (Part 4: Advanced Routing)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/who-wants-ice-cream-a-here-maps-api-for-javascript-tutorial-part-4-advanced-routing", "abstract": "Who wants ice cream?! — In this series of blog posts we are going to develop a small web application called “Gelary” using HERE maps and services. Gelary aims to disrupt the ice-cream market by enabling ice-cream producers to deliver their sweet goods directly to their customers, wherever they are. The final application will resemble a mobile dashboard view for the employees of our little start-up which they can either take on the road or use at Gelary HQ to plan their work. It will consist of a map and a floating control panel behind a menu button. The map is used to visualize a route, starting from the user's current position along a series of customers, and the traffic situation along the route. The control panel will enable our delivery drivers to search for nearby ice cream shops, display turn-by-turn directions as well as to calculate the best pick-up location for a group of selected customers.The app will also be able to handle order changes: e.g. if a customer cancels or updates his or her position, the route will automatically be recalculated. To keep things simple our application will use plain JavaScript (ES5) and front-end technologies and will target mobile and desktop browsers alike. What will we learn in this tutorial? In the previous post we finally got to work with the routing APIs. We started by calculating a route between two locations and drew the result as PolyLine onto our map. Today we'll start by refactoring our code a bit and then improve our routing functionality. We will display multiple routes as well some detailed information for each and enable the user to select the best one. Let's dive in! Refactoring As our little application is getting a more and more involved our codebase grows as well. In order to be able to move forward without losing our sanity we will want to take a break every now and then to clean up after ourselves a bit. Let's do this right now. We have already have moved most of the code related to routing into a class called HERERoute which lives in a separate file called route.js . The rest of our code seems to describe the following items: Map Utilities We'll assume for the time being that it makes sense to split our code accordingly into files and objects or classes. Map Let's start with the map. We create a new file called map.js inside our scripts folder, include it in index.html just before app.js and add the following code: function HEREMap ( mapContainer , platform , mapOptions ) { this . platform = platform; this . position = mapOptions . center ; var defaultLayers = platform . createDefaultLayers (); // Instantiate wrapped HERE map this . map = new H.Map (mapContainer, defaultLayers . normal . map , mapOptions); // Basic behavior: Zooming and panning var behavior = new H.mapevents.Behavior ( new H.mapevents.MapEvents ( this . map )); // Watch the user's geolocation and display it navigator . geolocation . watchPosition ( this . updateMyPosition . bind ( this )); // Resize the map when the window is resized window . addEventListener ( ' resize ' , this . resizeToFit . bind ( this )); } HEREMap . prototype . updateMyPosition = function ( event ) { this . position = { lat : event . coords . latitude , lng : event . coords . longitude }; // Remove old location marker if it exists if ( this . myLocationMarker ) { this . removeMarker ( this . myLocationMarker ); } this . myLocationMarker = this . addMarker ( this . position ); this . map . setCenter ( this . position ); }; HEREMap . prototype . addMarker = function ( coordinates ) { var marker = new H.map.Marker (coordinates); this . map . addObject (marker); return marker; }; HEREMap . prototype . removeMarker = function ( marker ) { this . map . removeObject (marker); }; HEREMap . prototype . resizeToFit = function () { this . map . getViewPort (). resize (); }; view raw gelary-part4-1.js hosted with ❤ by GitHub It appears that we have changed a lot, but on a closer look we have only organised the map related functionality a bit better: Constructor (HEREMap()) — Our class essentially wraps the HERE map class for our use case. In the constructor we're creating the map object, defining a bunch of instance variables and event listeners for resizing of the window and the change of the user position. updateMyPosition — This method is called when the browser detects a change in the user's position. It will centre the map and render the user position marker accordingly. addMarker(coordinates) — Adds a new marker at the provided coordinates. removeMarker(marker) — For good measure, let's add a method to remove a marker from the map as well. resizeToFit() — This method is used to update the centre point and size of the map if the browser window is resized. With the map class in place we can now replace most of the initialisation code in app.js with a single line: var map = new HEREMap (mapContainer, platform, mapOptions); view raw gelary-part4-2.js hosted with ❤ by GitHub Neat! — The keen observer might have noticed, though, that we're missing a crucial piece of previously implemented functionality now — routing. Let's fix that by adding one more method to our new map class: HEREMap . prototype . drawRoute = function ( fromCoordinates , toCoordinates ) { var routeOptions = { mode : ' fastest;car ' , representation : ' display ' , waypoint0 : locationToWaypointString (fromCoordinates), waypoint1 : locationToWaypointString (toCoordinates) }; this . routes = new HERERoute ( this . map , this . platform , routeOptions); }; view raw gelary-part4-3.js hosted with ❤ by GitHub With the drawRoute method in place we can now call it from within our updateMyPosition method: if ( ! this . route ) { this . drawRoute ( this . position , HEREHQcoordinates); } view raw gelary-part4-4.js hosted with ❤ by GitHub Once our user's location is available we'll render the route. Utilities Our map utilises a small helper function called locationToWaypointString to format a latitude/longitude pair for the use with our APIs. Let's create a Utils object to hold this and similar functions in the future and then move it into it's own file scripts/utils.js . Don't forget to include it before the route.js in our index.html file: var Utils = { locationToWaypointString : function ( coordinates ) { return ' geo! ' + coordinates . lat + ' , ' + coordinates . lng ; } }; view raw gelary-part4-5.js hosted with ❤ by GitHub Of course we also still have to update the function calls to reflect the change within maps.js : var routeOptions = { mode : ' fastest;car ' , representation : ' display ' , waypoint0 : Utils . locationToWaypointString (fromCoordinates), waypoint1 : Utils . locationToWaypointString (toCoordinates) }; view raw gelary-part4-6.js hosted with ❤ by GitHub And with this change in place our app.js file looks once again nice and tidy: var mapContainer = document . getElementById ( ' map-container ' ); var platform = new H.service.Platform ({ app_id : ‘…’, // // <-- ENTER YOUR APP ID HERE app_code : ‘…’, // <-- ENTER YOUR APP CODE HERE }); var HEREHQcoordinates = { lat : 52.530974 , lng : 13.384944 }; var mapOptions = { center : HEREHQcoordinates, zoom : 14 }; var map = new HEREMap (mapContainer, platform, mapOptions); view raw gelary-part4-7.js hosted with ❤ by GitHub If you refresh your browser everything should work just as it did before. Eventually it will make sense to also simplify our HERERoute class a bit, create a specialised class for markers and extract some of the configuration into a separate object but let's save that for after the new routing features are implemented. Multiple routes A delivery driver likely knows his or her city better than anyone and we should account for that. Instead of dictating the one and only route the driver must take, let's offer a set of multiple routes to chose from. As it turns out, the HERE APIs make this very easy. By passing an integer via the alternatives key when requesting routing information from the API we will be provided additional options. In our case, simply update the drawRoute method of the HEREMap class: HEREMap . prototype . drawRoute = function ( fromCoordinates , toCoordinates ) { var routeOptions = { mode : ' fastest;car ' , representation : ' display ' , alternatives : 2 , waypoint0 : Utils . locationToWaypointString (fromCoordinates), waypoint1 : Utils . locationToWaypointString (toCoordinates) }; this . routes = new HERERoute ( this . map , this . platform , routeOptions); }; view raw gelary-part4-8.js hosted with ❤ by GitHub Now the API will return us a primary route as well as 2 alternatives — 3 routes in total. When refreshing the browser, nothing should have changed as we're currently simply selecting the first route from the response set for our visualization anyway. Let's update that class and enable it to handle multiple routes. First-off, the code which currently draws the route will need to be called repeatedly now so let's move it into it's own local function beneath the onError callback: var drawRoute = function ( route ) { var routeShape = route . shape ; var strip = new H.geo.Strip (); routeShape . forEach ( function ( point ) { var parts = point . split ( ' , ' ); strip . pushLatLngAlt (parts[ 0 ], parts[ 1 ]); }); var routeLine = new H.map.Polyline (strip, { style : { strokeColor : ‘blue’, lineWidth : 3 } }); map . addObject (routeLine); // map.setViewBounds(routeLine.getBounds()); }; view raw gelary-part4-9.js hosted with ❤ by GitHub This change allows us to significantly simplify the onSuccess handler: var onSuccess = function ( result ) { if ( result . response . route ) { var routes = result . response . route ; routes . forEach (drawRoute); } }; view raw gelary-part4-10.js hosted with ❤ by GitHub Setting view bounds Very tidy indeed! You might have noticed that we have commented the call to the map's setViewBounds method out. That's because this line would resize the map only according to the last route in the set which might lead to less than optimal results in certain situations. A simple way around this is to add all routes to a group ( H.map.group ) and then use the bounds of the group to update the map. This requires some changes to the onSuccess handler: var onSuccess = function ( result ) { if ( result . response . route ) { var routes = result . response . route ; var routeLines = routes . map (drawRoute); var routeLineGroup = new H.map.Group ({ objects : routeLines }); map . addObject (routeLineGroup); map . setViewBounds ( routeLineGroup . getBounds ()); } }; view raw gelary-part4-11.js hosted with ❤ by GitHub Additionally we need to update the drawRoute method as well. As we're no longer adding the individual routes to the map but rather the group, we have to remove the following line: map . addObject (routeLine); view raw gelary-part4-12.js hosted with ❤ by GitHub Furthermore we're now calling drawRoute using JavaScript's Array#map method which requires us to return the routeLine in order to add them to the group. Hence we have to end the function with return routeLine; view raw gelary-part4-13.js hosted with ❤ by GitHub So far so good — let's refresh our browser. We should now see three routes instead of one. Visual tweaks: custom markers So far we're using default markers for the current position of the user and we're not even rendering any marker for origin and destination. Let's change that! In our first tutorial we have learned how to use custom markers. Why not put this knowledge to good use now? As we need three different icons for origin, destination and the user's current position we'd like to be able to pass a type identifier when calling our HEREMap#addMarker method. Here's an example: this . addMarker (coordinates, ' destination ' ); view raw gelary-part4-14.js hosted with ❤ by GitHub As each icon might have a different size and anchor point we will need to define a dictionary to hold this information. By defining an empty markerOptions object up-front and checking whether the requested icon has been defined in the dictionary we can ensure that the default icon is used if necessary. Here's the whole method including these updates: HEREMap . prototype . addMarker = function ( coordinates , icon ) { var markerOptions = {}; var icons = { iceCream : { url : ' ./images/marker-gelato.svg ' , options : { size : new H.math.Size ( 26 , 34 ), anchor : new H.math.Point ( 14 , 34 ) } }, origin : { url : ' ./images/origin.svg ' , options : { size : new H.math.Size ( 30 , 36 ), anchor : new H.math.Point ( 12 , 36 ) } }, destination : { url : ' ./images/destination.svg ' , options : { size : new H.math.Size ( 30 , 36 ), anchor : new H.math.Point ( 12 , 36 ) } } }; if (icons[icon]) { markerOptions = { icon : new H.map.Icon (icons[icon]. url , icons[icon]. options ) }; } var marker = new H.map.Marker (coordinates, markerOptions); this . map . addObject (marker); return marker; }; view raw gelary-part4-15.js hosted with ❤ by GitHub To be fair, our function is starting to gain a bit of weight, right? Let's take this as an indicator for the need of refactoring and return to it in the next post. Visual tweaks: opacity In many cases, parts of the routes might overlap and become essentially indistinguishable from one another. Let's reduce the line width and change the color used when rendering the Polyline to include some transparency to make up for it. As the strokeColor attribute may be defined using CSS syntax, we're able to utilise the rgba function here. var routeLine = new H.map.Polyline (strip, { style : { strokeColor : ' rgba(0, 85, 170, 0.5) ' , lineWidth : 3 } }); view raw gelary-part4-16.js hosted with ❤ by GitHub Let's refresh our browser and take a look at our app. Already looking a lot better! Route selection Now that we have our three route options showing up, we should enable the user to select the best one and get some more information on it from the routing API. Let's start by defining a callback in our HERERoute class which will be triggered every time a route is selected. var selectedRoute; var onRouteSelection = function ( route ) { console . log ( ' A route has been selected. ' , route); selectedRoute = route; }; view raw gelary-part4-17.js hosted with ❤ by GitHub We're using the selectedRoute variable to keep track of which route is currently selected, if any. The call to console.log represents a stand-in for functionality implemented in the future. Now we will want to somehow indicate which route is selected on the map. This poses a problem, as we're currently keeping track of routes and their respective PolyLine representations separately. Let's store them in the same place for easier use. This requires an update to the onSucess callback in our HERERoute class: var onSuccess = function ( result ) { if ( result . response . route ) { var routeLineGroup = new H.map.Group (); var routes = result . response . route . map ( function ( route ) { var routeLine = drawRoute (route); routeLineGroup . addObject (routeLine); return { route : route, routeLine : routeLine }; }); map . addObject (routeLineGroup); map . setViewBounds ( routeLineGroup . getBounds ()); } }; view raw gelary-part4-18.js hosted with ❤ by GitHub From here on out the routes variable will hold an array of objects, essentially pairing the data representation of the route as returned from the API with their visual representation on the map. Still following? Great! Let's move on then. Indicating selection With all necessary pieces in place we can now continue to specify a new PolyLine style to highlight the fact that a given route has been selected. As it's starting to look like we might be using these style definitions in multiple places from here on out, let's define them in a dictionary at the top of our class: var routeLineStyles = { normal : { strokeColor : ' rgba(0, 85, 170, 0.5) ' , lineWidth : 3 }, selected : { strokeColor : ' rgba(255, 0, 0, 0.7) ' , lineWidth : 7 } }; view raw gelary-part4-19.js hosted with ❤ by GitHub This should allow us to highlight the route as a nice, fat red line on the map. Let's update the onRouteSelection function to make use of this style. The map rendering engine allows us to modify the style of PolyLines using the setStyle method: var onRouteSelection = function ( route ) { console . log ( ' A route has been selected. ' , route); if (selectedRoute) { selectedRoute . routeLine . setStyle ( routeLineStyles . normal ); } route . routeLine . setStyle ( routeLineStyles . selected ); selectedRoute = route; }; view raw gelary-part4-20.js hosted with ❤ by GitHub In order to test the new functionality you could temporarily add a call to onRouteSelection and pass the first route as argument at the bottom of our onSuccess callback: onRouteSelection (routes[ 0 ]); view raw gelary-part4-21.js hosted with ❤ by GitHub Refresh your browser and you should see one of the three routes selected in bright red. Depending on which route is selected you might notice that it is actually rendered beneath one of the other routes which is not really looking all that great. Thankfully the map rendering engine also gives us a tool to deal with that problem. Using the PolyLines' setZIndex method we can ensure that our selected route is always rendered on top. Oh, and did I mention that you can chain all method calls for PolyLine ? — Nice! Armed with this new knowledge we can update the onRouteSelection function once more. Let's set the z-index for our selected route to something sufficiently high — like 10: var onRouteSelection = function ( route ) { console . log ( ' A route has been selected. ' , route); if (selectedRoute) { selectedRoute . routeLine . setStyle ( routeLineStyles . normal ). setZIndex ( 1 ); } route . routeLine . setStyle ( routeLineStyles . selected ). setZIndex ( 10 ); selectedRoute = route; }; view raw gelary-part5-22.js hosted with ❤ by GitHub Let's take a look by refreshing the browser. Sweet — today we are really making some progress. But we're not quite done yet! Route selection panel So far we have no way to select either of the routes manually. Let's change that by introducing a small floating panel, listing all routes and their main properties such as duration and distance. By clicking on either of these elements we'll want to select the corresponding route and indicate our selection. First, let's clean up our test code, though, and remove the call to onRouteSelection from our onSuccess callback. It looks like we'll need a bit of code for our panel so let's not clutter our HERERoute class any further and create a new class called HERERoutesPanel in a file named routes_panel.js . By now you know the drill — \"don't forget to include the file in your index.html before app.js \". Additionally we'll need a container in the DOM to render our panel into. As we expect a list of routes, let's add the following snippet of HTML to our index.html file: < div id = \" route-panel \" > < ul ></ ul > </ div > view raw gelary-part5-23.html hosted with ❤ by GitHub Time to define the HERERoutesPanel class. Let‘s start outside our new class, though by calling our imaginary constructor from the very bottom of the onSuccess callback in our HERERoute class. This will help us to figure out which parameters are needed: this . routePanel = new HERERoutesPanel (routes, { onRouteSelection : onRouteSelection } ); view raw gelary-part4-24.js hosted with ❤ by GitHub So far so good. In our new class we define a render function to create the list: function HERERoutesPanel ( routes , options ) { var render = function ( routes ) { var routeList = document . querySelector ( ' #route-panel ul ' ); routes . forEach ( function ( route , i ) { routeList . appendChild ( renderRouteElement (route, i)); }); }; } view raw gelary-part4-25.js hosted with ❤ by GitHub If you have been working on web front-end projects before you might be thinking — “Why not use React (or any other framework)?” and you would be right. For the code that we're about to write a framework and a templating library would be a big help and likely the right choice. However, it's a bit out of our scope to cover those technologies so we'll have to make due with what we got: good ‘ol vanilla JavaScript, the DOM APIs and a touch of CSS. Feel free to use your favorite framework instead! As you can see, we're calling a function called renderRouteElement in our loop. Let's continue by defining that: var renderRouteElement = function ( route , i ) { var element = document . createElement ( ' li ' ); var routeSummary = route . route . summary ; element . innerHTML = renderRouteTitle (routeSummary, i); element . addEventListener ( ' click ' , function () { if (selectedRoute) { selectedRouteElement . classList . remove ( ' selected ' ); } element . classList . add ( ' selected ' ); selectedRoute = route; selectedRouteElement = element; if ( options . onRouteSelection ) { options . onRouteSelection (selectedRoute); } }, false ); return element; }; view raw gelary-part4-26.js hosted with ❤ by GitHub What's going on here? — We're creating a new <li/> element for each route and calling a yet-to-be-defined function called renderRouteTitle to generate the text content for it. Then we proceed by defining an event handler for click events on our new element. This handler will store the newly selected route and update the UI by adding a selected class for the corresponding element and removing it from any previously selected element. In order for this all to work, we'll need a local variable to store the selection state — let's add it at the top of the class: var selectedRoute; var selectedRouteElement; view raw gelary-part4-27.js hosted with ❤ by GitHub We're getting there! But we're still missing a bit of code — the renderRouteTitle function has not been implemented or discussed yet. As it turns out, the routing API returns a whole treasure trove of information including a summary object. However, as this is additional data we need to explicitly request it using the routeattributes key in the routeOptions . Let's switch over to our HEREMap class for a moment and account for this new requirement. Within the drawRoute method we add a new line to our routeOptions : var routeOptions = { mode : ' fastest;car ' , representation : ' display ' , alternatives : 2 , // Our new line: routeattributes : ' waypoints,summary,shape,legs ' , waypoint0 : Utils . locationToWaypointString (fromCoordinates), waypoint1 : Utils . locationToWaypointString (toCoordinates) }; view raw gelary-part4-28.js hosted with ❤ by GitHub Great — let's continue working on the renderRouteTitle method back in the HERERoutePanel class: var renderRouteTitle = function ( routeSummary , i ) { return [ ' <strong>Route ' + (i + 1 ) + ' </strong> ( ' , Utils . formatDistance ( routeSummary . distance ) + ' in ' , Utils . formatDuration ( routeSummary . travelTime ) + ' ) ' ]. join ( ' ' ); }; view raw gelary-part4-29.js hosted with ❤ by GitHub As you can see, the summary contains — among other things — both distance and travel time. All we have to do is a bit of formatting and we're good to go. Distance is represented in meters and travelTime in seconds so we'll need some utilities to convert them into a more human-readable format. For this purpose we extend our Utils object in utils.js a bit: var Utils = { // … formatDistance : function ( distanceInMeters ) { if (distanceInMeters < 1000 ) { return distanceInMeters + ' m ' ; } else { return (distanceInMeters / 1000 ). toFixed ( 1 ) + ' km ' ; } }, formatDuration : function ( durationInSeconds ) { var hours = Math . floor (durationInSeconds / 3600 ); var minutes = Math . floor (durationInSeconds % 3600 / 60 ); if (hours > 0 ) { return hours + ' h ' + minutes + ' min ' ; } else { return minutes + ' min ' ; } } }; view raw gelary-part4-30.js hosted with ❤ by GitHub Take a deep breath — we're almost done. Let's add a call to our new render function at the bottom of the HERERoutesPanel constructor and pass the routes: render (routes); view raw gelary-part4-31.js hosted with ❤ by GitHub Now is a good moment to remember that we have just constructed a whole bunch of HTML using good old string concatenation. While there's certainly more elegant ways to do this it will do the job just fine. However, it's still lacking some finishing touches in form of CSS styles. Appearances are a thing of preference and we'd never dare to tell you how your app should look like but for a shortcut you may borrow our styles and paste them into your app.css file. Now — the moment of truth has arrived. Let's refresh the page and see what we got. Awesome! Things are really coming together now. Try selecting a route as well. Now that we got this far, don't you also feel like pushing our app just a tiny tad further before calling it a day? Directions Did you know that the route API also returns driving directions in plain English? It would be a shame to not make use of this information as it could really help a driver getting his sweet freight faster and safer from A to B. Let's render a second list beneath our title information for each route which is only shown when the corresponding route is selected. This list will simply represent all maneuvers as returned by the API. We start by updating our `renderRouteElement` function in the HERERoutesPanel class: var renderRouteElement = function ( route , i ) { var element = document . createElement ( ' li ' ); var routeSummary = route . route . summary ; element . innerHTML = renderRouteTitle (routeSummary, i); var maneuvers = route . route . leg [ 0 ]. maneuver ; element . innerHTML += renderManeuvers (maneuvers); // … } view raw gelary-part4-32.js hosted with ❤ by GitHub As you can see, maneuvers are returned as part of the leg data for each route. A “leg” is the part of a route between two waypoints but since we're only routing from waypoint A to waypoint B for now we can expect there to be never more than one leg per route. For the last step we need to implement the renderManeuvers function — easier than it sounds, thanks to the pre-formatted maneuver instruction string: var renderManeuvers = function ( maneuvers ) { return [ ' <ol class=\"directions\"> ' , maneuvers . map ( function ( maneuver ) { return ' <li> ' + maneuver . instruction + ' </li> ' ; }). join ( ' ' ), ' </ol> ' ]. join ( ' ' ); }; view raw gelary-part4-33.js hosted with ❤ by GitHub Refresh the browser, select a route et voila! There are your directions for the selected route. Pretty sweet, don't you think? Wrapping up Time finish up. Today we have done a lot of work! We have added support for multiple routes, enabled route selection and are now rendering route details and even turn-by-turn directions. Well done! Remember that you can get the complete code from this (and all other) tutorials on GitHub . In the next post we'll enable our application to react to changes like changing waypoints. — Stay tuned!", "date": "2016-10-27"},
{"website": "Here", "title": "HERE launches Mobility On-Demand", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/here-launches-mobility-on-demand", "abstract": "HERE launches Mobility On-Demand, a toolkit for on-demand app developers. The aim of the toolkit is to enable developers to build location-centric features into their apps and go to market quickly. You can build e-hailing, carpooling, food delivery, package delivery or any other on-demand app. Pricing is simple, based on number of orders booked. After listening to customers and the developer community, HERE has specially priced and packaged the toolkit to meet your needs. It comes with a technical solution paper containing step-by-step guides on how to use HERE APIs and SDKs. The toolkit supports end-to-end development of all the building blocks of an on-demand solution. In the case of e-hailing, for instance, this would include the passenger app, the companion app for the driver, the backend dispatch system, as well as backoffice analytics and data visualisation. Everything you need. In one place. Ready to Get Started? Access the technical solution paper here . And sign up for a 90-day Free Trial license here . Once you register for the Free Trial license, you get everything you need to support the examples in the technical solution paper. Do remember to activate credentials for the SDKs you want. SDKs are available for iOS and Android. You have two easy options. If you want to develop custom navigation in your app, you will need the Premium Edition of the HERE Mobile SDK. If, instead, you want to keep things simple and do a navigation handover from your app to the award-winning HERE WeGO navigation app, you can choose either the Starter Edition or the Premium Edition. Once you’ve tried things out and you’re ready to move to a commercial implementation of your on-demand app, please contact us .", "date": "2017-03-15"},
{"website": "Here", "title": "Join us at the Volvo Trucks Hackathon Challenge in Antwerp", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/join-us-at-the-volvo-trucks-hackathon-challenge-in-antwerp", "abstract": "Trucks! Trucks are great. They bring you all your stuff and you can do epic splits on top of them. HERE loves trucks, and so the HERE APIs have some pretty cool features created specifically for trucks, the people who own trucks, the people who drive trucks and the people who do epic splits on top of trucks. For example, did you know that the HERE Routing API has support for truck restrictions? Big truck? Heavy truck? Tall truck? Afraid you’re going to be that guy ? No problem, just give the HERE Routing API some information about your truck and it will return a route that is safe for you to drive! Got a trailer? Hazardous materials? We got you covered. Our special map tiles show you truck-relevant information and our Places API can find you a place to fuel up and catch some sleep after a hard days truckin'. If you too like trucks and want to try our great truck features, we have some exciting news for you! We’re proud to announce that we are joining Volvo, one of the world’s leading manufacturers of trucks and buses, at the Volvo Trucks Hackathon Challenge in Antwerp Belgium on February 17-18 and we want you to join us! You can even win various prizes, including a 2 day trip to the Volvo Trucks HQ in Gothenburg, Sweden. For more information and details on how to sign up, please see the Volvo Trucks Hackathon Challenge website. Epic splits optional.", "date": "2017-02-06"},
{"website": "Here", "title": "April 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services-1506690933766", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: JavaScript API, Geocoder API, Geocoder Autocomplete API, Routing API, Traffic API, Positioning API, Custom Location Extension, Geofencing Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension, Waypoints Sequence Extension, HERE Android SDK and HERE iOS SDK. Summary of enhancements: Integrated the Maps API for JavaScript with the Platform Data Extension REST API Routing: Added a new range type consumption for CalculateIsoline, and a related option to CalculateRoute with consumption Custom Location Extension API: improved geocoding for POI lists, multiple points are supported now in a single proximity.json search request Route Match Extension: direct access to some link attributes; real time use cases support Geofencing Extension: Multiple points can now be sent to a single search request. Waypoints Sequence extension: Partial sequence order constraints can now be specified, such as Waypoint A must be reached before Waypoint B. New HERE Platform Self-hosted Q1/2017 release HERE Android and iOS SDK: Search along the route for data from PDE Below you can find detailed information on these major improvements of the HERE Platform for Business services: JavaScript API Version 3.0.13.0 We integrated the Maps API for JavaScript with the Platform Data Extension REST API. This includes: Search request functionality that allows you to search data available via the Platform Data Extension API and match it with the data provided by other HERE services. A tile provider that enables you to overlay meta information, provided by the Platform Data Extension, on the map. Geocoder API Version 6.2.133 Improved postal code search in Singapore where buildings are given their own unique postal code. Improved matching of number-based streets in Brazil. The Geocoder now recognizes street names in queries that use Arabic numerals even though the map data only contains the spelled out form of the numbers. For example, \"Rua 701\" instead of \"Rua Setecentos e Um\". Geocoder Autocomplete API Version 6.2.133 Improved ranking: Results are ranked by relevance independent of the query language. Users can now use their first language or a popular language such as English to get suggestions in countries with a different default language. Routing API Version 7.2.79 Added a new range type consumption for CalculateIsoline, which returns a polygon representing the reachable area based on a vehicle's current state of charge. Consumption details are provided with the request and can be used for fuel or electric vehicle use cases. Added the following option to CalculateRoute with consumption: For any route calculation, you can determine the amount of fuel/energy needed for each link along the route. Use the new consumptionModel and customConsumptionDetails parameters in calculateRoute. This option is useful for tasks such as predicting a vehicle's energy consumption along a route in order to decide when and where to recharge or visualize battery levels at any point. Positioning API Version 1.4.0 We made improvements to the locate resource Removed the dependency of rsrq to rsrp in LTE serving and neighbor cell object. If you specify a value for rsrq, you need to specify a value for rsrp. This is a change from previous behavior. Custom Location Extension API Version 2.1.0 Geocoding can deal with partially geocoded POI lists. It geocodes only those POIs that have no coordinate. Multiple points can now be sent to a single proximity.json search request. To speed to all.json attribute searches, database indexes can be defined on the relevant attributes at layer upload. The layer upload function upload.json now accepts zipped and unzipped WKT text files, and accepts any multipart filename. Geofencing Extension API Version 2.1.0 Multiple points can now be sent to a single proximity.json search request. The layer upload function upload.json now accepts zipped and unzipped WKT text files, and accepts any multipart filename. Fleet Connectivity Extension API Version 1.3.0 Google Push (Firebase Cloud Messaging) can now be used to send routes to assets or to cancel routes. Route Match Extension API Version 2.1.13 Link attributes, like speed limit or slope, can be retrieved directly in the response. This is an alternative to calling PDE along the route, for select use cases. Route Match Extension API can also be used for real time use cases, where short traces from vehicles are matched and feedback during the journey is provided (driver alerts), or the journey is influenced (re-routing). Matching a trace that contains the latest few hundred driven meters provides better match results than matching isolated coordinates. Note that for sensitive matches (alerts or rating penalties), the end of the trace (latest points) should be sent to Route Match Extension API but disregarded from the result, because they are missing future points. Waypoints Sequence Extension API Version 2.2.8 Partial sequence order constraints can now be specified, such as Waypoint A must be reached before Waypoint B. HERE Android SDK Premium Edition Version 3.3.1 Search along the route for data from PDE. HERE iOS SDK Premium Edition Version 3.3.1 Search along the route for data from PDE. The following services had new releases with minor changes: Traffic API (Version 6.0.62.0) Platform Data Extension API (Version 1.6.9) Toll Cost Extension API (Version 2.4.8) HERE Android SDK Starter Edition (Version 3.3.1) HERE iOS SDK Starter Edition (Version 3.3.1) HERE Platform Self Hosted Version Q1/2017 Traffic API 6.0.61.1 (D78) HLP-Router 7.2.78 (D78) Geocoder 6.2.131.2 (D78) Reverse Geocoder 6.2.131.2 (D78) Batch Geocoder 6.2.53.1 (D78) Geocoder Autocomplete 6.2.131.2 (D78) Geofencing Extension API 2.0.8 (D78) HERE Platform for Business Team", "date": "2017-04-11"},
{"website": "Here", "title": "New Usage Export has arrived!", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/new-usage-export-has-arrived", "abstract": "A few weeks ago we announced some improvements to the Usage Dashboard and let you know that we would be working on updates to the CSV download as well. We’re happy to announce that the changes to export function have been finished and you can now benefit from seeing an even more granular dataset in the CSV file. What are the improvements? You can now see specific usage data per App ID and category, and then split by each subcategory, e.g., geocoding total plus subtotals for forward, reverse, and multi-reverse geocoding. The usage data is sorted by environment and date of usage How it works In your usage dashboard, just click on Export CSV in order to download the usage data: In the export file, you will see the usage data split by the service categories, and then its subcategories:", "date": "2017-05-01"},
{"website": "Here", "title": "HERE launches Custom Route Extension – an easy way to build custom routes", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/custom-route-extension-an-easy-way-to-build-custom-routes-using-your-own-attributes-and-deviations", "abstract": "We understand the need of having access to a routing service which allows you to have more control over the routes you provide to your vehicles. Therefore, today, we’re proudly launching a new service, that gives you the flexibility to tailor routes using your own preferences and custom road geometries. The Custom Route Extension provides you with ways to create routes which make most sense to your vehicles and business operations. Since we all know that certain road restrictions can be applied differently from one vehicle profile to another, we provide opportunities to make the changes you need, on your own, so that your vehicles end up using and accessing the desired road segments and routes. With Custom Route Extension you can now block access to specific road segments, remove existing road blocks or add new road geometries to the HERE road network, especially on those private grounds where you’re familiar with the existing infrastructure. For example, you can block road links that are closed during short term construction work or add temporarily created road sections or exits. You can block usage of certain road links for certain type of vehicles (e.g. trailer access), or when the road conditions are known to be risky (e.g. muddy grounds from rain, rock falls). Below are some of the most important feature available today through the Custom Route Extension: Import of custom road data and geometries as WKT Storage of data (e.g. road closure, geometries) into custom data layers Map matching of changes onto current HERE map release Submitted changes are kept private in the customer environment For additional product information as well as developer documentation please click here . We hope you enjoy using the flexibility provided through the Custom Route Extension.", "date": "2017-05-02"},
{"website": "Here", "title": "HERE launches community feedback developer tools", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/here-launches-community-feedback-developer-tools-1", "abstract": "At HERE we pride ourselves on the high quality of our map data. One of the many ways we keep our maps accurate and up-to-date is by collecting feedback from our community. Using the HERE Map Creator tool , users can update, remove or add places, roads and point addresses. These changes are then reviewed and integrated into our official maps, which are used by millions of peoples, vehicles and devices all over the world. With the launch of the Map Feedback API and Embedded Editor SDK, we now also provide developers with the tools to enable this type of map feedback capability directly in their HERE-powered applications. To find out more, check out the full documentation for both the API and the SDK on the HERE developer portal . Best of all, the Map Feedback API and Embedded Editor SDK are available free of charge as part of all plans available on developer.here.com, including our free plan. If you are using any of our paid plans, usage of this API and SDK does not count against any of your usage limits. Ready to Get Started? Register for a 90-day free trial license here .", "date": "2017-06-08"},
{"website": "Here", "title": "May 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services-1506690753798", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: JavaScript API, Geocoder API, Geocoder Autocomplete API, Traffic API, Data Lens, Public Transit API, Custom Route Extension, Custom Location Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension, Waypoints Sequence Extension and Mobile SDKs for Android and iOS. The release is mainly a maintenance release. Summary of enhancements: Initial launch of Custom Route Extension Geocoder: added support of new Armenia Intermediate Map Major release of Public Transit API following refactoring of all endpoints to a new format. Introduced new road layers in Platform Data Extension Below you can find detailed information on these major improvements of the HERE Platform for Business services: Custom Route Extension API Version 1.0 CRE allows for calculating routes with custom deviations and preferences. The service is available through a routing interface that connects with the HLP Router for the standard route calculation, but provides custom routes while taking into account all custom data. For more information, see the Custom Route Extension Developer's Guide Geocoder API Version 6.2.135 Added support of small municipalities for the district level of the administrative hierarchy in Peru. Updated Armenia maps to include additional administrative levels and the local language. Public Transit API Version 3.0.0 This is a major release following refactoring of all endpoints to a new format. In other words, the API endpoint format have been changed from https://transit.api.here.com/metarouter/rest/routeservice/v2/<resource> to: ://transit.api.here.com/v3/<resource> Key changes are: all endpoints now start with version, that is /v3/, followed by a resource name; the versioning now applies to the whole API and not for individual endpoints; the documentation versioning will correspond to the API versions. However for now the coming releases will continue to support all deprecated endpoints (with old parameter names). Custom Location Extension API Version 2.1.1 Improved performance of the substring search expressions COL_NAME.indexOf(\"my_substring\") >= 0 and COL_NAME.startsWith(\"my_prefix\") for updatable layers. Platform Data Extension API Version 1.6.10 Introduced new layers ROAD_NAME_FC1 ... ROAD_NAME_FC5 . This makes the NAMES column in the ROAD_GEOM_FCn layers obsolete. The NAMES column in the ROAD_GEOM_FCn layers is deprecated and will be removed by May 2017. The following services had new releases with minor changes: Java Script API (Version 3.0.13.1) Geocoder Autocomplete API (Version 6.2.135) Traffic API (Version 6.0.63.0) Data Lens (Version 2.4.0) Fleet Connectivity Extension API (Version 1.3.1) Route Match Extension API Version 2.1.14 Waypoints Sequence Extension API (Version 2.2.9) HERE Android SDK Premium Edition (Version 3.3.1) HERE iOS SDK Premium Edition (Version 3.3.1) HERE Platform for Business Team", "date": "2017-05-08"},
{"website": "Here", "title": "Crave InfoTech", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/crave-infotech", "abstract": "Crave InfoTech, a leading provider of GPS tracking applications, helps organizations track their assets improving customer service, reducing operational costs and improving asset health. Leveraging HERE maps and APIs like Routing, Crave InfoTech’s fleet and workforce management applications optimize routes for traffic and road conditions in real-time and provide their customers with real-time information about their assets and employees.", "date": "2017-06-10"},
{"website": "Here", "title": "June 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Maps API for JavaScript, Map Feedback API, Embedded Editor, Geocoder API, Map Image API, Map Tile API, Traffic API, Public Transit API, Geovisualization, Custom Location Extension, Custom Route Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension and Waypoints Sequence Extension. Summary of the release enhancements: Initial launch of Embedded Editor Launch of the Maps Feedback API on the developer.here.com Custom Location Extension integration into JavaScript API New Traffic API incidents endpoint has new format and supports more incidents information More customization opportunities in Custom Route Extension API New premium package “Live Traffic Speed record” in Platform Data Extension Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Maps API for JavaScript Version 3.0.14.0 A tile provider that enables you to overlay user defined geospatial information, provided by the Custom Location Extension, on the map. Maps Feedback API Version 2.6 The HERE Map Feedback API is a REST API that allows you to improve the map experience by submitting feedback to HERE and to check the status of the feedback you have submitted. Street Level Imagery (SLI) Blurring Feedback Attributes no longer require areaOnImage. Added support for product feedback. Added support for road network feedback. Embedded Map Editor Version 1.1 The Embedded Map Editor is a ready-to-use, customizable map editor that provides feedback on maps to HERE. It can be integrated into web and mobile customer environments either as an iframe within a web page or as a WebView/WKVebView component on an Android or iOS device. The Embedded Map Editor enables you to embed an iframe in your pages that allows your customers to provide feedback on HERE maps. Can be customized to control the user experience in terms of UI, use cases, and languages. Any content submitted via the Embedded Editor is reviewed by HERE before the data in the HERE maps is updated. Geocoder API Version 6.2.137 Support for intersections in Chile using Spanish terms is available. The Forward Geocoder now finds named highway ramps in selected countries. It is now possible to find German city names that include bracketed qualifiers coming from region or landmark names without the additional qualifier in queries. Traffic API Version 6.0.64.0 Added support for Incidents TML version 2.3. Access is provided via the /traffic/6.2/incidents endpoint. The new incidents format supports DLR Incidents, non-roadway events and other improvements. The old endpoint /traffic/6.1/incidents is still available and will be supported at least for 6 months. Geovisualization API Version 2.5.0 The Data Lens product renamed to Geovisualization. A Data Manager portal available for a management overview of Datasets and Queries. Infrastructure improvements. Custom Location Extension API Version 2.1.2 WKT files can now contain a GEOMETRY_ID column for uploading. If this column is provided, its values must be numeric and unique. Following filter expressions are now executing much faster: COL_NAME == \"str\" COL_NAME === \"str\" COL_NAME != \"str\" COL_NAME !== \"str\" COL_NAME.indexOf(\"str\") >= 0 COL_NAME.startsWith(\"str\") COL_NAME.like(\"%str%\") Custom Route Extension API Version 1.0.1 Dead end links can be inserted. Sequences and graphs of new links can be inserted. One way directions can be changed. Platform Data Extension API Version 1.6.11 Added new layers that contain the live traffic speed record of the last 7 days for every 15 minutes. Made Point Address layer commercially available. The following services had new releases with minor changes: Map Image API (Version 1.6.36.8) Map Tile API (Version 2.1.68.20) Public Transit API (Version 3.0.1) Fleet Connectivity Extension API (Version 1.3.2) Route Match Extension API (Version 2.1.15) Toll Cost Extension API (Version 2.4.10) Waypoints Sequence Extension API (Version 2.3.0) HERE Platform for Business Team", "date": "2017-06-14"},
{"website": "Here", "title": "TimoCom", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/timocom-uses-here-for-fleet-management", "abstract": "In order to provide customers with the ability to track their trucks independently of the respective telematic systems used in a single map in near real-time, TimoCom turned to HERE. Using HERE's platform, TimoCom reverse geocodes truck coordinates from telematics providers, resulting in greater visibility so dispatchers can better calculate routes, costs, and delivery times. Timocom can also share the location of the freight with their clients, providing them with greater transparency.", "date": "2017-07-14"},
{"website": "Here", "title": "Trucking made easy with the HERE Truck Routing API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/trucking-made-easy-with-the-here-truck-routing-api", "abstract": "Breaker One-Nine, this here's the Rubber Duck and everything I know about trucking I learned from Convoy . Well, almost everything. I also know that trucks and their drivers work hard every day to get me my stuff. I like stuff! A lot has changed since 1978 and the CB radio is no longer the most advanced piece of technology in a truck's cab. In fact, location data and service like those offered by the HERE location platform have become key components of modern logistics. Central to this is of course routing. Let's face it, finding the best way from A to B is critical to getting me my stuff. Trucks have a harder time getting from A to B though, not just because they are big and heavy, but also due to the many legal requirements and restrictions they face. Just because a route exist, doesn't mean a truck can drive it, and just because a truck can drive a route, doesn't mean it is allowed to. Fortunately, HERE offers a dedicated truck routing feature to provides drivers and operators with safe and efficient routes for their trucks. To see how this feature works, let's have a look at our Routing API . To get a basic route we need just three things: waypoints, a routing mode and credentials. Let's have a closer look at each. Waypoints define where we start, where we want to end up and any potential points we want to pass through or stop at along the way. We need at least two waypoints, a start and a destination. Waypoints are defined by using a latitude and a longitude (geographic coordinates). For example, the Brandenburg Gate in Berlin is located at a latitude of 52.5163 and a longitude of 13.37801. There are multiple ways to get geographic coordinates. For example, for our starting waypoint, we can ask the device for its current location or use HERE Positioning API . For the destination waypoint we could use the HERE Geocoder API to convert any delivery addresses we may have into geographic coordinates. An easy way to get some test coordinates is to use HERE WeGo . We can simply right click on any location on the map, then click the address that pops up and choose \"See more info\" on the left. This will display additional information about the location, including its latitude and longitude. Not all possible routes are made equal, and the routing mode allows us to provide additional information to the routing algorithm which helps it determine the most suitable route for our specific situation. To set the routing mode, we must first choose between the type of route (fastest or shortest) and the transport mode, for example walking, biking or driving by car. Credentials are used for authentication. They consist of an app id and an app code. You can get your own set of credentials by signing up on developer.here.com . There's a 90 day free trial available that provides all of our routing features, including truck routing. If you have already signed up, you can access your credentials on your projects page. Let's have a look at an example. Let's say we're in Berlin and want to drive our car from the Brandenburg Gate to the East Side Gallery on the fastest route. Here's how that API call would look like. Pretty simple. Just remember to replace the credentials placeholders with your own app id and app code! It's also easy to add additional waypoints or change the mode of transport. Let's say that we want to get from the gate to the gallery again, but this time we want to walk on the fastest route. We also need our daily caffeine fix, so we are going to pick up an Americano to go at Oslo Kaffeebar on the way. Our API call would now look like this. Both of these API calls will return a response in JSON, which contains a route array. This in turn contains one or more leg arrays. Each leg represents the route between two waypoints. As we have three waypoints in our second example, we get a response with one route containing two legs. Each leg then contains a set of maneuver arrays. Maneuvers represent the actions needed to move from one road segment on the route to the next. Let's have a look at a maneuver. As you can see the maneuver contains various information about the segment of the route, including its position and appropriate instructions to follow the route. You can check out the documentation for full details on the response. So far, so good. That said, we're not walking or driving a car. We're in a truck and trucks are special. Trucks also don't do much sightseeing, so let's pick a slightly more suitable route. Let's pretend we're in Durham, NC at the Northgate Mall and our truck has just picked up a delivery for a customer in Gregson Street. If we ask the Routing API for a fastest car route, the response will look like this. At first glance that looks fine. There's just one small problem. This route would take us right under the infamous Canopener Bridge . We don't want to crash our truck and/or endure public humiliation on the web, so what do we do? Let's try changing the routing mode from \"car\" to \"truck\"! That helps a bit, because it changes our route to comply with certain legal restriction, including turn restrictions and no trucks allowed areas. However, as we can see above, the route still take us right under the bridge. Into the bridge, really. Clearly, using the truck routing mode alone is not enough. We also have to give the routing algorithm additional information about our truck. For example, to prevent us from crashing into the Canopener Bridge, it needs to know the height of our truck. We provide it with this information by using the truck profile parameters . Let's give it a try. The bridge famously has a clearance of 11 foot 8 inches, which translates to about 3.56 meters. So let's pretend our truck 3.8 m high. There's plenty of other opportunities to embarrass ourselves, so let's also set the width and weight of the truck to 2.4m and 10 tons respectively. Just to be sure. We do this using the height , width and limitedWeight parameters. Our API call now looks like this. As you can see this protects us from crashing into bridges and other hazards related to being big and heavy. Nice! Of course it doesn't prevent us from exploding. This is a bigger risk than you might think, as trucks often carry dangerous goods, including explosives, radioactive materials and boxes filled with poisonous Redback spiders . (That last one may or may not be true, but I definitely worry about it.) Obviously if you're carrying hazardous good, there are some restrictions. For example, when you're carrying cargo that could be harmful to water, the government generally doesn't want you to drive near the water source for a major city. Also, if you're carrying boxes full of radioactive Redback spiders, I really don't want you to drive anywhere near my house. Ever. Anyway, our routing algorithm can also find you a suitable route for a truck filled with hazardous materials. Let's assume we want to transport a load of toxic sludge from the small town of Erkner in Brandenburg to Berlin-Friedrichshagen. Without toxic sludge, this would be easy. Just follow the road for about 12 minutes and you're there. Unfortunately this route goes right past two lakes and a canal system. While Hollywood has taught us that toxic sludge is great for superhero origin stories, it's also technically harmful to water and the German government takes a dim view of environmental pollution. This means we're not allowed to drive there. So let's set the shippedHazardousGoods parameter and try this again. As we can see this means we have to go around. Way around. Still, better safe than sorry, particularly when dealing with toxic sludge. One thing to note: there are some special rules for hazardous goods tunnels that are only taken into account when you set the tunnelCategory parameter as well. Check out the documentation for additional details. Before I let you keep on trucking, here are some helpful tips. Truck routing always calculates the fastest route, so you can't use the shortest parameter. Truck routing uses truck speed profiles to calculate the time it takes to complete the route. Basically this means that the weight of the truck (as set in the limitedWeight parameter) influences the reported travel time. You can also use our Routing Reference Client to experiment with the various routing parameters. Never transport toxic sludge and Redback spiders in the same vehicle. The consequences could be catastrophic! We have other truck features, too. Check out our truck restrictions map tiles , which show where truck restriction apply right on the map! Finally, remember that truck routing is also available in our JavaScript API and our Mobile SDKs for Android and iOS . Happy trucking!", "date": "2017-05-23"},
{"website": "Here", "title": "Join us at #AH10 in Singapore and Seattle", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/join-us-at-ah10-in-singapore-and-seattle", "abstract": "I am coming to you live from the Angelhack Global Hackathon Series in Berlin, where despite the glorious weather quite a few teams have come together at Spielfeld DigitalHub to commit to their code . While it’s still a few hours until pitches begin, I’ve already seen some great hacks with the HERE location platform, including a safety app using the Geofencing API and an app that helps people volunteer to pick up trash using gamification and the Waypoint Sequence API (this is something Berlin urgently needs). One of the teams is trying to turn singing into maps. No, really. I can’t wait to see that pitch. Their debugging process sounds interesting to say the least. Another team has a member who’s a dreadlocks-wearing poodle . He’s definitely a good boy and possibly a full stack developer. Let’s just say I’m having a good time. If you want to have a good time, too, I have some great news for you. We will also be sponsoring and attending the #AH10 events in Singapore on June 17–18 and in Seattle on July 15–16. If that’s not enough, we’re also giving away prizes if you use our APIs at these hackathons. Check out this lil’ guy! Have a look at the event pages for Singapore and Seattle for details and tickets. If you want to know what the HERE location platform can do for you before the events, head on over to developer.here.com , check out our documentation and sign up for our 90-day freetrial . Happy hacking and we hope to see you in Singapore and Seattle soon!", "date": "2017-06-11"},
{"website": "Here", "title": "July 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services-1", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Public Transit API, Geovisualization, Custom Location Extension, Custom Route Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension, Fleet Connectivity Extension and Waypoints Sequence Extension. Summary of the release enhancements: Routing: support of Norma 12 regulations for Mexico; Routing: avoiding vignettes and congestion zones; Custom Route Extension supports multiple overlays per customer Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Geocoder API Version 6.2.139 In the UK changes were made to improve the addresses returned to be in proximity of the full postal code. District match levels will be returned for some countries where they're more precise than the postal code Routing API Version 7.2.82 We improved a capability of computing truck long routes avoiding highways and toll roads. We introduced the Routing Zones feature, which enables: Computation of routes avoiding vignettes and congestion zones; Computation of routes compliant to Mexican administrative regulations of the vehicle transport (Norma 12). Geovisualization API Version 2.6.0 Edge Browser compatibility. Custom Route Extension API Version 2.1.3 Resource calculateroute.xml added to support clients who expect XML instead of JSON. All truck restriction attributes can be submitted. Route Match Extension API Version 2.1.15 Trace files in KML format are now supported. Map Data Version 8.30.70.153 (Map#70, April 2017) Introduced Rapid Refresh for Asia Pacific region Adding new HERE Map Content - Azerbaijan Map upgrade from Intermediate Map Adding new Intermediate Map Content - French Polynesia, New Caledonia Switching to Entry Map Content for Iran The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.139) Public Transit API (Version 3.0.2) Custom Location Extension API (Version 2.1.3) Platform Data Extension API (Version 1.6.11) Toll Cost Extension API (Version 2.4.11) Fleet Connectivity Extension API (Version 1.3.3) Waypoints Sequence Extension API (Version 3.0) HERE Platform for Business Team", "date": "2017-07-19"},
{"website": "Here", "title": "Iowa Department of Transportation", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/iowa-dot", "abstract": "Iowa DOT enables driver notification and warnings with HERE APIs to create a more efficient and safer road network providing a smarter, simpler, customer driven solution. Iowa is looking to the future and working with HERE to prepare its road network for integrated automated vehicle and freight movement.", "date": "2017-08-10"},
{"website": "Here", "title": "Sodales Solutions", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/sodales-solutions", "abstract": "Sodales Solutions brings internal and external data together – the driver,  customer, enterprise and other outside forces – in its fleet management solution. It is an SAP S4 HANA extension app powered by HERE's platform and the SAP HANA Cloud. Leveraging HERE Maps and advance routing APIs, Sodales Solutions can track trucks, products and resources in real-time.", "date": "2017-08-17"},
{"website": "Here", "title": "Oracle", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/oracle", "abstract": "HERE Platform services provide geocoding and address standardization, travel times and distances, maps, and more to Oracle Transportation Management (OTM) users. Using the OTM workbench, dispatchers and end users alike can see travel routes, traffic conditions, traffic incidents and more directly on their devices. allowing companies to leverage HERE geocoding, HERE maps and point-to-point routing to manage their transportation needs with automated processes at lower cost. With more than 420,000 customers and deployments in over 145 countries, Oracle offers a comprehensive and fully integrated stack of cloud applications.", "date": "2017-08-17"},
{"website": "Here", "title": "August 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/release-notification-new-enhancements-to-here-platform-services-3", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Maps API for JavaScript, Map Feedback API, Geocoder API, Geocoder Autocomplete API, Routing API, Traffic API, Geovisualization, Custom Location Extension, Custom Route Extension, Geofencing Extension API, Platform Data Extension, Route Match Extension, Toll Cost Extension, Waypoints Sequence Extension and Mobile SDKs for Android and iOS. Summary of enhancements Geofencing Extension support in JavaScript API Improved handling of UK postal codes in Geocoder Optimized truck routing in the HERE Mobile SDK Added CLE2 upload support in the HERE Mobile SDK Toll Cost Extension integrated in the HERE Mobile SDK Multiple improvements in the HERE Mobile SDK related Autosuggest, Venue Maps, Indoor/Outdoor Positioning, Voice Navigation etc. Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Maps API for JavaScript API Version 3.0.15.0 Expanded the maximum zoom level of the map up to and including zoom level 28. Improvements in the spatial objects rendering include: Support of the polygons with holes Rendering of the GIS \"multi-\" type of geometries such as MultiPolygon, MultiLineString and MultiPoint Added service-level support for the Geofencing Extension REST API. Improved support for the Custom Location Extension including extended functionality to change a layer's contents and access rights. Map Feedback API Version 2.7 Introduced New Investigation request/interface to allow customers to ask for a new investigation of a feedback that has been investigated before but the customer is not satisfied with the outcome. Added support for the new use case Road Condition to allow customers to report road obstacles and other special circumstances on a road. Added new options to the reasons why a feedback got rejected. Added new address-specific property building name. Deprecated the probe use case to be removed in the 2.8 release. Note: We recommend to remove this function from your applications now. Geocoder API Version 6.2.141 Improved accuracy of street results containing full UK postal codes. Better handling of UK queries with details not matching to an address. Custom Route Extension API Version 2.1.4 The Custom Route Extension provides guidance instructions also for customized sections along the route in order to grant a better user experience. HERE Android SDK Starter Edition version 3.4: The HERE Android SDK is now packaged as an Android archive (AAR) file. Note: If you are upgrading from a release older than v3.4, you should clean up old components before integrating the AAR version of the HERE SDK. Premium Edition version 3.4: We have aligned CoreRouter.Connectivity (for routing) and Request.Connectivity (for Places search) and made their effects more consistent and predictable. With this change, you have more control over fallback and error scenarios. New Features: Applications can now dynamically initialize the HERE Android SDK with a license key rather than hard coding the license key in the application's Android manifest file. Added the ability to style the outline of a polyline object. Added a new callback for cases when an active guidance session passes a waypoint. Added the ability to be notified of violated routing options when a reroute is triggered by a deviation from the current route. Added the ability to automatically update partially installed map packages by updating the map version. Add support for restricting the results returned by Autosuggest. By default, autosuggest returns address, place, category, chain, and query results. With this feature, the application can request that only a subset of these are returned. See the Places API article, Restricting Suggestion Types, for more details. Autosuggest is no longer considered a beta feature. Added support to allow setting of perspective rendering of MapPolyline towards the horizon, when the map is tilted. Updated the included HERE Positioning (IPS) toolkit to a new version. Updated the map service and the map disk cache. See Functional and Behavioral Changes on page 10 for more details. For levels and outer areas in 3D Venues, you can now find all nearby spaces in a radius around a given position. The returned list of spaces contains all spaces that fall within or intersect the radius. When enabling open venue mode, venues that are in the viewport are now opened automatically, rather than requiring the user to click on the venue to open it. Added the ability for venue maneuvers to provide the names of natural guidance POIs. Added reverse venue space lookup. You can now get area at a given position, the area returned is either an outer area or a space. Added the ability to retrieve axis-aligned bounding boxes for the venue route and outdoor route sections. Added CLE2 upload support. You can now push your changes and new geometries directly from the device to CLE2 Integrated Toll Cost Extensions. You can now get the costs of your (truck) route with details about toll systems split by countries if needed Optimized truck routing. We added support for truck restrictions that do not apply to deliveries. We also added support for adjacent no-through zones. Extended PDE to support layers that are static, such as layers that do not require any bounding box or link ids to be fetched Added support for neighbor cell positioning in HERE Positioning. We now support also using non-serving cells to improve positioning accuracy. Added support for radiomap download. We now support pre-caching radiomaps to the device. Added support for Japanese voice navigation. You can enable this feature by using the downloadable Japanese text-to-speech voice. HERE iOS SDK Starter Edition version 3.4: We have enabled CocoaPod support in this release. We packaged the HERE SDK as a dynamic framework rather than a static library. Note: If you are upgrading from an older version of the HERE iOS SDK, ensure you first remove the old NMAKit.framework, NMABundle.bundle, and linked libraries from your Xcode project before you add the new dynamic framework to your project. For more information, see the \"Creating a Simple Application Using the HERE SDK\" tutorial in the Developer's Guide. Premium Edition version 3.4: We have aligned NMACoreRouterConnectivity (for routing) and NMARequestConnectivity (for Places search) and made their effects more consistent and predictable. With this change, you have more control over fallback and error scenarios. New Features: The HERE iOS SDK is now also distributed on CocoaPods. Added the ability to style the outline of a polyline object. Added a new callback for cases when an active guidance session passes a waypoint. Improved Swift support. Add support for restricting the results returned by Autosuggest. By default, autosuggest returns address, place, category, chain, and query results. With this feature, the application can request that only a subset of these are returned. See the Places API article, Restricting Suggestion Types, for more details. Added the ability to be notified of violated routing options when a reroute is triggered by a deviation from the current route. Autosuggest is no longer considered a beta feature. Added the ability to query for the list of supported map display languages. Updated the behavior of DEFAULT connectivity mode for search and routing features to be more consistent. Added support to allow setting of perspective rendering of NMAMapPolyline towards the horizon, when the map is tilted. Updated the included HERE Positioning (IPS) toolkit to a new version. For levels and outer areas in 3D Venues, you can now find all nearby spaces in a radius around a given position. The returned list of spaces contains all spaces that fall within or intersect the radius. When enabling open venue mode, venues that are in the viewport are now opened automatically, rather than requiring the user to click on the venue to open it. Added the ability for venue maneuvers to provide the names of natural guidance POIs. Added reverse venue space lookup. You can now get area at a given position, the area returned is either an outer area or a space. Added the ability to retrieve axis-aligned bounding boxes for the venue route and outdoor route sections. Added CLE2 upload support. You can now push your changes and new geometries directly from the device to CLE2 Integrated Toll Cost Extensions. You can now get the costs of your (truck) route with details about toll systems split by countries if needed Optimized truck routing. We added support for truck restrictions that do not apply to deliveries. We also added support for adjacent no-through zones. Extended PDE to support layers that are static, such as layers that do not require any bounding box or link ids to be fetched Added support for navigation with Japanese language. You can enable this feature by using the downloadable Japanese text-to-speech voice. The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.141) Routing API (Version 7.2.83) Traffic API (Version 6.0.65.1) Geovisualization API (Version 2.6.1) Custom Location Extension API (Version 2.1.4) Geofencing Extension API (Version 2.1.4) Platform Data Extension API (Version 1.6.13) Route Match Extension API (Version 2.1.17) Toll Cost Extension API (Version 2.4.12) Waypoints Sequence Extension API (Version 3.0.1) HERE Platform for Business Team", "date": "2017-08-18"},
{"website": "Here", "title": "September 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/september-2017-release-notification", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Maps API for JavaScript, Geocoder API, Routing API, Traffic API, Public Transit API, Places API, Venue Maps API, Custom Location Extension, Custom Route Extension, Geofencing Extension API, Platform Data Extension, Route Match Extension, Toll Cost Extension and Waypoints Sequence Extension. Summary of enhancements Custom Route Extension support in JavaScript API. Micro Point Addressing feature is extended to Australia and New Zealand. Added routing inside and in between venues Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Maps API for JavaScript API Version 3.0.16.0 Canvas and DOM layers enable addition of the custom rendering logic (with the help of WebGL, canvas2d or DOM) to the map.Added service-level support for the Custom Route Extension REST API. Added service-level support for the Custom Route Extension REST API. Geocoder API Version 6.2.143 Support of address lines queries at a country level. Micro Point Addressing feature is extended to Australia and New Zealand. Australian Postal Code result have been improved for locality information. Traffic API Version 6.0.66.4 Introduce support for returning all Shape elements (normal roads and ramps) for Flow 6.2 endpoint. Replaced old TMC table E3336 by new ones E3339, E3340 for Turkey. Public Transit API Version 3.1.0 Removed the Transit Isoline endpoint Venue Maps API Version 1.2.0 We have added routing inside and in between venues. 210 new venues added; new count: 14486. The following services had new releases with minor changes: Routing API (Version 7.2.84) Places API (Version 2.53.0) Custom Location Extension API (Version 2.1.5) Custom Route Extension API (Version 2.1.5) Geofencing Extension API (Version 2.1.5) Platform Data Extension API (Version 1.6.14) Route Match Extension API (Version 2.1.18) Toll Cost Extension API (Version 2.4.13) Waypoints Sequence Extension API (Version 3.0.2) Important Information: New incidents endpoint for Traffic API: In May 2017, new /traffic/6.2/incidents endpoint launched to support more incidents data. The old endpoint /traffic/6.1/incidents is still available and will be supported at least for 6 months Public Transit API refactoring: In April 2017, Public Transit API version 3.0.0 released, following refactoring of all endpoints to a new format. The API endpoint format has been changed from: https://transit.api.here.com/metarouter/rest/routeservice/v2/<resource> to: https://transit.api.here.com/v3/<resource> For now, the coming releases will continue to support all deprecated endpoints (with old parameter names).", "date": "2017-10-03"},
{"website": "Here", "title": "October 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/october-2017-release-notification", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Geocoder API, Routing API, Traffic API, Custom Location Extension, Custom Route Extension, Platform Data Extension, Toll Cost Extension, Waypoints Sequence Extension and Mobile SDKs for Android and iOS. Summary of enhancements Further geocoding improvements in Australia and Singapore Isoline corridor search in Custom Location Extension Pickup along a route in Waypoint Sequence Extension New HERE Mobile SDK Release for Android and iOS with new mobile OSes support and other improvements New HERE Platform Self-hosted Q3/2017 release Launch of Mobile SDK User Interface (UI) kit Below, you can find detailed information on these major improvements of the HERE Platform for Business services: Geocoder API Version 6.2.145 Australian Postal Code results have been improved. Improvements in parsing of Micro Point Address queries in Australia. Improvements in Singapore. Routing API Version 7.2.8.5 We increased in the speed profiles a medium truck maximum weight to 18 tonnes. Custom Location Extension API Version 2.1.6 New route + search function POIs along Route's Isoline. Compute a route and find all custom or map geometries reachable within N minutes or N kilometers detour from this route. New route + search function Links along Route's Isoline. Compute a route and find all road links reachable within N minutes or N kilometers detour from this route. Platform Data Extension API Version 1.6.15 Proximity can now be called with a whole set of coordinates, not just one. Waypoints Sequence Extension API Version 3.0.3 New functionality Pickup along Route . Define optional way points where goods or passengers can be picked up and dropped off to earn money. The service decides which optional way points are worth visiting and in which order. Optimization is minimum cost. Cost is the sum of driver cost, vehicle cost, and the value gained from picking up and dropping off goods or passengers is subtracted from the cost. HERE Android SDK Starter Edition version 3.5 This version of the SDK has been updated to work with Android 8.0. Premium Edition version 3.5 This version of the SDK has been updated to work with Android 8.0. We have aligned CoreRouter.Connectivity (for routing) and Request.Connectivity (for Places search) and made their effects more consistent and predictable. With this change, you have more control over fallback and error scenarios. Added Natural Language Processing (NLP) as a beta feature. NLP is only available in English. Added support for search modes in Reverse Geocoder requests Added beta feature to support route calculations based on fuel resource consumption. Added the ability in HERE Positioning to automatically switch between community and private radiomaps. HERE iOS SDK Starter Edition version 3.5 This version of the SDK has been updated to work with iOS 11. Premium Edition version 3.5 This version of the SDK has been updated to work with iOS 11. Added support for Xcode 9 Added APIs to turn off rendering for certain levels of traffic flow. Added the ability to enable GPX and Route Simulation in Guidance when the app is in the background. Added beta feature to support route calculations based on fuel resource consumption. Added support for search modes in Reverse Geocoder requests. Added the ability in HERE Positioning to automatically switch between community and private radiomaps. Mobile SDK User Interface (UI) kit Version 1.0.0 The HERE Mobile SDK UI kit provides pre-built and production ready UI components to be used with the Mobile SDK for Business Premium Editions. Version 1.0.0 of the UI Kit will mainly focus on route planning use cases including route and maneuver details. The components are provided as a framework for iOS and a library for Android which developers can integrate in their project and reuse the pre build UI components to reduce development efforts. All components are extremely customizable (also in terms of visuals) and due to the modular design flexible to use. The HERE Mobile SDK UI Kit components are available for iOS and Android, supporting Java and Kotlin on Android, and Obj-C and Swift on iOS. The required HERE Mobile SDK is version 3.4 or later. The following services had new releases with minor changes: Traffic API (Version 6.0.6.71) Custom Route Extension API (Version 2.1.6) Platform Data Extension API (Version 1.6.14) Route Match Extension API (Version 2.1.18) Toll Cost Extension API (Version 2.4.14) HERE Platform Self Hosted Version Q3/2017 Map Tile API 2.1.68.23 (D84) Traffic API 6.0.66.5 (D84) Geocoder 6.2.143.3 (D84) Reverse Geocoder 6.2.143.3 (D84) Geocoder Autocompletion 6.2.143.3 (D84) Maps API for JavaScript 3.0.16.0 (D84) Custom Location Extension 2.1.5 (D84) Geofencing Extension API 2.1.5 (D84) IMPORTANT INFORMATION: General Rules Related to HERE Materials and Applications Inline with HERE Platform core terms, please ensure that the users of your application build on HERE Mobile SDKs Premium Edition constantly download the latest map version within a couple of weeks after the new map release has been available. New incidents endpoint for Traffic API In May 2017, new /traffic/6.2/incidents endpoint launched to support more incidents data The old endpoint /traffic/6.1/incidents is still available and will be supported at least for 6 months. Public Transit API refactoring In April 2017, Public Transit API version 3.0.0 released, following refactoring of all endpoints to a new format. The API endpoint format have been changed from https://transit.api.here.com/metarouter/rest/routeservice/v2/<resource> to https://transit.api.here.com/v3/<resource> For now, the coming releases will continue to support all deprecated endpoints (with old parameter names).", "date": "2017-10-18"},
{"website": "Here", "title": "Custom Location Extension service update provides isoline search along a route", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/custom-location-extension-service-update-provides-isoline-search-along-a-route", "abstract": "If you use our Custom Location Extension, you’re probably familiar with corridor search, attribute search and bounding box search available for your private POIs. One gap in these search capabilities has been providing the exact time and distance to reach a POI. This new service release helps close that gap, allowing you to make precise estimations through your applications. Today, CLE 2.1.6 gives access to a new functionality called “isoline search along a route.” While corridor search provides a list of locations in the proximity (fly distance) of a route, isoline search along the route provides all reachable locations within a specified time and distance along a route. What’s the difference? Isoline search along the route considers the actual HERE road network to make such exact calculations, while the corridor search just lists the locations within a certain proximity, with no estimation on how long it will take a driver to get there. For example, the corridor search could find a location along a route that is only 0.5 miles fly distance. But to detour from a route and drive to this location, a driver would need to drive 2 miles due to unexpected road conditions (e.g. the next highway exit is a mile away or a river between the highway and that location can only be crossed at a bridge that is 2 miles away). This function becomes particularly important to drivers that need to make a stop or detour, and are already engaged in a route with very rigid ETAs, or when important locations like gas stations need to be reached right away. Besides a list of locations, isoline search along a route also returns all the link IDs that can be reached within a set time and distance. This can become an important tool when evaluating the addition of other possible locations within your database. Check out the documentation and code examples for the API here . Happy coding!", "date": "2017-10-16"},
{"website": "Here", "title": "November 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/november-2017-release-notification", "abstract": "A series of enhancements and updates to the HERE Platform services are now available on our production environment. These enhancements are related to the following services: Geocoder API, Geocoder Autocomplete API, Traffic API, Venue Maps API, Geovisualization, Custom Route Extension, Geofencing Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension and Waypoints Sequence Extension. Summary of enhancements: Private venues support added to Discovery and Routing services of Venue Maps API New enhancement in Custom Route Extension to add or modify link access restrictions Below, you can find detailed information on the major improvements of the HERE Platform for Business services. Venue Maps API Version 1.2.1 Metadata API introduced to support access to multiple namespaces and HERE Account token authorization Discovery and Routing services has been updated to support private venues Custom Route Extension API Version 2.1.7 New restrict operation to add or modify link access restrictions (also truck specific ones) Support for all motorway / ferry / toll avoidance levels Platform Data Extension API Version 1.6.16 New layers added as beta versions (not fully commercial available): Public Transport POIs Road Roughness Safety Alerts (accident spots and speed cameras) Waypoints Sequence Extension API Version 3.0.4 Required tunnel categories can be specified, e.g., the truck can only use tunnels of at least category C The following services had new releases with minor changes: Geocoder API (Version 6.2.147) Geocoder Autocomplete API (Version 6.2.147) Traffic API (Version 6.0.68.0) Geovisualization (Version 2.6.1) Geofencing Extension API (Version 2.1.7) Fleet Connectivity Extension API (Version 1.3.3) Route Match Extension API (Version 2.1.20) Toll Cost Extension API (Version 2.4.15)", "date": "2017-11-06"},
{"website": "Here", "title": "Meet the HERE DevRel Team", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/meet-the-here-team", "abstract": "The HERE Developer Relations team is headed to some exciting events this fall, and we'd love to meet you in person. If you're around Istanbul at the end of October, please consider signing up for our free hackathon . We have some great prizes, including a trip to Tech Open Air 2018 in Berlin. Our full list of upcoming events is below. Please stop by and say hello at: Silicon Valley Code Camp October 7-8 in San Jose, California. Developer Evangelist Richard Süselbeck will be giving a talk at 1:30PM on Saturday and on hand all weekend to talk location APIs. Samsung Developer Conference October 18-19 in San Francisco, California. Richard, Mithun Dhar, who leads Developer Relations at HERE, and I will be hanging out at the HERE Technologies booth. HERE Hackathon Istanbul October 27-29 in Istanbul, Turkey. Mithun and Developer Evangelist Michael Palermo will be judging entries and supporting teams throughout the event. GeoIT Wherecamp Conference October 30 in Berlin, Germany. Richard will be giving a talk. Garage48 SpaceTech: Integrated Applications hackathon November 3-5 in Tartu, Estonia. Richard will be there as a mentor. DevRelCon: London December 6. Richard and Rebecca Amir, Product Owner for Developer Portal, will be representing our team.", "date": "2017-10-04"},
{"website": "Here", "title": "Build beautiful interfaces with the HERE Mobile SDK UI Kit for Android and iOS", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/build-beautiful-interfaces-with-the-here-mobile-sdk-ui-kit-for-android-and-ios", "abstract": "When it comes to any application, the user interface defines the experience you provide when someone interacts with your software. It can mean the difference between acquiring and retaining users or deterring them from returning to your app. We understand how critical this is to your success, so we pre-built a variety of screens with full functionality that can be used directly in your application. They are available today through the HERE Mobile SDK UI Kit for Android and iOS . The HERE Mobile SDK UI Kit gives access to modular and highly customizable UI components and controls that allow you to provide an interactive user interface for your app. With just a few lines of code you can now build a full UI when developing with the Premium edition of the HERE Mobile SDK. This means reduced development time and a faster time to market. So, for example, where you would normally need several days to build a maneuver list using our native APIs, with the new UI kit, you'll only a few hours. However, if needed, the UI Kit still allows you to modify the appearance (e.g. colors, dimensions) and behavior (e.g. data presentation, logic, flow, subcomponents) of some UI controls. What's included? Version 1.0 of the UI Kit mainly focuses on enabling experiences related to route planning. It provides all UI components needed when creating a route, adding additional waypoints, seeing alternative route options and getting maneuver lists. UI components available in this version: Route Planner Waypoint list (start, stop, incl. support for stopovers, drag & drop sorting) Transport mode panel selection (car, truck or pedestrian) Traffic options panel Different route options (incl. different sub-views for trucks like tunnel or hazardous good) Travel time options and picker (to select departure or arrival times) Route Summary Show route details overview Show alternative routes Route Maneuver List Show maneuver details overview Assemble actions and turns into instruction texts Instruction icons What are the supported platforms? The HERE Mobile SDK UI Kit components are available for iOS and Android, supporting Java and Kotlin on Android, and Obj-C and Swift on iOS. The HERE Mobile SDK version 3.4 or later is required. Where can I get it? To get access to the HERE Mobile SDK UI Kit, first sign up for a developer account on the HERE Developer Portal. Then you can easily access the Kit at one of the links below: For Android developers: https://github.com/heremaps/msdkui-android For iOS developers: https://github.com/heremaps/msdkui-ios", "date": "2017-11-01"},
{"website": "Here", "title": "Waypoints Sequence Extension gets smarter at pickups along routes", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/waypoints-sequence-extension-gets-smarter-at-pickups-along-routes", "abstract": "Today we’re announcing the extension of the service capabilities of Waypoints Sequence Extension (WSE) with an easy-to-use syntax and an intelligent sequencing algorithm to allow you to optimize pickups along your route . WSE has always provided optimized sequences of waypoints along routes, and now WSE can also make intelligent calculations for any given waypoint to be considered (or not) along a route based on value, cost of business, and capacity. The newly available parameters and constraints to determine which waypoints should be considered along the route are: incremental value per waypoint time restrictions applicable to final destination time windows per waypoint and opening hours drop-off locations and opening hours capacity required at waypoint maximum detour time vehicle capacity any sequencing priorities (e.g., point A before point B) The above functions can be extremely useful when developing for logistics and on-demand applications. For example, the incremental value at pickup points could be the value associated with picking up additional cargo along a route, or in the case of on-demand, the fare associated with picking up another passenger along the way. The service also considers time windows necessary at pickup locations to ensure that any delays associated with these detours are time reasonable and don’t affect the quality of service. Cargo capacity can be either the space (capacity) available on a truck, or the number of passengers that can fit inside a vehicle. But that’s not all – if you’re developing an application that needs to comply with the latest hours of service (HOS) regulations, WSE allows you to consider all the legal rules regarding driving times and driver rest times when making such calculations. These new features are available in our 90-day free trial license , as well as for existing customers of WSE. Try them out and let us know what you think. More information is available in our API documentation .", "date": "2017-10-16"},
{"website": "Here", "title": "Spotlight on Machine Learning: Oliver Monson", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/spotlight-on-machine-learning-oliver-monson", "abstract": "“Have humans focus on things that humans are really good at and machines can’t replace. That’s the transition.” – Oliver Monson Image credit: “ Unicorn Crossing ” by rumpleteaser is licensed under CC BY 2.0 The transcript of this interview has been condensed and lightly edited for clarity. You're a Data Operations Manager in our Highly Automated Driving division at HERE. What do you do? When I first started with HERE, I was focused on dealing with the data from the [HERE True] vehicles and making it useful to the rest of the organization. Two years ago, we transitioned to focusing on the highly automated driving use case. I’m making sure that that data I dealt with back then is useful to the rest of the org, specifically for machine learning and algorithm development. So, taking that imagery—that Lidar data we collect with these vehicles, petabytes of data that’s sitting in our cloud—and converting it to useful data that we can build automated feature extractors from. Traditionally, we have people look at that data and make a 2D map out of it. That doesn’t scale for making a really detailed 3D map that’s required for autonomous driving. So, my role supports the teams that are trying to automate that map creation process. What’s a more specific example of a problem you have to solve? Detecting all the signs in the world. Signage is very useful to mapmaking. The attributes that are on the sign: the speed limits, the stop signs, the warning indicators—all that signage tells the driver something about the environment, the rules of the road. There’s thousands of different types of signs and every country has their own variations, languages, and symbols. We can look at imagery and label a sign or label the lanes and make a map that way, but that requires a human to do that. So now can we replace that human with a machine that can detect signs automatically. I support building that vast library of training data, so that we can detect those signs automatically and classify them. In order to develop these algorithms, we leverage our internal workforce and crowdsourcing options to human label this data as input. What’s the strangest sign you’ve ever seen? The variation of animal crossing signs around the world is amazing and so very specific. Kangaroo signs in Australia—sure, but frog crossing signs in Germany and France are something you don’t see very often here in the United States. So how do you detect signs? The brute force way is to have a bunch of people sit at a computer, go through every single image, draw a box around the sign and write down what that sign means. That’s how it’s been done for years. Now the shift is take those resources and instead of labeling everything, label only enough data that we can train a machine to do the same thing. The most cutting edge research around deep learning algorithms has shown they’re very successful at doing this type of extraction out of imagery, given enough training data. The difference isn’t the algorithms anymore—they’re so many available off the shelf—it’s really the training data as input into those algorithms that determines how successful you are at detecting those features and classifying those. The goal is to iterate as fast as possible with as much data as you can get every time, and you see significant improvements in performance of those algorithms as you teach it all the edge cases. Whether you’re labeling the data to draw a map manually or to train a machine to draw the map, there’s still a lot of human effort involved. What analytics do you use to optimize the process? Metrics focused on getting training data are super important because we’re spending thousands of hours labeling this data. It’s very expensive to collect the amounts of data needed to create these really high-performing algorithms. Understanding your process and seeing how small tweaks, whether it’s just a mouse click—reducing one mouse click can have huge effects on how much manual work there is and the throughput of creating training data or building the map. All of these things need to be constantly evaluated. Let’s talk about the human side of this. How do you motivate someone to label data accurately if the person perceives doing so as a threat to their job? It’s not about automating people out of a job, it’s about leveraging them differently. We’re actually scaling. Instead of brute forcing the map creation process and having humans look at every single thing, we have humans focus on things that they are really good at and machines can’t replace. That’s the transition. Focus their efforts on labeling edge cases and difficult environments, things that we can’t generalize easily. Have them focus on that 10% that’s really the most difficult and that we might have oversimplified or not even approached. What’s an example of that 10%? We didn’t label every single highway information sign that points you to a business down the road or a unique vista…some unique signage that’s only relevant and pertinent to that location in this world, we would not have bothered converting that information into the map. When we first started, we were focused on what signage is needed to make a navigable map, like speed limits. Now the map is a 3D map that’s useful to machines. Can the machine know with really high confidence where it is in this world? GPS by itself is not good enough. The machine needs to understand the reference map and understand its location in the world by comparing what it sees to the map, and position itself based on that within a meter of accuracy. So, going from twenty meters of potential error to within a meter, to centimeters really is the goal. What kind of sign would help a machine position itself? Every single sign. Anything that’s static, anything that you can feel confident will usually be there next time you drive by is a useful data point. What have been the biggest challenges? Marshalling a huge amount of human labeling power and having them focus on the things that are hard for machines. That is the core of what I do: identifying what is hard. So how do you identify what’s hard? We have a lot of algorithms that do similar things, that detect similar features or overlapping features. By identifying where they might conflict or where a human has labelled one thing and the machine says it’s another, those are the conflict points. Whether it’s machine versus machine or human versus machine, I try to build processes that find those conflict points as efficiently as possible. How do you measure success? We’re going into new countries and expanding the scope of the problem, so the finish line is always moving. Let me throw out this other idea that might be useful. We have thousands of people who are experts at making the map. Can we leverage non-expert mapmakers? If you can simplify the things that we need humans to help inform us, then that labor is unlocked and allows us to scale completely differently than we have in the past. What do you know now that you wish you knew when you started working on this problem? Ensuring you’re asking the crowd the right questions and doing the right kind of checks that you can be confident in the answers back. Arabic letters on a sign in Saudi Arabia is not something you want to ask a person in Columbia to translate. What’s the next big thing in Machine Learning? Finding ways that you don’t have to have as much data, where you can supplement your existing data sets with smaller and smaller amounts of human-labelled data to create the same results. Right now, there’s a focus on getting a lot of high quality data, but because that’s expensive there’s a lot of research happening in how can we synthetically create that data automatically. Can we show that we can create the same level of performance with 1,000 human images and 100,000 synthetic as we would have got if we had a million human-labelled images? What’s an example of synthetic data creation? Using video game engines to create a 3D world that looks so much like our real world and has all the weather conditions that you can simulate. You can create a virtual world that is so close to real life but you also enable manipulation of that world in a way that you can’t manipulate the real world. Can we make a snow storm in San Francisco? That is only possible with this virtual environment. Do you see any other applications for what you’ve been doing with Machine Learning inside or outside of HERE? Applying feature extraction of signs to other things in the world that are useful for a map. Can you take a stream of data from a sensor and automatically identify things that are useful like available parking or real-time gas prices? How can developers tap into what HERE is doing with Machine Learning? We’re starting to use our Open Location Platform (OLP) to provide infrastructure for our internal processes. A lot of the data that we extract and that we will create and put into the HD Live Map , parts of that data stream will be available in OLP and will get information from OLP. That will be another layer of information that we can use to cross-reference our machine learning algorithms, and likewise an external developer could use it to cross-reference their own stuff. [Note: these data processing capabilities will open to external developers in 2018] What resources would you recommend for someone just starting out with Machine Learning? Udacity and Khan Academy . They’re not focused on machine learning, but the amount of material that’s within the computer science field there is amazing. For algorithms, published academic research is the cutting edge. There’s this big conference, CVPR [The Conference on Computer Vision and Pattern Recognition] that is one of the premier conferences to stay up to date on research in this field. You were an anthropology major at Cal. As an anthropologist, what do you think about Machine Learning and automating the world? It’s going to be really exciting. Our world is going to look so different in twenty or thirty years than it does today because of all this work on automation. It opens up so many possibilities for the way we use our time, the way we use our space, the way we get stuff. Almost every aspect of our lives will be affected by this in some way. It’s hard to think of a revolution beyond the printing press and what that enabled that’s comparable. Learn more about Oliver and connect with him here .", "date": "2017-11-08"},
{"website": "Here", "title": "Grab", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/grab", "abstract": "Grab, South East Asia’s largest ride-hailing platform, uses HERE Platform to optimize services provided to their network of 1.3 million drivers and 60 million passengers. Using HERE services like traffic-enabled , matrix , and isoline routing, Grab streamlines pick-up and drop-off processes, provides reliable ETAs and will improve traffic management in underserviced cities like Yangon. For more information on how HERE's Routing services can help optimize your dispatch processes, please see our REST , Android , and iOS SDK documentation.", "date": "2017-11-20"},
{"website": "Here", "title": "Build apps that help save lives at the Critical App Challenge Hackathon with HERE and Airbus", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/critical-apps-airbus-here-hackathon", "abstract": "Join us at the Critical Apps Hackathon in Munich from Feb 2nd - Feb 4th. Mission critical communication systems are typically used by emergency and disaster response units, especially when vital information needs to be delivered reliably because lives are at risk. Police, firefighters, paramedics, but also critical mission professionals in fields such as oil and gas, airport operations and public utilities, use professional mobile radio (PMR) systems such as TETRA to prevent and respond to emergencies. However, in addition to their PMRs these professionals also make use of their smart phones to provide additional information and communication for their daily work. To make them more effective in their daily operations, Airbus is launching a new hybrid product, the Tactilon Dabat . The Tactilcon Dabat is an Android smartphone which provides both regular LTE network access and built-in mission-critical TETRA capability. It’s not hard to image how location technology can be used to build exciting new applications leveraging the hybrid capabilities of this device, and so HERE is joining forces with Airbus for the Critical Apps Challenge Hackathon. If you join us, your challenge will be to improve the mission-critical communications of police officers, firefighters, caretakers, doctors and other life-saving and society-building professionals. What kinds of useful, secure and engaging applications and functionalities can you come up with using the HERE APIs and the new Airbus Tactilon Dabat? The hackathon will take place in Munich from Feb 2nd to Feb 4th, 2018. You can find more information and the application form on the Critical Apps Challenge homepage. Also check out the SmarTWISP developer programme for the Tactilcon Dabat, and of course sign up for the free trial on the HERE Developer Portal. See you in Munich!", "date": "2017-11-13"},
{"website": "Here", "title": "Delivery made easy with the HERE Waypoint Sequence API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/delivery-made-easy-with-the-here-waypoint-sequence-api", "abstract": "The HERE Routing API is great. If you know where you need to be, it will help get you there, whether you’re walking or driving a truck. It will even help you dodge traffic jams and let you catch the subway in time. Sometimes though, knowing where you’re going isn’t enough. This is particularly true if you’re going to a lot of different places. Let’s look at an example and pretend we are in the package delivery business around the picturesque seaside resort of Milton Keynes . We have ten packages deliver to ten different addresses. Obviously, we want to deliver these packages as efficiently as possible. As a first step, we can use the HERE Geocoder API to convert those addresses into geographic coordinates. Check the Geocoder documentation for details on how to do this. We can then call the Routing API, using these coordinates as waypoints. This returns the following route. (If you need and app code and id, you can sign up for our freemium plan .) Oh dear. While this will certainly allow us to deliver all our packages, it would require a lot of driving back and forth on the A5. While this is Milton Keynes’ famous scenic coastal road, it would take over 150km of driving to get the job done. Our boss might reasonably be asking what on earth took us so long. Clearly, we need to find a better route. At this point, we could start a discourse on combinatorial optimization, and argue that delivering packages is not just hard, but actually NP-hard work. Unfortunately, our boss doesn’t have a computer science degree and doesn’t care about our excuses. In fact, he would probably just tell us to deliver the packages faster, or else. (And if he did have a relevant degree, he’d probably start yelling at us about heuristic techniques.) So, what are we to do? Well, fortunately there’s an API for that! It’s called the Fleet Telematics Waypoint Sequence API. The Fleet Telematics Waypoint Sequence API allows us to request the optimal order in which we should travel between a set of waypoints to minimize either the overall travel time or the distance travelled. It will even take road network restriction and traffic patterns into account while doing so. This sounds exactly like what we need, so let’s have a look at another example and pretend we’re in Auckland for a business trip. We have found a few hours of free time before our flight leaves and we want to see as much of the city as possible in as little time as possible. Here's a list of sights we figure we can squeeze in. To get these waypoints optimized for time, our API call needs to look like this. As we can see, the API has a reasonably simple interface. All we need to do is give it the list of destinations, our preferred mode of transport and whether we want to optimize for time or distance. We also need to provide a start point. When delivering packages this will likely be our logistics hub, but for our sightseeing tour we’ve picked a hotel. Finally, we need to provide a start waypoint and a departureTime . The departure time is needed, because the Fleet Telematics Waypoint Sequence API cleverly takes both current and historic traffic into account for its calculations. Note that the id strings in the destination parameter are optional, but can be helpful as they will also be included in the response. Of course, you can simple use the lat/long coordinates by themselves (e.g. destination4=-36.84827,174.76223 ). You may note that we seem to be optimizing for time twice, once with the mode=fastest parameter and once with the improveFor=time parameter. Using improveFor will optimize the entire sequence for time, while mode will optimize the routes between two individual waypoints for time. In our example we are short on time, so we will optimize for speed in both instances. Let’s have a look at the result. As we can see, the result contains a waypoint object with the optimized sequence of waypoints, conveniently numbered, and an interconnections object with information about time and distance for each route between two consecutive waypoints. It also gives us some information about the time and distance of the total route. What it doesn’t give us, however, is an actual route. So, we once again need to put the waypoints into the routing algorithm, except this time we do it in the optimized order. Our sightseeing route now looks like this. That’s not bad! We can get all our sightseeing done in under 2 hours and catch our plane back home in time. Let’s go back to our original example now. Speed is important, but our boss also cares about fuel economy, so this time we are going to optimize by distance. Thus, we set improveFor=distance . We’re also driving a delivery truck, not a car, which means we will be using the truck mode for routing. Check out our  for more information on the various special parameters available for truck routing. Regardless of the order in which we deliver our packages, we need to be back at the logistics hub at the end of our work day. This means we will also set the optional end parameter to get us back to where we started from. Our API call now looks like this. If we feed this into the routing API, we get the following result. Much better. We get one clean route around town, with deliveries neatly clustered. Thank you, Fleet Telematics Waypoint Sequence API! Of course, that’s not the whole story. When delivering packages there are many other constraints we may have to consider. For example: Some packages must be delivered before others. Some packages must be delivered within a specific time frame. Some packages must be delivered at a specific time. Delivering each package takes some time, which influences overall delivery times. Delivery drivers work hard and deserve some breaks. It’s not just a good idea, it’s often the law! The Fleet Telematics Waypoint Sequence API supports all these constraints and can provide optimized routes and delivery times based on them. We will look at the necessary parameters in part two of the Waypoint Sequence API tutorial, coming soon. See you then, and many happy deliveries!", "date": "2017-11-21"},
{"website": "Here", "title": "Creating a location-aware chatbot with HERE & Twilio", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/creating-a-location-aware-chatbot-with-here-twilio", "abstract": "Chatbots are all the hype these days. You can use chatbots to stay updated with current events, order a ride sharing vehicle, or even schedule an appointment. But have you ever considered building your own chatbot? In this guide, I'll teach you how to create a location-aware chatbot with HERE Location Services and Twilio using Node.js . The chatbot will enable users to search for places near a location. For example, a user could search for \"Sandwiches near Central Park New York City\" or \"Subway near 701 Pike Street Seattle.\" That's both places and addresses you can search for! To accomplish this, we're going to be using a few different APIs: HERE Geocoding API HERE Places API Twilio SMS API This tutorial requires basic knowledge of JavaScript or Node.js apps. You'll need both HERE Developer and Twilio accounts, so if you don't already have those now is a good time to sign up and create a new project on each. For Twilio, you'll also need to sign up for a free phone number. Make sure to register your own phone number with your Twilio account to ensure you can send and receive messages. If you get lost during the Twilio setup, give this helpful guide a read. Part 1: Starter Code & Configuration To get started, you'll need a few npm modules installed: twilio express body-parser request To install these modules, run npm install package-name in the command line. (Alternatively, give this package.json file a try.) We're also going to need to install ngrok to run a tunnel providing an externally available URL to our server. Now we can start coding! Open up your preferred text editor and create a new JavaScript file called server.js . This file will enable us to send and receive messages. Paste the following code: Don't forget to paste your HERE and Twilio API credentials into their respective fields. We'll want to configure our server to reply to messages sent to our Twilio phone number. Once Twilio is configured correctly, the above code will enable our bot to reply with 'Hello, there!' anytime you text your Twilio phone number. To get the server up and running, you're going to want to run node server.js in the command line. In order to make your server publicly accessible, you'll want to run the command ngrok http 1337 (on macOS a quick way to do this is to run these two commands on different tabs). Port 1337 is now exposed to the public internet. Copy the forwarding URL (highlighted in the below screenshot) provided by the ngrok console. Take the copied URL and configure it as a webhook for your phone number . Under the Messaging header, paste this URL followed by /sms in the message comes in field. Once you've got that configured, try sending a message to your Twilio phone number. You should get a friendly reply saying 'Hello, there!' Part 2: Integrating HERE Location Services Now that you've got a functional SMS messaging service, let's make this chatbot location-aware by equipping it with HERE Location Services. We want our bot to perform the following way: User texts the chatbot with two parameters: a search query and a location . For example: Pizza near 701 Pike Street Seattle Chatbot geocodes the search query from a POI or an address to coordinates (latitude and longitude) Chatbot searches for places based on the search query near the geocoded location Chatbot replies with three relevant places and gives the option to learn more about a place The user replies to learn more about a certain place Chatbot replies with address of the requested place Let's change the contents of the app.post block to look like this: Let's break down the above code. The variable incoming is the plain text sent by the user to the chatbot. We can split this variable into two parts by using incoming.split(' near ') . This by no means is the best way to parse text, but we'll do it this way for simplicity's sake. searchQuery : the query we'll search for with the Places API locationString : the string of the location (address or POI) we'll geocode into coordinates We'll pass our searchQuery , hereID , hereCode into a variable geocodeURL to create a request URL to the HERE Places API request.get constructs the request and gives us back parsed JSON containing our results Once we've received our reply for the API, we can extract the latitude and longitude from the response. Be sure to place the remaining code examples all within the request.get() block. Now that we've transformed our location string into coordinates, we can start searching for places that fit the constraint of the search query and location. To do so, we're going to construct a HERE Places API search (within the geocode request). We provided the geocoding request the following parameters: at : latitude and longitude of where to search q : the query to search for. I've added .replace(/  /g, '+') to replace the spaces with plus signs to make a more friendly URL tf : text format of response app_id & app_code : access credentials for the API I'd like to return 3 results to the user each time, but sometimes there aren't always 3 results available for a particular query, so I created the variable resultAmount to show the appropriate amount of available results. Let's start processing the results from our API response and begin preparing our reply to the user. responseMessage sets up the first line of our reply message to the user: Here are the 3 closest Mexican restaurants to 701 Pike Street Seattle . We loop through the amount of appropriate results (determined with the resultAmount variable) to do the following tasks: Add a place's name, category, and address into a dictionary. We'll be using this dictionary later to reference information about a place Append additional text onto the reply to the user. We add: A number the user can reply with to learn more about a place The name of the place Sometimes the Places API returns subcategories of the search query, not actual places. To avoid and filter out subcategory results, we can add a simple conditional blocking subcategory results. In the event we do come across a subcategory instead of a place, we increment resultAmount to ensure we return the appropriate amount of results (usually 3). Now that we've created both our dictionary of places and our text reply to the user, let's go ahead and send something via SMS. Voila! The user is now sent a list of results relevant to their search query and location! Give it a try with \"Sushi near Pike Place Seattle\" Part 3: Additional Information About the Place We've written code to receive messages, geocode locations, search for places, and send messages. At this point, the user will now receive a message with something along the lines of: Here are the 3 closest Hamburgers places to you: (1) Kidd Valley Hamburgers (2) McDonald's (3) Eureka! Reply with # to learn more information Our service encourages the user to reply with a number to learn more about a particular place. To enable this feature, we're going to want to add some conditionals within our app.get() block. Modify your code to fit this structure: The if (incoming.length > 1) is designed to accept the user's first message. The initial message to begin the process must contain a search query, the word 'near', and a location string. This will be longer than one character. The else if (places.length > 0 && incoming.length == 1) is designed to accept the user's second message. We check to make sure that the places dictionary is empty and that their incoming message is only one digit in length (the second message is supposed to be an integer between 1 and 3). There are plenty of additional ways to check this case, but we'll stick with these conditions. Within the else if statement, let's insert the following code: We're now able to send the address to the user about the requested place. Part 4: Error Handling & Advanced Functionality To ensure messages that don't follow the strict 'near' format don't crash our service, let's add some error handling. Right below the if (incoming.length > 1) statement, let's add: This ensures the user's first message contains a 'near' so we're able to extract the search query and location string. Additionally, let's add this if statement right after we create our geocodeJ son variable in the geocoding request: In the event no places are returned from the Places API query, we send a message informing the user to try again. Congratulations, you've created a functioning location-aware chatbot! You can check out the full source code here . There's no need to stop here! We've created just a simple version of a location-aware chatbot. What additional features could you bring to this chatbot using HERE APIs? Try enhancing this project by giving our Traffic , Routing , Transit , Weather , and Positioning services a shot. Want to chat in person about HERE Location Services? You can find me at the Turkish Airlines Travel Hackathon on December 22-24 in Istanbul, Turkey ! Update: Now you can watch this hands on tutorial on YouTube !", "date": "2017-12-04"},
{"website": "Here", "title": "What would you build to improve flying?", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/what-would-you-build-to-improve-flying", "abstract": "Dylan and I wrapped up the year by joining the students and professionals that signed up for the Turkish Airlines Travel Hackathon in Istanbul for two strenuous days of creativity and problem-solving. We joined 14 other companies to sponsor this event that took aim at the pain points we have all felt in the air travel experience. 150 developers were up for the challenge. Remember back to your least favorite airport experience... You are in a moshpit of people in the security checkpoint line for much longer than you had planned. Perhaps you are wearing your go-to TOMS for easy slip-off which makes for a chilly walk through the x-ray machine. You grab your carry-on and shoes, to book it to your gate. You hang a left towards gate A3. (Was it Gate A3 or seat A3? Oops... S4! That is on the other side of the airport!) Too late to try to get a magazine; the plane is already boarding. The plane ride is satisfactory and you make it to your destination. Unloading you scan the airport signs for the nearest bathroom. All right, bag check time. But which carousel? Fingers crossed your bag isn't lost. Now, where can I catch a Lyft to my Airbnb? The travel experience is rich with opportunities to streamline and enhance and the 43 teams in this hackathon were up for the challenge. They looked at pre-flight. They looked at post-flight. They looked at the airport experience, and they looked at what they could do to improve your time in the sky. Location services can be a tool in the toolbox of any developer, and the travel experience is no exception. 12 of the 43 teams used HERE APIs to spice up their prototypes with location. The teams \" Mahşerin Dört Atlısı \" and \"Taxim\" used HERE location services and earned 1st place in Airport and Post-Flight categories. They all scored free roundtrip flight tickets to any Turkish Airlines destination for their creativity and ablity to deliver solid prototypes. Mahşerin Dört Atlısı's idea was my favorite. They created a luggage tracking solution. Their idea, if implemented, would include afixing a triangular camera system to each \"bag drop checkpoint\" to record the barcode, color, weight, brand, dimensions, and first seen/last seen data enabling better bag tracking thoroughout the customer journey. According to 2015 data, lost luggage costs were ~$2.3 billion, and an airline implementing an idea like this well could mean a significant cost savings to their company. Now, that's an idea with potential to improve the traveler experience and save the company a bundle! Great thinking, Four Horsemen! The 48-hour event, a blur of sleepless nights, was a wonderful way to spend a wintry weekend. Whether it was flying around in the flight simulators or hacking away in airplanes on the ground, the entire event was a great experience to help make the entire flight experience a little more tolerable and we were happy that HERE location services could help the teams harness the power of location in their projects. Stay tuned for more hackathons in 2018. We would love to join you for one soon.", "date": "2018-01-09"},
{"website": "Here", "title": "Build your own map with LEGO", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/build-your-own-map-with-lego", "abstract": "When I was a kid, my favorite Christmas presents were often LEGO sets. Now that I’m a grown man, well, that hasn’t really changed. With the holidays just behind us, I thought why not ease into the new year with a combination of two of my favorite things: maps and LEGO bricks! If we want to build a map with bricks, we must first decide which kind of map. I went with a topographic map , mostly because LEGO bricks are three-dimensional by nature. It’s also colorful and easy to build at the right scale with bricks. Second, we must decide what our map is supposed to show. I’ve gone with a place that I’ve always wanted to visit, the island of Madagascar . All right, now that we’ve decided what to build, we need to get out the bricks. Topographic maps usually show the different heights of the terrain using distinct colors, so we need to decide which LEGO brick colors to associate with each height. I’ve gone with the following palette, using Bright Blue , Medium Azur , Dark Green , Bright Yellowish Green , Bright Yellow and Dark Brown . We mostly need small plates, but some bricks can also be helpful, particularly in yellow and brown. Let’s start by creating the deep ocean and build a flat surface in Bright Blue. If have a large enough baseplate in the proper color, you’re already good to go, but I needed to use a whole bunch of smaller blue plates. A gray baseplate is holding them together. As the next step, we’re roughly outlining the island in in Dark Green. (A brick separator is a very useful tool to remove misplaced plates.) Once we’ve got the outline done, we need to build the shallower water around the island in Medium Azur. Since we’re building a three-dimensional map, we want the Medium Azur water to be higher than the Bright Blue water and the Dark Green land to be higher than the Medium Azur water. The first we’ve already achieved, but we need to add another layer of Dark Green on top of what we've previously built. We also start adding some Bright Yellowish Green to indicate even higher areas. We can then start putting in yellow and brown bricks to create the mountainous areas on the island. We may need to add some plates underneath the bricks to make sure they are high enough. Finally, we add some finishing touches and a little flag to indicate the country’s capital city, Antananarivo . There we go, our own little map made of LEGO bricks! Happy new year! May it be filled with all things maps and LEGO.", "date": "2018-01-02"},
{"website": "Here", "title": "December 2017 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/december-2017-release-notification", "abstract": "This month, we have updates to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Traffic API, Transit API, Geovisualization, Custom Route Extension, Geofencing Extension, Platform Data Extension, Route Match Extension and Toll Cost Extension. Summary of enhancements: Avoid countries feature in the Routing API Arrival time option in Custom Route Extension API New content Road Roughness in Platform Data Extension now commercially available HERE Mobile SDK User Interface (UI) kit update. Detailed information of these major improvements: Geocoder API Version 6.2.149 GB full postal codes are now being extended to Northern Ireland. Routing API Version 7.2.87 New Exclude Countries feature which enables computation of routes avoiding indicated countries. Traffic API Version 6.0.69.0 Improved performance of Tiles responses Improvements in Split Lane traffic generation. Geovisualization API Version 2.6.2 New Functions for the RawDataProvider of the JavaScript API. Custom Route Extension API Version 2.1.8 Added arrival time to allow for the user to find out when to start to arrive at a certain point Added stopOver option for waypoints to specify the wait or loading time at each waypoint Added an option to submit overlays by means of a POST request. Platform Data Extension API Version 1.6.17 Road Roughness layer that provides the average roughness category applied to a road segment now commercially available Truck Speed Limit layer now also contains street level limits (previously purely admin wide ones) Road geometry layers have new columns overpass and underpass. HERE Mobile SDK User Interface (UI) kit Version 1.1.0 Added support for the upcoming HERE Mobile SDK version 3.6 Added extended example applications with source code for: Android in Kotlin iOS in Swift iOS in Objective-C Added translations for 14 languages Change: Due to API changes in the upcoming Mobile SDK, the minimum SDK version increased to 3.5. Supported SDK versions are now 3.5 and 3.6. The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.149) Geofencing Extension API (Version 2.1.8) Route Match Extension API (Version 2.1.21) Toll Cost Extension API (Version 2.4.16)", "date": "2017-12-08"},
{"website": "Here", "title": "Spotlight on Computer Vision and Machine Learning: Steve O'Hara", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/spotlight-on-computer-vision-and-machine-learning-steve-ohara", "abstract": "Introducing Steve O’Hara, a Principal Research Engineer leading the Sensing and Perception team in the Highly Automated Driving division at HERE, based in Boulder, Colorado. Steve, what are you and your team working on? The Sensing and Perception team tries to provide useful and comprehensive information extracted from video and other data sources—like GPS, inertial measurement units (IMUs), and odometry—that’s collected by cameras and sensors mounted in or on top of vehicles. Our focus is on developing techniques suitable for edge processing to enable real-time road scene understanding. The idea is that consumer-owned devices can help us generate and maintain HERE’s HD Live Map , which is part of HERE’s crowd-sourced mapping initiative. In this context, a consumer-owned device might be a dash camera, a smart phone, or the sensing systems built into future automobiles. We’ve been pushing the limits of running deep [neural] net[work]s in constrained/embedded hardware. What’s an example of a road-scene comprehension problem you’re trying to solve? Determining if a sign that we have in our HD Live Map was not seen because it’s no longer there or because the view was blocked by a truck. To figure this out, we develop semantic segmentation models using deep learning. Semantic segmentation is the process of assigning every pixel in an image with a semantically meaningful class label. For example, we might classify each pixel as road, vehicle, sky, terrain, building, lane, sign, etc. This is an important input to understanding the observed road scene so that we can not only detect features useful for mapping, but also the context of the observation. Segmentation results from a HERE SpotCam image The classification process you describe reminds me of a toddler learning language, pointing at things and saying aloud “sky, grass, dog.” I’m looking forward to congratulating my parent friends on their child’s semantic segmentation next time I witness this! Speaking of language, Sensing and Perception is an interesting team name. It sounds more like something from a Meyers & Briggs test than a corporate org chart. Could you talk a little bit about this confluence of language between psychology and technology? During the first few years of my PhD studies, we were focused on biomimetic vision. We studied the literature from cognitive psychology on how the mammalian visual pathway works (to the best of our knowledge) and we sought to mimic the functional decomposition of biological vision for computer vision systems. As long as the field of AI has existed, there have been cross-over efforts with cognitive psychology. How we learn, how we perceive, how we compress/store experiences, how we move about the environment and build mental maps, and so forth. Deep learning is based on the work of Artificial Neural Networks (ANNs), which started as abstract models of how a collection of neurons can be connected layer-wise as a general-purpose learning mechanism. What have been the biggest successes? On the deep learning side of things, one of our big breakthroughs was being able to show 14-class (e.g., sky, terrain, car, road, sign, bridge, pedestrians, etc.) segmentation running at 30 frames per second on a development board that was drawing less than eight watts of power. This came about from thinking critically about the design of popular deep net architectures and what aspects of those designs were unnecessary to achieve sufficient quality within the computational budget of the device. Hats-off to Brad Keserich on our team for this achievement, but also to all our team members that were involved in many discussions relating to this topic. This sounds like a good example of what you meant earlier when you said “We’ve been pushing the limits of running deep [neural] net[work]s in constrained/embedded hardware.” Could you talk a bit more about these constraints? Deep neural networks in the conventional wisdom require an enormous amount of compute, so if you want to use them in the cloud, that’s great. You can spin up as many cloud computers as you want. You want to do it in the car without a trunk full of computers, a second battery, and a customer alternator? Then what do you do? You create highly optimized, efficient, small deep-neural networks that give you the performance you need. Beyond hardware constraints, what have been the biggest challenges? One of the biggest challenges is generating training data for this task. It takes about an hour per image for a human to generate full scene segmentation labels. We have a training set of about 20,000 images. Considering there are roughly 2,000 working hours in a year, this data set reflects about 10 person-years of effort to generate! There is tremendous value in lowering the cost or effort required to generate high quality training and evaluation data. What do you know now that you wish you knew when you started working on this problem? I have no regrets. We learn new things every day. We all have those head-slapping moments where we realize something that in hindsight maybe should have been obvious all along. But that’s the nature of fast-paced innovative work. What do you see as the next big thing in machine learning? Returning to the topic of training data, I think we need a big breakthrough in unsupervised/self-supervised learning before we achieve the next level of machine learning. Unlocking the information contained in our massive archive of images without having to label them all will be a key to significant advancement. Any big misconceptions about machine learning out there that you’d like to clear up? As with all trending technology, hype can lead to unrealistic expectations. It is true that deep learning, combined with massive data sets, has enabled major advances in computer vision, robotics, and related fields. But there is still significant expertise involved in fielding a robust and comprehensive product based on deep learning models, and the business processes required to support, maintain, and improve data-driven products is something that many companies struggle with. Tell me about your side projects. I have a smart home system and a set of outdoor security cameras that monitor the perimeter of my property. I play around with trying to make the cameras smarter and to reduce false positive alerts. My interest here dates to when I worked for a small business defense contractor developing AI support systems for force protection applications (i.e., monitoring the perimeter of bases to detect threats). This led me to computer vision for the first time when I was tasked with developing an algorithm to detect fast-moving small boats from the video streams of unmanned aerial vehicles (UAVs). It was then that I decided computer vision was my career passion, and, in my mid-thirties, enrolled in the computer science (computer vision/machine learning) Ph.D. program at Colorado State University. I also maintain an open source python library called PyVision3 . It’s mostly a set of convenience functions for helping prototype and evaluate computer vision algorithms like annotating images and displaying results in a montage. I find it saves me from having to write a bunch of boilerplate code for every project I work on. For fun, I practice and teach a Japanese martial art called Aikido, which I’ve been involved in for about 20 years. Has Aikido influenced your work? It helps in trying to stay calm when you’re facing frustration. Research and development is mostly failure, so you have to persevere, you have to keep trying different things, and come up with new hypotheses. But most of your hypotheses are probably wrong, and most things you’re going to try to make that next breakthrough are going to fail. So being able to keep your cool is beneficial to the machine learning practitioner. Other than Aikido, what resources would you recommend for someone just starting out with machine learning? I took graduate courses in machine learning, but there are many online courses that may be helpful, such as those from Coursera , Udacity , or other providers. There is no substitute, however, for putting in the time to learn theory/math and then to put it into practice. There are some classic texts, such as Christopher Bishop’s Pattern Recognition and Machine Learning and Michael Kirby’s Geometric Data Analysis: An Empirical Approach . I like these two because they come from different points of view of the broad topic of machine learning. Bishop uses Bayesian formulations to derive and motivate classic algorithms, while Kirby applies linear algebra and geometry to uncover patterns in large data sets. Both predate the rise of deep learning, but there are numerous deep learning tutorials and mature frameworks to help a newcomer get started. How do you stay on top of developments in machine learning? The top conferences in computer vision and machine learning are great to follow, especially CVPR and NIPS . Even if you can’t afford the time or money to attend, you can access the papers published at these conferences and learn a lot. For earliest access to new developments in the field, I monitor arXiv’s computer vision ( cs.CV ), A.I. ( cs.AI ), and machine learning ( cs.LG , cs.NE ) posts. Learn more about Steve and connect with him here .", "date": "2017-12-12"},
{"website": "Here", "title": "January 2018 Release notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/january-2018-release-notification", "abstract": "This month we have updates to a number of services, as well as the launch of HERE Tracking, Intermodal Routing, and the new Electronic Horizon feature for the HERE Mobile SDK. Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Traffic API, Geovisualization, Intermodal Routing API, HERE Tracking and Mobile SDKs for Android and iOS. Summary of updates: Electronic Horizon feature in HERE Mobile SDK Release for Android and iOS Launch of Intermodal Routing API Launch of HERE Tracking Detailed information on these major improvements of the HERE Platform for Business services: Geovisualization API Version 2.7.0 New ingestion process for larger and complex data sources New provider for venue information for the JavaScript API Intermodal Routing API Version 1.1.0 Park and Ride: An Initial release of the Intermodal Routing API for Intermodal Park and Ride. For more information, see the Intermodal Park and Ride Developer's Guide HERE Intermodal Park and Ride is a REST API that allows you to plan a trip using different modes of transportation in the same journey to deliver optimized routes that include driving via car, parking at a dedicated parking lot, and continuing to your final destination via public transit. Ultimately, Intermodal Park and Ride assists vehicle drivers to use Park and Ride services to reduce congestion in Urban Areas and lower emissions; resulting in an environmentally friendly solution. HERE Tracking Version 1.0 HERE Tracking is a horizontal PaaS cloud product designed to address location tracking problems for a wide range of Location IoT industry verticals. HERE Tracking exposes a set of REST APIs and client libraries to enable location tracking and geo-fencing for a variety of device form-factors including small-footprint (small memory and processing power) devices. HERE Tracking also includes end-user applications on mobile and web to be used as reference apps to demonstrate the product capabilities. Generate credentials to connect devices to HERE Tracking using TLS 1.2 and SHA256 Seamless indoor/outdoor positioning of low-profile devices using WiFi, Bluetooth and GPS Create and manage geofences and generate notifications when a device transitions into or out of a geofence Access a historical record of device locations and configuration through time HERE Android SDK Starter Edition version 3.6: We added support for Discovery search requests using a center location and radius. We added the ability to filter Places autosuggest results by type, such as by address or category. We introduced GeocodeResult to keep aligned with iOS SDK. Premium Edition version 3.6: We added the Electronic Horizon feature, which provides a view on the road network ahead of the vehicle and predicts the most probable path and other possible side paths. For these paths it provides content such as Traffic signs, Curvature geometry, Height and slope data and Lane information that can be used for developing driver assistance features. We added support for the Android emulator. For more information, see \"Android Emulator Support\" in the Developer's Guide. We added the ability to change route colors and traveled navigational route colors using the MapRoute class. We added new class GeocodeResult to return more details on the geocoding result including match level and match quality. You can now choose to avoid difficult turns in a truck routing request. We added support for walk guidance along an indoor route or a combined indoor and outdoor route. Note: HERE Indoor Radio Mapper tool is no longer included in the SDK package. It is available for download via Google Play. HERE iOS SDK Starter Edition version 3.6: The HERE SDK now supports Swift 4.0. We added support for Discovery search requests using a center location and radius. Premium Edition version 3.6: We added the Electronic Horizon feature, which provides a view on the road network ahead of the vehicle and predicts the most probable path and other possible side paths. For these paths it provides content such as Traffic signs, Curvature geometry, Height and slope data and Lane information that can be used for developing driver assistance features. The HERE SDK now supports Swift 4.0. We added the ability to change route colors and traveled navigational route colors using the NMAMapRoute class. We added APIs to retrieve the time-to-arrival to the next stopover waypoint. You can now choose to avoid difficult turns in a truck routing request. We added support for walk guidance along an indoor route or a combined indoor and outdoor route. Note: HERE Indoor Radio Mapper tool is no longer included in the SDK package. It is available for download via App Store. The following services had new releases with minor changes: Geocoder API (Version 6.2.150) Geocoder Autocomplete API (Version 6.2.150) Traffic API Version (Version 6.0.70.3)", "date": "2018-01-06"},
{"website": "Here", "title": "Meet us at CES", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/meet-us-at-ces", "abstract": "Meet the HERE Technologies Developer Relations team at CES on January 9-12 in Las Vegas. Our booth location is HERE Booth LVCC, Central Plaza CP-2, and the DevRel team will be in the lounge on the ground floor. Join us to experience our vision of an autonomous future and the products that, combined with your innovation, will help shape it: Get an exclusive preview of the future of Reality Index™ a digital representation of reality to enable advanced services for the autonomous world See how the HERE Open Location Platform allows organizations and developers to create unique products and services Find out how real-time, rich sensor data helps HERE create next-generation automotive safety services Witness how HERE Tracking allows customers to follow goods every step of the supply chain – indoors and outdoors, offline and online Play with a voice-activated map built using HERE APIs with Alexa Plus hear further innovation announcements from HERE live at the show ! To schedule a meeting, please send us a request using this form . Or just come have a developer to developer talk. We would love to show you what we have and give you a sneak peek into what’s coming. See you at CES!", "date": "2017-12-11"},
{"website": "Here", "title": "Getting Started with AWS Serverless Applications from HERE", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/getting-started-with-aws-serverless-applications-repository-from-here", "abstract": "Recently at AWS re:INVENT, HERE announced the availability of ten applications through the newly launched AWS Serverless Application Repository. A serverless application makes it possible to manage an application feature as a configurable microservice. You can create and publish your own serverless applications for sharing, or deploy existing applications into your own environment. The applications featured in the repository from HERE align with many of our core APIs, such as geocoding, positioning, and routing. For an overview of the benefits serverless applications can bring to your overall solution, please take a few minutes to review the HERE segment of the AWS Serverless Application Repository breakout session from re:INVENT shown below. This post will guide you through the process of discovering, selecting, and deploying the HERE Geocode Serverless Application for use in your development projects. Currently, the AWS Serverless Application Repository is in preview mode and you must sign up to request access to it. In addition to obtaining access to the repository, you will also need the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com After signing up for a developer account at HERE, you will get access to APP ID & APP CODE values which are required to call HERE APIs. The AWS account is required to get access to all the developer resources at AWS, which includes the serverless repository (upon getting access to the preview). One of the advantages of using a serverless application architecture is encapsulating application behavior in the Cloud and simplifying client logic and configuration. For example, as just mentioned, to use HERE APIs you must provide APP ID & APP CODE values from the calling client code. If you have an application that supports web and mobile clients, this would mean you need to configure each client to use your secret APP ID & APP CODE values. By using a serverless application, the APP ID & APP CODE values can be securely managed in the Cloud, and each client simply calls the serverless app via a custom API gateway. If that doesn't seem so simple, keep following along to see the implementation details. Discovering AWS Serverless Applications It should be noted that the output of a deployed serverless application produces AWS development resources that we are already familiar with. The core of a serverless application is AWS Lambda . In many cases, access to the Lambda will be accomplished via the Amazon API Gateway service. This means you could write your own serverless architecture from scratch. You could create your own Lambda, write all the code to call the HERE Geocode API, configure the APP ID & APP CODE values as environment variables used in the Lambda, and create your own API Gateway and configure it to trigger Lambda. Or... You could simply get all of that packaged together by choosing a serverless application as a starting point instead. Because Lambdas play an essential role, this is where you will discover how to find existing serverless applications. In other words, to discover what serverless applications already exist, you start by creating an AWS Lambda. When you create a Lambda, you have three options for a starting point: Author from scratch, Blueprints, and now Serverless Application Repository. Note in the screen capture below, the Serverless Application Repository is selected, which is followed by a textbox search for \"Geocode\", which then produces the Geocode Serverless Application provided by HERE. Typing values other than \"Geocode\" will show serverless applications related to whatever value you provide. You can also search for providers, such as \"HERE Technologies.\" Configuring an AWS Serverless Application When creating a Lambda using a serverless application, you will likely get prompted for configuration information. In the case of all the serverless applications provided by HERE, the secret APP ID & APP CODE values are required up front as shown in following screen capture. Once the values are all provided, you are ready to deploy the serverless application into your environment. But before we move on to that, consider the value being provided. The APP ID & APP CODE values entered will automatically be configured for you as environment variables to the resulting Lambda. The code produced in the Lambda will already be written to use these values for making HERE restful API calls. This is a huge time saver for developers! Deploying an AWS Serverless Application After clicking the deploy button, AWS goes to work and produces all the resources required to make the serverless application complete. By the way, this step can take a little time. Once finished, you should have results similar to the screen capture shown below. The Geocode Servlerless Application provided by HERE supports two primary behaviors: geocoding and suggest. This results in the creation of two Lambda functions. In this post, we will focus on the core geocoding behavior. Now let's examine the default code provided in GeocodeFunction Lambda. Consider lines 4 and 5 of the preceding code. These lines are using the the secret APP ID & APP CODE values provided during configuration which are now stored as environment variables. How does this Lambda get triggered? By your newly created API already configured for you. At the AWS Console, search for API Gateway. You will notice you have new APIs. In the screen capture below, the Get method is selected for the /geocode API in Stage. In the resulting screen, the Invoke URL contains the specific URL your client code will need to call. Take note of the highlighted area below, as it will be different for you than shown here. That highlighted value will be needed in the next part of this post. Using an AWS Serverless Application For a simple demonstration of using the newly created serverless application, consider the following web client code: On line 9 of the client, replace the { Your API } section with the highlighted value discussed in the previous section. Also observe the end of line 9, where the value \"phoenix\" is hard-coded into the URL as the search value. In this very simple HTML page, the goal is to call your custom API with the search value of \"phoenix\", and log to the developer console the JSON response. So if you intend to follow along in this post, you will need to toggle your browser's developer tools to display the console. Upon running the page in your browser, you will likely see something not so friendly like the error shown here: The short explanation for this issue is that CORS is not enabled on the client calling the HERE API. But wait, before thinking a change needs to be done to the HTML, ask yourself, 'Who is the client of the HERE API?' It is not the HTML, it is the Lambda code. So in order to support a web client, you need to enable CORS in the Lambda. Can you do that? Of course, and that is what is discussed next. Modifying an AWS Serverless Application Once you have deployed a serverless application into your own development environment, it is totally in your control. That means you can modify any aspect to suit the needs of your requirements. In the scenario provided in this post, you will need to modify the Lambda code shown earlier to enable CORS. To do that, find the line of code (line 32 shown previously) in the Lambda code that looks like this: queryApi (url, ( body ) => { callback ( null , { body : body }); }); And replace it with the following to enable CORS: After making the change to the Lambda and saving it, rerunning the HTML page will now work without error. Remember, the only output of the demo is in the developer console. Summary In this post you learned about the AWS Serverless Application Repository. HERE is proud to be among the initial contributors to the repository, launching ten applications which map to core HERE APIs. You learned how to discover, deploy, consume, and modify the Geocode Serverless Application. The process shown in this post applies to the other applications provided by HERE in the AWS Serverless Application Repository. Happy coding!", "date": "2018-01-10"},
{"website": "Here", "title": "Navigate your way through the airport with HERE Venue Maps", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/navigate-your-way-through-the-airport-with-here-venue-maps", "abstract": "Ever get lost within the complexities of large venues like airports, stadiums, malls or convention centers? Luckily, HERE Venue Maps provides a one-stop solution for indoor mapping and indoor routing in over 14,400 venues across the globe. In this guide, I'll teach you how to get an indoor map of the Istanbul Atatürk Airport up and running in under 10 minutes. You'll need an active HERE Developer account, so if you don't have one already, head on over to the HERE Developer Portal and sign up for one--don't worry, it won't cost you anything! Setting up the HTML skeleton Create a file called venues.html and paste the above code. We've included not only the basic HERE JavaScript API imports, but also: mapsjs-service.js : in order to display Venue Maps here.js (local file): where we'll be writing our code I've also included some internal CSS to help us with the look and feel of the interactive map. Creating a basic HERE map Next, we'll need to set up a basic HERE JavaScript map. Create a new file called here.js (the same file we linked to in our venues.html). You'll want to make sure both venues.html and here.js are in the same directory. Paste the following code into the newly created file: platform initializes our blank map. Make sure to paste your own app_id and app_code credentials from the developer portal to make sure everything runs smoothly. Additionally, make sure useCIT is set to false --this makes sure all available venues are shown. I've centered the map directly on top of the Atatürk Airport with a nice zoom level so we can see all shops, restaurants and rooms within the airport, although they are not yet available with the code we've written so far. The variables behavior and ui are controls that provide additional functionality such as zooming, panning, etc. And now you should have a basic HERE map visible. Now onto the fun part... adding venues! Appending venues onto the map Let's initialize some objects: venueService : the venues service containing all the data regarding venues customVenueLayer : the custom layer we'll append to the map with venues venueProvider : the object of the particular venue we'll be dealing with After that, we'll add the custom venue layer to the map. Give your page a refresh and you'll be able to see an indoor map of the airport! I've also changed the current floor level to 2 to show the level with the most detail. Changing levels within the venue Now that we have our venue map up and running, let's add some additional functionality: changing levels. Wouldn't it helpful to visitors to see what else is available within the airport outside level 2? I've included a quick function to embed some HTML into our venues.html page. The function, renderControls() : creates a div container containing a title (current level indicator) and two control buttons (floor up, floor down) enables switching between floors using the setCurrentLevel() function updates the title to show the current level after a change to the view To find additional functions like setCurrentLevel() , be sure to give the API reference a visit. There you go! Give the controls a try and see how the floors change right in front of you. At this point, you'll basically know the inside of the Atatürk Airport like the back of your hand. See if you can find the Italian restaurant Sbarro :) But don't stop there! This tutorial walked you through how to complete the most basic step of the Venue Maps API functionality: displaying a map. The HERE Venue Maps service provides rich functionality such as: indoor routing : calculate routes inside and outside venues venue discovery : explore venues (+ what's inside) around the world display 3D venues (Android SDK) customize venue experience : change display, highlight certain venues Depending on what platform you're using, you can find Venue Maps API documentation, guides and examples that fit your exact needs: Venue Maps REST API Venue Maps JavaScript API Venue Maps iOS SDK Venue Maps Android SDK For those of you participating in the Turkish Airlines Travel Hackathon : happy hacking!", "date": "2017-12-22"},
{"website": "Here", "title": "Adding Alexa Voice Control to HERE Maps", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/adding-alexa", "abstract": "The Developer Relations team at HERE had a busy week at CES, with a positive outcome noted for developers. Among the many offerings we had to display, I was proud to have produced a demo showcasing voice control over our HERE Maps API using Amazon Alexa. As attendees approached, we would ask where they were from, and instruct Alexa via an Amazon Echo to show on the map their city or country. We also used voice commands to zoom in and out of the map. When developers approached, we often talked about the technology that made the demonstration possible. With the number of questions asked and interest shown, I promised to produce a technical blog to put it all in perspective. This post will 'speak' to the major components of the demo and how each connect to one another. To fully benefit from this post, you will need the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com An Alexa developer account at https://developer.amazon.com/alexa This post will assume you have a general understanding of the developer resources available from Amazon, and a degree of experience developing skills for Amazon Alexa. For more information, please visit Getting Started with the Alexa Skills Kit. Defining the Alexa Voice Interface Developers create skills to extend capabilities of Amazon Alexa. An important aspect of making a skill is defining the voice interface The interface consists of sample utterances, intents, and slot types. To put this quickly in perspective, consider the following sample utterances used in the context of the demo featured at CES and the focus of this post: \" Show me Phoenix, Arizona \" \" Go to Palermo, Sicily \" \" Display Las Vegas, Nevada \" In each utterance above, the verb highlighted in bold represents the intent of the user. The location highlighted with an underline is the slot of data we are acquiring from the user. In this demo, I defined ShowPlace and Zoom as intents, as shown in the interactive model designer. Users of the skill may have a variety of ways to ask how to 'show' a location on the map. Likewise, there may be a few ways to express zooming behavior. Fortunately, the voice interface supports synonyms to represent these variations as seen in the 'types' section of the interactive model schema: The types defined above can now be used in sample utterances as shown in the 'intents' section of the schema: To understand the above from a developer's perspective, consider lines 3-10 in the schema above. Essentially, we want to map this somewhere to somewhere in code to a function like showPlace(place,region) . While there is not a direct mapping, you will see how this is accomplished soon. Likewise, for lines 28-31, a functional code equivalent could be setZoom(behavior) , where behavior indicates 'in' or 'out'. Once the design of the skill is complete, it is time to code the skill. Coding the Alexa Skill Amazon allows custom skill code to reside where you prefer. In this example, I chose to host the code for the skill in an AWS Lambda. The lambda used in this post is connected to the following resources: The Alexa Skills Kit is used as a trigger to call this lambda. Amazon CloudWatch logs is a great resource for logging and troubleshooting. AWS IoT is used to provide the communication channel between the skill code and the client code it will interact with. Now look at the starting code of the lambda: Let's first draw attention to the postMQTT function declared at lines 11-24. This function will be used later in the lambda to post data retrieved from the voice interaction to any subscribing clients. In my demo, the subscribing client was a simple HTML page, which we will examine a little later. The function takes two parameters, 'place' and 'zoom'. Line 14 shows how these values are concatenated into a value for 'payload'. On line 13, notice the value of 'topic' is 'location-point'. This is a resource previously created in AWS IoT , and is associated with an endpoint required at the end of line 5. The value on line 5 of \" your endpoint \" will need to be replaced by an endpoint provided after creating a thing > in AWS IoT . In this post, the thing created is called 'location-point' (used in line 13 in code above) as shown here: Creating a thing is simple. All I did was give it a name, 'location-point'. Once it is created, you can determine your endpoint by navigating to the test section and selecting the 'View endpoint' option from the small dropdown arrow in the upper right part of the screen as shown here: Once you have your endpoint, replace \" your endpoint \" at the end of line 5 in the preceding code with that value. Now let's look at the function in the lambda that is invoked when the user's intent is to show a place on the map: Lines 3-5 collect the data from the user from the 'intent' parameter passed in by the Alexa service. Line 5 shows that the 'Region' value is optional, thus make it an empty string if it is not provided by user. After a series of validations, the postMQTT function is invoked with the place value. Let's also look at the function for managing zoom requests: The function above is very similar to the previous function. It obtains the values provided by the user, performs validations, and then invokes the postMQTT function on line 15. One interesting difference is noted on line 4 - the use of the slot ID. Previously in this post when examining the 'types' section of the interactive model schema, note the IDs provided for the two ZoomType values: PLUS and MINUS. This is handy when I want to know the behavior in code, not necessarily the word spoken by the user. For example, whether the user says \"Zoom in\", \"Zoom down\", or \"Zoom closer\", the value of the ID in each case is PLUS. This is what is passed to the subscribing MQTT client. Coding the Client As mentioned before, the client application of the demo is an HTML page. It is configured to use the HERE Maps API and is a subscriber to the AWS IoT thing called 'location-point' via MQTT protocol. Here is the relevant code used by the web page, with inline comments: Line 1 is for your benefit in reading the code as the variables were declared elsewhere but used above. Of significance to what we have seen so far is the function declared on lines 77-93. Notice the message parameter contains a payloadString property. This contains the values sent from the lambda associated with the Alexa skill. Most of the code is self describing, but let's examine two lines in particular. Line 34 is referring to an endpoint - the same endpoint value referenced earlier in the post. So you will need to replace that value with yours. Also, line 7 shows the value of \" your identity pool id \" that will also need to be replaced. This is obtained from Amazon Cognito, a resource available once you are logged into AWS with developer credentials. You can obtain the pool id as shown below: You can either get the identity pool id by selecting the 'Edit identity pool' link or take it from the Get AWS Credentials code sample on the screen. Summary In this post, we showed how it is possible to add voice control to allow a different way to interact with HERE Maps. We examined briefly how to construct the voice interface for an Alexa Skill, how to manage functionality in the associated lambda, and how to wire up the lambda and client to communicate via AWS IoT. Happy coding!", "date": "2018-01-19"},
{"website": "Here", "title": "Discover the Routing API with our new routing reference client", "author": ["Marek Krysiuk"], "link": "https://developer.here.com/blog/discover-routing-api-with-new-routing-reference-client", "abstract": "“A picture is worth a thousand words” and we believe that good visualization accelerates the process of understanding complex ideas. Even for REST services, a visual tool is a great way to discover and experiment with the API, which is why we created the Routing Reference Client web app . It also saves precious time digging through the routing documentation . The tool exposes a variety of modes, eg, Truck Routing , and has many options to customize to your use case, including allowing the selection of different vehicle profiles, displaying route elevation profiles, exposing matrix routing, drawing reachability isolines, customizing response content, and exposing tens of other options. It automatically generates a URL-encoded request which can be executed within the tool. The response can then be visualized on the map together with route meta-information: You can also export the request URL and run it directly from your app or service. We also expose some beta features like EV routing and consumption model parameterization, with many more coming soon. Discover our Routing API service using the Reference Client at https://refclient.ext.here.com . Just remember to add your API credentials in the settings section: … and if you don’t have them, just register for a free 90-day trial and you're ready to route!", "date": "2018-01-29"},
{"website": "Here", "title": "February 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/february-2018-release-notification", "abstract": "This month's updates to the HERE Platform include support for Republic of Ireland postal codes, known as Eircodes. Updates are related to the following services: Maps API for JavaScript, Geocoder API, Geocoder Autocomplete API, Positioning API, Traffic API, Places API, Venue Maps API, Custom Location Extension and Custom Route Extension Summary of updates: Geocoder now supports postal codes for the Republic of Ireland, known as Eircodes Places API now supports search queries of the form: [Chain]/[Category] \"near\" [Intersection] or [POI] New feature in Custom Route Extension to block existing private roads within the area of newly submitted roads Detailed information on these major improvements of the HERE Platform for Business services: Maps API for JavaScript Version 3.0.17.0 The noWrap option in the map allows to disable wrapping of the world on the longitudal axis. Geocoder API Version 2.7.0 The service now supports postal codes for the Republic of Ireland, known as Eircodes. Positioning API Version 1.5.0 We added a new optional client element in the locate request body. The information about the client hardware and software can be used to further improve the positioning service quality. Traffic API Version 6.0.71.1 Updated TDA service with new Taiwan market ID F1D13. Performance improvement. Places API Version 2.57.0 Search now supports queries of the form: [Chain]/[Category] \"near\" [Intersection]. For example: \"Mcdonalds near Cucumber and Vine\" Search now supports queries of the form: [Chain]/[Category] \"near\" [POI]. For example: \"parking near New England Aquarium\" Venue Maps API Version 1.2.1 Content types Image tiles and POI Models have been deprecated and will be removed at a future date. Custom Route Extension Version 2.1.23 New feature to block existing private roads within the area of newly submitted roads. Required when refining/replacing existing map geometry, e.g. in facility maps, to suppress less fine grained existing roads. See &private_link_handling=PLAIN/UNCONNECTED/DROPEXISTING. New parameter to require a certain match quality. Required when adding to existing map geometry, e.g. in facility maps, to avoid snapping to nearby existing roads. See &max_distance_to_match, &min_match_confidence (does an attribute override accept a poorly matching road geometry or not) and &max_distance_to_connect (does a new road connect to a nearby link or stay as dead end). HERE Mobile SDK User Interface (UI) kit Version 1.2.0 Better landscape orientation support Improved traffic data handling WaypointItemDelegate protocol is deprecated in the iOS and will be removed with the next release The packages are available for download for: Android iOS The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.151) Custom Location Extension (Version 2.1.23)", "date": "2018-02-12"},
{"website": "Here", "title": "Electronic Horizon capabilities extended to mobile devices", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/electronic-horizon-capabilities-extended-to-mobile-devices", "abstract": "We’re all aware of how anticipatory data is contributing today to ADAS and Autonomous Driving applications, but this data is becoming increasingly useful to a variety of mobile applications as well. For this reason, we’ve extended these capabilities beyond the ADAS onboard unit, and onto mobile devices. With the HERE Mobile SDK, you can now access Electronic Horizon capabilities and utilize them the way it makes most sense to your application. What does this mean? Electronic Horizon gives you access to a variety of ADAS compliant road geometry and relevant map data. Information on form of ways, roundabouts, carriageways, as well as interchange and service roads can now be utilized by your application to prepare users and drivers of upcoming road conditions. Speed limits, stop signs, crossroads, blackspots and traffic light information can also be provided for a more realistic view of the journey ahead. This can be possible, with or without a data connection, while in the navigation mode as well as in tracking mode, when the user is not following turn-by-turn directions to a destination. How can it be useful to my application? Using the ingested map topography, the vehicle positon and other related road attributes, the Mobile SDKs can calculate the vehicle’s most probable, as well as alternative paths, and provide it to the mobile device. Then it scopes out the topography and curvature of the road ahead and other linked roads, as well as other map attributes. This is done for over several kilometers ahead, in order to efficiently warn a user or driver regardless of the path selected. For example, you can notify a user if a stop sign is located within 800 meters which the driver needs to carefully approach, or if a dangerous curve is nearby and the driver needs to slow down and carefully engage in a sharp turn. Other type of anticipator data can also be provided, like if a road is open for cars or pedestrians only, as well as the direction of traffic and if traffic is possible both ways. When a road goes through a tunnel, it can intelligently alert a driver to assure proper precautions are taken when passing through. What devices are supported? An easy to use native API is available for development on both Android and iOS devices. This service gives access to a variety of ADAS data that can be easily embedded into any mobile application. Where can I get it? Electronic Horizon is included in the Premium SDK for Android and the Premium SDK for iOS. You can test out the features through our 90 Day Free Trial , or contact us for a commercial premium SDK.", "date": "2018-02-08"},
{"website": "Here", "title": "Introducing GitHub and JSFiddle Support for JavaScript API Examples", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/introducing-github-and-jsfiddle-support-for-javascript-api-examples", "abstract": "Our documentation for the JavaScript API includes many examples of self-contained common use cases. To enhance the developer experience, we display the supportive code with each example, as shown below. While this is helpful for when a glance at the code is all that is needed, what about experimenting with the code itself? Sure, you can copy-and-paste from the screen, but there is a more elegant approach. We are happy to announce GitHub and JSFiddle support and integration for all the JavaScript API examples provided in our documentation. This allows sharing the entire example quickly into a development environment of your choice with a click of a button. This post will briefly demonstrate how to use each new feature. Although previewing the code does not require a developer account at HERE, GitHub, or JSFiddle, it is strongly recommended to set up accounts at each - especially if you intend to edit and preserve your own code changes. HERE developer account: http://developer.here.com GitHub account: http://github.com JSFiddle account: https://jsfiddle.net Edit in JSFiddle As the name implies, JSFiddle is on online resource that allows developers to quickly fiddle around with JavaScript and related web stack technologies. If you click on the \"Edit in JSFiddle\" button, a new browser tab/instance opens with all the example code. In the screen capture below, the \"Map at a specific location\" example is instantly loaded and ready to edit and execute. Fork on GitHub You can also choose to fork the example from the HERE GitHub repository. When clicking on the \"Fork on GitHub\" button, a new browser tab/instance opens revealing the self-contained example in folder structure as seen here. Once you are at any of the examples in GitHub, you are one link away from viewing all the JavaScript API examples in the repository. Summary We hope you enjoy these new features and welcome your feedback. Happy coding!", "date": "2018-02-26"},
{"website": "Here", "title": "HERE launches Intermodal Routing API", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/here-launches-intermodal-routing-api", "abstract": "In our efforts to solve some of the most challenging commuting problems that users face today, we're proud to announce the launch of HERE's intermodal routing service. Intermodal routing is a new service that allows developers to provide routes combining three different routing modes for car, pedestrian and public transit; as well as access to parking information within the proximity of transit stops. While our current Transit and Routing APIs enable you to route a user from point A to point B either by car, public transit or by foot, the Intermodal routing service leverages these features to provide you with routes that intelligently combine all three modes with no additional development required. So, when do you choose which service? If you want to provide separate transportation options to your users, such as routes considering only public transit or only drive or walk, you can easily do so with the Transit and Routing APIs. But if you want to provide alternative options with interconnected transportation modes, that include a combination of walk, park, drive and public transit, then the Intermodal Routing API is a more straightforward approach. Why did we build this service? We recognize that majority of daily commuters, who travel every day to or within a city, usually prefer to drive a little, park where there's access to a good transit choice and ride the public transit to their final destination. Our intermodal routing does just that - it gives users intermodal alternatives in case traffic builds up, or simply if they want to avoid driving within a city. What is provided with this service? Developers can use this service to build applications that support various pre-trip and dynamic/on-the-go scenarios. For pre-trip scenarios, users can decide, ahead of time, if they want to use a combination of walk, drive and ride the public transit to a destination. While on-the-go, users can use intermodal routing to find alternative commuting options right on the spot. To provide for a comprehensive algorithm, our intermodal routing service takes into account a variety of HERE Location capabilities which makes it a very useful service: Vehicle routing Public transit routing with real-time and timetable departures Pedestrian routing with pedestrian connectivity Real-time traffic and traffic incidents Public transit service delays/disruptions information from transit authorities Amenities available at transit stations or nearby (eg. off-street parking, EV charging) For those of you building applications meant to solve some of the more difficult commuting challenges such as avoiding unexpected traffic, reducing driving hours or meeting important arrival times; the service enables a full set of location capabilities for: drive, park early, ride and walk to final destination drive, park late, ride and walk to final destination drive, park while on-the-go, ride and walk to final destination. And to ensure that your users get the most optimal routes and accurate ETAs to a destination, the service considers the time needed to walk from a parking lot to a transit stop, to transfer from one transit line to another or to walk from a transit line to the final destination. It's truly an excited service to try! We hope you enjoy it as much as we do! Check out the documentation we have available.", "date": "2018-01-22"},
{"website": "Here", "title": "March 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/march-2018-release-notification", "abstract": "This month's highlights include filtering on postal codes for countries in the Geocoder Autocomplete API and an avoid U-turns features in the Routing API. Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Map Tile API, Custom Location Extension, Custom Route Extension, Geofencing Extension, Fleet Connectivity Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension, Waypoint Sequence Extension and Map Data. Summary of updates: Geocoder Autocomplete API now allows filtering on postal codes for countries New International Map Data release deployed for hybrid clients for Mobile SDK ( Android SDK , iOS SDK) Avoid U-turns feature introduced in Routing API. Detailed information on these improvements of the HERE Location Suite services: Geocoder API Version 6.2.153 The service has increased coverage for Eircodes for the Republic of Ireland Improvements have been made for some US address queries . Geocoder Autocomplete API Version 6.2.153 Changes have been made for GBR to return the full postal code in Autocomplete A new parameter has been introduced to allow filtering on postal codes for countries. This filter requires that the \"&country\" is provided with a 3-letter ISO code and that a new parameter \"&resultType\" is also provided. Map Data for Mobile SDK Version 8.30.79.155 (Q1 2018, (January 2018)) Cambodia intermediate coverage is exposed to all platform customers. Previously it was on purpose downgraded to entry map coverage on compilation phase due to legal considerations. Increased bundle size from 128Kb to 256Kb to overcome map index (MAP.IDX) size growth beyond limits that are supported by existing clients Enabled Cyprus country label display in all political views except Turkey view Improved border representation between Chile and Argentina to be compliant with government requirements Improvements to address offline search and voice search issues with Abington and Mahwah townships (USA) POI categories configuration improvements for Speech Recognition artifacts (added \"charging station(s)\" as alternative name for EV Charging Station POIs) Updated land parcels data for Australia and New Zealand with November 2017 data Updated 2D Generalized Signs to 2D Signs SR2 171G (Q4/17) product Improved Public Transit compilation in order not to exclude some travel arcs due to day-by-day schedule of transit lines Fixed issue with Cancún (Mexico) not being displayed Fixed issue with Norfolk Island (NFK) not available in offline search results Compiler improvements to decrease amount of unused legacy code. Public Transit Improvements: New coverage for United Kingdom, Switzerland and Iceland New data for Nürnberg (Germany) and Vienna (Austria). Package Improvements: The following packages for on device map loading (ODML) were updated Cambodia added as download package under Asia Thailand split into sub-regions: Central Thailand, Northern Thailand, Northeast Thailand and Southern Thailand Vietnam split into sub-regions: Northern Vietnam, Central Vietnam and Southern Vietnam Philippines split into sub-regions: Luzon‚ Visayas and Mindanao Malaysia split into sub-regions: Peninsular Malaysia and East Malaysia. The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.151) Custom Location Extension (Version 2.5.2) Custom Route Extension (Version 2.5.2) Geofencing Extension (Version 2.5.2) Fleet Connectivity Extension (Version 1.3.10) Platform Data Extension (Version 1.6.19) Route Match Extension (Version 2.5.2) Toll Cost Extension (Version 2.5.2) Waypoint Sequence Extension (Version 3.0.9)", "date": "2018-03-14"},
{"website": "Here", "title": "Powering Virgin Hyperloop One", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/powering-virgin-hyperloop-one", "abstract": "Virgin Hyperloop One is building the next generation of mobility and partnered with HERE to create an app capable of delivering a seamless multimodal experience on the high-speed system. Showcased at CES earlier this year, the real-time journey planning app loaded mock hyperloop timetable data for a Vegas-Los Angeles route on devices and used the routing engine in HERE's Premium SDK for Android to calculate and display the route. The app allows user to navi gate to their final destination via ride-share, public transit in more than 1,300 cities, or through venues with our 3D indoor and venue maps. Check out the app below, and to get started using HERE's Premium SDK for iOS or Android and bring your own navigation solution to life, sign up for a free trial .", "date": "2018-03-01"},
{"website": "Here", "title": "Developer Week in the Bay is going to be a blast! Are you going?", "author": ["Brietta Easterlin"], "link": "https://developer.here.com/blog/developer-week-in-the-bay-is-going-to-be-a-blast-are-you-going", "abstract": "Developer Week is about to kick off with workshops, a hackathon, and an expo with a whole slew of seminars and talks sprinkled in. The HERE team and I are really excited to be part of it! The event starts on Saturday, Feb 3rd with a hackathon and on Monday the expo and workshops begin. We are sponsoring a lounge area with places to sit, relax, charge your device, and enjoy some refreshments. It is going to be party, so I hope you can swing by! We're also focusing on giving back to the communities in which we work and play. So for this event, in lieu of spending funds on swag, we decided to donate to the Berkeley Food and Housing Project , a local group helping people affected by homelessness in the Bay Area. Michael from our developer evangelism team will be on hand to lead an interactive workshop on Tuesday , which will cover using the AWS Serverless Application Repository (aka AWS SAR) and HERE location services for streamlined application building. A serverless application allows you to manage an app feature as a configurable microservice. (Read more about using AWS SAR with HERE in this blog post or on our GitHub repo .) If you are planning on joining this session, remember to have ready: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com For those who are new to AWS SAR, listen up because it's really handy. You normally would have to create your lambda, triggered by URL API endpoints you defined, and manage the configuration and permissions all on your own. We took the heavy lifting out so you can build and deploy your app with a fraction of the time and effort. Here are the services we've integrated into AWS SAR for you: Map Images Map Tiles Geocoder Transit Positioning Toll Cost Extension Traffic Places So, if you want to learn how to build faster with less hassle and are coming to Developer Week in Oakland, join us on Tuesday at 2PM for a 50-minute workshop where we will help you put together all the pieces. If you're coming to the expo, please stop by to say hi. We would love to hear what you've been up to and what you're building!", "date": "2018-02-02"},
{"website": "Here", "title": "Arity taps into HERE Location Services to help companies manage road risk", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/arity-taps-into-here-location-services-to-help-companies-manage-road-risk", "abstract": "Arity, the technology company founded by The Allstate Corporation to make mobility safer, smarter, and more useful, uses HERE Location Services to help drivers avoid accidents before they happen. Combining their wealth of historic accident-related data with HERE Location Services, Arity has built three offerings to help predict and prevent accidents. Risk Data Stream provides a real-time risk assessment of the road networks, including where there is a high probability of accidents happening. Drive Shield Routing provides the lowest-risk route for navigation systems. Finally, Drive Shield Alerts informs drivers with real-time information with dangerous locations and areas. Four HERE APIs were used to build these solutions. The foundation layer includes HERE’s Geocoder , which converts street addresses to geo-coordinates and vice-versa, and Traffic service, which provides traffic incident and flow data. Two HERE Telematics services provided additional intelligence: Route Matching , which matches GPS traces to the HERE road network, and Platform Data , which provides additional map attributes and data layers for more advanced navigation content. Harnessing the power of HERE, Arity is helping logistics, Automotive OEMs and ride-share companies reduce the risks for their cars on the roads. To get started building your own driver safety solution using HERE Location Services, sign up for free .", "date": "2018-03-16"},
{"website": "Here", "title": "Introducing HERE Tracking", "author": ["Alex Osaki"], "link": "https://developer.here.com/blog/introducing-here-tracking", "abstract": "Have you ever wondered where your car, the power tool you think your cousin may have borrowed or virtually anything that you own is right now? It can be nerve-racking to try to find these, especially when someone else may have borrowed and taken them. Now imagine this at scale… people have gotten so used to loss that it has a business term—shrinkage. But does it have to exist? We developed HERE Tracking because we wanted to create a tool that would make sense of the billions of moving objects around the world. By putting those movements into context, we can better understand the \"where\", the \"why\", the \"when\", and sometimes even the \"who\". We wanted to provide our developer community, partners, and customers the tools to create these solutions quickly—and have a platform where all the tedious parts of the development process have been taken care of. So, that's the cliché, but really: what are we providing you? This is probably a good time to dive into our developer documentation , but here's the high-level overview. We're providing the entire middle of the stack, and we’ve even included reference applications you can use to test the system or build on to create a customized solution. Let's take a closer look at the reference applications. Register an account on tracking.here.com to get started, and download the HERE Tracker app from the Google Play store to start out creating some test data. In the web app, use the Device Management screen to add a new device. HERE Tracking is designed to work with all kinds of IoT devices, but for simplicity’s sake, choose to add an Android tracker and create a new ID. Scan the QR code using the HERE Tracker app on your phone and specify the update interval you want. You’ll start getting data from the app pretty much immediately. To request data from the tracker yourself, you'll need an access token: With this token, you can now connect to the shadow endpoint to retrieve data about the device you’ve registered by including its ID in the URL: The response will look something like this: It should all be fairly self-explanatory. You get back a timestamp (from the Unix epoch, in milliseconds), the reported position, and the degree of accuracy. The \"payload\" is user-defined: for the reference application, we report information about the battery charge and the temperature, but you can include any data you want. This opens up opportunities for analytics, or for adding location to any telemetry already being reported by your IoT devices. We intend for HERE Tracking to be as flexible as possible, and a rich partner ecosystem allows you to quickly source connectivity, device, or even SoC/chipset solutions at scale. From that starting point, and the super-efficient HERE Positioning stack, you can connect, monitor, and analyze whatever you want. For example, here are some things we've done: Tracking 50 runners at the Berlin Marathon using only smartwatches Putting the cars in the Noordkaap rally on a map for spectators to follow A heatmap of the activity at our demo kiosk at CES 2018 Making sure the cake at our launch party got there on time What will you do with HERE Tracking? Come and check out the product at http://tracking.here.com/ and take advantage of our 90 day free trial !", "date": "2018-03-02"},
{"website": "Here", "title": "Mapping is more fun with friends", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/geomonday", "abstract": "Are you someone who struggles to get through Mondays? Are you passionate about mapping, GIS, cartography? Do you want to learn a way to end a regular ol’ Monday with a fun, social and educational party? Since this blog is a safe space and we're all friends here, let me share the secret with you: organize a meetup with a whole bunch of map nerds like yourself plus some of the top mapping companies in the world and geek-out on all-things-maps over pizza. Now that's the way I want to spend a Monday night! So, what did we do? We hosted the 17th GeoMonday meetup at our Berlin office on March 19th. We love mapping, as you might expect, but we weren’t sure how many mappers were in Berlin who would be into map talks and hanging over pizza on a Monday. 66 people showed up at our office in Mitte at 7:00 PM—right after what possibly had been a plain ol’ Monday for them — and we got right to business. Richard, our comically-cynical German evangelist, shared routing for the uninitiated and introduced the Intermodal Routing API , including why anyone should care. (Spoiler: you should care because if you're a commuter, chances are you like having flexibility on your mode of transport depending on the hour, weather, traffic or just your feelings.) He soon was off musing about flying taxis and Hyperloop and how these transport options will be built into routing in the future. Other large-scale mapping tech was also represented. Dr. Falk Hüffner from TomTom talked about On-Street Parking and pitched a model that uses historic data to predict parking probability on time of day and day of week for a given location. That solution tries to provide the best option available by minimizing the driving and walking time. And honestly, who has time to circle the block 5 times to find a spot? Truly a time-saver! It's the era of people who like to take pictures of, well, almost anything, but Thomas Mönkemeier’s talk really hit home for the amateur photographers in all of us. He presented various ways to collect street-level imagery, highlighting similarities and differences between OpenStreetCam and Mapillary . He also shared advice on how to be discreet while taking street pictures, a useful skill for those trying to collect data while avoiding creeping people out. Thomas's pro tip: use a selfie stick to look like a tourist and dodge the weird looks from passersby. We’d like to thank Prof. Dr. Roland Wagner, the initiator of this meetup and president of GeoIT , who helped with the logistics for the group. Now that we know how many folks in Berlin are into mapping, we'll double-down on pizza and beer for the next event. If you want to hear more from us and come to our next meetup, keep following the blog. Also, if you want us to host your big data, mapping, or general tech meetup, just shout at us on Twitter , and we can come to you —w e know you want to get your map on! See ya out there, and may your Mondays be full of geeking out over location services.", "date": "2018-04-03"},
{"website": "Here", "title": "Spotlight on Augmented Reality: Reinhard Köhn", "author": ["Jennifer Glen"], "link": "https://developer.here.com/blog/spotlight-on-augmented-reality-reinhard-kohn", "abstract": "Introducing Reinhard Köhn , Principal Architect on the CTO Team at HERE, based in Berlin, Germany. Tell me about yourself. I joined HERE five years ago. The challenge that attracted me was handling the enormous amounts of data this company processes. Technology and electronics already fascinated me as a kid. I started programming at age twelve in the eighties, with a Sinclair ZX Spectrum, one of these computers that still had a normal tape recorder connected to read and store data. I studied computer engineering at the TU Berlin. Later I worked at Siemens, where I participated in the standards for 3G mobile networks (I even wrote part of the standards documents) and led a team developing software and hardware for one of the first 3G base stations. After nearly ten years in the corporate world, I decided to try something completely different and joined a startup as a founder and CTO in Berlin to build a social virtual world and gaming product. I learned a lot about big data storage and processing because online games generate a huge number of events from the interaction of the user with the game. To store and process these efficiently at low cost was a challenging problem, and surprisingly close to the problems we solve at HERE when we receive and process billions of traffic and sensor events in our Open Location Platform . What do you do at HERE? Anything related to complex software systems needed in the company. In the past I’ve worked on architectures to publish and consume maps efficiently while they constantly change, and on some components for map data processing that are now part of the Open Location Platform. Since last year I've worked on topics around augmented reality. What’s an example of a problem you’re trying to solve with augmented reality ? In our work the term augmented reality has a very wide scope. Before computers can augment the reality around us, they first have to understand it. And that’s what we are looking at: teaching computers to understand where they are, how they move, what they see. Then we can tell them to change parts of this reality and show it to us as a ugmented reality. We’re trying to put an additional layer on top of today’s state - of - the - art AR , like ARKit and s imultaneous localization and mapping (SLAM) algorithms , in our core competencies of building maps. Can we run additional algorithms to recognize objects from the real-world —a clock over there, a TV set, a window— record these and build a map autonomously? Can we build a generic system with t oday’s algorithms that will then evolve fast with the al gorithms ? What’s SLAM? It’s basically what the iPhone does when it does an augmented-reality session. You move the iPhone and it keeps track of certain points around the room, and it simultaneously builds a map of where these points are and how the phone moves relative to them. The movement is measured internally with accelerometers, then it can see from the camera how the points moved in the camera image, and with these two inputs it can build a 3D model. Then it can track that—that’s the localization—and add new points—that’s the mapping. We’re still talking pretty conceptually here. Sounds a bit fuzzy huh? Let’s take a delivery use case. The delivery driver has a street address, they park, but now they have to find the door to ring the bell and hand over the package. That can be surprisingly complex, especially in urban and commercial areas. Assume you give those drivers a device that does this AR capturing while they deliver. So, the first time he has to ask. He will run around an area three times in a circle and at some point he will find the door. But we can track him all the time because there’s a camera, there’s the SLAM algorithms that build a map while he’s moving. We can detect key elements like signs on the entrance, the numbers, characteristic objects like fire extinguishers or logos of companies and put those in the map so that later, in case we lost tracking, we can find where we are by relocating those objects. So, you just give the device that will build the AR map to a delivery person for a few weeks, you generate the map out of that data, and next time a colleague has to visit the same place when he leaves the car, he already knows the map to the door, the direct way. Now we can start to use AR in real rendering in a user input device, maybe smart glasses, to guide the person from his car to the door. So, the real AR application is only in the last step where we guide someone. But we can only enable this application if you also automate all the map generation—and updating the map automatically when things change, because maybe a new wall’s been constructed, or the door moved. All of these things have to be tracked. If you go to this level of detailed map you have to automate everything. Right now we are building a proof of concept of the combination of several algorithms. [Starts a video on his laptop.] So, what we have is tools to visualize the data we get from different algorithms. This is a 3D point cloud of our office area recorded using an iPhone, so this is commodity technology. On the video images we do object detection—computer keyboards, plants, televisions—and now we map back the detected objects to the 3D scene because we know the geometry, we know where the camera has been looking, so we can now figure out the real 3D location of these objects. The proof of concept will go not just from the room as you’re seeing here, but from an outside location to an indoor one. What have been the biggest challenges? So far, the biggest challenge has been to narrow down how to approach the end-to-end view of augmented reality and break it down in smaller pieces. Fortunately, we could build on the long experience of our colleagues from the map rendering team for the visualization, which has been part of our mobile SDK for some years. But in other areas we had to start from scratch. What are the newest algorithms for recognizing the world in research? How can we leverage machine learning? We discussed these topics with our researchers, and with the teams already using machine learning technologies, like Steve O’Hara who presented his work in the last edition of Spotlight . What have been the biggest breakthroughs so far? Every month there is some new paper that is relevant to what we do and pushing forward the limits of the algorithms we use. By integrating these algorithms in a smart way, we can leverage the individual improvements in the entire system and get exponential improvements. We have three algorithms, all three get improved 20 percent and we get a total improvement of 50 percent or more end-to-end because it accumulates. What do you know now that you wish you knew when you started working on this problem? How hot this topic is! Of course, it’s fun and very interesting, but it’s also an emerging technology where recent breakthroughs in research, as well as the constant increase of compute power on mobile devices, will enable applications in the near future that nobody has been thinking about in the past. Do you see any other applications for what you’ve been doing with a ugmented reality inside or outside of HERE? If you put these technologies on a drone or a robot, you can use them to g et localization independent of GPS . There are now GPS jammers, technologies where you can disable GPS in an entire region . So, if you have any safety critical device like a drone and it only has GPS to figure out its position, it’s just not good enough for the future. What do you see as the next big thing in a ugmented reality ? Today the applications may be guiding humans, but with the advances in robotics the next thing will be to guide maybe a cleaning robot, or to build this map when a cleaning robot works inside a mall. Because you can recognize objects semantically—for example, fire extinguishers—then the cleaning robot can automatically scan and map the mall and we can capture all the locations of fire extinguishers. And if a fire extinguisher is missing it can be detected automatically from this augmented reality representation, which is computer readable, so you can implement safety measures to replace the missing ones. Y ou’re talking about using the cleaning robot to map the mall, but I was thinking of it the other way: that this technology would allow the robot to move aro und the mall and do it s job. It goes both ways. You have this iteration between building the map, giving guidance to the robot with a map, but then also getting feedback and updating the map from the robot. This is in principle very similar to what we see with autonomous cars. It’s just being applied where you have maybe less security and safety requirements because if the robot walks very slowly or is very light… It’s not going to kill someone like a car? [Interjection made before interviewer watched the Metalhead episode of Black Mirror ] Exactly. Also, the environment is maybe much more controlled: no rain, no snow. In many ways it’s much easier, but these environments can also be more varied. Any big misconceptions about augmented reality out there that you’d like to clear up? Augmented reality is more than Pokémon Go. Most people when they talk about augmented reality, they think about glasses or applications—like Facebook and putting ears on people. We’re not working on the application level, but rather what we call spatial-temporal augmented reality, to see how we can augment our maps and data sets with more generic 3D data. Are you working on any technology-related side projects? My newest side project is building a FPV (first-person view) racing drone . I just ordered all the components, so I have a few weekends of soldering and fixing electronics ahead of me. I’m looking forward to flying it in summer with my kids. What resources would you recommend for someone just starting out with a ugmented reality ? Maybe a Coursera course and a nice intro to object detection, a racoon detector . Learn more about Reinhard and connect with him here .", "date": "2018-04-10"},
{"website": "Here", "title": "Park and Ride Routing with the HERE Intermodal Routing API", "author": ["Lene Preuss"], "link": "https://developer.here.com/blog/park-and-ride-routing-with-the-here-intermodal-routing-api", "abstract": "As previously announced , HERE recently released the Intermodal Routing API. Intermodal routing is a novel capability that allows users to find routes across different modes of transportation, such as combining air and ground travel, rail and bike share, or public transit and taxi services. Current routing services can only route across a single mode of transport — for example, car routing, public transit routing or bike routing. Combining modes really opens new possibilities. Because Park and Ride is a common and oft-requested application for intermodal routing, we implemented it first. Park and Ride enables use cases ranging from calculating your personal best route to reach your office, to showing customers a map with comfortable Park and Ride solutions to reach your company headquarters in a congested city, to offering a fully flexible Park and Ride Routing solution. Please note that HERE is offering Park and Ride Routing only in specific locations — see the Coverage Information for currently supported cities. This list is growing as we collect the necessary data for more and more destinations, so check back soon if you don't see what you're looking for now. Without further ado, let's show you how to implement a map using the HERE Intermodal Routing API on your website. What you need To work with any HERE API, you need to get yourself a pair of credentials . They consist of an App ID and an App Code. You can get your own set of credentials by signing up for free on developer.here.com . After signing up you will see an option to generate an App ID and an App Code. If you have already signed up, you can access your credentials on your \"Projects\" page. For this API, licensing compliance means there's one extra hoop to jump through to activate access. Please fill out the form on the Contact Us page, noting your App ID and requesting that it's enabled for the Intermodal Routing API. We'll try to respond ASAP, but it can take up to three days to activate. In the meantime, we will quickly show you how to set up the HERE Maps JavaScript API. While this post does not go into details of how to use the HERE Maps JavaScript API itself, our 8-part in-depth tutorial does: Part 1: Basic Map Set-up Part 2: Geolocation Part 3: Basic Routing Part 4: Advanced Routing Part 5: Refactoring Part 6: Reacting to outside influences Part 7: Traffic Part 8: Wrapping Up In this tutorial we will create a JavaScript program that displays a map of Chicago and, from a starting point you choose, calculates a Park and Ride route to the HERE offices in Chicago. It should be easy for you to choose a different destination, or extend the script so you can select both origin and destination for your journey freely. Finally: some code! Now that you have your HERE API credentials, you can go ahead and create a JavaScript script to render a map. Of course, you must first create an HTML file to render your JavaScript: Here we have included the basic HERE JavaScript API imports and also created a div where our map will be displayed. Then we are including the file here.js , which we are writing next: Now you have set up a HERE map, centered at the HERE Chicago offices, which are located at 41.884238 degrees North, 87.638862 West. (See? You already learned something!) It should look approximately like this: Since it is out of scope of this tutorial to explain how to process and render a route (the HERE Maps Javascript API tutorial is covering that), I'll just give you some code which takes care of that. Let's just very quickly add in some code to select a point on the map to start our route from. Copy it and save it to the file tools.js , which, you may have noticed, we are already including in the HTML file above: Now that you have the basics in place, you are ready for the big moment: Firing off a request to the HERE Intermodal Routing API. The request will look like this: The request parameters are the app ID and app code you set up earlier, the parameter profile you use to specify you want a Park and Ride route, dep and arr to specify the coordinates of your start and end point, and a time for which you want the route to be calculated. If you look at the function Mobility.prototype.route above, you will see this request being assembled, along with the parameters graph and maneuvers , which are needed if you want to visualize the returned route - if you don't want to know the geometry and maneuvers for the route, you can omit them. And here is (an edited version of) what the response will look like. Actually, you'll get a much longer response, but we are limiting ourselves to the bits that are interesting for this tutorial. For a depiction of the full response, see the Park and Ride Routing Example from the documentation. The response gives us a JSON list of three Connection objects (of which only one is shown here), each of which contains a list of Sec objects (again, we are only showing the first one). The Sec objects represent parts of the journey between which the vehicle is switched. Most importantly for us here, they also contain the Graph object, which we use to visualize the route on the map. Let's use our utility class to make a request to the HERE Intermodal Routing API and visualize the response. To the end of the here.js file, add this code: And with just that you have requested and displayed a Park and Ride route on a map. Your result, depending on the start point you use, should look something like this: Now you can go forth and modify the code to suit your needs! Summary We have implemented a map doing Park and Ride Routing in about 180 lines of code, most of which is needed to visualize the route. But of course there is more to it. The Intermodal Routing API Documentation is there to help you. For more general questions on how to use the HERE Javascript API, refer to the HERE JavaScript API documentation or the eight-part tutorial linked above. If you run into a problem the documentation cannot solve, please ask questions on Stack Overflow . Finally, this tutorial is available as a Markdown file on GitHub here . Happy coding!", "date": "2018-03-20"},
{"website": "Here", "title": "April 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/april-2018-release-notification", "abstract": "This month’s updates include a new release of the HERE Mobile SDK, and extended support for common street abbreviations in the Geocoder API. Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Places API, Positioning API, Custom Location Extension, Custom Route Extension, Geofencing Extension, Platform Data Extension, Route Match Extension, Toll Cost Extension, Waypoint Sequence Extension, Mobile SDKs for Android and iOS and Mobile SDK User Interface (UI) kit. Summary of updates: Geocoder API extended common street abbreviations support in queries for another 4 countries Enhanced support of Ireland postal codes in Geocoder Autocomplete API and Places API New HERE Mobile SDK release HERE Mobile SDK User Interface (UI) kit update New HERE Platform Self-hosted Q1/2018 release Below, you can find detailed information on these major improvements of the HERE Location Suite services: Geocoder API Version 6.2.155 Improvements to support common street abbreviations in queries in the Baltic countries Estonia and Lithuania, as well as in the Czech Republic and Slovakia. Geocoder Autocomplete API Version 6.2.155 Changes have been made for Ireland to return postal codes in suggestions for addresses. Routing API Version 7.2.91 We introduced the Avoid Turns feature which enables computation of routes avoiding complex U-turns. We introduced Route ID feature in CalculateMatrix which enables reconstruction of routes summarized in matrix entries. We added support for a vehicle type in Traffic Restrictions to avoid car routes being affected by truck specific traffic events. We fixed an issue of pedestrian maneuvers being provided in the truck routing mode. Places API Version 2.60.0 Map Data updates (January 2018), including: HERE Core map data (administrative units, cities, roads, point addresses and extended postal codes) New feature: Enhanced support for Republic of Ireland postal codes Positioning API Version 1.5.0 We added a new optional client element in the locate request body. The information about the client hardware and software can be used to further improve the positioning service quality HERE Android SDK Starter Edition version 3.7: We added support for the arm64-v8a architecture . Premium Edition version 3.7: Street Level Imagery is now marked as a deprecated feature and is no longer available for evaluation. Customers using Street Level Imagery in deployed applications may continue to use the feature. Please contact your HERE representative for more details. We added support for the arm64-v8a architecture. Added Map Data Prefetching as a beta feature. This feature allows users to download map data by specifying a route or a bounding box, rather than by a region using the map loader, or by panning the map. Added the ability to customize route outline colors. Extended options to configure voice guidance prompts. We have changed the map display so that the HERE logo is not displayed when the logo size takes up more than 1/8 of the screen width or screen height. We deprecated extended Venue Zoom Level support as higher zoom levels are now supported in the map view when a venue is selected. HERE iOS SDK Starter Edition version 3.7: Added support for restricting the results returned by Autosuggest . By default, Autosuggest will return address, place, category, chain and query results. Using the \"result_type\" parameter, the client can request that only a subset of these are returned. Premium Edition version 3.7: Street Level Imagery is now marked as a deprecated feature and is no longer available for evaluation. Customers using Street Level Imagery in deployed applications may continue to use the feature. Please contact your HERE representative for more details. Added Map Data Prefetching as a beta feature. This feature allows users to download map data by specifying a route or a bounding box, rather than by a region using the map loader, or by panning the map. Added the ability to customize route outline colors. Added support for software rendering the map to bitmaps when running in the background. For more information, see NMAMapView softwareRenderToBitmap . Added the ability to manually request traffic updates using a set of geocoordinates and a radius. Extended options to configure voice guidance prompts. We changed the map display so that the HERE logo is not displayed when the logo size takes up more than 1/8 of the screen width or screen height. We deprecated extended Venue Zoom Level support as higher zoom levels are now supported in the map view when a venue is selected. HERE Mobile SDK User Interface (UI) kit Version 1.3.0 Accessibility support for iOS and Android (fully localized) More than 100 bugfixes and improvements Download the zip packages here: Android iOS The following services had new releases with minor changes: Custom Location Extension (Version 2.5.4) Custom Route Extension (Version 2.5.4) Geofencing Extension (Version 2.5.4) Fleet Connectivity Extension (Version 1.3.10) Platform Data Extension (Version 1.6.20) Route Match Extension (Version 2.5.4) Toll Cost Extension (Version 2.5.4) Waypoint Sequence Extension (Version 3.0.10)", "date": "2018-04-16"},
{"website": "Here", "title": "HERE helps Solvertech optimize customers‘ delivery routes", "author": ["Zuzana Dittes"], "link": "https://developer.here.com/blog/here-helps-solvertech-optimize-their-customers-delivery-routes", "abstract": "We interviewed one of our customers, Czech company Solvertech , to understand how HERE helps them optimize their customers' route plans, saving time and money. What does Solvertech do? We produce software and additional services that allow our customers to create optimized route plans. As an example, t he above image shows a visualization of the different delivery routes and the numbers indicate the order of the destinations where the truck will be off-loading. We take pride in the fact that we take into account even the smallest details, and that's the key for a realistic and thus useful plan. We serve companies that distribute almost anything ranging from milk to furniture to steel ingots. A growing trend these days is city logistics and continuous planning with same-day deliveries. Tell us more about the history of your company. We were founded in 2009 in the backwoods of Moravia, Czech Republic. We have grown from a one-man company to two founders and eight employees. Our sales model was simple: let us show you how we can save you money and improve your routes. If it works we get paid, if not we don’t. We started small but have grown to a company that has a broad and rich customer base and some very interesting names to brag about. We have many international clients as well; this is why HERE comes in  handy. What was the problem you were trying to solve when you started looking for location solutions? With our international customers becoming more prevalent, the ability to quickly get routing data for almost any country is super important. Also, we wanted to provide our existing customers with better geocoding services. In some cases, our clients are trying to geocode free-form typed addresses. We tried a few solutions and found HERE Technologies to be the best solution. We also liked HERE’s map tiles for the routes display—a nice cherry on top. Why did you decide to use HERE? What factors in location services were most important for you? We needed the geocoder first in order to improve our service. In the longer run, routing with vehicle restrictions is the main reason for our choice. Being able to set the exact vehicle parameters (eg, weight, height, dangerous chemicals) and get routes based on that is crucial for our customers. Which HERE services are you using? Listed in order of importance: routing distance matrix generation , geocoding , map tiles . How is HERE helping you achieve your technical and business goals? We can get great distance and times estimates quickly with many options. Deployment of our software to any country using HERE is now extremely easy. We no longer have to carefully get, prepare and test mapping data in the countries we need to operate. We can fully rely on HERE for this.", "date": "2018-05-24"},
{"website": "Here", "title": "May 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/may-2018-release-notification", "abstract": "This month we've added improvements in the Geocoder API for Lithuania and US Virgin Islands. Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Transit API, Places API, Platform Data Extension, Route Match Extension and Waypoint Sequence Extension. Summary of Updates: The release is mainly a maintenance release; highlights are: Improvements in Geocoder API for Lithuania and US Virgin Islands A new Areas mode &resultType=areas has been introduced in Geocoder Autocomplete API Transit Isoline endpoint has been added to Transit API The maximum number of PDE tiles per request has been raised from 15 to 64 tiles in Platform Data Extension API The maximum number of PDE layers to be returned in the response has been raised from 15 to 32 in Route Match Extension API Geocoder API Version 6.2.157 Improvements in Lithuania for the handling of house and apartment number pairs. Improvements in the US Virgin Islands for postal cities. Changes in Kosovo to return the Country name. Geocoder Autocomplete API Version 6.2.157 A new Areas mode &resultType=areas has been added to allow only administrative area results (district, city, county, state, country) to be retrieved. This will exclude results with matchLevels of houseNumber , postalCode , street and intersection . Routing API Version 7.2.92 We reduced the light truck maximum speed to 90 kmph to make it more consistent with a typical permitted truck speed on highways. The change does not affect US and UK where permitted truck speeds are greater than the light truck maximum speed. Transit API Version 3.3.0 Transit Isoline endpoint has been added. Places API Version 2.62.0 HERE Search Catalog (March 26, 2018) Map Data updates (March 2018), including HERE Core map data (administrative units, cities, roads, point addresses and extended postal codes) Search responses now expose the type of Search executed: default, chain, category-recommendations, category-distance The international view for Kosovo has been changed. Kosovo addresses may now contain Kosovo as the country name. Platform Data Extension API Version 1.6.21 The maximum number of PDE tiles per request has been raised from 15 to 64 tiles. Route Match Extension Version 2.5.4 The maximum number of PDE layers to be returned in the response has been raised from 15 to 32. Waypoint Sequence Extension Version 3.0.11 Requests can now also be sent as POST.", "date": "2018-05-15"},
{"website": "Here", "title": "Build your own Sightseeing app with Garmin Connect IQ and the HERE Location APIs", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/build-your-own-sightseeing-app-with-garmin-connect-iq-and-the-here-location-apis", "abstract": "A short while ago, I received a mysterious package in the mail from my friends at Garmin. Inside I found a shiny new fēnix 5 Multisport GPS Watch . I was thrilled, especially because I was just about to head off for a short 5-day hiking trip to Madeira . Perfect timing! In the end the trip was just OK, but the fēnix 5 turned out to be amazing. It’s got everything you want in an outdoor adventure watch (GPS! Epic battery life! Readable screen! Waterproof! Every possible activity! Every imaginable statistic!) and then some. Seriously, the device is so ridiculously capable that I’m still finding cool new features on a regular basis. The watch has now become my constant companion, even when navigating the urban trails of Berlin on my way to work. Rain or shine, the fēnix 5 is the perfect hiking companion. One of the reasons the trip turned out to be just OK was that some serious fog rolled into the mountains on the third day. It was so impenetrable that hiking was out of the question. My fiancée and I had to entertain ourselves otherwise and so we headed into town, looking for interesting things to see. As it turns out, Madeira is a solid destination for hiking, but not necessarily gifted with great museums - unless of course you enjoy pictures of Cristiano Ronaldo licking his collection of golden shoes . This hiccup got me thinking though. If the fēnix is a great hiking companion, maybe it could also be a great sightseeing companion? After all, it’s also smartwatch and I have access to the world’s greatest location technology platform. As I was pondering this existential question, I looked up and there he was - CR7 himself, in wax form, smiling down on me. I took this as a sign and immediately went to work on building a sightseeing app using the Connect IQ SDK and the HERE Location APIs . Well, not immediately. First the fog went away, and we enjoyed some more hiking. Also, when I returned to the office in Berlin there were 762 new emails waiting for me. But, I went to work immediately after marking those as read. CR7 approves. But not officially, because we don’t have that kind of sponsorship money. The app I ended up building works like this. First, it finds your current location using GPS. Then, it searches for nearby points of interest which are relevant to a touristically inclined person and displays them in a list. Said person can scroll through the list and select the entry they are most interested in. The app will then provide routing instructions toward the selected point of interest. The user can follow these instructions, walk to the sight and see it. Behold! Sightseeing. To get a better idea of what this looks like in action, let’s have a look at the flow of the user interface. User interface flow of our sightseeing app. Here are some pictures of the app in action in Berlin. I used it to walk to the East Side Gallery, a piece of the former Berlin Wall which has been turned into an art project. It’s also become one of the world’s most Instagrammed places and, consequently, a bit of a tourist trap. 2 out of 5, would not Instagram again. Using the app to get to the East Side Gallery. Before we can start coding, a brief note. I will be assuming that you are at least somewhat familiar with building Connect IQ applications. If you’ve never created a Connect IQ app before, you should head over to the Garmin Developer Portal, follow the Getting Started section and have a look at the rest of the Programmer’s Guide . (Seriously, do it! Monkey C is like the language you didn’t know you already knew. I’ve had a lot of fun making this app.) In this blog post we will mostly be discussing how to integrate the HERE Location APIs into your Connect IQ applications. When setting up your application, please make sure to give it permissions for communications (to allow our API requests to go through) and positioning (to enable access to the GPS model). Alright then, time to get going! To build our app, we need to make use of two location APIs, the HERE Places API and the HERE Routing API. Let’s take a closer look at them. The HERE Places API lets us search for and get information about points of interest (POIs), such as gas stations, restaurants, train stations, museums, etc. This is a powerful API with many capabilities, but the relevant features for our app are: searching for POIs around our location filtering these POIs by a category for relevant tourist sights providing information about the distance of these POIs from our location The HERE Routing API lets us find routes between two or more waypoints, using a variety of transport modes, such as car or public transit. Once again, this is a powerful API with many features, but for us the relevant ones are: finding a route between our location and a selected POI providing a walkable route using pedestrian mode (as a tourist we are likely on foot) providing human-readable text instructions to display on the watch To sum this up, we will be using the HERE Places API to find nearby sights and display them to the user. When the user has selected a sight, we will use the HERE Routing API to get routing instructions and display these to the user as well. The HERE APIs are available in a variety of flavors, from JavaScript to Mobile SDKs for iOS and Android, but when building our Connect IQ app we will be using the REST interface. Conveniently, the Connect IQ SDK provides a function to access REST APIs in the Communications module, called makeWebRequest . This function takes four parameters: url (the API endpoint) parameters (the parameters we want to pass to the API) options (determines how Connect IQ handles the request and its response) responseCallback (the method that will handle the response) To determine the correct values, we need to take a closer look at one of our APIs. Let’s start with the HERE Places API. The HERE Places API offers multiple endpoints for browsing, searching by strings, autosuggest, and much more. The correct choice for our use case is the “discover/explore” endpoint, which “retrieves a list of relevant places nearby a given position”. The following parameters are relevant for our use case: app_id (your credentials) app_code (your credentials) at (our position as a decimal latitude/longitude coordinate, e.g., “52.5308,13.384”) cat (the list of categories we want to filter by, e.g., “sights-museums”) size (how many places we want in our results, e.g., “15”) Let’s walk through these one by one. First, you will need an app_id and app_code to access the HERE Location APIs. Just click the 90-day Free Trial button at the of the page to sign up. Then generate credentials for a “JavaScript/REST” project and you’re good to go! To get our current location, we need to make use of the GPS feature in our Garmin device. The Connect IQ SDK provides the Toybox.Position module for this. First, we need to request location events and provide a callback function using the Position. enableLocationEvents () function. One place to start and stop requesting location events are the onStart() and onStop() functions of our app. When the GPS has found a position, the callback function then receives a Position.Info object which contains all the information provided by the positioning system. This includes everything from accuracy, heading and speed to a Location object, which has the latitude and longitude we are looking for. The Places API provides a variety of categories we can use to filter our search results. There’s even a dedicated API endpoint to get a list of locally relevant categories. However, for our use case we can simply use one of the permanent categories and set the cat parameter to “sights-museums”. Finally, we need to tell the API how many different points-of-interest we would like to receive in the response. As the results are sorted by popularity and we don’t want the user to scroll through a large list of possible sights, we can set the size parameter to “10” for now. So let’s make a call to the API using makeWebRequest () with our endpoint and parameters. The response from the HERE Places API will be provided in JSON, so we need to tell the Connect IQ SDK to treat it as such, using the appropriate Communication.REQUEST_CONTENT_TYPE option. We also provide “onReceive” as a response handler function. Let’s look at how this function works. The response handler receives a Communications. HTTP_RESPONSE_TYPE code and the data contained in the API response body. Let’s have a look at an example of the JSON that the API returns. As we can see the response contains a list of items . These are the points of interest we are looking for. The title and distance elements are essential information for the user. The category object is also of interest, in particular its title element which helps with displaying the category. We also need to store the position information, because this will end up as the destination waypoint parameter for our Routing API call later on. Note that we don’t have to manually parse the JSON in Connect IQ as the SDK automatically transforms the response into a Monkey C Dictionary object. Now that we have an items object (an array that contains the information we’re looking for), we can extract that information and display it when the user scrolls through the list of places. So far so good! We have now understood how to make REST API calls using the Connect IQ SDK and how the HERE Places API works. We’ve put these two together, so let’s run our code and see what happens. Unfortunately, it doesn’t work. Instead of a list of places, we are getting an error: 402. According to the ConnectIQ documentation this is a “NETWORK_RESPONSE_TOO_LARGE” error. What does this mean exactly? As it turns out, memory can be a very limited resource when developing for wearables and so the maximum size of a makeWebRequest () response ConnectIQ accepts is 16KB. Whenever we are calling an API from a Connect IQ device, we must therefore ensure that the response remains under that limit. With the HERE Places API, we have two options for reducing our response size. First, we can simply reduce the “size” parameter. Experience has shown that setting it to a value less than 8 is sufficient to get responses under 16K in size. For our purposes this will likely be sufficient as we don’t want to present the user with a very long list. However, the HERE Places API also supports pagination, which allows us to be more sophisticated. If you take another look at the JSON above, you will see that beside the list of items , the response also has a next element which contains the full API call required to get the next page of results. For example, if you have requested five nearby places of the category “sights-museums”, then using the request in next will give you another response with five additional nearby places of that category. This response will also contain a next element, so you can continue the process. In addition, it will contain a previous element, which allows you to go back as well. To request the next or previous page in Connect IQ, you can simply make another web request, set the url parameter to the content of the next or previous element and leave the parameters empty. Whichever approach you choose to reduce the size of the request, remember that you can never completely predict it, so make sure to handle 402 errors appropriately. Now that we have the Places API working, we can take a look at the Routing API. The HERE Routing API only has one endpoint but provides a large number of possible parameters . Fortunately, requesting a basic route requires just three parameters plus your credentials. Let’s look at these parameters now. app_id (your credentials) app_code (your credentials) waypoint1 (your start waypoint, once again in decimal lat/long format) waypoint 2 (your destination waypoint, once again decimal lat/long format) mode (determines whether the route is calculated for driving, biking, walking, etc.) We’ve already discussed how to get your credentials and are familiar with latitude/longitude parameters. This leaves us with the mode parameter. The Routing API is quite powerful and supports a number of routing modes. You can route using a car, a bike, public transit and trucks. Most importantly, you can also get routes on foot, which is what we want to do when sightseeing. It’s not exactly trail running, but at least we want to meet our step and activity goals for the day, right? We therefore set the parameter to “shortest;pedestrian” or “fastest;pedestrian”, depending on our preference. Using makeWebRequest (), our code will look like the following. Once again, the HERE Routing API returns a JSON response. Looking at it, we can see that it contains a list of routes . (Multiple routes are possible because we could request a number of alternative routes. As we have not done this, there is only one route.) This route contains a list of legs . Legs partition a route between multiple waypoints. Since we have only chosen two waypoints, there is only one leg. The leg contains a list of maneuvers . Maneuvers describe the action that needs to be performed to progress along the route. This sounds like the information we are after! In fact, the instruction attribute in the maneuver has a verbal description of the action the user should perform, such as “Turn right on Stralauer Allee. Go for 473m.” Neat! Once again, the Connect IQ SDK wraps up this JSON response in a Dictionary object for us. We can parse this object and display the routing instructions to the user. There is an issue, however, and we are already familiar with it. What if the routing response is larger than 16KB? Fortunately, there are some strategies to reduce the size of the routing response. As you will have noticed there is a lot of additional information available in the response, even though we’re really only interested in the data in each maneuver. Using attribute switches , we can in fact tell the HERE Routing API to only show us the specific data we are interested in. Using the routeAttributes parameter we can tell the API to return only the leg information inside of a route and nothing else. Even when using attribute switches, there is no guarantee a response will always be small enough. The size of a HERE Routing API response is even less predictable than that a HERE Places API response. A route to a distant target might just be one instruction (“Follow the road for 400km.”) and a route through many small twisting alleys might be complex, even if the destination is close by. So once again, always make sure you properly handle a possible 402 error, not just in the code, but also in the user interface. Finally, you may have noticed that the instructions are in HTML format. You may want them to be, if you’re planning to use the markup information in your user interface; but, you can also turn this off by setting the instructionsFormat parameter to “text”. Our code for the request now looks like this. And that’s it! Well, sort of. Obviously, the code snippets in this blog post are somewhat simplified and there’s a lot more to building a great sightseeing app than what we’ve discussed. Fortunately, you can always have a look at the complete app on GitHub. Happy sightseeing! Speaking of seeing, why not come and see the HERE team at the 2018 Garmin CIQ Developer Summit! Among other things, I will be conducting a workshop on how to use location technology and the HERE Location APIs in your Garmin ConnectIQ applications. Be sure to follow us on Twitter ( @heredev ) for updates and more information.", "date": "2018-03-26"},
{"website": "Here", "title": "#LocationForDevelopers – Free, Reliable and Holistic", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/locationfordevelopers", "abstract": "Our mission at HERE has always been to create a digital representation of reality to radically improve the way everyone and everything lives, moves and interacts. To contribute to a better future, we’re pushing the boundaries of the technology behind the digital representation of reality—from our HD Live Map , which paves the way for better maps and autonomous vehicles; to the Open Location Platform , our powerful engine putting location intelligence and big data to work for you. To make these things effective, we’re constantly thinking about how we can empower others to use HERE tools to get to the good stuff: the radical improvement of the way we live our lives. Put simply, developers are at the heart of our mission. We can’t do it without you. Reflecting on that, we’re taking a moment to highlight our commitment to making it easy for developers to use a wide range of our most powerful tools—including a rich library of REST APIs, our JavaScript APIs, and native SDKs for Android and iOS—for free, no credit card required. These are the same tools used by some of our biggest and most innovative customers and partners, from Microsoft, to Grab, to Virgin Hyperloop One. To make this tangible, we have two free options available on our developer portal, developer.here.com . First, you can choose our “Get Started for Free” option, a 90-day free trial that gets you access to all our Standard and Advanced features, as well as our Premium, offline native SDKs. Advanced developer features include a powerful set of REST APIs —you’ll recognize them by the use of the term “Extension” on the end of the API name—to drive innovation around ridesharing and fleet management use cases. Second, you can choose our “Public Basic “option, which includes some of our most popular features, like indoor and outdoor maps; map tiles with real-time traffic around the world; car, bike, and walk routing; geocoding and places; positioning; and geovisualization. All the details are here: developer.here.com/plans Finally, and as always, stay tuned for what’s next. We have big plans for later this year that break down barriers to give you access to more features, more use cases, and more volume. Yep, for free. Until then, let us know what awesome things you’ve built in our joint mission to use the power of location to make life better. Tweet us @HEREDev . Cause every day is a good day for good news.", "date": "2018-05-07"},
{"website": "Here", "title": "Want to create solutions using the power of location?", "author": ["Yagnesh Shah"], "link": "https://developer.here.com/blog/want-to-create-solutions-using-the-power-of-location", "abstract": "We have some great events for you around the globe this May! Hope to see you there in person or online. #codegladiators TechGig Code Gladiators is India’s biggest coding contest. It's just kicked off and there's still time to join. The Mobility and Location Services challenge is to use HERE APIs & SDKs to resolve issues in growing cities of India using location. Get creative and build something to improve urban life for the chance to win cash prizes. #HereMapHacks We’ve partnered with the Higher Technical School of Geodetic, Cartographic and Topographic Engineering (ETSIGC) of the Technical University of Valencia, where we will be developing location solutions to help improve mobility and resource management in Valencia, Spain. The event will run from May 11-13 . Register your team here . #hacktm2018 We're onboard for the biggest software & hardware hackathon ever in South Eastern Europe, HackTM .  Join us in Timisoara, Romania May 11-13 , because \"life's too short to hack alone.\" Register here . #codeday CodeDay is a global event supported by Splunk , Lexis Nexis, SAP, and HERE, where student programmers, artists, musicians, actors, and others come together to build apps and games for 24 hours. People of all skill levels are welcome—workshops and mentors are available to help . Students age 12–25 are invited to participate. This excellent event is taking place in various cities across the US on May 26 - 27. More info and registration here .", "date": "2018-05-02"},
{"website": "Here", "title": "Announcing HERE Location Services and Mobile SDK availability in South Korea", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/announcing-here-location-services-and-mobile-sdk-availability-in-south-korea", "abstract": "We’re excited to announce the launch of the HERE Location Services and Mobile SDKs (Android and iOS) in South Korea. Starting now, developers building global or regional applications can use HERE’s APIs to access location technologies and maps for South Korea. Since the HERE map in South Korea is a stand-alone map, not yet integrated with the HERE world map, developers will have to use separate service URLs to access all the available location features and functions in South Korea. These include the following: Mapping: South Korea map coverage Map rendering Satellite imagery 3D Maps (Mobile SDKs) Routing Traffic-enabled routing Vehicle routing Pedestrian routing Traffic Traffic tiles for incidents, real-time and historical traffic flow Traffic flow data Geocoding Global coverage for geocoding and reverse-geocoding Offline geocoding Places POI search Places discovery Places description Search for full and partial addresses (including administrative units), and telephone numbers Navigation (Mobile SDKs) Hybrid and offline navigation Vehicle navigation Pedestrian navigation Dynamic information (e.g. signposts, street lane) Due to legal restrictions in South Korea prohibiting mapping data from being exported outside the country borders, all HERE’s location services are currently hosted in data centers located in South Korea and available for global use, with the exception of HERE's Offline Maps and Routing services which can only be accessed and used inside the country borders. We’re really excited about the opportunities that this release brings to our global and local customers. To evaluate or license services in South Korea, please contact us . And stay tuned as we continue to open up new territories and enable location capabilities in more areas.", "date": "2018-05-20"},
{"website": "Here", "title": "How to Migrate from Google Places to HERE Geocoder", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/how-to-migrate-from-google-places-to-here-geocoder-search", "abstract": "If you’ve worked with the Google Maps Platform or the HERE Location Platform you know that to add a map to your application, you need a latitude and longitude coordinate to center the map. You may still be wondering how to find a meaningful coordinate in the first place. That’s what a Geocoder is for – taking a free-form address entered by your application’s users and translating it into a place on a map. For making REST API calls, the Google Places Geocoding API requires an API KEY whereas the HERE Geocoding Service requires an APP_ID and APP_CODE. You can retrieve the credentials from your Projects console when you sign up for an account with https://developer.here.com . Regardless of your client programming language, this boils down to a GET request like the following: https://maps.googleapis.com/maps/api/geocode/json ?key=$GOOGLE_API_KEY &address=2168+Shattuck+Ave,+Berkeley,+CA https://geocoder.api.here.com/6.2/geocode.json ? app_id=$HERE_APP_ID &app_code=$HERE_APP_CODE &searchtext=2168+Shattuck+Ave,+Berkeley,+CA As you can see, the parameters on these endpoints are similar – just credentials and a query string. You can use a command like curl or a tool like postman to view the corresponding results. A full description of the response returned is described in the HERE Geocoder API Guide , but a few of the more frequently used data use cases are compared below. Is This the Correct Match? In this particular case the address was unique, so we found only a single zero-indexed result in our set. For more ambiguous queries it wouldn’t be uncommon to find multiple locations returned. match = response[“results”][0] match = response[“Response”][“View”][“Result”][0] The HERE Geocoder API includes some additional detail in the response that can be helpful if you are migrating from Google Places. Depending on the application you are building, you may want to take the quality values into consideration in how confident your application considers the match as the intended location. \"MatchLevel\":\"houseNumber\", \"MatchQuality\":{ \"State\":1.0, \"City\":1.0, \"Street\":[1.0], \"HouseNumber\":1.0}, \"MatchType\":\"interpolated\" Getting the Coordinates The latitude and longitude can be found in the corresponding attributes. match[“geometry”][“location”] match[“Location”][“DisplayPosition”] { “lat”: 37.869768, “lng”: -122.268468 } { “Latitude”: 37.86976, “Longitude”: -122.26846 } You can see both return a result with a high precision. In addition to a single point, the result set includes a bounding box. The Google Geocoder API returns northeast and southwest coordinates whereas the HERE Geocoder API provides TopLeft and BottomRight. Finding the Full Address Our search query didn’t include the zip code or country, but the response includes a full human readable and valid postal address. match[“formatted_address”] match[“Location”][“Address”][“Label”] 2168 Shattuck Ave, Berkeley, CA 94704, USA 2168 Shattuck Ave, Berkeley, CA 94704, United States Additionally, the components of the address are broken out as separate values. If you were only interested in identifying the zip code there is no need to parse the address with a regex as the components have already been codified. for each component in match[“address_components”] for each type in component[“types”] if type == “postal_code” then return component[“short_name”] match[“Location”][“Address”][“PostalCode”] 94704 94704 Reference a Unique Place ID A globally unique identifier (guid) is assigned by each platform for use in additional queries. The value has no meaning itself, but it can sometimes be helpful to use as an ID. match[“place_id”] match[“Location”][“LocationId”] ChIJ56lMNJx-hYARU3cMPHQpwzs NT_mYv2P3Ds2uTfo2vKqrWDEC_yEjN4A What's Next? The Geocoding API allowed us to extract the latitude and longitude for a street address. We could create a dynamic map to display the point or identify interesting places using the Places Search API, which is the topic of the next post in this series. Please reach out or comment to let us know what you think and what it is you want to see more of.", "date": "2018-06-26"},
{"website": "Here", "title": "June 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/june-2018-release-notification", "abstract": "This month's updates to the HERE Platform services include improvements to the Geocoder API for Argentina and new data layers in the Platform Data API.Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Traffic API, Positioning API, Custom Locations API, Custom Routes API, Geofencing API, Platform Data API, Route Matching API, Toll Cost Calculation API and Waypoints Sequencing API. Summary: Improvements in Geocoder API for Argentina to add sub-districts New data layers in Platform Data API Added support for Incidents TML version 2.4. Geocoder API Version 6.2.159 Improvements in Argentina to better support queries for sub-districts. Traffic API Version 6.0.73.0 Added support for Incidents TML version 2.4. Positioning API Version 1.6.0 We removed the deprecated frequency parameter in the CDMA Network measurements object in the locate request body . Platform Data API Version 2.5.5 New Layers STAB_TOPO_ID_FC1 ... STAB_TOPO_ID_FC5 to map between Link IDs and their corresponding Stable Topology IDs with offset. New Layer FUELSTATION_POI providing information about gasoline, diesel and EV charging offerings. The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.159) Custom Locations API (Version 2.5.5) Custom Routes API (Version 2.5.5) Geofencing API (Version 2.5.5) Route Matching API (Version 2.5.5) Toll Cost Calculation API (Version 2.5.5) Waypoint Sequence Extension (Version 3.0.12)", "date": "2018-06-12"},
{"website": "Here", "title": "June Event Radar", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/june-event-radar", "abstract": "We're all over the world and you still haven’t met any of us? Don’t be oh-so-quiet then! Join us at one of the events below or reach out to us on @heredev and let us take you out for a drink to talk about your experience with our developer portal! CodeGladiators June 7-8 – Mumbai, India https://www.techgig.com/codegladiators/mobility-hackathon Our local team and evangelists will be in Mumbai for the final round of CodeGladiators. This has been the biggest online & onsite hackathon we have ever participated in, and we're excited to see what the results of this 3-month-long hackathon will be! Techsylvania June 9-10 – Cluj, Romania https://techsylvania.co/hackathon/ The name can be suggestive and there's a reason for that! If you have an appetite for innovation and cutting-edge technologies, come and hack with us at Techsylvania hackathon. Make sure you say hi and get your cool HERE swag! We don’t really want to carry them back to Berlin. And, a little SWAG never killed nobody . City Coders Plock Hackathon June 16-17 – Plock, Poland http://hackathon.plock.eu/ Our local community team will be in Plock during the event on June 16-17th. If you are local and want to participate, you still have time. Register here . Developer Week June 18-20 – New York City http://www.developerweek.com/NYC/ Meet evangelist Michael Palermo . He'll be on the main stage for a talk as well as holding a workshop, both on June 19th. We're giving away free tickets to the event over on Twitter . droidcon Berlin June 25-27 – Berlin, Germany https://www.de.droidcon.com/ Evangelist Richard Süselbeck will be on his home turf. Hit him up for tips on all things location. Webit June 25-27 – Sofia, Bulgaria https://www.webit.org/festival/2018/ Want to have a stimulating discussion on how we can reinvent Europe's future around technology? Then Webit is the perfect fit for you! We will be there to show you the 5W1H of a European future with location at its core!", "date": "2018-06-06"},
{"website": "Here", "title": "How to Migrate from Google Maps to HERE Dynamic Maps", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/how-to-create-a-here-dynamic-map-like-google-maps", "abstract": "The “Hello World” of mapping is an interactive map where users can dynamically pan and zoom around a latitude and longitude origin. The two maps shown below demonstrate the Google Maps and HERE Location Services Map for the coordinates {lat: 33.8121, lng: -117.9190}. This post is one of a series that can help you migrate from similar offerings on other platforms. To embed maps like these in your web application you’ll need to (1) include some JavaScript libraries and (2) add some JavaScript code. Otherwise, these maps have similar functionality to zoom in, zoom out, switch to satellite or terrain view, layer traffic, etc. Included Resources To get your map up and running in your web app, you’ll need to include some external resources in the <head> section of your HTML. With Google Maps this is done with the following <script> tag. By way of comparison, the HERE Interactive Maps include code will look like the following listing. A few differences should jump out at you. The API KEY is not specified when including the HERE resources but comes later in the form of an APP_ID and APP_CODE in the JavaScript code section below. The HERE libraries are more granular in terms of their scope, so instead of including everything in one package you choose à la carte only the libraries you need to use and make use of the API Reference to add customizations based on the needs of your solution. In the case of an interactive map you need several of the modules to provide all of the functionality of a dynamic map . mapjs-core – is basic functionality needed for rendering maps, layers, and other map objects used for platform authentication. mapjs-service – handles client-server communication for map tile retrieval, routing queries, etc. mapjs-ui – provides cross-browser ui components for map settings, zoom control, etc. (you also need the stylesheet) mapsjs - mapevents – defines user-interaction behaviors that can be customized such as panning, pinch-to-zoom, etc. JavaScript When it comes to page execution, you’ll need the following source code snippet to render the interactive map in your applications. The Platform object handles authentication which is why you must provide an App ID and App Code. You can retrieve the HERE APP_ID and APP_CODE from your Projects console. There are more JavaScript objects here than you find in equivalent Google Maps source code with the expectation you’ll want to explore and customize the look, feel, ui, and behaviors to your own brand and user experience preferences. This is also where you can center the map on a specific coordinate during initialization and set a default zoom level. When you create the map object, you’ll need to identify the id property of the element where you want to place the map in your application. <div id=”mapView”></div> If you are new to web applications or need more context, check out the Quick Start for a more complete walkthrough of the full example . If you are looking for more help making the Switch to HERE you can check out some of the other posts for How to Migrate from Google Routes , How to Migrate from Google Places , How to Place Markers , and How to Migrate Google Maps on iOS .", "date": "2018-06-19"},
{"website": "Here", "title": "July 2018 Release Notification", "author": ["Rebecca Amir"], "link": "https://developer.here.com/blog/july-2018-release-notification", "abstract": "This month's updates to the HERE Platform services include a balanced mode in truck routing and scooter routing as a new beta function of the SDK. Updates are related to the following services: Geocoder API, Geocoder Autocomplete API, Routing API, Traffic API, Places API, Mobile SDKs for Android and iOS and Map Data. Summary Basic Environmental Zones support in Routing Balanced mode and fast speed profile in Truck Routing New HERE Mobile SDK release New HERE Platform Self-hosted Q2/2018 release. Routing API Version 7.2.94 Added environmental zones to supported zone types Improved support for balanced mode in truck routing Introduced the fast speed profile feature for trucks Introduced a new resource for querying supported routing zones . HERE Android SDK Starter Edition version 3.8 No new features were added in this release. Premium Edition version 3.8 Added a new cartographic POI category for EV Charging Stations Added scooter routing as a new beta feature. Scooter routes are optimized for scooter and motorbikes by avoiding highway and having less impact in time-to-arrival than car routes when traveling through an area with high traffic. Added turn-by-turn navigation support (beta) for scooter routes We support extended maximum zoom level as a beta feature. This is turned off by default. Once turned on, maximum zoom level is extended to zoom level 23 Added the ability to query for the estimated data size of selected area or route before prefetching Added support for displaying drop shadows on polylines Added the ability to retrieve the URI of a venue space's icon. Note: This is the last release where offline routing supports on demand map data downloads. Starting from the next release, map data must be downloaded before handed for offline routing to work properly. HERE iOS SDK Starter Edition version 3.8 No new features were added in this release Premium Edition version 3.8 Added new carto POI category for EV Charging Stations Added scooter routing as a new beta feature. Scooter routes are optimized for scooter and motorbikes by avoiding highway and having less impact in time-to-arrival than car routes when traveling through an area with high traffic Added turn-by-turn navigation support for scooter route We support extended maximum zoom level as a beta feature. This is turned off by default. Once turned on, maximum zoom level is extended to zoom level 23. Added the ability to query for the estimated data size of selected area or route before prefetching Added support for displaying drop shadows on polylines Added the ability to retrieve the URI of a venue space's icon. Note: This is the last release where offline routing supports on demand map data downloads. Starting from the next release, map data must be downloaded before handed for offline routing to work properly. Map Data for Mobile SDK Version 8.30.84.156 (June 2018) Inclusion of basic Scouter routing attributes for routing use cases. Speed limit changes in France Fixed issue with shown private petrol station POIs Fixed issue with casino POI categorized as amusement-park Fixed issue with missing Town names in South Africa when zoomed out The following services had new releases with minor changes: Geocoder API (Version 6.2.161) Geocoder Autocomplete API (Version 6.2.161) Traffic API (Version 6.0.75.1) Places API (Version 2.63.0)", "date": "2018-07-06"},
{"website": "Here", "title": "Check out our new Scooter Routing Beta!", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/check-out-our-new-scooter-routing-beta", "abstract": "Scooters! Scooters are great. They’re like bikes except without the health benefits. Scooters are amazing! They’re like cars except without the crumple zone. Scooters are brilliant! They’re like motorcycles except without the fun. I kid. Scooters are cool again, with a zillion scooter-related startups coming around the corner on two electric wheels, looking all stylish and hopefully wearing a helmet. Next up: Scooters on the blockchain! (That’s a free business idea, act now!) Seriously though, scooters are back in business and might just turn out to be a viable part of our future mobility mix. It’s no wonder then that we at HERE Technologies are now offering Scooter-specific routing! In essence you get a route that avoids all those roads you’re not allowed to use on a scooter. Like highways. And bike roads. Seriously, don’t do that. I’ve seen you. Not cool. Anyway, there are some caveats. First, it’s still in beta (but still more stable than a scooter kickstand). Second, for now it’s only available in the Premium versions of the HERE Android and iOS SDKs. Also, scooter routing only supports “fastest” mode. I mean, who wants to go slow anyway? Finally, dedicated scooter lanes are not yet supported. Yet. We’re working on it. It’s a beta, OK? Caveats aside, that’s pretty neat. So how does it work? Well, it works just like you’re used to from our routing, except that you set the TransportMode to SCOOTER. Check it out: Step 1: Set up the RoutePlan and throw some waypoints in there. Step 2: ??? (Create the RouteOptions and set phasers to scooter.) Step 3: Profit! (From the IPO of your massively successful scooter startup.) But now you’re saying: wait! That’s Android code. I’m cool, I’m stylish, I drive a scooter! Naturally I wouldn’t be caught dead with anything but an Apple device while texting and driving. (Fun fact: if you text and drive, you’re very likely to be caught dead! Seriously, stop doing that. You’re nice. We like you. Stick around for a while longer.) So anyway, here’s the iOS code for people who love laptops without working keyboards. Step 1: Spend 2600€ on a laptop. Step 2: Listen to Jony Ive talk in dulcet tones about the “more accurate and efficient keyboard design” Step 3: Sme f the keys are nt wrking There you go. Now scoot! (Preferably in scooter, using our neat and new scooter routing!) Before you do, check out the documentation on the HERE developer portal for Android and iOS and don't forget to sign up for the 90-day free trial so you scooter-route yourself. Photo by Pedro Pereira on Unsplash", "date": "2018-07-12"},
{"website": "Here", "title": "Location-aware Snapchat stickers with Snap Kit + HERE", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/here-maps-snap-kit", "abstract": "Earlier this month, Snap released its developer kit , allowing developers to harness some of Snapchat's features and content. Snap Kit enables developers to include a \"Login with Snapchat\" button at login, send content to the Snapchat camera, display public Snapchat Stories outside the app, and use Bitmoji outside the app. In this tutorial, we'll be focusing on the Creative Kit component of Snap Kit for iOS. Creative Kit lets developers send custom 3rd party content into the Snapchat app to be used as stickers and overlays. We'll be creating a demo iOS app that lets a user insert a map of the iPhone's current location as a Snapchat sticker. In order to achieve this, we'll take advantage of the nifty HERE Map Image API . In about 15 minutes, you'll be able to start snapping some selfies with a slick map sticker on Snapchat, just like the image below: Our Head of Developer Relations, Mithun Dhar, smiling for the camera. Sound fun? Let's get started! Setup Before we can start coding, we'll have to get some housekeeping out of the way first. You'll need accounts from both: HERE Developer Portal Snap Kit Portal Go ahead and register on both of those sites. Don't worry, they're both free! On HERE Developer, create a new project and grab a JavaScript/REST app id and code. Save these for later, we'll be using them in our code shortly. Do the same process on the Snap Kit portal; register a new app. Take a note of the oauth client id in the \"Development App Info\" as well. Navigate to SnapKit > Docs > Downloads and download the iOS SDKs. Go ahead and unzip the file while we're at this step, since we'll be using the frameworks in Xcode shortly. More Setup: Xcode It's time to fire up Xcode and start coding! Create a new single view project. Using \"File >  Add files to...\" in the top menu bar, select both \"SCSDKCoreKit.framework\" and \"SCSDKCreativeKit.framework\" from your downloads folder (or the directory they were downloaded to). Your project directory should look something like this now: Next, head over to General > Embedded Binaries and add the two frameworks using the \"+\" button. Upon completion, the Embedded Binaries view should look like this: Once that is complete, we'll need to edit and add some information in the Info.plist file. I prefer to edit as source code (right click > Open As > Source Code), but this can be done in the default Property List view as well. Add the following to the file: The first few entries are Snap Kit related, while the last two have to do with accessing the native location APIs in iOS. Make sure to swap YOUR-SNAPKIT-KEY with the Snap Kit development key you copied in the previous section. Now that our info.plist is configured, we need to configure some additional information for Snap Kit to function properly. Navigate back to the Snap Kit Portal and select the app you created for this tutorial. Two very important things must be done here: Add your Snapchat username to the Demo Users section Add your iOS Bundle Identifier of your recently created Xcode project into the Development App Info Caution, your app will not work if Snapchat doesn't have these two pieces of information! iOS Location Services The first component of the app we'll tackle is the native iOS location services. We've already configured some of the necessary location privacy properties in the Info.plist, so we can dive straight into some code. Modify your ViewController.swift to look like below: Don't forget to add the \"Import CoreLocation\" in the header and \"CLLocationManagerDelegate\" in the class declaration. I won't dive into how iOS CoreLocation works in this tutorial. If you're interested in learning more, I recommend taking a look at Andrew's Tutorial: Location Services . Now, whenever you'd like to access the current location of the iPhone, all you need to do is call this one line of code: HERE Map Image API Now that we've written the necessary code to access the iPhone's location, let's work on getting the Map Image API setup. The Map Image API is fairly straightforward; it returns a static map image of a location (coordinates). Additionally, it can do some advanced features like appending markers and polygons onto the map canvas. It wouldn't hurt to get familiar with the API by checking out the documentation , but if you prefer to live life dangerously, feel free to keep moving on. In this situation, we'd like the API to return a map with a marker of our current location. Create a new function in ViewController.swift with the following code: Be sure to replace \"YOUR-HERE-APP-ID\" and \"YOUR-HERE-APP-CODE\" with your HERE app id and code. In the above code, we do the following things: Access the iPhone's location via the locationManager Set some parameters for the Map Image API, such as the zoom level, the image quality, the marker type, and the map style. All of these can be customized. Create an HTTP request for the image and return it Now, whenever our app requires a ready-to-go map image, we have a function prepared to provide it! We'll be using this in the next section. Sending the image to Snapchat We'll now take a look at the code required to send a sticker to Snapchat. First things first, import SCSDKCreativeKit in the header of ViewController.swift. Your header should now have the following imports: We need a button for users to click inside the app to kick off the handover to Snapchat. In the viewDidLoad() function, let's create one: As well as the button's target function, send(): In our send function, we've written code that: Calls our createMapImage() function, returning a map image Creates a sticker object containing our map image Creates a snap object containing our sticker object Sends the snap object to the Snapchat app Voila! And just like that, you've created a location-enabled Snapchat sticker app! The file ViewController.swift file should look like this: The Map Image API was just one of the options available for creating a location-enabled sticker app. HERE Developer offers many location APIs that can be used with not only Snap Kit, but also any other REST/JavaScript, iOS, or Android app. For example, in place of the Map Image API, we could have used the: Places API to search for nearby places and create a POI sticker Geocoder API to translate coordinates to addresses to easily let your friends know where you are Let us know your experience building location-enabled Snapchat stickers in the comments below. Happy snapping! Fork or clone the project on Github . For more interesting location technology content, follow @dbabbs or @heredev on Twitter.", "date": "2018-06-27"},
{"website": "Here", "title": "Is it raining HERE?", "author": ["Marcel Pintó Biescas"], "link": "https://developer.here.com/blog/is-it-raining-here", "abstract": "See how Kotlin can be used to wrap HERE REST APIs to bring the power of location to Android apps. In a previous post we got hands-on with one of the newest HERE APIs, Park and Ride , which allows you to plan a trip using different modes of transportation in the same journey. But what if it's raining when the route switches to pedestrian mode? In today's hands-on we will play with another interesting HERE API, the Weather API . This time though, we will move to the mobile developer side and showcase how you can easily use it in your Android app. Let's Play Let's start playing with some examples to understand what this API can offer us. https://developer.here.com/api-explorer/rest/auto_weather/weather-observation-lat-long One of the examples we find is just what we need: the weather forecast in an exact location. The request looks pretty straightforward—we need to specify the product, pass the coordinates and our HERE credentials. The response is pretty extensive and provides a lot of information. Now that we have an idea of what we need to provide and what we can expect, we can wrap it into our code. But first things first, you need to get yourself a pair of credentials. They consist of an App ID and an App Code. You can get your own set of credentials by signing up for free . After signing up you will see an option to generate an App ID and an App Code. If you have already signed up, you can access your credentials on your 'Projects' page. For this API, licensing compliance means there's one extra hoop to jump through to activate access. Please fill out the form on the Contact Us page, noting your App ID and requesting that it's enabled for the Weather API. We’ll try to respond ASAP, but it can take up to three days to activate. Wrap it up If you are an Android developer or familiar with it, you must have heard about Retrofit and Moshi. We will use these libraries together with the Json to Kotlin class plugin to quickly create our entities. Let's open our Android Studio project and add the following dependencies We will need: Kotlin and coroutines Support libs for the views Network and a JSON parser Next, we will generate the entities using the plugin Json to Kotlin class, we can use the output of the example and let the plugin generate them. Easy, isn’t it? We have the response, we just need the request now. Using Retrofit we can easily create an interface that declares our GET method with the needed parameters. Note: we are hardcoding the App ID and App Code directly. Normally we would use a better mechanism, but for simplicity here you can change them with your credentials. Now it's time to build our Rest Client using Retrofit and Moshi Json converter. The setup is divided in to three parts: Set the host URL Set the Json converter to use Indicate which API instance we want to build. With that we complete the network part, we can use the instance of the API object that Retrofit generated and we can execute the GET request and retrieve the result. To wrap the code nicely, we added a WeatherRepository class with a method to get the weather observation base on a latitude and longitude. This method uses coroutines to execute the Network call and suspend it in another thread. Once the call returns the result, we use a simple ApiResponse wrapper to return the result to the view. Now is just matter of implementing the view according to our needs. Show it Back in the beginning we explained that this API could be used to retrieve the weather in the modal exchange points, and for that we would need to retrieve the location and query the API. In order to showcase it we created a small App instead that will query the weather of the selected location and display it. Now you are ready to let your users know if they should take the umbrella when commuting. As you can see, the HERE APIs are pretty straightforward to use and the documentation provides useful examples. We hope that this little example was useful and helps you to get started. Find the source code of this example on GitHub .", "date": "2018-07-03"},
{"website": "Here", "title": "How to Migrate from Google Routes to HERE Routing", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/how-to-migrate-from-google-routes-to-here-routing", "abstract": "With echoes of \"Are we there yet?\" Routing Services are easy to relate to because we use them to get driving directions from point A to point B. I'm going to take a look at a few uses to help navigate your application from Google Routes to HERE Routing. REST Request Let's say we're starting at 187 W 9th St. Boston, MA and heading to Gillette Stadium and need to get a simple route by making a REST service call. You can start by switching the GET request to the following endpoint: https://maps.googleapis.com/maps/api/directions/json https://route.api.here.com/routing/7.2/calculateroute.json The HERE services are typically version controlled so that you can decide when to upgrade or downgrade based on what behavior you are expecting and a time/place of your choosing. You'll need to substitute the Google api key with the HERE app_id and app_code as you may have seen in other tutorials. ?key=${GOOGLE_API_KEY} ?app_id=${HERE_APP_ID}&app_code=${HERE_APP_CODE} With the endpoint and authorization out of the way, we specify the parameters for the route we want. The Google Directions API to its credit accepts some flexible input parameters for origin and destination which can be an address doing the geolocation behind the scenes. If you use it this way and are migrating to HERE you'll need to make the geocoding request first to identify the latitude and longitude.  You can learn more about that in How-To Migrate from Google Places to HERE Geocoder . The HERE route API also requires a mode that specifies any constraints around the type of route you want returned.  You can find Transport Mode described in the documentation for the full range of options. &origin=187+W+9th+St+Boston,+MA&destination=Gillette+Stadium &waypoint0=42.332878,-71.052917&waypoint1=42.090963,-71.264316&mode=fastest;car;traffic;disabled There are a few variations on how the HERE API accepts Waypoint Parameters but \"geo\" latitude and longitude is the default.  The HERE Maps API for JavaScript may be helpful if you are doing this in your JavaScript application and as you can see the parameters are similar. Service Response After updating your requests, you'll need to find the data of interest for your application in the response. Let's say you are interested in a trip summary . This may include the distance and duration. You'll find them in the corresponding: Google routes[0].legs.distance and routes[0].legs.duration HERE response.route[0].summary.distance and response.route[0].summary.baseTime . This same request of the HERE Routing services returns additional information you may find valuable in your application such as the trafficTime and flags indicating features of the route. The driving directions for steps along the route can be found with: * Google routes[0].legs.steps * HERE response.route[0].leg This is an example step from the driving plan, where the leg identifies a start , end , and a list to include each maneuver : See the JavaScript API documentation for more on how Displaying a Route on the Map can be accomplished.  If you still haven't migrated your maps, also check out How-To Migrate from Google Map to HERE .", "date": "2018-07-18"},
{"website": "Here", "title": "How to Migrate from Google Map Markers to HERE Map Markers", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-to-migrate-from-google-map-markers-to-here-map-markers", "abstract": "A fundamental use case for displaying maps is pinning markers on them. This post is one of a series that can help you to migrate from similar offerings on other platforms such as Google Maps. To follow along, you will need a developer account you can register for at http://developer.here.com Of course to pin a marker on a map - you need a map. To learn how to display a map, please look at our post on how to display a map , which also explains what resources to include in the client HTML. Add a Simple Marker When adding a simple marker to Google Maps, the code looks like the following: When adding a simple marker to HERE Maps, the code is as follows: In the code above, 'M' is helper object maintaining references and data used in all the HERE demos in this post. For full context, see the entire HTML and code provided at the end. The result of running the function displays the default marker in the center of the United States as seen here: Add a Custom Image Marker You can add your own image as a marker. Here is the code to make that work: As noted above, associating the marker object with an icon object that has a path to your image is all it takes. Be sure the image you specify is not too large or it will overpower the map. Keep the image dimensions roughly between 10 to 50 pixels in width/height. When the code above executes, it places a custom home image over Phoenix, AZ (my home town): Add a Marker Using SVG You can also use SVG markup to create a custom marker. A simple example of this in code is here: When the code above executes, it creates a small white rectangle with an orange letter 'C' using SVG markup. The markup is then associated with an icon object, which is then supplied to the marker object. This is what is displayed when the code exectues: Add a DOM Marker Another option for markers is to use a DOM element. You control the element and it's style, and can associate events with it too. The following is a simple code example using this approach: In the code above, a div element is created and styled. It also attaches a title attribute to provide a simple tooltip. When the domIcon object is created, it is initialized with the dynamic div element. Notice when attaching events, the element is cloned so that you can add multiple types of this marker to a map if desired. When the code executes, it displays the marker at Berkeley, CA. When hovering over the marker, it displays the tooltip and changes the opacity. Complete Example To put all the functions discussed in context, here is the complete HTML and code for all the HERE marker features mentioned in this post: Summary In this post you learned how to add a variety of marker types to a map using HERE location services. For more information on this topic, please visit our documentation . Happy coding!", "date": "2018-07-26"},
{"website": "Here", "title": "How to Migrate from Google Maps to HERE Maps on iOS", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/how-to-migrate-from-google-maps-to-here-maps-on-ios", "abstract": "So far, we've taught you how to migrate your mapping application from Google Maps to HERE Maps with web maps , routing , predictive routing with traffic , and geocoding . Today, I'll walk you through how to easily transfer your iOS (Swift) application to HERE Maps. In this guide, I'll provide some quick steps to swap out the Google Maps mobile SDK for the HERE Maps mobile SDK. The process is fairly straightforward and should only take about 10-15 minutes to get a basic map with a marker up and running on your iPhone. If you'd like to explore the SDK before we get started, feel free to take a look at the official documentation. You can follow along with an existing Xcode project, or you can start from scratch. Both work fine. Developer Portal Authentication First things first, we'll have to head over to the HERE Developer Portal and register our project in order to grab an app id and code. Create a new project, and be sure to click Generate App ID and App Code under the iOS SDK section. You'll also have to input your project's iOS bundle ID from Xcode. Keep this window open--we'll be using these codes in our project in just a few minutes. Installation Just like any other iOS library, the HERE Maps SDK can be installed via CocoaPods . In the project's Podfile, swap out pod 'GoogleMaps' for pod 'HEREMapsStarter'. Go ahead and install those dependencies with pod install . Wasn't that quick? We've already installed the HERE Maps SDK. Just a few more steps until we have an interactive map up and running... Code The HERE Maps SDK is configured very similarly to the Google Maps SDK in Xcode. Both SDK's authentication is taken care of in the AppDelegate.swift file. So let's open up that up and start making some changes. We can go ahead and get rid of the import GoogleMaps statement and replace that with import NMAKit in the file's header. Next, edit the didFinishLaunchingWithOptions method to add your authentication code. Let's head over to ViewController.swift to initialize our map view. Be sure to include import NMAKit in the file's header. With just a few lines of code, we're able to get an interactive map with a marker setup! Happy coding! We'd love to see what you build with the HERE Developer APIs and SDKs--reach out to us @heredev to share any awesome projects.", "date": "2018-07-31"},
{"website": "Here", "title": "Developing with Map Images Using AWS Serverless Applications", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/developing-with-map-images-using-aws-serverless-applications", "abstract": "Last year at the AWS re:Invent conference, HERE announced the availability of ten applications through the newly launched AWS Serverless Application Repository. At the time of the announcement, the repository was in beta and invite-only. Now any developer can deploy from many of the public applications availabe in the repository to quickly create a custom configurable microservice. For a bit more understanding of the benefits of the AWS Serverless Application Repository please visit our post introducing the HERE geocode service using the repository . This post will guide you through the process of discovering, selecting, and deploying the HERE MapImage Serverless Application for use in your development projects. This will allow you to access custom map images from HERE via your own custom API. To accomplish this, you will need credentials at the following: A developer account at http://developer.here.com - now featuring our new freemium plan ! An AWS account at http://aws.amazon.com Discovering the HERE MapImage Serverless App After account credentials are confirmed, to find the HERE MapImage application, browse to the AWS Serverless Application Repository . After clicking the \"Browse all applications\" button, you will be prompted to do your search. Type \"HERE MapImage\" as shown below, then select the MapImage title in the results shown. The landing page for the MapImage application is shown. You are now ready to deploy. Deploying the HERE MapImage Serverless App What does deploy mean in this context? It means installing in your AWS environment all the code and resources needed for you to manage your own serverless app. Once the HERE MapImage application is deployed, it is now your serverless app. Deployment is so easy! Just click the \"Deploy\" button to start the process. You will prompted to provide three values. You can name the application whatever you choose - just know it is used to help identify resources related to your custom serverless app. The \"HereAppCode\" and \"HereAppId\" fields are filled with values you receive from your HERE developer account. Once the fields are filled in, click the \"Deploy\" button. It will take a little time for the deployment process to complete. The process is finished once you see the \"Application successfully deployed!\" message as shown here. In the resource list shown in the right panel, click on the \"MapImageFunction\" link. This will take you to the underlying lambda created. Once there, you are ready for the next step. Configuring Your Map Image Service As mentioned before, now that the MapImage application and related resources are now deployed in your environment, you are in total control of what do do from here. Techncially, you wouldn't need to do anything else to start using the service, as long as your client is not a web page. However, since this post will show how to call your custom map image service from a web page, it provides an opportunity to explore some of the resources deployed into your environment. From the previous step, you should be on the landing page for the custom \"MapImageFunction\" lambda. Near the top of the page, you will notice a visualization of the associated triggers and resources. The only trigger for the lambda is the API Gateway. In other words, it will be a call to your custom API that will trigger the code in the lambda. What does your custom API look like, and how can you call it from a client? To observe what was created for you, click on the \"API Gateway\" box in the visualization. You will see the API Gateway results appear on the page. If details are collapsed, expand them to view everything. For your benefit, copy the URL designated as the API endpoint and save for a future step. The API endpoint URL is used by client apps to call your custom map image service. Once you have copied the URL, click on the link residing above the details. On the page for the API Gateway, make sure the section selected on the left side is \"Resources\", and the root node \"/\" is also selected. Next, click the \"Actions\" drop down menu. Click on the \"Enable CORS\" menu item. Accept the default prompts, and return to the \"Actions\" menu. Now click the \"Deploy API\" menu item. If prompted to what environment to deploy to, choose \"Prod\" for now, since the API endpoint URL copied earlier resides there. The redeployment takes very little time, and you are now ready to test. Consume Your Map Image Service Listed below is the HTML client in it's entirety: Take note of line 11. You will need to replace the value with the data you have in your API Gateway endpoint URL copied earlier. Line 12 concatenates query string parameters to indicate coordinates [c], width of image [w], height of image [h], and zoom level [z]. Lines 14-22 make an asynchronous call to your custom API and return the results. Because the data returned is base64 encoded, it is designated as such with the data moniker shown on line 18. Executing the page results with an image! In this example, getting a view of the author's hometown. Summary HERE is proud to be among the initial contributors to the AWS Serverless Repository - launching ten applications which map to core HERE APIs. In this post, you learned how to discover, deploy, configure, and test your own microservice derived from the HERE MapImage serverless application. In upcoming posts, we will explore how to use some of the other serverless applications provided by HERE. For a recap of the benefits of deploying a application from the serverless repository, plese view the segment from the AWS RE:invent session below:", "date": "2018-08-14"},
{"website": "Here", "title": "Our HERE Freemium developer plan in detail", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/our-here-freemium-developer-plan-in-detail", "abstract": "If you’ve ever met us at a conference, joined us at a hackathon or even if you just visited our developer portal, we’ve probably told you to sign up for our 90-day free trial. It’s kind of what we do. We’ve got amazing map and location APIs and we want you to give them a try. In the past, the trial was fine. You got access to most of our APIs and you got 100.000 transactions per month. Like I said, the trial was fine. Of course, as its name implies, the 90-day trial expired after 90 days. This meant you had to sign up for the “Basic” plan and, well, that wasn’t fine. In fact, it was positively…basic. You lost access to all our advanced APIs, the Premium SDKs and your free transactions per month plummeted to 15.000. Even signing up for one of our paid plans didn’t restore your access to the advanced features. Like I said, it wasn’t fine. You could almost say it was mildly disagreeable. Well, I’m happy to report that the 90-day free trial is gone. So is the Basic plan. And all the other mildly disagreeable plans. They’ve all been replaced by one straight-up amazing plan. We call it “Freemium”. Let’s have a look at what this means for you, especially the “free” part of “freemium” Freemium means that you will get 250.000 transactions per month. For free. Yep, free. Not even a credit card required. Freemium means that you will get access to all our APIs. There are a few—a very few — exceptions that we’ve set out clearly here . But there is no more difference between “standard” and “advanced” features, no more whitelisting, no more problems. Freemium means that you will get all this forever. Yep, forever. As in “permanently”. 250.000 transactions a month for free until the heat death of the universe. (OK, maybe not that long. We’ll probably find a way to make this even better at some point. You catch my drift.) There’s more cool stuff, like how we’ve opened up what type of applications you can build for free to include mobile asset management and in-vehicle integration. Like how we’ve stopped charging you a different price depending on what you’re doing. And like the competitive pricing for transactions once you get past the 250,000 limit. This really is industry-leading stuff. It goes without saying that everyone gets access to this. Have a Basic plan? Congrats, you can get Freemium now. Did your 90-day trial expire? Congrats, you can get Freemium now. Have a paid plan? Congrats, you can get Freemium now (and probably save a lot of money). I think what I’m most excited about is how you now get access to our entire suite of map and location APIs, including some of our advanced features like isoline routing and geofencing. Isoline Routing, though it may be hard to infer from the name alone, allows a request for a polyline that connects the end points of all the routes leaving away from a defined center point with either a specified length or a specified travel time. Maybe that’s not easy to infer either. Let’s try this: an isoline will show you the difference between how far you’ll get in 20 minutes if you travel local roads compared to the expressway. Another advanced API is Geofencing. Say you have a vehicle that should be operating on a certain route, or in a certain area. Likely, you do not want your vehicle to deviate from the route you’ve set. You can use the Geofencing Extension API to set up an alert if that vehicle gets off track, or if it leaves a defined area like a warehouse or a harbour. Similarly, you can use geofencing to reverse this case and alert when things are getting close. If you are operating a loading dock and you’re planning the order that trucks will pull into bays and your crews need to be ready, the Geofencing Extension API can be used to alert when the next truck is 10 minutes away, and your crews can prepare appropriately. Frankly, all of this is awesome. This is genuinely awesome, and I can’t wait to share our capabilities with you. When you’re ready to get started, come and sign up at https://developer.here.com/plans – Thanks!", "date": "2018-08-01"},
{"website": "Here", "title": "HERE topples Google to become the #1 location platform! Thanks to you, developers!", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-topples-google-to-become-the-1-location-platform-thanks-to-you-developers", "abstract": "Beating out Google, Apple, MapBox and others, industry-leading tech and communication firm Ovum names HERE the #1 provider of location mapping and navigation services There are plenty of awards out there, but this one really hits home. For the first time, HERE Technologies surpassed Google to become the world’s leading location platform in a highly competitive and dynamic industry. According to its latest biannual report, Location Platform Index: Mapping and Navigation , the industry-leading research and consulting firm Ovum ranked HERE number one after assessing 14 other vendors according to mapping and technology offerings as well as developer relations and outreach. I couldn’t be more excited to say our efforts in building and scaling the developer community with an embrace of a developer-first mentality was what made the difference. For the last three years, HERE outscored all of our market competitors in overall “completeness.” This year, we scored the highest in overall ranking thanks to a few exciting advancements in our developer relations program, including the introduction of our Freemium plan for developers. To me, the award acknowledges something we’ve known all along: that you, the developer, are the cornerstone, the fundamental part that defines the success of any platform. We at HERE not only understand this, we’ve embraced it. It’s been an effort to convince, not confuse, our community, and we’re proud that Ovum took notice. We have simplified our pricing model — not only have we made it effortless to get started, but we’ve also removed any barriers to get started. No credit card required, no long account creation and no head scratching to figure out pricing — all the APIs, are the same price all the time. Simple! Ovum seems to agree, writing in their report: “HERE’s new developer hub and pricing model will help it gain further traction with developers, particularly given the dissatisfaction with the controversial new pricing policy for Google Maps.” Analysts Eden Zoller and Charlotte Palfrey add that the plan “appears more developer friendly and competitive than the new Google Maps model, which should play to HERE’s advantage and bring long term benefits in terms of HERE’s reach.” We believe it all comes down to people. So, if this latest award from Ovum is any indication, it means we’re doing something right. But how can we maintain that momentum in our mission to empower every developer to succeed and enjoy using the HERE location platform ? Look for more onboarding improvements, better developer dashboards, and a slew of new products next year. I’m super excited about the future, one that will see us branching out from location services to a fully integrated open location platform. It feels great to be recognized for our maturing developer program by a world-class player like Ovum. It’s certainly a testament to all the hard work at HERE and beyond. So, let’s take a moment and enjoy the score, but remember that we’re focused on moving forward with your help. When you’re powering an autonomous world, no one can do it alone. This conversation is just getting started! Download the full report here.", "date": "2018-08-22"},
{"website": "Here", "title": "Predictive Routing Using Traffic Patterns", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/predictive-routing-using-traffic-patterns", "abstract": "I am fortunate to work for HERE Technologies because of the flexible work hours. Instead of waking up dreading how bad Bay Area traffic is, I can ask the question -- what time *should* I leave for work to minimize the time it takes to get to the office. If you read our 360 blog post today Understanding the Depth of Traffic Services Available for Developers you can learn a few things about our premium offerings. The dataset used for our Traffic Service is much deeper than the set of red and yellow lines you see on a map. The tools we provide for reporting and updating traffic utilize billions of GPS data points every day. We use more than 100 incident reporting services, data captured from connected-car sensors, smartphones, personal navigation devices, fixed road sensors, smart-enabled commercial vehicles, and expert monitors observing accidents and construction, 24/7/365. The HERE patented algorithms process the accumulated data in real-time and produce an updated traffic picture every 60 seconds -- and we do this at a global scale done with machine learning based models.  It's very cool, but unfortunately I can't share the details of how that works with you now.  Instead, let's walk through a single-page demo that demonstrates using this data from the Traffic Service to get from Mountain View, CA to Berkeley, CA at two different times of day. 04:30 16:30 The demo has a control panel so that you can edit the start and end locations, modify the day of the week and departure time with a slider to see the impact on traffic time and route.   To run, you can download the full listing and sign up for your own developer account with an app_id and app_code. Reach out or comment if you have any questions or want to learn more about traffic services.", "date": "2018-07-27"},
{"website": "Here", "title": "August 2018 Release Highlights", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/august-2018-release-highlights", "abstract": "Before jumping into this month's API release updates there was an exciting change this month.  If you haven't already read about Our HERE Freemium Developer Plan in Detail , you can now use nearly all of our APIs for free, up to 250,000 transactions per month.  You can use more APIs and features including access to our Premium Mobile SDKs for iOS and Android, including offline maps and turn-by-turn navigation for up to 5,000 monthly active users. Head over to the pricing page to learn more. If you have questions, take a look our FAQs or contact us at selfservesupport@here.com . Now on to what's new this month in some of our APIs.  Many minor updates but a few noteworthy changes related to the following services: Geocoder API , Routing API , Custom Routes API , Route Matching API , Toll Cost Calculation API , and the Mobile SDK User Interface (UI) Kit . HIGHLIGHTS Parameter now allows you to ignore waypoint access restrictions for vehicle types in the Custom Routes API . Additional attribute layers information can be returned directly in the response in Route Matching API . Ferry cost and ferry type support in Toll Cost Calculation API . New HERE Mobile SDK User Interface (UI) Kit. SERVICES GEOCODER API Convert street addresses to geo-coordinates and vice-versa with forward geocoding, including landmarks, and reverse geocoding. Version 6.2.163 Improvements for Eircodes, Ireland's postcode system, that consists of a seven character alpha-numeric code made up of a routing id and unique identifier. To improve location accuracy many new Interpolated point addresses are now available in the USA.  This will show up as matchType=\"interpolated\" in the returned response indicating scenarios where a single building may include multiple units but searching for the location of one unit can be interpolated. ROUTING API Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Version 7.2.95 Added Portuguese and Polish language translations for route summary text -- see Languages in the documentation for a complete list of the 100+ supported languages codes you can include in your routing request. CUSTOM ROUTES API Build custom routes considering your own road restrictions and geometries. Version 2.5.7 Router can reach way points even if they are forbidden for the vehicle type by using the &ignoreWayPointVehicleRestriction parameter by specifying a radius in meters.  See the calculate route documentation for more details. ROUTE MATCHING API Match GPS traces to the HERE road network. Version 2.5.7 New Route Matching API attributes were added for: Conditional Speed Limits, Variable Speed Limits, Truck Restrictions, Turn Restrictions, Toll Booths, Toll Links, and Traffic Signs.  See More Attributes for each Route Link for a list of the 20+ layers supported in the Match Route Response . RouteLinks represent the matched route as a connected sequence of road links.  The response now also details the offset from the reference node when route is only partially driven from first link, last link, and u-turns as described in the Match Route Response . TOLL COST CALCULATION API Calculate tolls for international driving routes. Version 2.5.7 One if by land, toll if by sea.  Ferry cost accuracy (estimated, average, precise) and ferry types (boat, rail, and my favorite -- hovercraft!) included in calculations. HERE MOBILE SDK UI KIT Version 1.3.1 Deliver missing and updated strings Route planner improvements Integration of the HERE SDK 3.7 Support for Xcode 9.4 More details found in the release notes of downloaded package Android: http://android.uikit.dl.developer.here.com/uikit-android-release-1.3.1-13.zip iOS: http://ios.uikit.dl.developer.here.com/uikit-ios-release-1.3.1-12.zip", "date": "2018-08-16"},
{"website": "Here", "title": "September Event Radar", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/september-event-radar", "abstract": "You might be wondering what a developer evangelism team does in the summer when the weather gets hot. Well, in our 2018 Summer/Fall collection, we fly around to share our good news with you. You might also be wondering what good news is being referred to here. It is Freemium ! Bear with us while we are in our dating-the-drummer-gotta-tell-everyone phase regarding Freemium. We know we have said it couple of times by now. Make no mistake, you will hear about it even more if you come and join us at one of the following events. droidcon August 27-28, NYC, USA https://www.nyc.droidcon.com/ We have our evangelists speaking at this event on one of the trending topics of our era: ride sharing! If you are in NYC, you wouldn’t want to miss this! hacknbreak September 2-9, Izmir, Turkey http://hacknbreak.com/ We’ll be joining this open innovation camp to mingle with the young and bright of Turkey. Having a sea view doesn’t hurt - experts say. Got our SPF 50+ ready, can’t wait! If you want to come and treasure-hunt and/or hack with us, register now! Disrupt SF Sept 5-7, SF, USA https://techcrunch.com/events/disrupt-sf-2018/ We are all over the place, it isn’t possible to miss us if you are attending this year’s Disrupt! We are very serious, come by our booth and say hi. You might also want to drop by our workshop on Sept 7th to get to know us a little better. Webinar: Switch to HERE Sept 6, on Twitch.tv Our team has prepared our very first webinar on switching to HERE after our amazing Freemium plan! They will be streaming live from Disrupt SF. API World Sept 10-12, San Jose, USA http://apiworld.co/ It’s one of the unique chances to meet with us and judge us by our booth, workshop and speech – the whole package! If you are a judgmental one - like almost all of us - drop by and prepare to be surprised! GeoMonday Sept 10, Berlin, Germany http://geoit.org/talks/ If you live in Berlin, by now you might be aware that we don’t let a GeoMonday happen without us. Recent Berlin weather might have broken our epidermis, but it hasn’t damaged our spirit yet! Come join us at the 19th edition of GeoMonday. Grace Hopper Sept 26-28, Houston, USA https://ghc.anitab.org/ We are aware that it still not a gender balanced ecosystem out there. Being aware is not enough, we also want to support you and share our own experience with you. Self-doubt and glass ceiling will always be there if we choose to let it. We want to empower more women to be bold and support each other. If you are attending, make sure you drop by our booth to chat.", "date": "2018-08-28"},
{"website": "Here", "title": "Spotlight on Data Science: Gavril Giurgiu", "author": ["Ian Roderick"], "link": "https://developer.here.com/blog/spotlight-on-data-science-gavril-giurgiu", "abstract": "You're a Principal Data Scientist working on the Open Location Platform (OLP) Customer Solutions Team at HERE, based in Chicago. What do you do? I lead a team working on multiple data science projects, including customer data analytics, location algorithms, and data science tutorials for new OLP users. Tell me about yourself. I am a physicist by training. Before HERE, I spent a lot of time doing statistical analysis of data collected by large physics experiments. Data was accumulated over years and amounted to many terabytes. It was processed using thousands of CPUs, running for weeks, at a time when Hadoop and Spark did not exist and the term “Data Science” was not yet invented (failed jobs had to be resubmitted manually, multiple times; that was the not-so-fun part). During those years I developed a passion for squeezing information out of large and messy data samples using statistics and machine learning. I joined HERE in 2012 as part of the Traffic organization. In 2014, we joined the Auto Cloud Services organization, where we worked on clustering of road objects[1], historical speed profiles[2,3] and personalized recommendations[4,5]. Most recently, our focus has been to support our partners to solve their analytics problems on the Open Location Platform (OLP). We are working on analytics tutorials for new OLP customers, on location algorithms (such as distributed clustering and most probable path), and provide data science support for various projects, including the OLP weather and vehicle sensor analytics. What’s a specific problem or class of problems you’re trying to solve with data science? One problem that we have been working on, in both Auto Cloud Services and now in OLP, is clustering of observations from connected vehicles[1]. As a vehicle drives along the road network, its sensors identify various road objects and events, such as traffic signs, markings on the pavement, poles on the side of the road, potholes, speed bumps, slippery areas, accidents and many others. All these observations can be used to update our map and road conditions in real time. This source of data is complementary to the data collected by the HERE True cars. The HERE True car data is of very high quality, but it’s generated by only a few hundred vehicles, which cannot capture the road conditions and changes all over the world in real time. The crowdsourced data from OEMs is collected from millions of connected vehicles, constantly scanning the roads and providing us with real time updates. However, the crowdsourced data is never the same quality as that of HERE True vehicles. To deal with such problems, instead of using single observations to update the map, a safer option is to cluster together many observations of the same object/event, coming from multiple vehicles. The more observations in a cluster, the better the position estimate and the higher the confidence in the existence of the object/event. Clustering methods can be applied not only to vehicle observations but pretty much to any location points which are associated with a certain geographical area. For example, one can cluster GPS positions associated with a point of interest to better position them on the map. What have been the biggest challenges? One of the biggest challenges is the collection of large scale “ground truth” or “labeled” data, needed to validate and optimize our algorithms and in any kind of supervised machine learning analysis. It is a laborious and costly process which we, as a company, are continuously trying to improve. What have been the biggest successes? One of our successes was a PoC in which we have shown that vehicle sensor data can be used to identify and precisely localize traffic signs, and by extension any other road objects/events, using unsupervised learning techniques such as clustering. We have successfully applied similar techniques to localize road surface anomalies (such as potholes or speed bumps) using sensor data, which proves the feasibility of a potential “Road Roughness” product using OEM sensor data. We have also built the first high resolution speed profiles using both HERE probe data and OEM sensor data [2,3]. We expect that speed profiles will play an important role in the future of autonomous navigation. Do you see any other applications for what you’ve been doing with data science inside or outside of HERE? Let’s take the speed profiles. I can see a time in the future when all vehicles on the road communicate with their neighbors and drive as synchronous platoons. Most probably, there will be a speed profile optimal for each platoon, on each road and for the corresponding road conditions. We will be the providers of these optimal speed profiles. Another example is clustering. Observations of road changes, by connected vehicles, have to be continuously clustered to confirm these changes and properly localize them. This will enable continuous map and road conditions updates in real time, improving the driving experience. What resources would you recommend for someone just starting out with data science? One of the introductory books I liked was Introduction to Statistical Learning by Hastie and Tibshirani. They also have a more advanced text called Elements of Statistical Learning and an online class based on these books. In addition, I would take Andrew Ng’s Machine Learning class with Coursera. Another good starting point is https://www.kaggle.com/ . How do you stay on top of developments in data science? There are so many developments that I am afraid it’s hard to stay on top of them all. I’m trying to browse through the latest papers on https://arxiv.org/list/cs.AI/recent and https://arxiv.org/list/stat.ML/recent , but I have to admit that my to-read list is growing beyond control. Within our team, we find interesting data samples, news and FAQs on Kaggle and KDnuggets . Learn more about Gavril and connect with him here . References [1] A. Anastassov, D. Jang, G. Giurgiu, “ Analysis of OEM sensor data for determination of speed sign placement on road maps ”, 22nd ITS World Congress, 2015 Bordeaux [2] D. Jang, G. Giurgiu, ” Human driving behavior ”, 22nd ITS World Congress, 2015 Bordeaux [3] A. Anastassov, D. Jang, G. Giurgiu, “ Driving speed profiles ”, IEEE Intelligent Vehicles, 2017 [4] Y. Zhao, D. Ayala, D. Jang, G. Giurgiu, “ Smart recommendations for drivers ”, 22nd ITS World Congress, 2015 Bordeaux [5] J. Thompson, Y. Zhao, D. Jang, G. Giurgiu, “ Feature selection in a personalized refueling recommendation system ”, Transportation Research Board (2016)", "date": "2018-08-30"},
{"website": "Here", "title": "Display HERE Maps within your Angular Web Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/display-here-maps-angular-web-application", "abstract": "It is incredibly easy to include a map within your web application using the HERE JavaScript API as long as you’re using vanilla JavaScript, but how do you include a map in your application if you’re using one of the more popular frameworks like Angular? Frameworks like Angular typically have a transpile process and a specific way to do business. We’re going to see numerous approaches to including a map in your Angular application using the HERE JavaScript API and how easy it is to do so in comparison to vanilla JavaScript. The goal of this project will be to render a map that looks like the following: While it is a basic project, we’re going to see two different approaches towards solving the problem with Angular. The Requirements There are a few requirements that must be met prior to developing a web application with Angular and displaying a map on the screen. The Angular CLI must be installed and configured. A HERE developer account must have been registered with an App ID and App Code available. If you’re new to Angular, the Angular CLI can be obtained through the Node Package Manager (NPM). A HERE developer account can be created for free from the Developer Portal . Creating a New Angular Project with the Angular CLI With the development prerequisites in place, the next logical step is to create a fresh project to work with. Somewhere on your computer, execute the following command from your command line: ng new here-project The above command will create a new project directory with the appropriate Angular boilerplate files. With the project created, the appropriate JavaScript libraries must be loaded to work with maps and the other location services. Open the project’s src/index.html file and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> In the above HTML markup, notice that the scripts are loaded before the <body> tag closes. This will eliminate the risk of any render blocking JavaScript. At this point in time, we can start developing an application that includes a map. Including a HERE Map within your Angular Component The first approach towards including a map component in our application is convenient, but probably only for the short term and not at scale. Neither approach is wrong, but it is a good idea to look at both approaches. Open the project’s src/app/app.component.html file and include the following: <div #map style=\"width: 1280px; height: 768px\"></div> If you’ve read the official documentation for the HERE API with JavaScript, the above line might look loosely familiar. Basically it is going to act as a container for the map component. However, we are no longer working with an id and instead are working with a #map . The #map acts as an Angular template variable which is more appropriate when trying to work directly with the DOM rather than using data bindings. Now open the project’s src/app/app.component.ts file so we can add our TypeScript logic that performs the bulk of our work: import { Component, OnInit, ViewChild, ElementRef } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n    title = 'here-project';\n    private platform: any;\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    public constructor() {\n        this.platform = new H.service.Platform({\n            \"apikey\": \"API_KEY\"\n        });\n    }\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() {\n        let defaultLayers = this.platform.createDefaultLayers();\n        let map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.vector.normal.map,\n            {\n                zoom: 10,\n                center: { lat: 37.7397, lng: -121.4252 }\n            }\n        );\n    }\n\n} In the AppComponent class we are creating a ViewChild variable using the #map variable name and assigning it to a TypeScript variable that we can continue to use. In the constructor method we are initializing the HERE platform service using the App ID and App Code that we obtain through our developer account. The constructor method is triggered when the component is created. This takes us to the ngAfterViewInit method which is triggered after the HTML view is initialized. Because we are working with a UI component, it is not a good idea to run any map related code until we’re sure the UI has rendered. When we initialize the map, we use the mapElement variable that is linked to the HTML. You can test the application by executing the following from your command line: ng serve In this scenario everything is more or less hard-coded and is not really able to be recycled within the application. The second approach is going to change this. Developing a Map Component with Custom Input Attributes The next approach is to create a component to strictly maintain the map and nothing else. Within this component we can define input attributes so values can be defined via HTML attributes and not directly in the TypeScript. With the command line within your project’s path, execute the following command: ng g component here-map The above command will create a new Angular component and link it within the project’s src/app/app.module.ts file. Open the project’s src/app/here-map/here-map.component.ts file so we can define the core logic: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    private _apikey: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    @Input()\n    public width: any;\n\n    @Input()\n    public height: any;\n\n    public constructor() { }\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() {\n        let platform = new H.service.Platform({\n            \"apikey\": this._apikey\n        });\n        let defaultLayers = platform.createDefaultLayers();\n        let map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.vector.normal.map,\n            {\n                zoom: 10,\n                center: { lat: this.lat, lng: this.lng }\n            }\n        );\n    }\n\n} The above code is similar to what we’ve already seen, but not quite the same. We are creating a reference to a #map variable within our HTML, but we are also creating references to possible inputs. After the view initializes, the input values are used to initialize the map. Let’s look at the HTML markup that pairs with our TypeScript. Open the project’s src/app/here-map/here-map.component.html file and include the following: <div #map [style.width]=\"width\" [style.height]=\"height\"></div> The above HTML also looks similar to what we’ve already seen. However, this time we are binding the public width and height variables from the TypeScript to the styling of the element. Eventually, these width and height values will be defined by the user. Now let’s make use of our new Angular component. Going back to the project’s src/app/app.component.html file, wipe out what’s currently in there and include the following: <here-map _apikey=\"API_KEY\" lat=\"37.7397\" lng=\"-121.4252\" width=\"100%\" height=\"835px\"></here-map> We’re going to break down what is happening in the above custom HTML tag. The here-map name is derived from our TypeScript file. In the TypeScript file you’ll notice that our selector is actually here-map . All the attributes on this custom tag are actually the inputs that we defined in the TypeScript file. By creating a component for our map, I personally think it becomes easier to manage in Angular. Conclusion You just saw how to use maps in your web application built with Angular and the HERE Maps API for JavaScript . Generally the setup for JavaScript UI components require a bit more configuration than vanilla JavaScript, but as you’ve seen, it isn’t too bad. With custom tag attributes, you could link up other aspects of the API to include markers or something else, all of which we’ll explore in future Angular tutorials. Last Updated: 2020-10-06", "date": "2018-09-05"},
{"website": "Here", "title": "HERE with React - A Location Based TODO App", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/here-with-react-location-based-todo-app", "abstract": "With the HERE JavaScript API you typically find samples on this blog and in the documentation that use plain old JavaScript. This can be helpful if you suffer from Yet Another JavaScript Framework Syndrome as the examples apply whether using Backbone, Meteor, Ember, Angular, Vue, or React. The truth is though that sometimes a little help integrating with these libraries and frameworks can be useful so let's kick off some posts to explore working with some popular JavaScript frameworks. Today, I’m going to start by diving into React to build a TODO application that takes into account where I need to be to complete a task. I don’t “buy milk” while at home nor do I “cut the grass” when I’m at work. I want my TODO application to be smart and only show me tasks that make sense for where I am or where I’m going. TodoMVC If you are unfamiliar with TodoMVC , it was started by Addy Osmani and Sindre Sorhus sometime around 2012 with the help of many contributors over the years as “a project which offers the same Todo application implemented in most of the popular JavaScript MV* frameworks of today — think of it as speed dating for frameworks.” ( 1 ) With the TodoMVC React implementation as a starting point we’re going to start adding location features. [ ] Add latitude and longitude with a TODO React component [ ] Display TODOs with a marker on a Map component Additionally, there is a little bit of housekeeping to update the sample with the latest ES6 and React functionality. // TODO: Run “Hello World” There are at least two paths for getting a “Hello World” started quickly. If you are more of a deconstructionist that wants to start with a working app and take it apart to understand how it works: You should be able to view http://localhost:8000 and navigate to the React example found in examples/react . If you are more of a constructionist and want to start with a blank slate and build up by adding piece by piece: I prefer this approach, so when create-react-app finishes you should be able to view http://localhost:3000 with live reloading and a basic Hello World React App. // TODO: Add A Component A React component is a structure for creating independent, reusable pieces of a user interface. The component accepts properties as input and returns a React element that can be rendered. TodoMVC originated with a goal of implementing an architecture by which the M odel, V iew, and C ontroller were independent. React aims to not artificially separate technologies such as JavaScript from HTML/CSS but rather separate concerns with loosely coupled components that contain both. The Reactjs.org Main Concepts goes into more detail on this design approach. Review the following component source. It defines a simple text input box that defaults to the current location. There are inline comments to help describe some of the logic. // TODO: Add a Map For the map, we’re going to use the Map Image API which provides a quick and easy way to fetch a static image. The parameters take some getting used to but let me unpack the basics here: w=600 specifies the width of the image tile requested and h=300 the height z=10 specifies the zoom level t=5 specifies the rendering scheme so you can choose from various styles of map tiles including satellite, transit, etc. poitxs=1 , poitxc=black , and poitfc=yellow specifies the point of interest size, background color, and foreground color app_id=... and app_code=... are found in the here developer projects section and needed for working with any HERE APIs. Each of these parameters could be stored as either props or state on the component to provide rich customization options to users. The last parameter we want to send to the Map Image API is the poi= for a comma separated list of latitude and longitude for any markers we want to place. In the case of my TODO app, I’ve added two tasks with locations: “Return Library Book” at 37.86836, -122.26859 “Pickup Badge for TechCrunch” at 37.784117,-122.401386 The poi query we’d want to make for these todo items would look like poi=37.86836,-122.26859,37.784117,-122.401386 . Here is an example of the Map component that will re-render with each setState() call when adding points of interest: Once defined, you can reuse this component in any other component such as the root app component. // TODO: Wrap It Up This first post introduced TodoMVC with a couple of very basic React components that leverage the HERE Map Image API. In upcoming React posts I’ll dive deeper into this example to respond to state changes with event handling for geocoding lookups, map clustering for TODOs at the nearby locations with conditional rendering, Matrix Routing to get between TODO locations efficiently, Place Search to find related TODO items, and a few other project integrations to polish up the final todo app. If you haven't yet, sign up for a freemium account to get access to use HERE services to build your own TODO app.  You can follow the developer blog RSS feed to find updates as new articles are published or look for updates in the developer newsletter. Want More ReactJS? Use HERE Interactive Maps with ReactJS to Pick a Theme HERE Matrix Routing with ReactJS to Optimize Your Black Friday Street Address Validation with ReactJS and HERE Geocoder Autocomplete More ReactJS Blog Posts...", "date": "2018-09-04"},
{"website": "Here", "title": "Finding my Dream Home with Isoline Routing", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/finding-my-dream-home-with-isoline-routing", "abstract": "I went to my local bakery recently to get some sugary treats in order to celebrate the launch of our new Freemium plan and I made two observations. First, Berliners insist on calling a Berliner a Pfannkuchen and I’m sorry but that’s just wrong . (If you’re not German, this probably doesn’t make sense to you. You can safely move on, this paragraph is in fact entirely irrelevant for anything to follow.) Second, I don’t live in a good neighborhood. I can tell, because I paid with a 10€ bill and the lady at the bakery ran it through a machine to check if it was counterfeit. Let that sink in. I live in a place where people pay for bread with fake 10€ bills. We’ve been thinking about moving, and I can't say that this incident has done much to change my mind. That’s not to say that moving is easy. As with many things, location matters. For example, we’d like to move to a location where drunk Dutch teenagers don’t vomit on the sidewalk quite so much. In fact, I’d probably prefer a place entirely devoid of drunk Dutch teenagers or the buses the come in on. More importantly (and like most people), I’d like to live in a place from where I can get to the office in finite time. 30 minutes is fine. More than that and those Dutch teenagers don’t seem so bad anymore. Unfortunately, it can be a bit of chore to figure out how of a drive it is to the office, when looking at a lot of apartments. Fortunately, I’m a developer and I have access to the world’s greatest location technology platform. Surely there’s an API that can help? First, don’t call me surely. Second, there really is an API for that! Meet Isoline Routing , a pretty neat feature hiding in our powerful Routing API. What Isoline Routing does, is to give you an area that can be reached within a certain time frame or driving distance. (By the way, Isoline Routing used to be one of our advanced APIs, unavailable even through our paid plans, but with our new Freemium you can now call this API 250.000 times a month. For free! How neat is that?) As an example, consider a ride hailing app. When a user calls for a ride, you may want to check with all drivers who are no more than 5 minutes away if they want to accept this ride or not. Now you could simple ask all drivers within a certain radius. This seems fine, but what if one of those drivers is on the other side of the river? She probably won’t reach the customer for a long time. Unhappy customer, unhappy driver, not a great choice. You could also call the Routing API for every single driver (maybe bounded by some radius) to check driver availability, but that’s inconvenient and slow. What you should do instead is use the Isoline feature of the HERE Routing API to find the area from which the customer can be reached in five minutes. Once you’ve done that you can simply ask all drivers within that area whether they want to accept the ride or not. Here’s an example from London, with someone hailing a ride near the National Theatre after suffering through a performance of War Horse, having been dragged there by a friend who really should have known better. As you can see, five minutes of driving doesn’t get you very far in London, and it certainly doesn’t get you on the other side of the Thames, so good thing we didn’t just use a radius. Anyway, back to apartment hunting (and let’s take a moment to be grateful we’re not looking for an apartment in London). We can apply the same principle to our search. For example, we could only consider apartments that are within a 30 minute drive of the office. Let’s have a closer look at the Isoline Routing API and build a little application in JavaScript to help us do this. First, we need to set up a map. You can check out the JavaScript Maps API documentation for more details on this. Then we need to create an instance of our routing service. Whenever we click on the map we want to see a 30 minute isoline around that location, so we need to register the ‘ tap ’ event with the map to react to the user’s click. The ‘ tap ’ event gives us the screen coordinates of where the user clicked, so we need to convert that to latitude and longitude in order to use it in the Isoline API call. The screenToGeo () method does just that. To start our Isoline Routing API call, we need to first set up our routing parameters and then call the function calculateIsoline on the routing service instance we’ve created earlier, providing callbacks for the results and errors respectively. Let’s look at these parameters now. mode : Isoline Routing supports car and pedestrian modes. We can also choose whether to take traffic into account. Since traffic plays a big part in our commute, we want to enable this. start : The location of our office from which we’re trying to reach our apartment. You can also replace this with destination if your looking for all roads from which you can reach this office within 30 minutes (this is what we would have chosen for our ride hailing use case earlier). This may seem like the same thing, but one-way streets, etc. can lead to different results. You may want to check both for your commute. departure : This is an optional parameter which let’s you set the time of departure. This matters for traffic. You probably want to check for results during rush hour. Play with this parameter to see how traffic patterns change the results during the day. rangetype : This determines whether you want to create an isoline for time or distance. For our commute we mostly care about how much time we’re spending in the car, not how long the drive is. If you care mostly about fuel economy, you can also search for consumption . range : In our case, the range is the time we are willing to drive. This is in seconds, so for 30 minutes we need to set it to 1800. There are many more parameters, so please check out the Routing API documentation for more details. Finally, we need to handle the response and draw the isoline on the map so we can compare it against apartment locations. We’re not going to go too much into detail here, so again check out the documentation for more info on how to draw shapes on the map. If we run this, we should now be able to click on the map and get an isoline. Even better, we can click again and get another isoline! After all, your significant other probably has a job and an office, too. That way you see where the isolines overlap and can find the perfect place to live. Well, “perfect”. Unfortunately the API currently does not take the density of drunk Dutch teenagers into account. We’re working on it.", "date": "2018-08-07"},
{"website": "Here", "title": "Transportation Routing and Directions in an Angular Application with the HERE Routing API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/transportation-routing-and-directions-in-an-angular-application-with-the-here-routing-api", "abstract": "When I think of maps and location services, the first thing that comes to mind is GPS routing and navigation. Having a map is great for finding places and other points of interest, but navigating between points of interest is awesome. However, how might you tackle such a task when it comes to finding the fast route between two points? Do you have to create your own graph of points and traverse through them manually? This isn’t an issue when taking advantage of the HERE Routing API . We’re going to see how to create an Angular application that displays a map and allows users to pick two points and find the fastest traveling path between them while showing address directions along the way. Things you’d expect in your car navigational unit or on your mobile device. The goal of this project is to create something like the following image: As you can see in the above image, we have two input fields for a starting and destination position. The map on the screen shows a line which represents the fastest path of travel when using a car. Next to the map we have navigation instructions for traversing the path demonstrated on the map. If we wanted to, we could collect the current position of our device and display it as a marker somewhere on the path to demonstrate progress. Starting with the Angular CLI Assuming that you have the Angular CLI installed and configured, we are going to create a new Angular project. If you haven’t already, I strongly encourage you to take a look at my previous tutorial titled, Display HERE Maps within your Angular Web Application as it goes into further detail around creating an actual map. Most of our focus in this tutorial will be around displaying routing information on the map. From the Angular CLI, execute the following: ng new here-project The above command will create a new project for us. Before we get into any actual development, we need to include the HERE JavaScript libraries in our project. Open the project’s src/index.html file and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> The above two JavaScript libraries act as a baseline for displaying a map and using the HERE services. Other APIs will have other requirements when it comes to the JavaScript components. Now that we have the dependencies in place, we can focus on the development of our map. Creating a Map Component with Directions Box Like I mentioned previously, when it comes to building our map, a lot of the code will come from my previous tutorial on the topic. However, there will be some modifications as we progress. The first step towards displaying a map is to create a dedicated component within Angular. From the CLI, execute the following: ng g component here-map The above command will create a component with an HTML view and a TypeScript file for all the logic. Before we get into the UI portion, let’s create our baseline logic. Open the project’s src/app/here-map/here-map.component.ts file and include the following: import { Component, OnInit, OnChanges, SimpleChanges, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit, OnChanges {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public start: any;\n\n    @Input()\n    public finish: any;\n\n    @Input()\n    public width: any;\n\n    @Input()\n    public height: any;\n\n    public directions: any;\n\n    private platform: any;\n    private map: any;\n    private router: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        this.directions = [];\n    }\n\n    public ngAfterViewInit() {\n        let defaultLayers = this.platform.createDefaultLayers();\n        this.map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.normal.map,\n            {\n                zoom: 4,\n                center: { lat: \"37.0902\", lng: \"-95.7129\" }\n            }\n        );\n    }\n\n    public ngOnChanges(changes: SimpleChanges) { }\n\n} The above code is lengthy, but not a whole lot is happening and it is definitely not complete. The first thing to take note of is how we’re declaring the following line: declare var H: any; Because we don’t have any TypeScript definitions, we need to declare the JavaScript library so that the TypeScript compiler will ignore it and not throw any errors instead. Inside the HereMapComponent class, we have a bunch of variables with an @Input() . These variables represent potential attributes for the HTML component, kind of like the traditional class or id attributes that you’d find on components. Most of our focus will be on the start and finish variables as they will hold our coordinates. Inside the ngOnInit lifecycle hook, we initialize our platform with the app id and app code for our project. To obtain an app id and app code, you’ll need a developer account with HERE. An account can be created for free from the HERE Developer Portal . The directions variable that is initialized in the ngOnInit will eventual have the turn by turn directions for our route. Because the map is a UI component, we cannot begin working with it until the ngAfterViewInit method has triggered. Once triggered, we can create a new map and center it on some coordinates. You’ll notice that we have an ngOnChanges method. We’ll be using the ngOnChanges hook for when component attribute values change in realtime. This will be useful for when the user enters new coordinate information and we need the map to reflect the change. With the base TypeScript in place, let’s take a look at the HTML component for our map. Open the project’s src/app/here-map/here-map.component.html and include the following: <div #map [style.width]=\"width\" [style.height]=\"height\" style=\"float: left\"></div>\n<ol style=\"float: left; background-color: #FFF; width: 35%; min-height: 530px; margin-left: 20px; margin-top: 0\">\n    <li *ngFor=\"let direction of directions\">\n        <p [innerHTML]=\"direction.instruction\"></p>\n    </li>\n</ol> Ignoring my terrible CSS skills, we have two parts to this component. We have the map itself as referenced by the #map template variable and we have an ordered list which loops through our directions variable. We are using the [innerHTML] attribute because the instructions that the HERE Routing API returns is HTML data. With the core map logic in place, we can focus on routing information and navigation instructions. Using the HERE Routing API for Navigation Remember how I mentioned the ngOnChanges hook? This is going to be a critical function towards our routing data and updating the map. However, before we get there, we need to create another function. Open the project’s src/app/here-map/here-map.component.ts file and include the following route function: public route(start: any, finish: any) {\n    let params = {\n        \"mode\": \"fastest;car\",\n        \"waypoint0\": \"geo!\" + this.start,\n        \"waypoint1\": \"geo!\" + this.finish,\n        \"representation\": \"display\"\n    }\n    this.map.removeObjects(this.map.getObjects());\n    this.router.calculateRoute(params, data => {\n        if(data.response) {\n            this.directions = data.response.route[0].leg[0].maneuver;\n            data = data.response.route[0];\n            let lineString = new H.geo.LineString();\n            data.shape.forEach(point => {\n                let parts = point.split(\",\");\n                lineString.pushLatLngAlt(parts[0], parts[1]);\n            });\n            let routeLine = new H.map.Polyline(lineString, {\n                style: { strokeColor: \"blue\", lineWidth: 5 }\n            });\n            let startMarker = new H.map.Marker({\n                lat: this.start.split(\",\")[0],\n                lng: this.start.split(\",\")[1]\n            });\n            let finishMarker = new H.map.Marker({\n                lat: this.finish.split(\",\")[0],\n                lng: this.finish.split(\",\")[1]\n            });\n            this.map.addObjects([routeLine, startMarker, finishMarker]);\n            this.map.setViewBounds(routeLine.getBounds());\n        }\n    }, error => {\n        console.error(error);\n    });\n} Most, not all, of the above code was taken from the official documentation . When calling the route method, we are expecting a source coordinates and destination coordinates to be supplied. These coordinates should be a string and delimited by comma. When we have the coordinate information, we can create our routing parameters. For this particular example we’re going to navigate by car and only have a starting and destination endpoint. After we define our parameters we need to clear the map. Every time we change the data, we don’t want old markers or navigation paths to linger on the map. Once the map is clear, we can calculate the route. Assuming that an actual route exists, we can get the maneuver information for navigation instructions and start constructing our path on the map. A scenario where a route doesn’t exist might be if I want to drive from California to Berlin, it just isn’t going to happen. To create a line with the HERE API, we need to push each of the latitude and longitude coordinates into a LineString variable. With those coordinates we can create a Polyline and give it a color as well as a width. While not necessary, we could create markers to represent our starting and ending points on the map. With all of our objects (line, markers, etc.) we can add them to the map and re-center the map to best fit the routing path. Before we get into the ngOnChange stuff, let’s wire up the route function so it works. First we need to revise the ngOnInit method to the following: public ngOnInit() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.directions = [];\n    this.router = this.platform.getRoutingService();\n} In the above method we are just initializing the router. Then in the ngAfterViewInit method we need to call the route method: public ngAfterViewInit() {\n    let defaultLayers = this.platform.createDefaultLayers();\n    this.map = new H.Map(\n        this.mapElement.nativeElement,\n        defaultLayers.normal.map,\n        {\n            zoom: 4,\n            center: { lat: \"37.0902\", lng: \"-95.7129\" }\n        }\n    );\n    this.route(this.start, this.finish);\n} The start and finish variables that are passed will be whatever data is bound to the component attributes. Finally we can take a look at the ngOnChange method: public ngOnChanges(changes: SimpleChanges) {\n    if((changes[\"start\"] && !changes[\"start\"].isFirstChange()) || (changes[\"finish\"] && !changes[\"finish\"].isFirstChange())) {\n        this.route(this.start, this.finish);\n    }\n} Remember, the ngOnChange hook is called any time one of the component attribute values has changed. So if the start or finish coordinates change, this method will execute. When the method is called, we first need to figure out if one of our start or finish attributes triggered it. If yes, we can call our route function again to clear and update the map. Developing a Functional Angular Application for Routes and Navigation If I haven’t lost you yet, there are a few more things we need to take care of. While we have a functional map and instructions component, it isn’t being used as of now in our application. We need to make use of it. Because we are going to be working with forms, we need to enable such functionality in Angular. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from \"@angular/forms\";\n\nimport { AppComponent } from './app.component';\nimport { HereMapComponent } from './here-map/here-map.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        HereMapComponent\n    ],\n    imports: [\n        BrowserModule,\n        FormsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } In the above code you’ll notice that we’ve imported the FormsModule and added it to the imports section of the @NgModule block. It is simple and a little annoying that we have to do it at all, but it is necessary for Angular. The next step is to add some brief logic for initializing our form variables. Open the project’s src/app/app.component.ts file and include the following: import { Component, OnInit } from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    public start: string;\n    public finish: string;\n\n    public constructor() {\n        this.start = \"37.7397,-121.4252\";\n        this.finish = \"37.6819,-121.7680\";\n    }\n\n    public ngOnInit() { }\n\n} While of no direct relevance to the variable naming in the map component, the start and finish variables will be bound to our form. Open the project’s src/app/app.component.html file and include the following HTML markup: <div style=\"padding: 10px 0\">\n    <div>\n        <label style=\"display: inline-block; width: 60px; color: #FFF\">Start</label>\n        <input type=\"text\" [(ngModel)]=\"start\" />\n    </div>\n    <div>\n        <label style=\"display: inline-block; width: 60px; color: #FFF\">Finish</label>\n        <input type=\"text\" [(ngModel)]=\"finish\" />\n    </div>\n</div>\n<here-map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" [start]=\"start\" [finish]=\"finish\" width=\"60%\" height=\"530px\"></here-map> There are a few things to note in the above markup, ignoring my lack of CSS skills. Each of the two inputs are bound to our variables and those same variables are bound to the map component via the attributes. As the data in the forms change, so will the data in the map because of the ngOnChange method. In this example, I’ve chosen not to include my app id and app code values. Make sure to update those with your own. Conclusion You just saw how to use the HERE Routing API to find the quickest path of travel between two positions on a map using Angular . In this example we took a map, rendered a line as well as markers on the path, and then printed out the turn by turn directions on how to traverse that path. As previously mentioned, if you were using a device that had GPS, you could add a marker on the map to represent your current position in relation to the starting and ending points.", "date": "2018-09-17"},
{"website": "Here", "title": "Pub Crawl with HERE", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/pub-crawl-with-here", "abstract": "I am a student in the beautiful city of Berlin! While we had an almost tropical summer this year, on any given day, I had two major goals. First, chill by the river during the day. Second, enjoy the nightlife of Berlin. While the scorching sun didn’t let me do the former most days, I have my pockets to blame for not letting me do the latter. My friends and I even tried to make a list of awesome but cheaper pubs that we could hop to. Who were we kidding? Berlin is huge and has countless pubs and bars. We were never going to finish that list. The nerd in me had an idea! Why not make an app which will navigate me through a pocket-friendly pub crawl from wherever I am. It was also empowering to be able to solve every day “ problems” with a little bit of coding. I had to figure out a few things though, such as: What does the app actually do? On what device will I be using it? Which APIs do I need. Let's try and answer these questions. First, the app should be able to locate me on a map , search for pubs around me and navigate me through them. I also have an Android based phone (I wouldn't be searching for cheap pubs if I could afford an iPhone). So, I chose the android platform and made sure I had the Android studio set up. Finally, the key points from my ideation were map, location, search and navigate. After going through the documentation, I realized that the APIs I will be needing are: Interactive Maps : To render a map with features suitable for walking around. Positioning : To locate myself on the map. Places : To search for pubs and get their names, location and other details. Routing : To navigate me through selected points of interest. Once the ‘Whats’ and ‘Hows’ were answered, it was time to implement . As daunting as it sounds, it can be achieved when done in small steps. To be able to use these APIs, there is a simple process to be followed. Register for a HERE account with a Freemium plan. Obtain your credentials for the project. (The registered package name must match the package name in your Android project.) Download the SDK. All set for your first app! If you are a novice like me when it comes to making an android app, the Get Started section will help you render a basic app with as few as 6 steps. You can take another route by downloading the examples and taking one of them as the base of your app. I selected the search example as the base for my app. I went through the code and identified the changes I would need to make. Adding functions Tip: Adding the functional modules one by one makes it easier to debug in case you get a bunch of incoherent errors! First, be sure to add a way to ask permissions for using location in the app. You wouldn’t want to violate the users’ privacy. You can do this by creating a request for asking permissions, and then start the main body of the application only if the permissions are accepted. So, let’s go ahead and add all four elements one by one. Rendering a map If you start the project with Quickstart or downloading an example like I did, the map will be already rendered. As it is an app that aims at navigating the user on foot, I added some customization for the map scheme, details like the crosswalks, bridges, stairs and tunnels to make it suitable for a pedestrian use case. I also added the co-ordinates to center the map in Berlin. If you are making the app from scratch, and want to explore more features of the map, you can follow the documentation on Interactive Maps and customize your map fragment with numerous elements Locating Locating yourself on the map is as essential as rendering the map itself. Imagine having a stretched-out paper map in your hand, but no idea where you are on the map. You still wouldn't know where to go. A PositioningManager is a class that manages information collected from positioning devices like speed, location updates etc. and can be used to get current location as well as changes in the current position. Create an instance of the PositioningManager . The PositioningManager collects position information in 3 ways. GPS - the GPS chip in your phone receives information from satellites which is used to calculate the position. Network - Your proximity from the network towers is calculated to give a position. Combination of GPS and Network- Both the above methods are used for better accuracy. I used a combination of GPS and Network and marked the position with a marker. Set your map to center at your current location. I added a cool animation so that the map swooshes over to my location. Check out other map animation options here . Done, you now have your current location in the variable currentLocation . Searching The main functionality of this app lies is searching for places with the right query and sorting the results according to your requirement. The Places API provides us with 4 options to perform the Search and Discovery: Search : Finds a place that match user-defined search terms. Explore : To find interesting places around a location which can be filtered with types of places. Here : To identify places you are already at, to be able to perform check-ins etc. Around : This type of request is intended for applications that employ features such as augmented reality, where places around the user's location are displayed on a device. I chose to use the Search class to search for pubs around me. Although the CategoryFilter has many pre-defined search options like EAT_DRINK , SHOPPING etc., I chose to search with the help of a search string. I limited the result list to 5 results and restricted the search area to a radius of 5km. Once you have framed your request, you can invoke it by calling Here the discoveryResultPageListener is the listener that will handle the result of your request. The result is a DiscoveryResultPage object which represents a paginated collection of items. Depending on your request, the result can be of several such pages. When additional pages of search results are needed, retrieve and invoke the DiscoveryRequest returned by DiscoveryResultPage.getNextPageRequest() . The listed items on these pages can be either a PlaceLink or DiscoveryLink . The PlaceLink can be used to retrieve place details by firing another PlaceRequest . Check the documentation on PlaceRequest . I stored the results of my search query and placed some martini glasses to identify these places - because, why not? Navigating After having the list of places I wish to go to, I want to navigate to them from my current position. Ordinarily, If I know where I am going, I will try to figure out the route I will be taking. If I have more than one destination, I will try to select the route that covers all of them while considering the traffic on the route and overall length of the route. The CoreRouter class does exactly the same for you. It is responsible to calculate routes with cars, trucks, public transport, trucks, scooters, intermodal and pedestrian routing. It requires a plan of your destination with the list of desired stopovers and this can be done with the help of class RoutePlan . A RoutePlan is a container that holds your destinations or Waypoints as they are called here and routeOptions . RouteOptions includes parameters like number of routes expected, mode of transport, direction of travel, routing type- fastest/ shortest. You can add your destinations and stopovers using RouteWaypoint . Once your query is set up, you can request the calculated route by calling the CoreRouter.calculateRoute(RoutePlan, CoreRouter.Listener) method. The Router.Listener has to be written in a way to handle the result of the routing request. The RouteResult class represents a route calculation result. It consists of the Route class which is a distinct calculated path connecting two or more waypoints, consisting of a list of maneuvers and route links. After the route is calculated, it has to be displayed on the map. For this, we have the MapRoute class which is a type of MapObject that displays a calculated route on a map. This jargon has already fried my brains. Let us break it down step by step. Mode of Transport As this is an app for a pub crawl, I chose pedestrian routing as you should not drive when you are drinking. You can also add an option to mix up public transport and pedestrian routing. (Although if you do have a designated driver, you can opt for adding car routing.) There are several route options that you can select to customize your route. You can read about them here . Set other parameters like number of routes and fix your route options. Adding waypoints Add the waypoints to the route which should consist of your current location and the location of the places collected in the place result list. The route plan is now ready to calculate the route by calling the function below. Listener The listener should handle the above request by storing the calculated route and displaying the MapRoute on the map. Don't forget to handle instances where no route is returned due to various reasons like- too many filters, no connecting route etc. To make things easier, I reused the code for the listener which can be found in the routing example on GitHub. This concludes all the elements of the app. \\o/ And that’s how I made my first app using HERE Android SDK. Now this is just a plain version and I am sure you will be able to make a cooler version of this which has more functionalities. What would be interesting is to explore all the parameters of the various classes and customize the app for an amazing user experience. You can add intermodal routing by using a combination of public transport and pedestrian routing. That way you could increase the radius of your search. You could add external references like yelp to your places by using You can add voice instructions with turn by turn navigation. You can also make the app responsible for counting the number of drinks you've had. There is so much you can do. So, go ahead and create your pub crawl app with developer.here.com !", "date": "2018-09-12"},
{"website": "Here", "title": "September Release Highlights", "author": ["Denis Panov"], "link": "https://developer.here.com/blog/september-release-highlights", "abstract": "Many minor updates but a few noteworthy changes related to the following services: Geocoder API , Geocoder Autocomplete API , Routing API , Traffic API , and Custom Route Extension HIGHLIGHTS Improvements in Geocoder API to enhance response details for certain countries Traffic coverage extended by Indonesia New routing parameter and option in Custom Routes API for fuel optimized routing New HERE Mobile SDK User Interface (UI) kit now with first guidance components Geocoder API Convert street addresses to geo-coordinates and vice-versa with forward geocoding, including landmarks, and reverse geocoding. Version 6.2.165 Improvements in reverse geocoding for house addresses Additional Turkish Metropolitan Municipalities added to cities to support matching and responses Administrative changes in responses in the Isle of Man, Jersey and Guernsey Geocoder Autocomplete API Correct misspellings and get better suggestions for your address search with fewer keystrokes. Version 6.2.165 Improvements have been made for postal code results to add more administrative information in the label. Routing API Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Version 7.2.96 Fixed elevation data provided in the route shape Traffic API Display map tiles with real-time traffic flow information overlays reflected as colored lines drawn on affected streets and roads and get access to real-time traffic flow and incident data in XML and JSON. Version 6.0.81.0 Traffic Coverage was extended by Indonesia Custom Routes API Build custom routes considering your own road restrictions and geometries. Version 2.5.8 New routing parameter &maxSpeed=110kph for fuel optimized routing. Assumes lower speed driven bigger roads to save fuel. New option ;builtupFactor=1.8 for routing parameter &customConsumptionDetails for fuel optimized routing. Increases the fuel cost while driving through cities HERE Mobile SDK User Interface (UI) Kit Version 1.4.0 Major changes and features: Scooter routing Deliver first guidance flows & components Route planner improvements Integration of the HERE SDK 3.8 Example apps and a new user guide Note: This release supports only HERE SDK 3.8 due to newly added feature. Please note, this version requires also map update (Map#84.156 released on June 28, 2018 or fresher), so a re-installation of the demo application might be required for a proper use. On Android please delete the hidden folder msdkui-data on the root level of the internal storage to get rid of the old map data. For a full functional application, the license key needs to be extend to support scooter routing. More details can be found in the release notes file inside the zip packages Get the updated packages directly from developer.here.com via this link: - Android: http://android.uikit.dl.developer.here.com/uikit-android-release-1.4.0-124.zip - iOS: http://ios.uikit.dl.developer.here.com/ui-kit-ios-release-1.4.0-126.zip", "date": "2018-09-11"},
{"website": "Here", "title": "Displaying Places on a HERE Map in an Angular Web Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/displaying-places-on-a-here-map-in-an-angular-web-application", "abstract": "If you’ve been following along, I had previously written a tutorial that demonstrated including a visual map in your Angular web application using the HERE Maps API for JavaScript. In that tutorial we saw several methods towards using a map, leading up to creating a custom component for the job. However, in that tutorial we just made use of a basic map with no markers or interaction. Our Angular application could be substantially more useful if we had some interaction with the map. For example, what if we wanted to display all locations of a particular vendor on the map? Or what if we wanted to see address information for a particular vendor? In this tutorial we’re going to see how to use the HERE Places API in an Angular application to search for particular points of interest and display them on a map using markers and captions, also known as information bubbles. The Project Requirements There are a few development requirements that must be met in order to make this tutorial a success on your own server or computer. A HERE developer account must have been created. The Angular CLI must be installed and configured. To use the HERE maps and location services (HLS) platform, you must have an app id and app code created through your developer portal. It is free to sign up and use the HLS platform. The easiest way to develop with Angular is through the Angular CLI . It can be installed through the Node Package Manager (NPM). While not a requirement, much of this tutorial will be a continuation to the previous tutorial I wrote, so it might be a good idea to familiarize yourself with what I had demonstrated previously. Through this tutorial, we plan to create something as seen in the following animated image: As you can see, there will be a map and a search box. After entering a place of interest, all matches will be displayed on the map in the form of a marker. When clicking or tapping on a marker, an information bubble will appear with the name of the place as well as the address. This is a realistic scenario on what someone might expect from a map. Creating an Angular Project with the HERE Maps API for JavaScript As previously mentioned, this is more or less a followup to the previous tutorial I wrote which was a getting started with HERE and Angular tutorial. To get us up to speed, I’m going to share the code from the previous tutorial, but if you want thorough explanations as to why things are the way they are, I encourage you to revisit the previous tutorial titled, Display HERE Maps within your Angular Web Application . From the command line, execute the following to create a new Angular project with the necessary components: ng new here-project\ncd here-project\nng g component here-map With the project and files in place, we need to copy our previous map component code into our new project. Open the project’s src/app/here-map/here-map.component.html file and include the following HTML markup: <div #map [style.width]=\"width\" [style.height]=\"height\"></div> With the UI component in place, we can create some TypeScript logic that will bind the HTML component above. Open the project’s src/app/here-map/here-map.component.ts file and include the following: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    @Input()\n    public width: any;\n\n    @Input()\n    public height: any;\n\n    private platform: any;\n    private map: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n    }\n\n    public ngAfterViewInit() {\n        let defaultLayers = this.platform.createDefaultLayers();\n        this.map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.normal.map,\n            {\n                zoom: 10,\n                center: { lat: this.lat, lng: this.lng }\n            }\n        );\n    }\n\n} The above TypeScript logic should be more or less what we’ve already seen. We have several inputs that can be accessed from the component, we are initializing the HLS platform, and we are creating a new map after the view has initialized. With a map component created and readily available, it can be used in any other component. As seen previously, open the project’s src/app/app.component.html file and include the following: <here-map\n    #map\n    appId=\"APP-ID-HERE\"\n    appCode=\"APP-CODE-HERE\"\n    lat=\"37.7397\"\n    lng=\"-121.4252\"\n    width=\"75%\"\n    height=\"530px\">\n</here-map> Don’t forget to replace the appId and appCode with that of your actual project values, otherwise the map and services will fail to work. The last part to bring us up to speed is the inclusion of the HERE JavaScript libraries. Open the project’s src/index.html file and include the following HTML markup: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> It may seem like we’ve accomplished a lot as of now, but we really just got our map up and running. Everything as of now is not the goal of this particular tutorial. It was included to prevent confusion between configuring a map and using the Places API. If you completed the previous tutorial, everything here should look familiar and can probably be skipped. Now we can focus on the HERE Places API with marker and information bubble support. Implementing Search Functionality with the HERE Places API Because we are planning to use the JavaScript libraries offered by HERE, we need to include a few more in our project. As of right now we have the core library and the map service library, but we need a library for places, events on the map, as well as an interactive user interface. Open the project’s src/index.html file and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1533195059\" />\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-places.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> Notice that this time around we’ve included three more libraries as well as a stylesheet file. This will allow us to do searches, click on markers, and add other behavior to the map. To make use of these new libraries, a few things must be added to our map component. Open the project’s src/app/here-map/here-map.component.ts file and include the following variables: private ui: any;\nprivate search: any; The goal is to initialize the search service and alter the UI behavior to be used throughout the component, hence the global variables. Within the same file, we need to alter the ngOnInit and ngAfterViewInit lifecycle events. The ngOnInit method should now look like this: public ngOnInit() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.search = new H.places.Search(this.platform.getPlacesService());\n} Since the search functionality doesn’t rely on the UI, it can be initialized prior to the view being ready, hence the ngOnInit method. In the ngAfterViewInit method, we need to prepare for some UI and event behavior: public ngAfterViewInit() {\n    let defaultLayers = this.platform.createDefaultLayers();\n    this.map = new H.Map(\n        this.mapElement.nativeElement,\n        defaultLayers.normal.map,\n        {\n            zoom: 10,\n            center: { lat: this.lat, lng: this.lng }\n        }\n    );\n    let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n    this.ui = H.ui.UI.createDefault(this.map, defaultLayers);\n} Even though we’ve just seen a few new things to get marker support, click support, and search support on our map, it was more or less bootstrap code for the bigger picture. Now we want to add some actual functionality. Within the project’s src/app/here-map/here-map.component.ts file, include the following two methods: public places(query: string) {\n    this.map.removeObjects(this.map.getObjects());\n    this.search.request({ \"q\": query, \"at\": this.lat + \",\" + this.lng }, {}, data => {\n        for(let i = 0; i < data.results.items.length; i++) {\n            this.dropMarker({ \"lat\": data.results.items[i].position[0], \"lng\": data.results.items[i].position[1] }, data.results.items[i]);\n        }\n    }, error => {\n        console.error(error);\n    });\n}\n\nprivate dropMarker(coordinates: any, data: any) {\n    let marker = new H.map.Marker(coordinates);\n    marker.setData(\"<p>\" + data.title + \"<br>\" + data.vicinity + \"</p>\");\n    marker.addEventListener('tap', event => {\n        let bubble =  new H.ui.InfoBubble(event.target.getPosition(), {\n            content: event.target.getData()\n        });\n        this.ui.addBubble(bubble);\n    }, false);\n    this.map.addObject(marker);\n} So what is happening in the places method and the dropMarker methods? Let’s first examine the places method. In the places method, we are removing any objects that might already exist on the map. This includes markers, events, etc. This is because every time the places method is called, we are trying to add new markers. It probably wouldn’t be a good idea in this scenario to append new markers to the already existing list. It makes more sense to start fresh. Once the map is cleared, we issue a search based on a provided query string. The query string represents some point of interest. We are also providing a latitude and longitude for the general search area rather than an entire global search. For any results that are found, we loop through them and call the dropMarker method. In the dropMarker method, we are expecting some coordinate information as well as some data to be used to create an InfoBubble . Using the coordinate information we can create a marker. The marker is going to store the data that was passed which should include the place title as well as the address or vicinity. The data contains a lot more information, but for this example we’re not interested in it. We need a way to display the data, so we can create a click event. When a marker is clicked, a new information bubble is created where the content is the stored data. This bubble is added to the UI and the marker is finally added to the map. So how do we use these places and dropMarker methods? For this example, it makes sense to have a search form within our application to populate the location results. However, in Angular forms don’t really work by default. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from \"@angular/forms\";\n\nimport { AppComponent } from './app.component';\nimport { HereMapComponent } from './here-map/here-map.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        HereMapComponent\n    ],\n    imports: [\n        BrowserModule,\n        FormsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } In the above code we’ve included the FormsModule and added it to the imports section of the @NgModule block. Now we can use forms within our Angular application. As seen in the image at the beginning of this tutorial, we had a search form with a pre-populated string of text. To do this, open the project’s src/app/app.component.ts file and include the following: import { Component, OnInit } from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    public query: string;\n\n    public constructor() {\n        this.query = \"starbucks\";\n    }\n\n    public ngOnInit() { }\n\n} The query variable is going to be bound to the form and it is also going to be used when searching for places and populating the map. It had to be declared in the TypeScript file to prevent any undefined errors. Finally, the project can be brought to a close with the core UI of the application. Open the project’s src/app/app.component.html file and include the following: <div style=\"padding: 10px 0\">\n    <input type=\"text\" placeholder=\"Search places...\" [(ngModel)]=\"query\" />\n    <button (click)=\"map.places(query)\">Search</button>\n</div>\n<here-map #map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\" width=\"75%\" height=\"530px\"></here-map> In the above HTML markup, there is a search field that is bound to the query variable in the TypeScript. There is a button that has a click event as well and it does some interesting things. Notice the #map template variable on the actual map component. This is how we get local reference to that particular UI element. The map component has a public method called places which accepts a string for a query. Now let’s jump back into the click event for the button. We are using the local component reference, calling the places method, and passing in the query variable from the input field. When the click event triggers, the search will occur and the markers will be placed on the map. Angular does some awesome things when it comes to binding of the data. To run this application, execute the following from the CLI: ng serve You’ll probably notice that when click a marker, the information bubble isn’t the most attractive due to word wrapping. We can clean it up through some simple CSS. Open the project’s src/styles.css file so we can add some global CSS: .H_ib_body {\n    width: 275px;\n} If you’re a much better CSS wizard than I am, you can do some pretty amazing things when it comes to the cosmetics of this application. However, from a functional perspective, you should have a map that you can search for places as of now. Conclusion You just saw how to use the HERE Places API to populate markers on a map for points of interest using Angular and the various JavaScript libraries offered by HERE. This tutorial was a continuation of a previous getting started tutorial I wrote titled, Display HERE Maps within your Angular Web Application . If you haven’t seen the previous tutorial, I recommend you have a look to clear up any loose ends that this particular example with points of interest, may have brought up.", "date": "2018-09-13"},
{"website": "Here", "title": "Using the HERE Geocoder API for JavaScript in an Angular Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/using-the-here-geocoder-api-for-javascript-in-an-angular-application", "abstract": "Have you ever needed to plot an address on a map that requires a latitude and longitude, but you only have a string of text representation? What about the opposite where you have a latitude and longitude, but that information isn’t valuable to you without knowing a nearest address about the information? Being able to geocode address information into coordinates and reverse geocode coordinates into address information is a powerful necessity for many applications. We’re going to see how to use the HERE Geocoder API for JavaScript within an Angular application so that we can take coordinates and address information and convert between the two, while getting far more information than when we started with about the query. The Requirements If you’ve been reading my other HERE with Angular tutorials, you’ll likely be familiar with the small set of requirements that they have. The requirements are as follows: You must have an active HERE developer account. You must have the Angular CLI installed and configured. The good news is that the Angular CLI can be easily installed with the Node Package Manager (NPM) and the HERE developer account can be created for free on the developer portal . Creating a New Project with the Angular CLI To start this tutorial, we’re going to create a fresh project for simplicity. Using the Angular CLI, execute the following command: ng new here-project The above command will create a new project with all the Angular dependencies. Because we’ll be using the HERE JavaScript libraries, we need to include them in our project. The best way to do this is by opening the project’s src/index.html file and including the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> Notice that we’ve included two JavaScript libraries from the official documentation . At this point in time we can begin actual development of our Angular application. Developing a HERE Service to be Injected throughout the Application When working with any group of related tasks in Angular, it is often a good idea to create a service that can be injected in any component that might appear in the application. While not absolutely necessary, it is good practice. From the Angular CLI, execute the following to create a service: ng g service here For reference, any logic that communicates with the HERE Location Services (HLS) platform, will be added to our Angular service. Any logic that communicates with our UI will find its way into the corresponding Angular component. Open the project’s src/app/here.service.ts file and include the following TypeScript code: import { Injectable } from '@angular/core';\n\ndeclare var H: any;\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class HereService {\n\n    public platform: any;\n    public geocoder: any;\n\n    public constructor() {\n        this.platform = new H.service.Platform({\n            \"app_id\": \"APP-ID-HERE\",\n            \"app_code\": \"APP-CODE-HERE\"\n        });\n        this.geocoder = this.platform.getGeocodingService();\n    }\n\n    public getAddress(query: string) {}\n\n    public getAddressFromLatLng(query: string) {}\n\n} Notice that I’ve left pieces out of the service for now. Let’s take a look at what is available and work our way into it. Because we’re working with TypeScript and the HERE API is JavaScript, we need to tell the TypeScript compiler to ignore the fact that our library doesn’t have the appropriate type definitions. This is done through the following line: declare var H: any; Within the Angular service, HLS must be initialized with the users app id and app code values. Both of these values can be found in the developer portal after you’ve signed in. Within the constructor method, the geocoder service must also be initialized. With HLS and the geocoder initialized, we can have a look at each of our functions. public getAddress(query: string) {\n    return new Promise((resolve, reject) => {\n        this.geocoder.geocode({ searchText: query }, result => {\n            if(result.Response.View.length > 0) {\n                if(result.Response.View[0].Result.length > 0) {\n                    resolve(result.Response.View[0].Result);\n                } else {\n                    reject({ message: \"no results found\" });\n                }\n            } else {\n                reject({ message: \"no results found\" });\n            }\n        }, error => {\n            reject(error);\n        });\n    });\n} The above getAddress function is an example. When called, a new promise is created because this is an asynchronous operation. The query is passed to the geocode function and assuming results were found, they are resolved to the client. If there was an error or no results were found based on the query, then the promise will reject. Similarly, we have the getAddressFromLatLng function: public getAddressFromLatLng(query: string) {\n    return new Promise((resolve, reject) => {\n        this.geocoder.reverseGeocode({ prox: query, mode: \"retrieveAddress\" }, result => {\n            if(result.Response.View.length > 0) {\n                if(result.Response.View[0].Result.length > 0) {\n                    resolve(result.Response.View[0].Result);\n                } else {\n                    reject({ message: \"no results found\" });\n                }\n            } else {\n                reject({ message: \"no results found\" });\n            }\n        }, error => {\n            reject(error);\n        });\n    });\n} Instead of taking a query string that might be an address, or a city, or something similar, we are providing a query string that represents a latitude and longitude. Beyond the geocode vs reverseGeocode function being used, the responses are more or less the same. While you can do more with the HERE Geocoder API , we’re going to focus on the geocode and reverseGeocode functions for this example. With the Angular service created, we can focus on the core logic and HTML markup behind our web application. Open the project’s src/app/app.component.ts file and include the following TypeScript code: import { Component } from '@angular/core';\nimport { HereService } from \"./here.service\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n    public query: string;\n    public position: string;\n    public locations: Array<any>;\n\n    public constructor(private here: HereService) {\n        this.query = \"Tracy, CA\";\n        this.position = \"37.7397,-121.4252\";\n    }\n\n    public getAddress() { }\n\n    public getAddressFromLatLng() { }\n\n} Again, I’ve purposefully not provided all the function code for now. Notice that we’ve imported the service that we’ve just created, defined a few public variables to be bound to the UI, and injected our service for use in the constructor method. With the preparation work in place, we can take a look at our two functions. public getAddress() {\n    if(this.query != \"\") {\n        this.here.getAddress(this.query).then(result => {\n            this.locations = <Array<any>>result;\n        }, error => {\n            console.error(error);\n        });\n    }\n} The getAddress function acts as a wrapper to our service function. Assuming the promise resolves, we can take the result and add it to our public variable to eventually be rendered on the screen. Similarly, the getAddressFromLatLng function does the same: public getAddressFromLatLng() {\n    if(this.position != \"\") {\n        this.here.getAddressFromLatLng(this.position).then(result => {\n            this.locations = <Array<any>>result;\n        }, error => {\n            console.error(error);\n        });\n    }\n} The exception with the above function is that we’re calling a different function from the service and using a different value for our query. The plan when it comes to the geocoder is to take user input from a form. However, in Angular by default, data binding with forms is disabled. To activate forms, open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from \"@angular/forms\";\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n    declarations: [\n        AppComponent\n    ],\n    imports: [\n        BrowserModule,\n        FormsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } In the above code we’ve imported FormsModule and added it to the imports array of the @NgModule block. With forms functional, we can finalize this tutorial with HTML markup. Open the project’s src/app/app.component.html file and include the following: <div>\n    <input type=\"text\" [(ngModel)]=\"query\">\n    <button type=\"button\" (click)=\"getAddress()\">Search</button>\n</div>\n<div>\n    <input type=\"text\" [(ngModel)]=\"position\">\n    <button type=\"button\" (click)=\"getAddressFromLatLng()\">Search</button>\n</div>\n<hr>\n<table style=\"width: 100%\">\n    <thead>\n        <tr style=\"text-align: left\">\n            <th>Label</th>\n            <th>Latitude</th>\n            <th>Longitude</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr *ngFor=\"let location of locations\">\n            <td>{% raw %}{{ location.Location.Address.Label }}{% endraw %}</td>\n            <td>{% raw %}{{ location.Location.DisplayPosition.Latitude }}{% endraw %}</td>\n            <td>{% raw %}{{ location.Location.DisplayPosition.Longitude }}{% endraw %}</td>\n        </tr>\n    </tbody>\n</table> The above HTML markup has two input fields, with two buttons, as well as a table for the results. The first input is bound to the public query variable and the button is bound to the getAddress function. Likewise, the second input is bound to the public position variable and the button is bound to the getAddressFromLatLng function. When the locations variable is populated with results, the results are looped through and rendered in the table. While the usage scenario may be unrealistic for a production application, it is functional and will get you familiar with the HERE APIs for JavaScript with Angular. Conclusion You just saw how to use the HERE Geocoder API for JavaScript within an Angular application. While we created a service in this example, it wasn’t absolutely necessary. However, it is best practice given the scenario. If you’d like to see a more realistic example of using the HERE Geocoder API, check out a previous tutorial that I wrote titled, Simple Data Processing with JavaScript and the HERE API , that uses REST instead of the JavaScript libraries.", "date": "2018-09-19"},
{"website": "Here", "title": "Safely Route College Students Using the HERE iOS SDK", "author": ["Brandon David"], "link": "https://developer.here.com/blog/safely-route-college-students-using-the-here-ios-sdk", "abstract": "It's a late Monday night and I'm at one of UC Berkeley's campus libraries studying with my friends for our upcoming midterm. After cramming for hours with practice exams, we are exhausted and decide to call it a day. I begin packing my bags, but then have a sudden realization: it is 11PM, my friends live on the other side of campus, and my off-campus dorm is three blocks away. Well, three blocks can't be that bad of a walk, right? Sure, the walk isn't too bad when walking in the middle of the day. But when you're a new student walking alone in the middle of the night and you're constantly emailed police reports of crime activity around campus, three blocks can feel like a treacherous journey. The city of Berkeley's Crime Index Ranking is #4 , meaning that Berkeley is only safer than 4% of all U.S. cities. Many UC Berkeley students have experiences similar to mine, regularly staying on campus until the evening to study or contribute to their extracurricular activities. These safety concerns extend to cities around the world, affecting everyone from college student to full-time employees. Location is important. Our lives are important too, and navigating through any unfamiliar area can be dangerous, especially when walking alone in the evening. During my summer internship at the HERE Berkeley office, I had the opportunity to work with Vanasa Liu—another intern—and the Berkeley Design Office on a location based side project that utilizes HERE's location technology. Safely, the iOS app ensuring pedestrian safety Using the recently released HERE Freemium plan , we developed Safely, the iOS app that helps users route safely from start to destination. When users provide a starting location and destination, Safely calculates several routes that avoid areas with large amounts of crime. The following is a simplified demo of how we implemented some key features with the iOS Premium SDK using Swift. HERE Maps and Positioning Let's start by displaying the HERE map on the phone screen and tracking the user's location. We need to set up a NMAMapView and NMAPositioningManager within a UIViewController. Now that we have a NMAMapView and NMAPositioningManager, we can set the NMAMapView to center on the user's location when the NMAPositioningManager initially updates. Great! Now our map starts at wherever our user is. However, there may be cases when the user's position is lost while using the app. Let's handle whenever the app accidentally loses the user's locaton. Setup for Routing Now that we have the map and basic positioning set up, let's move onto the setup for calculating routes. The NMAPositioningManager is used to obtain the starting location for our routing. After we provide a destination, we can also add areas that should be avoided. Let's create a new function and instantiate a NMACoreRouter object to handle the routing. In order to prevent our app from routing users into dangerous areas, we must provide a NMADynamicPenalty object, which provides restrictions while calculating routes. In the case of Safely, we created NMAMapPolygons around regions that experienced the highest crime rates according to Berkeley PD's Calls for Service Heat Map . Before we start calculating routes, we must note the routing options that we want to avoid and instantiate a NMARoutingMode object. In the case of Safely, we wanted to find the fastest valid route and avoid all routing options that do not involve safe pedestrian travel. It may also be helpful to limit the maximum number of routes that we can retrieve. Calculating Routes Now we can start finding safe routes! Our NMACoreRouter object has a function that involves a completion block, in which we are able to access the routes that we have retrieved. For the first (fastest) route we retrieve, we set its color to green, set its z-index to 999 so it will be the frontmost route, and add the route to the mapView. For any other routes, we set its color to light gray and add it to the mapView. The map should now display a green route with up to two alternative routes, all of which do not traverse through our NMADynamicPenalty object. With that, we have covered some of the most important features in HERE's iOS Premium SDK! To see how we put these features to use in our Safely app concept, check out the gif below. Next steps for Safely? Currently, Safely's scope is limited to using Berkeley PD's public datasets and focuses on HERE Routing. There is a lot to consider should this app continue in development. For example, what are some other HERE API features that could be implemented? HERE's iOS Premium SDK has a plethora of features to experiment with. Also, is the number of crime incidents truly the best indicator for safeness of an area? Places with larger population density, like major streets and intersections, would likely have more crime activity simply due to the greater number of people that choose to walk that way. A better statistic to consider could be the number of crime incidents relative to pedestrian traffic; however, pedestrian traffic is not readily available as a public dataset and can be difficult to obtain. Final Remarks Technology continues to evolve, and we aspire to devise more and more ways to benefit society with novel ideas and solutions. Over the summer, Vanasa and I discovered a problem that has an effect on people all around the world. We took a concept from ideation through product design and multiple iterations. And with HERE's extensive location database and readily available APIs, we took this concept all the way to a functional prototype that routes users to their destinations safely. As developers continue to make the #SwitchToHERE, there's no limit to what we'll be using HERE's APIs for in the future. Thank you to Vanasa and the Berkeley Design Office for your guidance and contributions to this project. And thank you Jayson DeLancey for reaching out to us.  You can find my portfolio here: https://brandonhudavid.github.io/", "date": "2018-09-18"},
{"website": "Here", "title": "Visualizing Large Scale 3D Terrain with Open Source Tools", "author": ["Mauritius Seeger"], "link": "https://developer.here.com/blog/visualizing-large-scale-terrain-with-open-source-tool-tin-terrain", "abstract": "TL;DR In this article we will offer an overview of current best methods for building large scale 3D terrain maps and present two open source tools that will help you build your own: TIN Terrain and CesiumJS . TIN Terrain is our new open source tool that generates TIN meshes from raster terrain. CesiumJS will load these meshes and render them on a client. Introduction Why 3D? Digital and web based maps have been stuck in 2D mode for many years, but with an ever increasing supply of good quality terrain data, there is now a race to provide 3D mapping services. Use cases for this are numerous. Terrain can help in routing and path finding, construction, visualisation, simulation or simply yield a better and more compelling user experience. Crater Lake terrain rendered in 3D Where does data come from? Height data is measured by satellite or aerial vehicles using a number of techniques. The newest one of which is autonomous flying drones that can infer the 3D dimension from scene video using photogrammetry . Why is 3D hard? Large scale big data These datasets can be very detailed with resolutions down to 20cm and are therefore extremely large. For example, raster terrain data covering 100 square kilometres at 20cm resolution comes to roughly 20GB of data. To map an area of a typical city like Berlin would generate around 180GB of data. This presents a challenge. Web-based and mobile maps must retrieve terrain data at the correct location and resolution, and transfer this over the network in reasonable time. Rendering Once the data has arrived at the client, it must be rendered to produce visually appealing and realistic imagery. If we want to use hardware accelerated graphics, we need triangle meshes. Height data is however typically stored as raster data, so it must be converted first. To do this well, in an optimal way , is non-trivial and run-time intensive. How can it be done? So in practice, how do we overcome these challenges? In this section we will briefly outline the current best solutions for building 3D terrain maps. Data sources Let's start with the data: Terrain data is collectively referred to as DEM: Digital Elevation Models. A distinction is also made between raw ground elevation (DTM: Digital Terrain Model) and height measures that include man made structures such as buildings (DSM: Digital Surface Models). The difference between DSM and DTM There is an increasing wealth of terrain data for many parts of the globe. These typically come in raster formats but at widely varying resolutions and accuracy. Raster data in this context means that height measurements are stored at a fixed spacing in a 2D grid. This is very similar to the way brightness is stored in a bitmap image or photographs. The data here is not truly 3D but “2.5D” because there is only one height measure for each surface point. This means that such data does not accurately model tunnels or overhangs, and is not ideal for mapping buildings and cities in detail. However, 2.5D is sufficient to describe most natural terrains, while keeping things simple. Terrain can be stored in a number of file formats but is mostly delivered as GeoTIFF, a format which in addition to the data contains the size of the raster and the position in geo coordinates, plus projection information. As the files tend to be very large they are usually split into more manageable tiles. Crater Lake DEM as \"depth map\": brightness represents height If you want to build your own maps you can now get data from a number of popular free sources or even make your own. For small areas you can now gather this yourself by flying drones . For anything larger you are stuck with either buying or sourcing free data. Fortunately the free offering is getting very comprehensive. Here is a list of some good free terrain data sources to get you started: mapzen openterrain list terrain party Tiling and quad tree zoom levels Tiling is the current standard way to efficiently load and display web based maps. This method can be applied to both raster and vector content. For example, satellite images are stored and transferred as bitmaps. Roads and geographic geometry are typically stored as vector data. This data is then partitioned into tiles and for each zoom level there is a separate tile set with the appropriate level of detail. This method is called quad-tree tiling . Tiling of images (same principle applies for terrain and vector data): All tiles have the same resolution, so for lower levels of detail, less tiles are used. For lower levels of detail, fewer tiles are used.  This is true for both terrain and vector data. Why meshes? We can apply the same tiling principles to terrain data, since it is similar to image data. However, once transferred to the client, the terrain data needs to be displayed in 3D , and for this we need meshes. There are a number of ways to create these. Meshing on the fly In the simplest case we use an existing image tile server to transfer raster terrain and convert to a dense mesh on the client, just before rendering. This means every height measure in the raster becomes a vertex in the mesh. This places extra runtime demands on the client as meshes with many vertices are slow to render. Height data can be efficiently stored in a raster format or converted for display to a regular mesh by adding edges to form triangles. Meshing offline A better approach is to generate tiles of optimized meshes (or TIN's, see below) on the server, where it can be computed offline and free from runtime constraints and memory limitations. These type of meshes are also typically smaller than an equivalent raster (especially if it's compressed), so there are bandwidth advantages too. TINs One of the main engineering challenges is to generate good meshes from raster data. In the simplest case, 3D triangle meshes can be made directly by taking each height measurement in the original raster and adding a vertex for it. However, this makes for very large meshes that are inefficient to store and display. In many cases, not all of these vertices are needed to define a surface. The difference between regular meshes and irregular meshes (TINs): the latter make more efficient use of vertices by placing them only where needed. This is where TIN’s come in: Triangulated Irregular Networks. These are meshes that contain only vertices where they define meaningful change in surface height. In flat areas, where there is no extra data required, no vertices are added. To illustrate this, imagine a perfectly flat square: We can define this using two triangles and only four points, regardless of the resolution or area covered. By the same principle, we can define some areas almost perfectly with only a few points while for others we may need many more. Single Crater Lake TIN tile Putting it all together So then, how can you build your own 3D terrain maps? There are basically two approaches : Raster tiles on server and dense meshing on client TIN mesh tiles on server and direct display on client Crater lake terrain rendered in our quantised mesh viewer , showing tile coordinates. Raster tiles For option one, there is an end to end solution that can be achieved with existing open source tools: Cesium terrain-builder . This tool takes large DEM files and generates multi-resolution raster tiles. These work out of the box with the CesiumJS, a JavaScript library that handles 3D geometry. Point a CesiumJS based client app at the tile directory structure from terrain-builder and you can view terrain in 3D, world wide, texture mapped if needed, and Bob is your Uncle . Raster terrain tile sets: dense meshes only get created on the client. TIN mesh tiles Except not quite. Terrain tiles in this tool chain are still in raster format, which is inefficient to load and slow to render.  So option 2. is a better solution: storing optimised irregular meshes (TIN's) on the server and transferring and displaying them efficiently on the client. This becomes especially lightweight if meshes are compressed using Cesium's modern quantised mesh format. This is our preferred and recommend path . TIN mesh tiles created offline to reduce rendering overhead due to smaller vertex count However, we found no viable open source software that generates these meshes. So, to make this all very easy, we developed our own: TIN Terrain , an open source tool for generating modern quantized meshes from large raster files. TIN Terrain generates a directory structure of quantised mesh tiles at multiple resolutions which can then be directly loaded in any CesiumJS based client. Crater Lake terrain assembled from a mosaic of TIN-terrain meshes Same set of mesh tiles with rendered surface Bottom Line The open source tool Tin-Terrain in combination with CesiumJS allows you to privately or publicly host your own state of the art 3D terrain map. We have provided a sample client application , complete with tiled TIN meshes for you to get started.", "date": "2018-09-14"},
{"website": "Here", "title": "Developing a Cross-Platform Desktop Maps Application with Electron, Angular, and HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/developing-a-cross-platform-desktop-maps-application-with-electron-angular-and-here", "abstract": "I have a Mac and every once in a while I use the Apple Maps Desktop application. There are potentially a few problems with the Apple Maps application, for example, it only works on Mac and not Windows or Linux. Also, the maps could be using a more reliable and trusted solution like HERE. This is where Electron and the HERE JavaScript APIs can make an impact. If you’re unfamiliar, Electron is a framework that lets you build cross-platform, native packaged desktop applications using JavaScript and other web frameworks. Combine that with a framework like Angular and HERE for mapping and you’ve got yourself a very powerful toolset. We’re going to see how to build a desktop mapping application that works on Mac, Linux, and Windows using Electron, Angular , and HERE. To get an idea of what we want to accomplish, take a look at the following animated image: As you can see, we have a standalone desktop application with a map and a fixed position search box. Searching in the box for points of interest will display markers on the map that can be clicked for address information. The map takes up the full dimensions of the application and can be panned or zoomed. If you’ve seen some of my other Angular with HERE tutorials, you’ll probably recognize a lot of the functionality. For example, I wrote a tutorial titled, Displaying Places on a HERE Map in an Angular Web Application , which focused on the HERE Places API as well as another tutorial titled, Display HERE Maps within your Angular Web Application , which focused strictly on displaying a map with Angular. We’re more or less going to clean up these previous tutorials and package them as a desktop application with Electron. Creating a New Angular Web Application for Interacting with Maps To be successful with this project, you’re going to need the Angular CLI and a free HERE developer account . With those prerequisites met, we need to create a new project by executing the following: ng new here-electron-demo The above command will create a new Angular project. Before we get into the mapping and Electron content, we need to make some adjustments in preparation. Open the project’s src/index.html file and make it look like the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"./\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n        <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\"></script>\n        <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\"></script>\n    </body>\n</html> There are a few things to note in the above HTML markup. The first of which is in our <base> tag. Instead of referencing an absolute path, we’ve added a period character to reference a relative path. This is necessary for the Angular project to build in a way that is compatible with Electron. The other things you’ll notice is that we’re including Bootstrap which we’ll use as our theming layer. Bootstrap is not a requirement to be successful, but it will make our project look nice with minimal effort. After all, my design skills are not very good. With the project created and prepared, we can move along to the next step of configuring Electron. Configuring a Web Application to be Deployed with Electron For this particular project, Electron will act as strictly a packaging mechanism for our Angular application. In other scenarios that use native operating system features, Electron acts as more than just a packaging mechanism, but we won’t be using any operating system features here. From the Angular project, execute the following: npm install electron --save-dev The above command will install Electron as a development dependency. Electron does require its own configuration for things like screen size, menu information, etc., and that can be handled in an electron.js file at the root of your project. Create an electron.js file and include the following: const {app, BrowserWindow} = require('electron')\n\nlet win\n\nfunction createWindow () {\n    win = new BrowserWindow({width: 1200, height: 750, resizable: false})\n\n    win.loadFile('dist/demo/index.html')\n\n    win.on('closed', () => {\n        win = null\n    })\n}\n\napp.on('ready', createWindow)\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n        app.quit()\n    }\n})\n\napp.on('activate', () => {\n    if (win === null) {\n        createWindow()\n    }\n}) If you’ve ever used Electron before, the above code might look familiar. Most of it was taken from the official quick start documentation for Electron. However, do take note of the loadFile line. When Electron launches, we want it to load our production-ready Angular application. This will eventually be found in the dist/demo path. With the configuration in place, we can create our build script. Open the project’s package.json file and include the following: {\n    // ...\n    \"main\": \"electron.js\",\n    \"scripts\": {\n        // ...\n        \"electron\": \"npm run build; cp electron.js dist/; ./node_modules/.bin/electron .\"\n    },\n} Notice that we have added a main property as well as an electron script. The script will build our Angular project, copy the electron.js file, and launch the project as an Electron application. This will not build the Electron application as a deployable binary, but it could easily be adjusted following the Electron documentation. At any time, if you wish to run the project, execute the following: npm run electron Now that the project is ready and Electron is ready, we can start the development of our project. From this point on, we’ll be more or less revisiting content from previous tutorials. However, we will be cleaning it up and making it a bit more fancy from a UX and UI perspective. Developing an Interactive Map Component with Angular Since we’ll be using a map in our application, we should probably build a dedicated component for it with Angular. From the Angular CLI, execute the following to create a here-map component: ng g component here-map The above command will create a CSS, TypeScript, and HTML file for our component. However, we’re going to focus on strictly the TypeScript file for logic and the HTML file for UI. Open the project’s src/app/here-map/here-map.component.html file and include the following HTML markup: <div #map id=\"map\"></div> Notice that we only have a <div> tag here. This represents a placeholder for our map. Because we need to interact with the DOM directly, we need to create a reference variable in Angular, as noted by the #map attribute. The id attribute will be used for our stylesheet information later in the tutorial. As of right now, we don’t have any of the HERE libraries available in our project. Open the project’s src/index.html file and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"./\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n        <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1533195059\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\"></script>\n        <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-places.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\"></script>\n    </body>\n</html> As you can see, we’ve just added more JavaScript and CSS libraries to our project. These libraries are for using HERE Maps as well as other HERE related services in our application. With HERE available to us, we can continue editing our here-map component. Open the project’s src/app/here-map/here-map.component.ts file and include the following: import {\n    Component,\n    OnInit,\n    ViewChild,\n    ElementRef,\n    Input\n} from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    @Input()\n    public zoom: any;\n\n    private platform: any;\n    private map: any;\n    private ui: any;\n    private search: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        this.search = new H.places.Search(this.platform.getPlacesService());\n    }\n\n    public ngAfterViewInit() {\n        let pixelRatio = window.devicePixelRatio || 1;\n        let defaultLayers = this.platform.createDefaultLayers({\n            tileSize: pixelRatio === 1 ? 256 : 512,\n            ppi: pixelRatio === 1 ? undefined : 320\n        });\n        this.map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.normal.map,\n            {\n                zoom: this.zoom,\n                center: { lat: this.lat, lng: this.lng },\n                pixelRatio: pixelRatio\n            }\n        );\n        let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n        this.ui = H.ui.UI.createDefault(this.map, defaultLayers);\n    }\n\n} So what is happening in the above code? Since we won’t be working with any official type definitions for TypeScript, we’re going to declare our HERE library using the following line: declare var H: any; This prevents any TypeScript related errors at build time. Inside the HereMapComponent class, we have a @ViewChild and several @Input attributes. These variables are how we bind to the DOM element and the elements HTML attributes. You can include as little or many attributes as you want as long as our @ViewChild is there and referencing the same name as we defined, in this case #map . Inside the constructor method we can load our HERE platform using the app id and app code values found in the HERE Developer Portal . We can also initialize our search variable to be used later. Because we’re working with a DOM element, we need to wait until after the view has rendered before we try to work with it. In the ngAfterViewInit method we have the following: public ngAfterViewInit() {\n    let pixelRatio = window.devicePixelRatio || 1;\n    let defaultLayers = this.platform.createDefaultLayers({\n        tileSize: pixelRatio === 1 ? 256 : 512,\n        ppi: pixelRatio === 1 ? undefined : 320\n    });\n    this.map = new H.Map(\n        this.mapElement.nativeElement,\n        defaultLayers.normal.map,\n        {\n            zoom: this.zoom,\n            center: { lat: this.lat, lng: this.lng },\n            pixelRatio: pixelRatio\n        }\n    );\n    let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n    this.ui = H.ui.UI.createDefault(this.map, defaultLayers);\n} To create a pixel perfect map, we get the pixel density from the browser or Electron container and create our layers based on that information. The map is then loaded from our DOM element and the latitude and longitude is centered on based on the user provided information in the HTML attributes. To make the map interactive, we add a new behavior and initialize the UI. To see what we have in action, we can open the project’s src/app/app.component.html file and add the following: <here-map\n    #map\n    appId=\"APP-ID-HERE\"\n    appCode=\"APP-CODE-HERE\"\n    lat=\"37.7397\"\n    lng=\"-121.4252\"\n    zoom=\"13\">\n</here-map> The above component has attributes that match what we have as @Input in the logic file. You’ll notice that we also have a #map attribute, like what we had in the other HTML file. This is a coincidence and it isn’t technically necessary for this step. Removing it will still leave you with a map. Renaming it also is fine too. It will be relevant for when we want to search for places. From a stylesheet perspective, to get a full screen map, add the following to your project’s src/styles.css file: #map {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n} Almost everything that you’ve seen so far was discussed in my previous article titled, Display HERE Maps within your Angular Web Application . For more clarity and depth, I recommend checking out that previous tutorial. Leveraging the HERE Places API for Points of Interest Searching Now that we’ve got an interactive map, we can give it some more useful functionality. We’re going to implement a points of interest search that displays markers on the map. Open the project’s src/app/here-map/here-map.component.ts file and include the following function to our HereMapComponent class: private dropMarker(coordinates: any, data: any) {\n    let marker = new H.map.Marker(coordinates);\n    marker.setData(\"<p>\" + data.title + \"<br>\" + data.vicinity + \"</p>\");\n    marker.addEventListener('tap', event => {\n        let bubble =  new H.ui.InfoBubble(event.target.getPosition(), {\n            content: event.target.getData()\n        });\n        this.ui.addBubble(bubble);\n    }, false);\n    this.map.addObject(marker);\n} When latitude and longitude coordinate information and generic data is provided, we can create a clickable marker. The marker will be placed at the coordinate position and the data will be presented in an InfoBubble when the marker is clicked. In this case, we are expecting the generic data to be a point of interest title and address. Now that we have a mechanism for adding markers, we can search for places to actually drop the markers. Within the HereMapComponent class, add another function: public places(query: string) {\n    this.map.removeObjects(this.map.getObjects());\n    this.search.request({ \"q\": query, \"at\": this.lat + \",\" + this.lng }, {}, data => {\n        for(let i = 0; i < data.results.items.length; i++) {\n            this.dropMarker({ \"lat\": data.results.items[i].position[0], \"lng\": data.results.items[i].position[1] }, data.results.items[i]);\n        }\n    }, error => {\n        console.error(error);\n    });\n} When the places method is called, the query string is used to search for points of interest using the HERE Places API . The results from the API include coordinate information and other data which includes a title for the point of interest and its address. This information is passed into our dropMarker function so it can be displayed. Before we can effectively use these functions, we need to enable forms in Angular. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from \"@angular/forms\";\n\nimport { AppComponent } from './app.component';\nimport { HereMapComponent } from './here-map/here-map.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        HereMapComponent\n    ],\n    imports: [\n        BrowserModule,\n        FormsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } Notice we’ve imported the FormsModule which is disabled by default. By enabling it, we can bind form data to components, which is critical for searching for places. Head back into your project’s src/app/app.component.html file and include the following: <div id=\"searchbar\">\n    <div class=\"input-group input-group-sm w-100\">\n        <input type=\"text\" [(ngModel)]=\"query\" (keydown.enter)=\"map.places(query)\" class=\"form-control\" placeholder=\"Points of Interest...\" aria-label=\"Points of Interest\" aria-describedby=\"button-addon2\">\n        <div class=\"input-group-append\">\n            <button (click)=\"map.places(query)\" class=\"btn btn-primary\" type=\"button\" id=\"button-addon2\">Search</button>\n        </div>\n    </div>\n</div>\n\n<here-map\n    #map\n    appId=\"APP-ID-HERE\"\n    appCode=\"APP-CODE-HERE\"\n    lat=\"37.7397\"\n    lng=\"-121.4252\"\n    zoom=\"13\">\n</here-map> Now instead of only having a map, we have a search form as well. The search form uses Bootstrap and the <input> field will eventually be bound to variables in our logic file. It will be bound to a query variable as well as to our places method in the map component. We can call the places method because of the #map we placed on our <here-map> tag. In addition to having a keydown event, we are also adding a button that accomplishes the same thing. Open the project’s src/app/app.component.ts file and include the following TypeScript logic: import { Component } from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n\n    public query: string;\n\n    public constructor() {\n        this.query = \"\";\n    }\n\n} All we’re doing in the TypeScript file is defining the query variable that we’re using in our HTML file. This variable is bound and is used when calling the places method of our map. To bring things to a close, we can add the rest of our stylesheet information. Within the projects src/styles.css file, append the following: .H_ib_body {\n    font-size: 0.8em;\n    white-space: nowrap;\n    line-height: 1.5em;\n}\n\n.H_ib_body p {\n    margin: 0;\n    padding: 10px;\n}\n\n#searchbar {\n    position: fixed;\n    z-index: 1;\n    top: 10px;\n    left: 50%;\n    transform: translateX(-50%);\n    background-color: #262626;\n    padding: 15px;\n    width: 50%;\n    border-radius: 5px;\n} If you run the application, it should look like what I had previously demonstrated in the animated image. Feel free to put your design talents to good use and make it even better. You can find more information on using the HERE Places API with Angular in a previous tutorial I wrote titled, Displaying Places on a HERE Map in an Angular Web Application . Conclusion You just saw how to build a cross-platform desktop application using Angular, Electron and HERE, to display and use maps for Mac, Linux, and Windows. Being able to build a desktop mapping application is useful because you can enhance the user experience that you’d find on the web and then compete with Apple. As I previously mentioned, a lot of this tutorial was taken from my other Angular tutorials. To make this Electron application more useful, you could add routing as demonstrated in my tutorial titled, Transportation Routing and Directions in an Angular Application with the HERE Routing API .", "date": "2018-09-21"},
{"website": "Here", "title": "Collect Forecast Information with Angular and the HERE Weather API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/collect-forecast-information-with-angular-and-the-here-weather-api", "abstract": "Knowing weather conditions for cities or coordinate based locations could be very important for your business. Imagine you’re operating a fleet of vehicles scheduled to perform activity at a certain location. If there are severe weather conditions, you know it can affect productivity or create safety concerns. Being able to gather forecast information programmatically opens the door to optimizing or automating different business scenarios. We’re going to look at a simple scenario of getting the seven day forecast for a particular location using the HERE Weather API , REST, and Angular . The Requirements Because we’re using Angular and the HERE location services (HLS), there are a few requirements that must be met to be successful with this project: A HERE developer account must have been created. The Angular CLI must be installed and configured. If you’re new to HERE, the good news is that you can create a new account for free through the HERE Developer Portal . In terms of the Angular CLI , it can be installed through the Node Package Manager (NPM). So what are we going to be creating? Take a look at the image below: As you can see in the above image, we are simply going to display the seven day forecast with icon illustrations for the weather, the temperature in Celsius as well as Fahrenheit, and the date that the weather reflects. There are plenty of things that can be discovered from the HERE Weather API , but our focus isn’t going to adventure elsewhere for this particular tutorial. Starting a New Angular Project For simplicity we are going to start by creating a fresh project to work with. Assuming that you have the Angular CLI ready to go, execute the following from the command line: ng new here-project With the project created, we need to install a separate dependency that will make our lives easier when working with date and time data. Navigate into the project and execute the following: npm install moment --save The above command will install Moment.js , which is a popular JavaScript library for parsing date and time data. We aren’t going to explore it until later in this tutorial. Consuming Data from the HERE Weather API Now that we have a project created we can start including the HERE Weather API so we can eventually display weather information to the user. In a production scenario it might make sense to create an Angular service for this, but since this is such a small example we can just include our HTTP logic directly in the component. Before we can start collecting weather data, we need to configure our application for HTTP requests since it is disabled in Angular by default. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpClientModule, HttpClientJsonpModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n    declarations: [\n        AppComponent\n    ],\n    imports: [\n        BrowserModule,\n        HttpClientModule,\n        HttpClientJsonpModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } You’ll notice that we’ve imported two modules. We’ve imported an HTTP client as well as the module that will allow us to make JSONP requests with the HTTP client. Because of cross-origin resource sharing (CORS), JSONP is a requirement. You can read more about CORS and the HERE Weather API in the official documentation . With HTTP enabled, we can start developing the core logic as well as the UI to be rendered. Starting with the TypeScript logic, open the project’s src/app/app.component.ts file and include the following: import { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { map } from 'rxjs/operators';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    private appId: string;\n    private appCode: string;\n\n    public weather: any;\n\n    public constructor(private http: HttpClient) {\n        this.appId = \"APP-ID-HERE\";\n        this.appCode = \"APP-CODE-HERE\";\n        this.weather = [];\n    }\n\n    public ngOnInit() { }\n\n    public getWeather(coordinates: any) {}\n\n} So what is happening in the above code? First we’re importing a few classes and services. The HttpClient will allow us to make HTTP requests against the API and the map will allow us to transform our observable when making the request. Within the AppComponent class we have two private variables which will represent our data from the HERE Developer Portal. The public weather variable will be populated from the API and rendered on the screen. These variables are all initialized in the constructor method and the HttpClient service is injected. Now we can focus on the core of our logic. Let’s look at the getWeather method first: public getWeather(coordinates: any) {\n    this.http.jsonp(\"https://weather.cit.api.here.com/weather/1.0/report.json?product=forecast_7days_simple&latitude=\" + coordinates.latitude + \"&longitude=\" + coordinates.longitude + \"&app_id=\" + this.appId + \"&app_code=\" + this.appCode, \"jsonpCallback\")\n        .pipe(map(result => (<any>result).dailyForecasts.forecastLocation))\n        .subscribe(result => {\n            this.weather = result.forecast;\n        }, error => {\n            console.error(error);\n        });\n} In the above method we are making a JSONP request to the HERE Weather API. We are specifying that we want the forecast_7days_simple and we are providing our app id and app code. Most of the magic in this request comes in the latitude and longitude coordinates that are passed into the method. After executing the request, the result is transformed into something a little more pleasant and we subscribe to the result, at which point it is added to our public variable. This is where things can get interesting. Instead of prompting the user to input an address or a latitude and longitude, we’re going to get that information from their web browser. public ngOnInit() {\n    if(navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(position => {\n            this.getWeather(position.coords);\n        });\n    } else {\n        console.error(\"The browser does not support geolocation...\");\n    }\n} In the ngOnInit Angular lifecycle event, we are checking the location using the HTML5 geolocation APIs. Assuming the browser is supported and the user grants permission, the coordinates will be passed into the getWeather method. Let’s have a look at what the HTML that powers this application looks like. Open the project’s src/app/app.component.html file and include the following: <div style=\"background-color: #F0F0F0; width: 75%; padding: 20px; border: 1px solid #CCC; margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)\">\n    <p *ngIf=\"weather.length == 0\">Searching...</p>\n    <div *ngIf=\"weather.length > 0\">\n        <table style=\"width: 100%; text-align: center\">\n            <thead></thead>\n            <tbody>\n                <tr>\n                    <td *ngFor=\"let forecast of weather\">\n                        <img [src]=\"forecast.iconLink\" />\n                        <p>{{ forecast.highTemperature }}C</p>\n                        <p>{{ forecast.utcTime }}</p>\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</div> In the above UI, we have two *ngIf conditions. If the weather variable does not yet have data, text saying that it is searching is shown. Once the weather variable has data, it is switched to a table where the weather data is looped and presented on the screen. The weather data returned from the HTTP request is a bunch of objects and we’re only looking at the icon graphic, the temperature in Celsius, and the UTC time. The above HTML works, but we can do better! Formatting Complex Data with Angular Pipes at Render If you’re in the United States like I am, you probably have no idea how to read Celsius temperatures. At least, I have a difficult time doing it since it isn’t the norm around here. You probably also don’t necessarily want to see a long timestamp for the date as well. We can actually do data transformations at render time using Angular pipes. The plan is to convert Celsius to Fahrenheit and format the timestamp using Moment.js. From the command line, execute the following: ng g pipe fahrenheit\nng g pipe moment The above two commands will create two different pipes for us. Starting with the time conversions, open the project’s src/app/moment.pipe.ts file and include the following: import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from \"moment\";\n\n@Pipe({\n    name: 'moment'\n})\nexport class MomentPipe implements PipeTransform {\n\n    public transform(value: any, args?: any): any {\n        return moment(value).format(\"MMMM DD, YYYY\");\n    }\n\n} What’s happening is when we decide to use the pipe, the value which is our timestamp will be formatted using Moment.js and returned. Similarly, open the project’s src/app/fahrenheit.pipe.ts file and include the following: import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n    name: 'fahrenheit'\n})\nexport class FahrenheitPipe implements PipeTransform {\n\n    public transform(value: any, args?: any): any {\n        return ((value * (9 / 5)) + 32).toFixed(2);\n    }\n\n} In the above pipe, we are using the Celsius to Fahrenheit conversion formula to take the Celsius value and return it as Fahrenheit. Now that we have our pipes, we need to actually make use of them. Open the project’s src/app/app.component.html file again because we need to make a change: <div style=\"background-color: #F0F0F0; width: 75%; padding: 20px; border: 1px solid #CCC; margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)\">\n    <p *ngIf=\"weather.length == 0\">Searching...</p>\n    <div *ngIf=\"weather.length > 0\">\n        <table style=\"width: 100%; text-align: center\">\n            <thead></thead>\n            <tbody>\n                <tr>\n                    <td *ngFor=\"let forecast of weather\">\n                        <img [src]=\"forecast.iconLink\" />\n                        <p>{{ forecast.highTemperature }}C / {{ forecast.highTemperature | fahrenheit }}F</p>\n                        <p>{{ forecast.utcTime | moment }}</p>\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </div>\n</div> Inside our table we’ve made use of our two pipes. If you can’t see it, take a look at the following two lines: <p>{{ forecast.highTemperature }}C / {{ forecast.highTemperature | fahrenheit }}F</p>\n<p>{{ forecast.utcTime | moment }}</p> Notice that we’re using the pipe character and the name of the pipe that we created. The value on the left is passed into our transformation function and the result is rendered. Conclusion You just saw how to use the HERE Weather API in an Angular application that makes use of HTTP and JSONP requests. Going beyond what we saw in this tutorial, we could easily check for severe weather reports, sunrises and sunsets, and several other things that may be useful depending on the scenario.", "date": "2018-09-24"},
{"website": "Here", "title": "October Event Radar", "author": ["Laura Callahan"], "link": "https://developer.here.com/blog/october-event-radar", "abstract": "Even though the days may be getting shorter, we’re still HERE, there, everywhere making the most out of the daylight we have left to tell everyone about our #1 Location Platform! If you’re out and about at any of these events, come by and say hello! SAP TechEd 2018 | October 2 – 5 | Las Vegas, USA We’ll be on-site talking about Integrating Location Services with SAP Solutions.  Pretty cool stuff, eh? Internet & Mobile World | October 3 – 4 | Bucharest, Romania We’ll have our Head of Design on-site, stop by our booth (booth 70) to meet J F Grossen! State of the Map | October 4 – 6 | Detroit, USA You’re not going to want to miss this one – stop by our booth to hear about our exciting news! KavKaz Hack | October 12 – 14 | Stavropol, Russia Make sure you join and hack with us at KavKaz Hack if you are in Stavropol - people say, hacking with us is one of the most geeky things you can do there. Silicon Valley Code Camp | October 13 – 14 | San Francisco, USA Don’t sit this one out! We have not one, not two, but THREE workshops coming at you at SVCC. DroidCon Tel Aviv | October 18 | Tel Aviv, Israel We’ll be on-site, come say hello and talk all things Android with Richard. DroidCon London | October 25 – 27 | London, UK Are you participating in the hackathon? Be sure to stop by our booth to talk to Richard about integrating location services into your project for FREE! #hack4no | October 26 - 27 | Oslo, Norway We'll be on site! Stop by our booth to say hello to Shruti and learn how easy it can be to integrate location services into your hackathon project. Hack.Moscow | October 26 – 28 | Moscow, Russia Our Russian team of wonders will be there to hack and mentor at one of the biggest hackathons in Russia, along with 450 other hackers!", "date": "2018-09-28"},
{"website": "Here", "title": "Using the HERE Geocoder API with cURL and Postman", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/using-the-here-geocoder-api-with-curl-and-postman", "abstract": "If you’ve been keeping up with my tutorials, you’ll remember that I’ve written about Angular, Vue.js, and other development technologies. However, to consume data from the HERE APIs, a particular SDK is not a requirement because at the end of the day, REST is still an option. We’re going to explore how to use the HERE Geocoder API with popular and quickly available tools such as cURL and Postman . Creating a Free Developer Account for HERE Application Development To use the HERE Location Services (HLS), a freemium account is required. As of now, you get 250,000 free requests every month before needing a credit card. After creating an account, you’ll be able to access a list of your available projects: Don’t worry about the number of projects you have or how many applications you need to connect. I like to think of it as one project per every one application, but feel free to change it up for your needs. Pick a project, and you should have something that looks like the following: If you haven’t already generated JavaScript / REST tokens, you’ll need to in order to use the HERE APIs. Through the tokens you’ll be able to track usage of the APIs in your applications, including requests made through HTTP. Consuming Geolocation Data with cURL and the Command Line There are numerous ways to use a REST API in your application. Most programming languages offer a way to make HTTP requests, but in case you’d rather use scripts or other tooling, we have other options. cURL is a great option for working with HERE data because cURL is readily available on most operating systems and can be included in shell scripts for reporting or other purposes. Take the following cURL request for example in the Command Prompt (Windows) or Terminal (Mac and Linux): curl -X GET \\\n    https://geocoder.api.here.com/6.2/geocode.json?app_id=<APP-ID-HERE>&app_code=<APP-CODE-HERE>&searchtext=Tracy+CA The app_id and app_code should be replaced with the values found in your developer account, but the searchtext is the address information you want to search for. Running the above query will give you results similar to the following: {\n    \"Response\": {\n        \"MetaInfo\": {\n            \"Timestamp\": \"2018-09-24T21:10:29.219+0000\"\n        },\n        \"View\": [\n            {\n                \"Result\": [\n                    {\n                        \"Location\": {\n                            \"Address\": {\n                                \"AdditionalData\": [\n                                    {\n                                        \"key\": \"CountryName\",\n                                        \"value\": \"United States\"\n                                    },\n                                    {\n                                        \"key\": \"StateName\",\n                                        \"value\": \"California\"\n                                    },\n                                    {\n                                        \"key\": \"CountyName\",\n                                        \"value\": \"San Joaquin\"\n                                    },\n                                    {\n                                        \"key\": \"PostalCodeType\",\n                                        \"value\": \"N\"\n                                    }\n                                ],\n                                \"City\": \"Tracy\",\n                                \"Country\": \"USA\",\n                                \"County\": \"San Joaquin\",\n                                \"Label\": \"Tracy, CA, United States\",\n                                \"PostalCode\": \"95376\",\n                                \"State\": \"CA\"\n                            },\n                            \"DisplayPosition\": {\n                                \"Latitude\": 37.7397,\n                                \"Longitude\": -121.42641\n                            },\n                            \"LocationId\": \"NT_xAlrGP4IQF8iid.6Qry-PA\",\n                            \"LocationType\": \"point\",\n                            \"MapView\": {\n                                \"BottomRight\": {\n                                    \"Latitude\": 37.67872,\n                                    \"Longitude\": -121.38\n                                },\n                                \"TopLeft\": {\n                                    \"Latitude\": 37.77642,\n                                    \"Longitude\": -121.54868\n                                }\n                            },\n                            \"NavigationPosition\": [\n                                {\n                                    \"Latitude\": 37.7397,\n                                    \"Longitude\": -121.42641\n                                }\n                            ]\n                        },\n                        \"MatchLevel\": \"city\",\n                        \"MatchQuality\": {\n                            \"City\": 1.0,\n                            \"State\": 1.0\n                        },\n                        \"Relevance\": 1.0\n                    }\n                ],\n                \"ViewId\": 0,\n                \"_type\": \"SearchResultsViewType\"\n            }\n        ]\n    }\n} A lot of information came back, but probably some of the most useful is in the Response.View[].Result[].Location path as it took a very vague search query and gathered information about the country, postal code, latitude, and longitude. A little tip, if you have Python installed, you can format your JSON response rather than getting a mashed mess. Execute the command below to see it in action: curl -X GET \\\n    https://geocoder.api.here.com/6.2/geocode.json?app_id=<APP-ID-HERE>&app_code=<APP-CODE-HERE>&searchtext=Tracy+CA | python -m json.tool The above command pipes the API response into Python and then the result is pretty printed. In terms of using the HERE Geocoder API, some results may be more complicated than what I had demonstrated with my “Tracy CA” query. For example, multiple results could be returned for a particular query, where in my example, only one result was returned. The more specific you are with the query, the fewer results will be returned. While cURL is a great tool for making requests to the HERE API, it isn’t the only thing available. Using Postman with the HERE REST API Postman is a very popular tool amongst developers because of how easy it is to generate requests using a very easy to understand interface. Let’s take a look at that same request that we made with cURL, but this time with Postman. In the above image you’ll notice that the request is set to GET and the URL to the API is provided. For the parameters, each parameter can be entered without having to manually construct the URL that we saw in cURL. While not terribly complicated, it does make life significantly simpler. Postman does allow you to keep track of previously ran requests or save them as favorites to be executed at a later time. Conclusion There is no wrong way (at least to my knowledge), when it comes to making HTTP requests against the HERE APIs. It all comes down to the requirement of the task and the preference. For example, using Postman probably isn’t an option if you need to script something on a scheduler. Also you probably wouldn’t use cURL or Postman in your applications that use JavaScript or another programming technology. Pick the right tool for the job, but know that it isn’t difficult to make HTTP requests against any of the HERE APIs, including the HERE Geocoder API .", "date": "2018-09-26"},
{"website": "Here", "title": "Making Maps with HERE XYZ", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/managing-and-visualizing-geospatial-data-here-xyz-now-in-beta", "abstract": "Today I am excited to share that we've launched a new service into beta called HERE XYZ .  This includes an interactive designer, a command-line tool, and RESTful APIs available to use for managing and rendering geospatial data.  Let me explain why these tools are so useful. I have geospatial data – points, lines, polygons, and metadata for places of interest to me or my app. I need to store this data someplace so that I can visualize it on a customized map and serve it. How do I do that? I could start by: Provisioning a server from an Infrastructure as a Service provider. Installing a database, configure and tune it for geospatial related queries. Creating a service to process and query the data for visualization. … Or, I can just use HERE XYZ and be done .  As John Oram, XYZ Product Specialist put it – “Even better than owning a boat is having a friend that owns a boat.”  It’s your data but HERE is introducing new tools to help you store, manage and render it on a map.  You can start using these tools right now at no cost with a HERE developer account . Public Beta In announcing this public beta Achal Prabhakar, VP of Core Map Engineering, says “HERE XYZ offers on-the-fly interaction with uploaded data, served to the renderer of your choice, to be styled as you like it. Best of all, data owners no longer need to build a service to use or distribute their data.” There is a lot of usefulness bundled in this set of tools to solve many interesting problems.  For example… Let’s say, I want to quickly create a simple map with just a few markers on it. HERE XYZ Studio is an interactive, visual, web-based application for uploading geospatial data, editing it, and visualizing it on a map.  For quick one-off jobs this real-time feedback can be very useful to search for a few places by name, address, or coordinates and place a point or draw some geometry.  Then you can publish or embed that map directly in your own website and go back to edit the content whenever you want. Let’s say, I have some geospatial data in a CSV, GeoJSON, or Shapefile with lots of markers and geometry. HERE XYZ Hub provides cloud services where I can call the REST API to upload, organize, tag, and query geospatial data.  The HERE Command Line Interface (HERE CLI) further helps execute the API from a shell for even more precise control and script-ability than XYZ Studio UI provides. The REST interface also allows for generating tokens to help manage access rights for who (or what app) can read and write to data stored in your space on HERE XYZ Hub. Let’s say, I have some geospatial data but want to use a different renderer. Maps can be a personal expression of style, taste, and visual identity.  Our applications demand this flexibility so it’s good to have options.  By using the HERE XYZ Maps UI libraries and REST APIs I can integrate with many open third-party map renderers such as Leaflet, Tangram, three.js, or GeoJSON.tools to create a variety of maps to serve various purposes. GETTING STARTED XYZ Studio solves real-world (literally) problems you would face dealing with large amounts of geospatial data and is now available for you to try and get started for free .  Visit https://explore.xyz.here.com to learn more about the HERE XYZ tools.  If you like any of the visuals you saw above, you should check-out the tutorials that demonstrate step-by-step how they were created. Basic Tutorial: Mapping Seismic Activity Intermediate Tutorial: Air Quality in Madrid Advanced Tutorial: Green Amsterdam Expert Tutorial: Global Flight Tracker Check out one of these community tutorials and blog posts and let us know if you create one: Use Crowdsourced Data from Interline OSM Extracts in an XYZ Web Map Build an Interactive Web Map of Subway Stations New Maps in the Cloud Bringing Back the Spirit of Map Mashups Now, with access to professional map data management and rendering tools like HERE XYZ I’m excited to see what maps you will make.  We’re just getting started creating valuable tools for the community, so make a map and tell us what you think.", "date": "2018-10-01"},
{"website": "Here", "title": "Dropping Markers on Geocoded Locations within a Vue.js Web Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/dropping-markers-on-geocoded-locations-within-a-vue.js-web-application", "abstract": "When working with maps in any application, rarely do you ever want to work with only map tiles. Instead you’re probably going to want to include map objects such as markers to highlight locations on the map. HERE provides a very nice JavaScript API to get the job done, but more commonly you’re going to be working with a framework rather than vanilla JavaScript. We’re going to see how to use the HERE Maps API for JavaScript to place markers on a map using the Vue.js JavaScript framework. Take a look at the following image: In the above image we have a simple map with a single marker. Naturally, these markers are placed by using latitude and longitude coordinates. However, in our example, we’re going to see how to take an address string, obtain the coordinates of the address, and then place the marker on the map. The Requirements There are very few requirements necessary to get this project up and running. The requirements are as follows: You must have a HERE developer account You must have the Vue CLI installed and configured If you don’t already have a developer account, you can sign up for free . You’ll need the app id and app code for one of your developer projects to make this project functional. These values can be found in your HERE developer dashboard. While the Vue CLI isn’t absolutely necessary when working with Vue.js, it does make life easier. The Vue CLI can be installed with the Node Package Manager (NPM). Getting Started with a New Vue.js Web Application If you haven’t already seen it, I previously wrote about displaying maps in a Vue.js web application . If you haven’t seen the tutorial, it isn’t absolutely necessary, but it will give you more thorough descriptions when creating a map component. In other words, I recommend you taking a moment to look it over. We’re going to create a fresh project. With the Vue CLI, execute the following: vue create here-marker-project The above command will start the project wizard to create a new project. For this example, we’re only going to use the defaults. This means that it is not necessary to mess around with the Vue Router or Vuex. Within the new project, open the public/index.html file and include the following HTML markup: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>HERE Maps with Vue</title>\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but vue-map doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> In reality, all we added were the two <script> lines towards the bottom. These lines will give us a map and basic functionality with the HERE APIs for JavaScript. The next step is to create a reusable component for our map. Create a src/components/HereMap.vue file within your project and include the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width, height: height }\"></div>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                map: {},\n                platform: {}\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            lat: String,\n            lng: String,\n            width: String,\n            height: String\n        },\n        created() {\n            this.platform = new H.service.Platform({\n                \"app_id\": this.appId,\n                \"app_code\": this.appCode\n            });\n        },\n        mounted() {\n            this.map = new H.Map(\n                this.$refs.map,\n                this.platform.createDefaultLayers().normal.map,\n                {\n                    zoom: 10,\n                    center: { lng: this.lng, lat: this.lat }\n                }\n            );\n        }\n    }\n</script>\n\n<style scoped></style> Without re-explaining the previous article too much, the above code will create a placeholder for the map with dynamic style information, initialize some variables, define possible component attributes, initialize the HERE platform, and position the map when the view loads. The component can then be used in the project’s src/App.vue file like so: <template>\n    <div id=\"app\">\n        <HereMap appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\" width=\"100%\" height=\"835px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style>\n    #app {\n        font-family: 'Avenir', Helvetica, Arial, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        text-align: center;\n        color: #2c3e50;\n    }\n</style> Notice the HereMap UI component. Those are the attributes that we defined in the actual component file. Now we’re caught up to the previous tutorial in terms of bootstrapping our project. Did I mention that you should check out the previous tutorial I wrote? Dropping Markers on a Map with Latitude and Longitude Coordinates With the project created and our basic map component in a working state, we can focus on dropping our first marker on the map. As of now, the map centers on a set of latitude and longitude coordinates, but no marker is places. We’re going to change that so the user knows what we’re looking at. Open the project’s src/components/HereMap.vue file so we can prepare for the markers. Within the component, check out the mounted method: mounted() {\n    this.map = new H.Map(\n        this.$refs.map,\n        this.platform.createDefaultLayers().normal.map,\n        {\n            zoom: 10,\n            center: { lng: this.lng, lat: this.lat }\n        }\n    );\n    this.map.addObject(new H.map.Marker({lat: this.lat, lng: this.lng }));\n} If you take a look at your map, it should be centered on the latitude and longitude coordinates that the user provided and a marker should now exist at those same coordinates. Not so bad, right? Working with exact coordinates is nice, but we can do better. Geocoding an Address and Placing a Marker with the Results I think very rarely are users passing around latitude and longitude coordinates when they want to do mapping business. More commonly people are going to be passing around addresses instead. To be successful with addresses, we can actually make use of the HERE Geocoder API for JavaScript. This API will allow us to discover coordinate information from addresses, or the opposite. We’re going to make a few changes before we can make use of the Geocoder API. Open the project’s src/components/HereMap.vue file and include the following: data() {\n    return {\n        map: {},\n        platform: {},\n        geocoder: {}\n    }\n}, In the above data function, we are now initializing a geocoder variable so that we can use it globally throughout the component. There are many ways to collect address information, but to keep things easy, we’re going to create another optional property for the component: props: {\n    appId: String,\n    appCode: String,\n    lat: String,\n    lng: String,\n    width: String,\n    height: String,\n    location: String\n}, The location property will hold our address information. If you wanted to, you could remove the lat and lng properties as they won’t be too valuable to us any more. With the variables in place, now we need to initialize the geocoder: created() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.geocoder = this.platform.getGeocodingService();\n}, Now that the geocoder has been initialized, it can be used to find our coordinate information for markers. Let’s revisit the mounted method which will be responsible for placing our markers. mounted() {\n    this.map = new H.Map(\n        this.$refs.map,\n        this.platform.createDefaultLayers().normal.map,\n        {\n            zoom: 10,\n            center: { lng: this.lng, lat: this.lat }\n        }\n    );\n    this.geocoder.geocode({ searchText: this.location }, data => {\n        if(data.Response.View.length > 0) {\n            if(data.Response.View[0].Result.length > 0) {\n                var coords = data.Response.View[0].Result[0].Location.DisplayPosition;\n                this.map.setCenter({lat: coords.Latitude, lng: coords.Longitude });\n                this.map.addObject(new H.map.Marker({lat: coords.Latitude, lng: coords.Longitude }));\n            }\n        }\n    }, error => {\n        console.error(error);\n    });\n} In the above mounted method, I’ve decided to leave the latitude and longitude properties that the user provides. However, given a location string, we can use the geocoder to find our position. Once found, the map is re-centered to that position and a marker is placed. If we wanted to see this component in action, we could change our src/App.vue file to the following: <template>\n    <div id=\"app\">\n        <HereMap appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" location=\"Manteca, CA\" lat=\"37.7397\" lng=\"-121.4252\" width=\"100%\" height=\"835px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style>\n    #app {\n        font-family: 'Avenir', Helvetica, Arial, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        text-align: center;\n        color: #2c3e50;\n    }\n</style> In the above code, notice that I’ve included a location=\"Manteca, CA\" . This is the address that will be converted and displayed as a marker. You can refine the address to include a street number and street name as well. The geocoder will figure it out and return numerous results as necessary. Conclusion You just saw how to not only display markers on a map, but also use the HERE Geocoder API for JavaScript within a Vue.js web application. Vue.js is a very popular framework and it really isn’t difficult to include the HERE Location Services (HLS) within a project created with it. If you’re curious to see how to use the HERE Geocoder API for JavaScript with Angular, another popular framework, check out my previous tutorial on the topic titled, Using the HERE Geocoder API for JavaScript in an Angular Application .", "date": "2018-10-11"},
{"website": "Here", "title": "Our Platform Extensions are getting a makeover with the Fleet Telematics API", "author": ["Denise Vlaicu"], "link": "https://developer.here.com/blog/our-platform-extensions-are-getting-a-makeover-with-the-fleet-telematics-api", "abstract": "Today we’re announcing the Fleet Telematics API that gives access through just one service call to all features and functions that were previously accessible through the separate Platform Extensions. We launched our first Platform Extension in 2015 as a way of providing a more customized experience for business applications. Since then, we’ve continued to extend our portfolio of Platform Extensions to meet the location needs of our partners and developers. With the launch of the Fleet Telematics API we continue this evolution by providing a rich set of new algorithms that were built to support some of the more complex fleet management use cases. This new service will allow developers to integrate our services faster and more efficiently while minimizing the service calls needed for certain responses. What’s different? With Platform Extensions you would’ve made separate API calls when combining certain features (eg, calculating routes with rest times while utilizing custom routes, calculating the toll cost for a route that is optimized based on the sequence of waypoints). With the new Fleet Telematics API you can get access to all the features and functions through the same service, and sometimes one API call, when these features needs to be combined into your application. In addition, it provides the extended flexibility to utilize and combine feature sets in various ways without significant limitations. Access to all the available features is now provided through only three service end points: Upload data Search Routing & route matching Why is this important? Innovation demands iteration and requires constant change. And while we know change is never easy, we believe this new service will allow for a more innovative and robust development and application environment for our developers and partners. Stitching up APIs and combining features sets effectively can significantly impact development costs but can also have a tremendous bearing on the robustness of an application. The Fleet Telematics API solves all these challenges, and in addition, allows applications to achieve a faster time-to-market by giving access to a comprehensive list of complex location algorithms that are intelligently built and ready-to-use. What are some of new key features provided through this service? Some of the new features provided through this service, and not available before through Platform Extensions, are as follows: Define custom speed profiles for any FC class road in the HERE road network to calculate more appropriate ETAs Calculate routes considering driver rest times for any type of routes (eg, with/without waypoints, custom routes) Calculate routes based on desired arrival time and day to a destination while considering real-time or historical traffic Calculate fuel-/energy-optimized routes considering road conditions like uphill and downhill Calculate cost-optimized routes considering toll-cost information for various vehicle profiles Calculate routes considering admin-wide truck restrictions Isoline routing delivering reachable links/roads considering time, distance or consumption model What you have to do? If you’re already using our Platform Extensions, you can continue using the features as they are. If you want to take advantage of the new service and its enhancements, please check the Fleet Telematics API documentation and make any necessary adjustments to your service calls. If you’d like to start using this service but have never used the Platform Extensions before, sign up for a Freemium license on this site. What’s next? Over the coming months, we will continue to add new features and capabilities to the Fleet Telematics API to allow applications to make the most out of our location technologies and support your evolving needs. Stay tuned.", "date": "2018-10-08"},
{"website": "Here", "title": "Suggesting Places with jQuery, Geolocation, and the HERE Places API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/suggesting-places-with-jquery-geolocation-and-the-here-places-api", "abstract": "Have you ever tried to enter a location for a calendar event using one of the popular calendar applications? You’ve probably noticed that as you’re entering information about the location it suggests an address for you to save you some time. Being able to get suggestions for places is a powerful feature of a location service and can benefit applications far beyond a typeahead or autocomplete type scenario. In this tutorial we’re going to see how to create a typeahead using jQuery and the HERE Places API to suggest places based on a user defined query and their location based on the geolocation returned from HTML5 in the web browser. The goal of this project is to produce something like demonstrated in the following animated image: You’ll notice that when the application starts, it searches for the latitude and longitude coordinates of the web browser. Most browsers will prompt for permission before releasing this information. After the coordinates are found, any queries entered will be centered around those coordinates. Creating a New Web Application with Standard HTML Markup Before we can start gathering location data and performing searches against the HERE Places API, we need to get the foundation to our application in place. Somewhere on your computer, create a new directory with an index.html file in it. Open the index.html file and include the following HTML markup: <html>\n    <head>\n        <title>HERE Places Suggestions</title>\n        <style>\n            body {\n                background-color: #F0F0F0;\n            }\n            .tt-input, .tt-hint, .twitter-typeahead {\n                width: 100%;\n            }\n        </style>\n    </head>\n    <body>\n        <div id=\"remote\">\n            <p id=\"coords\">Location: searching....</p>\n            <input class=\"typeahead\" type=\"text\" placeholder=\"Places...\">\n        </div>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.0.11/handlebars.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/typeahead.js/0.10.5/typeahead.bundle.min.js\"></script>\n        <script>\n            // Search and location logic here...\n        </script>\n    </body>\n</html> There are a few things to note in the above HTML markup. First, we are creating some very simple style information. It isn’t necessary, but it will make our application look slightly more attractive. Next you’ll notice that we have a <div> tag with an id attribute. This will be referenced when we start working with jQuery. Inside our <div> tag we have text to display our location as well as an input field with a class attribute. It too will be used when we get into our jQuery. To make this project tick, we need to import three JavaScript libraries. jQuery will be the power-horse to the project, but we also need Handlebars.js to compile HTML and Typeahead.js for our typeahead logic. Notice the versions that I’ve chosen to use. As of right now, I’m using the latest jQuery and Handlebars.js, but a specific version of Typeahead.js. Due to lingering bugs in the latest version of Typeahead.js, we need to use the 0.10.5 release. Now we can focus on the next step of development. Gathering Location through HTML and the Web Browser In most circumstances, searching for a place without a general location in mind, probably isn’t going to be very beneficial. For this reason it makes sense to get the users current location so that we can search for places around that location. This can be accomplished in most web browsers using HTML5 and the geolocation APIs. Within the index.html file, include the following JavaScript within the <script> tag: var uiCoords = document.getElementById(\"coords\");\nif(navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(position => {\n        uiCoords.innerHTML = \"Location: \" + position.coords.latitude + \",\" + position.coords.longitude;\n    });\n} else {\n    console.log(\"Geolocation is not supported by this browser.\");\n} If you try to run your application, you should be prompted for your location. It may take a moment, but when it has found your location, the HTML in the UI will be updated to reflect it. Because we’re planning ahead, we are going to set a default location, just in case we can’t get the location from the web browser or the user has denied access to it. Take the following revised code: var coordinates = \"40.74917,-73.98529\";\nvar uiCoords = document.getElementById(\"coords\");\nif(navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(position => {\n        coordinates = position.coords.latitude + \",\" + position.coords.longitude;\n        uiCoords.innerHTML = \"Location: \" + coordinates;\n    });\n} else {\n    console.log(\"Geolocation is not supported by this browser.\");\n} When we start doing queries against the HERE Places API, we’ll be using the coordinates variable which is defaulted to somewhere in New York. After we get the location from the browser, it is updated. Implementing a Typeahead with jQuery for Visual Suggestions Now that we know a location, even if it isn’t our own, we can start planning our typeahead functionality. Within the same <script> tag in the index.html file, include the following: $('#remote .typeahead').typeahead(\n    {\n        hint: true,\n        minLength: 3,\n        highlight: false\n    }, {\n        name: \"place\",\n        displayKey: \"vicinity\",\n        source: function (query, callback) {\n            // HTTP request here...\n        },\n        templates: {\n            suggestion: Handlebars.compile('<div>{% raw %}{{title}}{% endraw %} - {% raw %}{{vicinity}}{% endraw %}</div>')\n        }\n    }\n); Remember the id and class attributes that existed on our UI components? They are now bound to this typeahead component with jQuery. The above code is how you’d use the typeahead component, with the exception that we’re not seeing the HERE Places API yet. When using the typeahead component, we specify that we’d like to see suggestion hints as we type, but our data source will only be called if we have more than three characters present. Take note of the displayKey and the templates property. The displayKey is what object property in the result set will be shown in the input field after a typeahead result is clicked. In this case we want to show the address, otherwise known as the vicinity. The templates is where we define how the typeahead will look. In our scenario we want a simple single line response that has the name of the place and the address separated by a hyphen. You can get significantly more complex if you wanted to. Using the HERE Places API to Find Places and Addresses Now that we have the typeahead in place and our location being resolved, it is time to make sense of our data with the HERE Places API . To be successful with this, you will need to have created a free developer account in the HERE Developer Portal . In the previous code example we had a source for the typeahead, but it didn’t do anything as of now. We need to have it issue an HTTP request to the HERE Places API for data. Take the following code for example: source: function (query, callback) {\n    $.getJSON(\"https://places.cit.api.here.com/places/v1/autosuggest?at=\" + coordinates + \"&q=\" + query + \"&app_id=APP_ID_HERE&app_code=APP_CODE_HERE\", function (data) {\n        var places = data.results.filter(place => place.vicinity);\n        places = places.map(place => {\n            place.title = place.title.replace(/<br\\/>/g, \", \");\n            place.vicinity = place.vicinity.replace(/<br\\/>/g, \", \");\n            return place;\n        });\n        return callback(places);\n    });\n} In the above example we are using jQuery to make an HTTP request. We are using the coordinates variable that was populated with the HTML5 API and we are using our app id and app code values from the HERE Developer Portal. The query is what is bound to the actual form input. The data that is returned from the HERE Places API isn’t necessarily the most useable for our example as is. We need to do some data manipulations to make it into a format that is more appropriate for us. For example, we only want data that has a vicinity. If data doesn’t have a vicinity it is removed using a JavaScript filter function. The data returned may also have some HTML characters so it is best to remove those characters and maybe replace them with a comma. When the data is ready, we can use the callback method to display the results. Conclusion You just saw how to use the HERE Places API as a datasource to populating a jQuery typeahead field. This is a common practice for calendars and other forms that request generic location or places information. It saves your users from having to know the full address or type the full address. As a next step to this tutorial, you could use the typeahead and populate the result as a marker on a map.", "date": "2018-09-27"},
{"website": "Here", "title": "HERE Workspace & Marketplace release archives", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-release-archives", "abstract": "A blast from the past. Prior to the 2.1 release, our release announcements were in PDF format. File downloads for these releases can be found below. OLP 2.0.1 OLP 2.2.0 OLP 1.6.1 OLP 1.6.0 OLP 1.5.5 OLP 1.5.4 OLP 1.5.3 OLP 1.5.2 OLP 1.5.1 OLP 1.5.0", "date": "2018-10-08"},
{"website": "Here", "title": "Showing a HERE Map with the Vue.js JavaScript Framework", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/showing-a-here-map-with-the-vue.js-javascript-framework", "abstract": "When developing a modern web application, very rarely does one use vanilla JavaScript when creating the frontend. HERE offers a JavaScript API for displaying and working with maps, but what if you’re using a modern framework? Previously I had written a tutorial titled, Displaying HERE Maps within your Angular Web Application which demonstrated getting set up with Angular, but what if you’re using another popular framework like Vue.js ? We’re going to see how to use the HERE Maps API for JavaScript within a web application created with the Vue.js JavaScript framework. The goal of our application is simple, show a map on the screen, and it can be seen in the image below. The process involved will include working with native DOM elements, reusable components, and user defined properties that are bound to the map component and dynamically changeable. The Requirements To be successful with this project, there are a few requirements that must be met prior: You must have a developer account with HERE. You must have the Vue CLI installed and configured. To work with HERE maps and other location services an account must be established. This can be done for free from the HERE Developer Portal . While not absolutely necessary when working with Vue, this particular tutorial will be making use of the Vue CLI . It can be obtained through the Node Package Manager (NPM). Creating a New Project with the Vue CLI For simplicity, we’re going to start with a new Vue.js project. With the Vue CLI, execute the following command: vue create here-project For this particular project we will not be using anything beyond the defaults when prompted by the stages of the Vue CLI. This means don’t worry about the Vue Router or Vuex. When the project has been created, you can run it at any time by executing the following: npm run serve The above command will serve the application which is great for testing. When you’re ready to deploy the application, you’ll probably want to build it instead of serving it. Developing a Reusable Map Component with Vue.js When using vanilla JavaScript, you’re probably familiar with adding map code where it is needed. This causes a lot of duplicate code to exist and isn’t really scalable for the long term. While we could do it this way in a Vue.js application, it makes sense to create a dedicated map component instead. Before we create the map component, let’s focus on including the appropriate HERE JavaScript libraries. Open your project’s public/index.html file and make it look like the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>vue-map</title>\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but vue-map doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> The lines that are important to use are the two scripts at the bottom. These scripts were taken out of the HERE documentation and will allow us to use HERE within our Vue.js components. Within your project, create a src/components/HereMap.vue file with the following code: <template>\n    <div class=\"here-map\"></div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() { },\n        props: { },\n        created() { },\n        mounted() { }\n    }\n</script>\n\n<style scoped></style> As you can see in the above code, it is very incomplete. However, notice that we have a <template> , <script> , and <style> block. For the extent of this application, the <style> block will remain empty, so let’s ignore it going forward. Because of how simple our UI is going to be, let’s focus on the <template> first. It should contain the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width, height: height }\"></div>\n    </div>\n</template> There are a few things to note in the above HTML markup. First, notice the ref attribute. Because we are going to have direct interaction with the DOM component, we need to create a variable that references it. The variable is map and it will be accessible from our <script> block when we make it there. Next, notice the v-bind:style attribute. We’re going to let the user define some dynamic styles. For the object, the key is the HTML style property while the value is actual a variable that will be found in the <script> block. Not too bad so far right? Now we can take a look at the JavaScript that powers the map component. Within the same file, notice that we have a data method, a created method, a mounted method, and a props object. The data method and the props object will both hold variables for our component. However, anything in the props object will be user defined component attributes. The props and data will look like the following: <script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                map: {},\n                platform: {}\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            lat: String,\n            lng: String,\n            width: String,\n            height: String\n        },\n        created() { },\n        mounted() { }\n    }\n</script> The map and platform variables found in the data function will hold information about our map and they will very closely resemble what is found in the official documentation for the HERE Maps API. The props that we used will be all the attributes that can be bound to the component. They do not need to be double declared in the data function. Vue.js has a few lifecycle hooks that are executed when an application or component loads. One of the first is the created method: created() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n}, When the created method executes we will initialize the HERE platform. This will include taking data from our bound properties and setting one of the component variables. Because the map is a DOM component, we need to wait until the components have rendered before we try to work with it, so we can’t do it in the created method. Instead we can use the mounted method: mounted() {\n    this.map = new H.Map(\n        this.$refs.map,\n        this.platform.createDefaultLayers().normal.map,\n        {\n            zoom: 10,\n            center: { lng: this.lng, lat: this.lat }\n        }\n    );\n} In the mounted method, we use one of our component variables as well as the ref variable that was set via an attribute in the HTML. Finally, the lat and lng data comes from the component attributes. More information on the Vue.js lifecycle hooks can be found in the official Vue documentation . Displaying a Map in the Web Application Now that we have a map component, we need to use it within our application. Given that this is a simple application, we’re going to be using it within the project’s src/App.vue file. Open this file and include the following: <template>\n    <div id=\"app\">\n        <HereMap\n            appId=\"APP-ID-HERE\"\n            appCode=\"APP-CODE-HERE\"\n            lat=\"37.7397\"\n            lng=\"-121.4252\"\n            width=\"100%\"\n            height=\"835px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style>\n    #app {\n        font-family: 'Avenir', Helvetica, Arial, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        text-align: center;\n        color: #2c3e50;\n    }\n</style> Again, we have a <template> , <script> , and <style> block. You can choose not to use the default styles, or leave them in. In the above code, it is the defaults. Before we can use the HereMap component, we need to import it and include it in the <script> block. Once we’ve done this, we can use it in your HTML. Notice that the component attributes match those that we defined in the props object of our component JavaScript. Don’t forget to change the appId and appCode with yours before trying to run the application. Conclusion You just saw how to use the HERE Maps API for JavaScript to display a map within a web application created with the Vue.js JavaScript framework. As you probably noticed, most of the work that we did was more or less Vue.js configuration and not so much on the map configuration. This is typical for any frontend framework, however, once it is configured, development remains smooth. If you’re an Angular developer and you want to see this same tutorial for Angular, check out the previous tutorial that I wrote on the subject.", "date": "2018-10-04"},
{"website": "Here", "title": "Run Circles Around GeoJSON, Beginner to Advanced with HERE XYZ", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/run-circles-around-geojson-beginner-to-advanced-with-here-xyz", "abstract": "Are you just getting started with GeoJSON? If you are not already familiar with the format but want to make a map with HERE XYZ ( public beta ) you may be trying to come up to speed quickly to take advantage of the geospatial data storage in HERE XYZ Hub or rendering capabilities for customization in HERE XYZ Studio . You can read the documentation for GeoJSON Basics but let's start with a quick primer that will have you drawing circles in no time. GeoJSON Primer What is it? If you are familiar with JavaScript and Web Services you already know about JavaScript Object Notation (JSON) as a way to syntactically represent the values of variables, arrays, and dictionaries in a text file. GeoJSON, is a standardized specification for how to represent those geospatial objects so that anybody can understand what they mean and semantically process it with software. A few months ago we celebrated 10 years since the original GeoJSON spec was proposed. The IETF would go on to formalize it as RFC 7946 . As much fun as reading a technical spec is, here’s what you need to know. COORDINATES We're just talking about latitude and longitude here but the order matters and in the case of GeoJSON X comes before Y which means longitude first in the order [longitude, latitude, elevation] . \"coordinates\": [-120.010789634, 39.094537102] TYPE If you've worked with other Geospatial data formats, you will quickly recognize some similarities. With coordinates representing a location on the globe, we can add a type that defines the shape of basic geometry. The Point, LineString, and Polygon represent the three primary types. POINT The Point is rendered as a dot. { \"type\": \"Point\", \"coordinates\": [-120.01078, 39.09453] } LINESTRING The LineString is rendered as a series of points connected with a line. { \"type\": \"LineString\", \"coordinates\": [ [-117.49389, 40.73069], [-115.98877, 37.95294] ] } POLYGON The Polygon is a chain of line segments in a loop for the purpose of rendering a filled shape. The first and last coordinates are identical to make sure the linear ring is closed. { \"type\": \"Polygon\", \"coordinates\": [ [-113.65967, 40.12857], [-113.62671, 38.85690], [-111.05591, 39.34287], [-111.25366, 40.22930], [-111.36352, 40.12910], [-113.65967, 40.12857] ] } MULTI In addition to the basic geometry types there are MultiPoint, MultiLineString, and MultiPolygon. It may not be a surprise to know that these are just simply extensions of the basic types to represent the coordinates as an array of arrays. It is not necessary to use these types but it becomes helpful for the compactness and parsing of the resulting GeoJSON file. { \"type\": \"MultiPoint\", \"coordinates\": [ [-117.49389, 40.73069], [-115.98877, 37.95294] ] } FEATURE To add context to your geometry there is a Feature type. By enclosing both geometry and properties together you can add real world metadata or attributes to the shapes defined in the geometry being rendered. { \"type\": \"Feature\", \"properties\": { “label”: “Favorite Place” }, \"geometry\": [{ \"type\": \"LineString\", \"coordinates\": [ -120.010789634, 39.094537102, 0 ] }] } You can also define a FeatureCollection that like the Multi types is a list of lists for defining many features at once. Drawing with HERE XYZ Studio Knowing GeoJSON is one thing, creating it is something else. So, how do you get GeoJSON in the first place? A few options: There are many public / open data sources that provide GeoJSON data for download. You can fire up a text editor and start typing. You can use HERE XYZ Studio and GeoJSON Tool. As you may have seen in the XYZ Studio Quick Tour , Studio has a mode where you can create or edit content . If you want to export or download this layer, you can use the HERE CLI from a bash shell to export the space: here xyz show {SPACE_ID} -r > output.geojson The -r dumps out the raw GeoJSON content which you can pipe into a file. You'll notice that Studio stores the geometry in a FeatureCollection along with some metadata properties. GeoJSON Tool Alternatively, you can also use GeoJSON Tool which has a built-in text editor and viewer for writing GeoJSON and viewing the results. It has an easy to remember URL as well -- http://geojson.tools . Circles Drawing circles could be handy if trying to represent radius around an area such as the no-fly zones for drones around an airport or the flight radius of a nesting European Swallow. Using XYZ Studio you can customize your map to change the look and feel which means you can bump up the size and color of a Point to look like a circle. You may be tempted to draw a circle in GeoJSON, but first think about what you’re trying to display.  Scaling the size of Points is best if you wanted to show the magnitude of an earthquake or to scale a Point based on a property like we did in the Madrid Air Quality Tutorial . If you wanted to show a circle with a specific radius (for swallows), remember that GeoJSON doesn't natively have a Circle type. This was intentional as drawing circles on a flat surface which is really a spheroid gets tricky. You can use your favorite programming language or tools to make a Polygon with a large number of sides to approximate a circle. Depending on the radius and zoom level you may want to experiment a bit. Here's a simple example with Python: You’ll need to setup a Python environment and pip install shapely geojson for this to work properly. (You can also draw a circle with a specific radius in miles or kilometers -- turf.js is a handy tool for that. But keep in mind you’ll be dealing with projections! This means a 5km radius circle will look like an oval once you leave the equator and will change shape at different latitudes.) Copying and pasting the output from running that Python code into geojson.tools renders a nice circle in the Gulf of Guinea. Next Steps This was not an exhaustive study of everything you can do with GeoJSON but aimed to get you started.  From here you should check out the GeoJSON Basics documentation for more detailed examples. From there you can start using the GeoJSON Tool or HERE XYZ Studio as interactive editors to experiment with GeoJSON for yourself.", "date": "2018-10-12"},
{"website": "Here", "title": "Reverse Geocoding Coordinates to Addresses with the Go Programming Language", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/reverse-geocoding-coordinates-to-addresses-with-the-go-programming-language", "abstract": "When working with GPS devices and popular software, you will typically find yourself with information around latitude and longitude coordinate information, which is great, but not exactly human readable. A more readable format would be address information with streets, cities, countries, etc., something that we can make sense of. HERE offers a reverse geocoder API that allows you to take latitude and longitude information collected from elsewhere and convert it into address information. We’re going to see how to use the HERE Reverse Geocoder API with REST and the Go programming language (Golang) to convert coordinate information to address information, quickly and easily. To get a better idea what we’re trying to accomplish, take a look at the following image: In the above image you’ll notice that a CLI was created. When running the application, a latitude and longitude was passed and we got address information as a response. The command is more complex than it needs to be because we’re pretty printing the JSON data with a Python script, which isn’t completely necessary. Mapping the HERE Geocoder API with Native Go Data Structures Before we start using the HERE Geocoder API, we need to add our boilerplate Golang code and create the data structures that will hold the results to our requests. Within your $GOPATH , create a main.go file and include the following: package main\n\nimport (\n    \"encoding/json\"\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n)\n\ntype GeoData struct {\n    Response struct {\n        MetaInfo struct {\n            TimeStamp string `json:\"TimeStamp\"`\n        } `json:\"MetaInfo\"`\n        View []struct {\n            Result []struct {\n                MatchLevel string `json:\"MatchLevel\"`\n                Location   struct {\n                    Address struct {\n                        Label       string `json:\"Label\"`\n                        Country     string `json:\"Country\"`\n                        State       string `json:\"State\"`\n                        County      string `json:\"County\"`\n                        City        string `json:\"City\"`\n                        District    string `json:\"District\"`\n                        Street      string `json:\"Street\"`\n                        HouseNumber string `json:\"HouseNumber\"`\n                        PostalCode  string `json:\"PostalCode\"`\n                    } `json:\"Address\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n}\n\ntype Position struct {\n    Latitude  string `json:\"latitude\"`\n    Longitude string `json:\"longitude\"`\n}\n\ntype Geocoder struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\nfunc main() {} In the above code you’ll notice we have our import packages, a main function, and three data structures. The GeoData data structure is probably the most important for this project. Essentially what I’ve done with GeoData is model the REST response defined in the HERE documentation . If you look closely, you’ll notice that I haven’t mapped the response property for property. In fact, I left half of the response out. I did this because I only really care about the address information. However, the format of the response and model must match. You’ll also notice the JSON annotations in the Go data structure. These JSON annotations match the property names in the response. The Position data structure will allow us to keep track of latitude and longitude coordinates, and the Geocoder data structure will allow us to keep track of our API token information. The AppId and AppCode can both be obtained after creating a free account with HERE . Now that we have a means to store our data in our application, we can start making requests against the REST API that HERE provides. Using REST to Convert Between Positions and Addresses To use the HERE Geocoder API, all we really need to do is create an HTTP request that includes our token information, along with coordinate information to be converted into addresses. The response will be stored as a GeoData object to be used however we wish. Within the project’s main.go file, include the following function: func (geocoder *Geocoder) reverse(position Position) (GeoData, error) {\n    endpoint, _ := url.Parse(\"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"mode\", \"retrieveAddresses\")\n    queryParams.Set(\"prox\", position.Latitude+\",\"+position.Longitude)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeoData{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geoData GeoData\n        json.Unmarshal(data, &geoData)\n        return geoData, nil\n    }\n} The function is quite large, but most of it is around formatting a request. The function will use the Geocoder information as well as passed Position information. When creating a request, we provide the correct URL, and construct a query string with the appropriate information. After we execute the request, we check to see if there was an error or success. If there was success, we can read the response, which is byte data, and convert it into GeoData to be returned. The conversions happen based on our JSON annotation mapping. Building a CLI for Accepting Data Defined by the User With the REST function in place, we can bring our application together so it can be used like a command line interface (CLI). The goal here is to just take user defined information and pass it into our function. Open the project’s main.go file and include the following: func main() {\n    latitude := flag.String(\"lat\", \"37.7397\", \"Latitude\")\n    longitude := flag.String(\"lng\", \"-121.4252\", \"Longitude\")\n    flag.Parse()\n    geocoder := Geocoder{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    result, err := geocoder.reverse(Position{Latitude: *latitude, Longitude: *longitude})\n    if err != nil {\n        fmt.Printf(\"The HTTP request failed with error %s\\n\", err)\n        return\n    }\n    if len(result.Response.View) > 0 && len(result.Response.View[0].Result) > 0 {\n        data, _ := json.Marshal(result.Response.View[0].Result[0])\n        fmt.Println(string(data))\n    }\n} In the main function we are anticipating two flags to be passed when launching the application. If these flags are not passed, the default value will be used. Once we parse the flags, we can set our app id and app code information and then call our REST function. Upon a successful request, if there is data found, we will display only the first result which is the nearest result to our coordinates. There can potentially be other results returned in the request. Conclusion You just saw how to use Golang to make requests against the HERE Reverse Geocoder API to convert latitude and longitude coordinate information into address information that is much easier to read. A next step to this might include taking a CSV file of data and converting it into addresses.", "date": "2018-10-15"},
{"website": "Here", "title": "Turn Text Into HERE Maps with Python NLTK", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/turn-text-into-here-maps-with-python-nltk", "abstract": "What is in your Top 5 travel destinations? I asked somebody this recently and the response surprised me. The answer was very specific and unfamiliar. Venice Mdina Aswan Soro Gryfino OK, I know Venice but I’m a software engineer in Northern California and haven’t studied geography in quite some time. I have to admit I have no idea where some of those places are. Maybe you have found yourself reading a travel article that beautifully describes a glamourous locale, places to stay, visit, and where to eat. These articles can be swell, but a simple map can go a long way to add the context of place that some expertly crafted prose alone cannot do. If the author or publisher didn’t include a map for you, Python can help. Solution To solve this problem we will stand up a Python Flask server that exposes a few APIs to Download a given URL and parse the HTML with BeautifulSoup. Extract locations from the text based on some clues with the Natural Language Toolkit (NLTK). Geocode the location to determine a latitude and longitude with the HERE Geocoder API . Place markers on a map to identify the recognized places with the HERE Map Image API . Server Setup For this section I make an assumption you are running an environment like OSX or Linux. If you are running Windows you will need to adjust some of the commands a bit. Configuration With the Twelve-Factor App the case is made that a best practice is to store config in the environment . I agree and like to store my API credentials in variables APP_ID_HERE and APP_CODE_HERE found in a file called HERE.sh . #!/bin/bash\nexport APP_ID_HERE=your-app-id-here\nexport APP_CODE_HERE=your-app-code-here I source it into my environment with . HERE.sh to avoid any hard-coded credentials accidentally being released with my source. Structure The web server component will need several files you can see summarized in the listing below. Start by running mkdir -p app/api_1_0 . ├── app\n│   ├── __init__.py\n│   └── api_1_0\n│       ├── __init__.py\n│       ├── demo.py\n│       ├── health.py\n├── HERE.sh\n├── manage.py\n├── config.py\n└── requirements.txt If you aren’t using Virtual Environments for Python you should be. You can find more from the Hitchiker’s Guide to Python to get off on the right footing. You’ll want to initialize your environment with the libraries in requirements.txt which can be done with pip install -r requirements.txt if the requirements.txt contains the following dependencies. Flask\nFlask-Script\ngunicorn\nnltk\nrequests App We will use manage.py as the main entrypoint to our application. It looks like the following listing: import os\nimport app\nfrom flask_script import Manager, Server\n\napp = app.create_app('default')\nmanager = Manager(app)\n\nif __name__ == '__main__':\n  port = os.environ('PORT', 8000)\n  manager.add_command('runserver', Server(port=port))\n  manager.run() I’ve left out a few niceties like logging and printing the URL for brevity. This isn’t particularly interesting to our task and is just some housekeeping to run a simple server for our APIs. The config.py is also important for pulling in some of those environment variables we’ll need to reference later. import os\n\nclass Config(object):\n  SECRET_KEY = os.environ.get('FLASK_SECRET_KEY')\n  APP_ID_HERE = os.environ.get('APP_ID_HERE')\n  APP_CODE_HERE = os.environ.get('APP_CODE_HERE')\n\n  @staticmethod\n  def init_app(app):\n    pass\n\nconfig = {'default': Config} Unlike other Python projects, our init files are pretty important on this one. In app/ init .py we define the create_app function we saw in manage.py . from config import config\nfrom flask import Flask\n\ndef create_app(config_name):\n  app = Flask(__name__)\n  app.config.from_object(config[config_name])\n  config[config_name].init_app(app)\n\n  from .api_1_0 import api as api_1_0_blueprint\n  app.register_blueprint(api_1_0_blueprint, url_prefix='/api/1.0')\n\n  return app This gives us nice clean api versioning for any resources in our API. We also need to define app/api_1_0/ init .py with some configuration from flask import Blueprint\napi = Blueprint('api', __name__)\n\nfrom . import health\nfrom . import demo As you can see, we do need to make sure each library we create is identified as part of the blueprint. Healthcheck To make sure our server is running properly we can add a quick healthcheck endpoint in the file app/api_1_0/healthcheck.py . from flask import jsonify\nfrom flask import current_app as app\nfrom . import api\n\n@api.route('/health', methods=['GET'])\ndef handle_health():\n  return jsonify({\n    'hello': 'world',\n    'app_id_here': app.config['APP_ID_HERE'],\n    'app_code_here': app.config['APP_CODE_HERE']\n    }) At this point we should be able to run python manage.py runserver and have proof of life. If you use your browser to go to http://localhost:8000/healthcheck we should get a response that confirms our server is up and has our app_id and app_code properly configured. You may not want to display this once you hit production but is fine while we’re at a “hello world” stage. Text For the purposes of getting started I will use a simple text file with just our locations from before. Venice\nMdina\nAswan\nSoro\nGryfino For more complex data sets to test with I recommend just trying out something from the New York Times , Wall Street Journal , or BBC travel sections. Extract We need to extract text from HTML and tokenize any words found that might be a location. We will define a method to handle requests for the resource /tokens so that we can look at each step independently. @api.route('/tokens', methods=['GET'])\ndef handle_tokenize():\n  # Take URL as input and fetch the body\n  url = request.args.get('url')\n  response = session.get('url')\n\n  # Parse HTML from the given URL\n  body = BeautifulSoup(response.content, 'html.parser')\n\n  # Remove JavaScript and CSS from our life\n  for script in body(['script', 'style']):\n    script.decompose()\n\n  text = body.get_text()\n\n  # Ignore punctuation\n  tokenizer = RegexpTokenizer(r'\\w+')\n\n  # Ignore duplicates\n  tokens = set(tokenizer.tokenize(text))\n\n  # Remove any stop words\n  stop_words_set = set(stopwords.words())\n  tokens = [w for w in tokens if not w in stop_words_set]\n\n  # Now just get proper nouns\n  tagged = pos_tag(tokens)\n  tokens = [w for w,pos in tagged if pos in ['NNP', 'NNPS']]\n\n  return jsonify(list(tokens)) Before this will work, we need to download NLTK resources. This is a one-time operation you can do in an interactive python shell or by executing a simple script. $ python\n...\n>>> import nltk\n>>> nltk.download('stopwords')\n>>> nltk.download('averaged_perceptron_tagger') With this demo.py in place we can restart our server and call the following endpoint to get back a list of any terms that could potentially be locations. #!/bin/bash\ncurl http://localhost:8000/api/1.0/tokens?url=$1 For example, if you were looking at \" Biking the Open Road in Colorado, With a Few Bumps Along the Way \" this returns a response including terms like: [\"Retreat\",\"Industry\",\"Boushnak\",\"Frise\",\"National\",\"Mesa\",\"Chicago\",\"Washington\",\"Forest\",\"Angeles\",\"Canyons\",\"Colorado\",...] We’ve trimmed the wordcount down dramatically from the original article but there is still much more work that could be done to fine tune this recognition process. This is good enough for a first pass though without adding more complexity.  There is obviously still some noise and not all of these are locations, but that's what we can use the HERE Geocoder to help with. Geocode The HERE Geocoder API very simply takes a human understandable location and turns it into geocordinates. If you put in an address, you get back latitude and longitude. Here’s the listing for a geocoder endpoint: @api.route('/geocode', methods=['GET'])\ndef handle_geocode():\n  uri = 'https://geocoder.api.here.com/6.2/geocode.json'\n  headers = {}\n  params = {\n    'app_id': app.config['APP_ID_HERE'],\n    'app_code': app.config['APP_CODE_HERE'],\n    'searchtext': request.args.get('searchtext')\n  }    \n\n  response = session.get(uri, headers=headers, params=params)\n  return jsonify(response.json()) Restart the python webserver and send a request for a city like “Gryfino”: #!/bin/bash\ncurl http://localhost:8000/api/1.0/geocode?searchtext=$1 The response includes among other things the location I might put a marker to display this position on a map. \"DisplayPosition\": {\n  \"Latitude\": 53.25676,\n  \"Longitude\": 14.48947\n}, Map Finally, we’re going to take the latitude and longitude we received from our geocode request and generate a simple render with the HERE Map Image API. This listing looks like the following: @api.route('/mapview', methods=['GET'])\ndef handle_mapview():\n  uri = 'https://image.maps.api.here.com/mia/1.6/mapview'\n  headers = {}\n  params = {\n    'app_id': app.config['APP_ID_HERE'],\n    'app_code': app.config['APP_CODE_HERE'],\n    'poi': request.args.get('poi')\n  }\n\n  response = session.get(uri, headers=headers, params=params)\n  image_path = tempfile.mktemp()\n  open(image_path, 'wb').write(response.content)\n\n  return image_path For simplicity and brevity I haven’t included any of the error / response handling you should do here. I’ve also cheated a bit by just storing the image to the local filesystem for illustration. Now by calling this endpoint with a comma-separated list of latitude, longitude pairs it will return a map with all of the locations having markers. Place names without additional context can be ambiguous so in some cases there was more than one match.  This map is only showing the first match, despite how much fun Venice beach may be. Summary The reason for making /tokens , /geocode , and /mapview separate endpoints is that this illustrates how you might setup microservices with Python + Flask for each operation you want to perform. This would allow a deployment to scale them independently. You can find the full source code listing in the GitHub project . For an extra dose of inception, try running the code and processing this article itself if you are still curious where to find Aswan and Gryfino.", "date": "2018-10-19"},
{"website": "Here", "title": "October Release Highlights", "author": ["Denis Panov"], "link": "https://developer.here.com/blog/october-release-highlights", "abstract": "Many minor updates and fixes across the board but a few noteworthy changes related to the following services: Batch Geocoder API , Routing API , Fleet Telematics API , Fleet Telematics Route Matching , and the Mobile SDKs for Android and iOS. HIGHLIGHTS Add time dependent restrictions to response attributes from Routing API requests. Updates to the HERE Mobile SDK with beta support of Environmental zone exclusions. Launch of Fleet Telematics API. The Fleet Telematics API gives access through just one service endpoint to all features and functions that were previously accessible through the separate Fleet Telematics Services (except Fleet Connectivity API).  L earn more in Denise Vlaicu's post Platform Extensions are getting a makeover with the Fleet Telematics API . Batch Geocoder API Send up to a million lines of address information for geocoding in batch process. Version 6.2.58 Additional map reference fields are now available for results. Routing API Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Version 7.2.97 Option timeDependentRestriction added to attribute types in linkAttributes parameter of a response. Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Version 1.0.0 Initial Release. Fleet Telematics Route Matching Match the GPS traces to the HERE road network to get the most probable routes for your vehicles, and detect illegal maneuvers. Version 2.5.9 RME can now also return custom layer geometries in the response (in addition to map layers): &customAttributes=layer(attributes) HERE Android SDK Starter Edition version 3.9 This version of the SDK has been updated to work with Android 9.0. Premium Edition version 3.9 Added support for Android 9.0. Enhanced routing options to exclude specified routing zones (such as environmental zones) from the calculated route as a Beta feature. Added option to periodically retrieve and display alternative routes during guidance. Scooter routing will now take scooter-only roads into account. Enhanced LaneInformation APIs to identify the lane direction which corresponds with the next maneuver on the route. Added support for patterned polylines, polygons and circles. Added an option to suppress streets where the map does not provide a name, from Reverse Geocoder results. Offline routing no longer works with on demand map data downloads. Starting with this release, map data must be downloaded or prefetched beforehand for offline routing to work properly. To ensure Turn-by-Turn navigation works in offline mode or area that has poor network connection, map data that covers the route should be first prefetched or downloaded via map loader. HERE iOS SDK Starter Edition version 3.9 This version of the SDK has been updated to work with iOS 12 and Xcode 10. The HERE SDK now supports Swift 4.2. Premium Edition version 3.9 This release fully supports iOS 12 and Xcode 10. The HERE SDK now supports Swift 4.2. Added option to periodically retrieve and display alternative routes during guidance. Scooter routing will now take into account scooter-only roads. Enhanced NMALaneInformation APIs to identify the lane direction which corresponds with the next maneuver on the route. Added support for patterned polylines, polygons and circles. Added an option to suppress streets where the map does not provide a name, from Reverse Geocoder results. Added option to enable/disable kinetic effects for specific gestures such as pinch zoom. Offline routing no longer works with on demand map data downloads. Starting with this release, map data must be downloaded or prefetched beforehand for offline routing to work properly. To ensure Turn-by-Turn navigation works in offline mode or area that has poor network connection, map data that covers the route should be first prefetched or downloaded via map loader.", "date": "2018-10-16"},
{"website": "Here", "title": "Searching for Points of Interest with the HERE Places API in a Vue.js Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/searching-for-points-of-interest-with-the-here-places-api-in-a-vue.js-application", "abstract": "When I’m looking at a map, I’m typically using it for two reasons. I’m either trying to navigate between two points or I’m trying to find a certain point of interest on the map. HERE provides an API for finding nearby places using REST and JavaScript, but what if you wanted to use a modern framework? Previously I had written a tutorial titled, Displaying Places on a HERE Map in an Angular Web Application which focused on Angular, but this time around we’re going to focus on Vue.js. In this tutorial, we’re going to see how to search for nearby places using the HERE Places API for JavaScript and display those points of interest on a map using the Vue.js JavaScript framework. The following image demonstrates what we hope to accomplish in this tutorial: We’re going to display a map with a search box. The user will be able to search for a place and all matches will be displayed on the map as markers. When a marker is clicked, the address information will be displayed as an information bubble. The Requirements To build an application with the HERE Places API, a few prerequisites must be met: The Vue CLI must be installed and configured. A HERE developer account must be available for the appropriate application tokens. While we won’t be doing anything intense in this tutorial when it comes to Vue.js, and the Vue CLI isn’t a requirement for creating Vue.js applications, it will make our lives easier. When working with the HERE Location Services (HLS), an app id and app code is required. These can be obtained after creating a free developer account . Bootstrapping a Vue Application with a Mapping Component This isn’t the first time that I wrote about Vue.js and HERE. In an effort to save me from re-explaining things that I’ve done in other tutorials, we’re going to bootstrap our application with the essentials and move beyond. If you’d like to see how to create a map component in Vue.js, I suggest checking out the tutorial I wrote titled, Showing a HERE Map with the Vue.js JavaScript Framework . If you want to learn about adding markers to your map, you can check out my tutorial titled, Dropping Markers on Geocoded Locations within a Vue.js Web Application . To get us up to speed, lets quickly create a project and add the code from those tutorials. From the Vue CLI, execute the following: vue create here-places-project The above command will use the Vue CLI wizard to create a project. Because this project is simple, we’re going to use the defaults to the questions asked by the wizard. This means we won’t be using Vuex or a Vue Router. The next step is to include the HERE JavaScript libraries. Open the project’s public/index.html file and include the following HTML markup: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>HERE Maps with Vue</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1533195059\" />\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but vue-map doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-places.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> Essentially, we’ve included a bunch of scripts and a stylesheet. This will give us access to maps, core APIs, and an interactive map user interface. With the libraries in place, let’s get our map component ready. Create a src/components/HereMap.vue file within your project that contains the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width, height: height }\"></div>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                map: {},\n                platform: {},\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            lat: String,\n            lng: String,\n            width: String,\n            height: String\n        },\n        created() {\n            this.platform = new H.service.Platform({\n                \"app_id\": this.appId,\n                \"app_code\": this.appCode\n            });\n        },\n        mounted() {\n            var defaultLayers = this.platform.createDefaultLayers();\n            this.map = new H.Map(\n                this.$refs.map,\n                defaultLayers.normal.map,\n                {\n                    zoom: 10,\n                    center: { lng: this.lng, lat: this.lat }\n                }\n            );\n        },\n        methods: { }\n    }\n</script>\n\n<style scoped></style> The above code gets us up to speed when it comes to our component in relation to the other tutorials. We create a placeholder UI component, initialize a few variables, define a few possible component properties, initialize HERE, and center the map. To use the component, the project’s src/App.vue file should look like the following: <template>\n    <div id=\"app\">\n        <HereMap ref=\"map\" appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\" width=\"100%\" height=\"800px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style>\n    #app {\n        font-family: 'Avenir', Helvetica, Arial, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        text-align: left;\n        color: #2c3e50;\n    }\n</style> Using the properties that were defined in the component, we can make use of the map. This sums up everything that was done in my tutorial titled, Showing a HERE Map with the Vue.js JavaScript Framework , but without the depth of explanations. We can now focus on actually using the HERE Places API. Searching for Points of Interest with the HERE Places API for JavaScript Before we can start searching for places, we need to initialize it within our application. Open the project’s src/components/HereMap.vue and alter the project’s data and created methods: data() {\n    return {\n        map: {},\n        platform: {},\n        ui: {},\n        search: {}\n    }\n},\ncreated() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.search = new H.places.Search(this.platform.getPlacesService());\n}, In the data method we are initializing a ui variable and search variable. These will be used throughout our component. In the created method we are setting the search variable using the new places service. It makes sense to create a places method now for searching. In the methods object, include the following: methods: {\n    places(query) {\n        this.map.removeObjects(this.map.getObjects());\n        this.search.request({ \"q\": query, \"at\": this.lat + \",\" + this.lng }, {}, data => {\n            for(var i = 0; i < data.results.items.length; i++) {\n                // Marker logic here\n            }\n        }, error => {\n            console.error(error);\n        });\n    },\n} When the places method is called, we are passing a query string. To allow multiple searches, we are going to clear the map every time the method is called. When the search is performed, the query string is used along with the latitude and longitude of the centered map. The response from the search should be coordinates which we’ll later use for placing markers. Now that we’re able to search, we need to configure search in the parent component. Open the project’s src/App.vue file and make some changes, like so: <template>\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"query\" />\n        <button type=\"button\" v-on:click=\"search()\">Search</button>\n        <HereMap ref=\"map\" appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\" width=\"100%\" height=\"800px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        },\n        data() {\n            return {\n                query: \"Starbucks\"\n            }\n        },\n        methods: {\n            search() {\n                this.$refs.map.places(this.query);\n            }\n        }\n    }\n</script>\n\n<style>\n    #app {\n        font-family: 'Avenir', Helvetica, Arial, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;\n        text-align: left;\n        color: #2c3e50;\n    }\n</style> A few things have changed. First look in the <template> block. We have an input field bound to a class variable and a button bound to a method in the class. If we look into the class, we initialize our query variable that is bound and define our search method. There are numerous ways to interact with child components, but for this example we’ll use the ref attribute. Using the ref attribute we can call methods from our component, passing the query string. If you were to print from the places method, you should see results appearing, but not on the map itself. Interacting with Places using Markers and Information Bubbles To bring our application to a close, we’re going to display markers for each of the places found. When clicking those places we’re going to see address information through information bubbles. Go back into the project’s src/components/HereMap.vue file and change the mounted method: mounted() {\n    var defaultLayers = this.platform.createDefaultLayers();\n    this.map = new H.Map(\n        this.$refs.map,\n        defaultLayers.normal.map,\n        {\n            zoom: 10,\n            center: { lng: this.lng, lat: this.lat }\n        }\n    );\n    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n    this.ui = H.ui.UI.createDefault(this.map, defaultLayers);\n}, You’ll notice that we added two lines. The first line for behavior gives us the ability to click on markers. Without it, markers will show, but not display anything on click even if click logic is in place. The second line is for our UI objects which will come in the form of information bubbles. Now we can set our markers and information bubbles through a method like so: dropMarker(coordinates, data) {\n    var marker = new H.map.Marker(coordinates);\n    marker.setData(\"<p>\" + data.title + \"<br>\" + data.vicinity + \"</p>\");\n    marker.addEventListener('tap', event => {\n        var bubble = new H.ui.InfoBubble(event.target.getPosition(), {\n            content: event.target.getData()\n        });\n        this.ui.addBubble(bubble);\n    }, false);\n    this.map.addObject(marker);\n} The above dropMarker method will appear in the methods object. The coordinates will be a latitude and longitude and the data will be the address information to present. When creating a marker, we are also creating an event listener for click events. The information bubble will be set using the data that was added to the marker. Once the information bubble is created, the marker is added to the map. With the dropMarker method in place, we can update the places method: places(query) {\n    this.map.removeObjects(this.map.getObjects());\n    this.search.request({ \"q\": query, \"at\": this.lat + \",\" + this.lng }, {}, data => {\n        for(var i = 0; i < data.results.items.length; i++) {\n            this.dropMarker({ \"lat\": data.results.items[i].position[0], \"lng\": data.results.items[i].position[1] }, data.results.items[i]);\n        }\n    }, error => {\n        console.error(error);\n    });\n}, If you do a search now, markers should show up on the map and those markers should have click events associated with them. Conclusion You just saw how to use the HERE Places API using JavaScript and the Vue.js framework. Most of the setup was around building a Vue.js component and not so much in the actual searching for points of interest which is great. If you’re interested in seeing how to search for points of interest with Angular, check out a previous tutorial I wrote on the subject.", "date": "2018-10-18"},
{"website": "Here", "title": "Why Smart Choice Technologies Chose HERE", "author": ["Zuzana Dittes"], "link": "https://developer.here.com/blog/case-study-on-why-smart-choice-technologies-chose-here", "abstract": "We interviewed one of our customers, the founder from Smart Choice Technologies to understand how they use HERE services. What does Smart Choice Technologies do? Smart Choice Technologies provides online application and enrollment systems for schools.  We also run lotteries for schools that take more applications than they have seats available. How did you get started? It started in 2006 as a school project.  The high school I was in wanted to have an online application process, so I worked with one of the teachers to set up a simple application that would allow this.  Around 2012, we made it into a product and started to offer it to other school districts.  Originally, I was the only founder but this year merged with another company called Firefly Digital who was supporting and marketing the system.  So now I have two other partners. Today, we have about 85 customers (larger school districts of the United States) which means that we are used by about 4000 schools and 4 million students total. What was the problem that led you to look for location solutions? We typically have parents enter an address in our system and , using that address , determine what zone th ey live in.  The zone identifies their home school and if they would qualify for other priorities that might be based on their location. Sometimes we even determine the distance from their home address to a school they are enrolling or applying so that they can determine the point to point distance. Recently we’ve been giving directions – not just a point to point – but the actual route to their school to give them an accurate estimate on how close they are to their school. To do this, we need to have an accurate and reliable geocoder service. How did you find out about HERE Technologies? I found HERE by doing an online search. We were using a different geocoding company since the time we started but we were not happy with the quality of their service, so we started searching for alternatives. Why did you decide to use HERE?  What factors in location services were most important for you? The number one reason for us was the accuracy of the service . The provider that we used before HERE was not very accurate. We were receiving complaints that the student addresses were wrong and that would put them in the wrong zone or giving them priorities incorrectly. After testing HERE for just a week we could see that the results were very accurate. We haven’t had one customer yet coming back and saying that the address was geocoded incorrectly. With the other services we tried we would typically hear every couple days something about a bad address. The second factor would be the cost. We do not charge our clients for the geocoding services as we used to be able to get it cheaply from the previous provider. With other big providers we tested, the cost was so high that we would not be able to justify that cost to our customers. With HERE, the cost was reasonable enough. Also, we are very happy with the HERE customer services. And now you have made my day with the new Freemium plan 😊. Which HERE services are you using? We mainly use the geocoder and now we are starting to test the routing services. I am very happy that HERE offers many different services because in the future we might need even more than that. How are we helping you to achieve your technical and business goals? By the service working. It gives us the data that we need, it is very reliable, the API was very easy to plug in. We don’t have to worry about the location services anymore, it just works.", "date": "2018-10-24"},
{"website": "Here", "title": "Street Address Form Validation with ReactJS and HERE Geocoder Autocomplete", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/street-address-validation-with-reactjs-and-here-geocoder-autocomplete", "abstract": "If you want customers to buy from you, requiring a shipping or billing address may become part of your ReactJS application. Nearly every database course looks at postal addresses as a good baseline tutorial for how to organize your data model in normal form, but what about on the client-side? To keep garbage out of your records you may want to take some time to address this with address validation. If you also want to improve the user experience, the HERE Geocoder Autocomplete API may help. This REST service lets you identify an address in fewer keystrokes which can help avoid spelling mistakes by providing suggestions with each character typed. There are also some powerful features like spatial and region filters to improve relevance as well. Project For this project, we want to create a simple address form as shown by this mockup. As you start typing “2168 Sha” the rest of the address should be filled in automatically. We can then check the address with the HERE Geocoder API to be sure we can identify a latitude and longitude value. Getting Started Generating 29,542 files for what amounts to a single page form may seem like overkill, but I still recommend starting with create-react-app . The development tools like a local server with live-reloading in a browser are helpful for quick iterations. Let’s get started by running the following: create-react-app app\ncd app\nnpm install bootstrap axios\nnpm start As you can see I’ll also be using Bootstrap as the CSS framework and axios as an HTTP client. Thinking in React Following the concepts from the ReactJS tutorial Thinking in React we will follow a few basic steps. Break the UI into a component hierarchy Build a static version Identify the minimal representation of UI state Identify where the state should live Add inverse data flow Break the UI into a component hierarchy Using our mockup from before, it looks like we can break the page up into a number of components. Build a static version Starting from the bottom, the AddressItem is a single row item consisting of a label and form element. I’m using ES6 classes and exporting the class for use by other components. import React, { Component } from 'react';\n\nclass AddressItem extends Component {\n  render() {\n    return (\n        <div className=\"row form-group justify-content-start\">\n            <label className=\"col-sm-4 col-form-label\">{this.props.label}</label>\n            <div className=\"col-xl-8\">\n              <input\n                type=\"text\"\n                defaultValue={this.props.value}\n                onChange={this.props.onChange}\n                className=\"form-control\"\n                placeholder={this.props.placeholder} />\n            </div>\n        </div>\n      );\n  }\n}\n\nexport default AddressItem; The AddressSuggest and AddressInput components both make use of the AddressItem in their render methods. // app/src/AddressSuggest.js\nclass AddressSuggest extends Component {\n  render() {\n    return (\n      <AddressItem label=\"Address\" value={this.props.query} placeholder=\"start typing\" />\n      );\n  }\n} You may recognize that I've skipped the import and exports here for brevity but they are still required.  You can find those in the full listing from the GitHub repository linked at the end. // app/src/AddressInput.js\nclass AddressInput extends Component {\n  render() {\n    return (\n      <div className=\"card\"><div className=\"card-body\">\n      <AddressItem label=\"Street\" value={this.props.street} placeholder=\"\" readonly=\"true\" />\n      <AddressItem label=\"City\" value={this.props.city} placeholder=\"\" readonly=\"true\" />\n      <AddressItem label=\"State\" value={this.props.state} placeholder=\"\" readonly=\"true\" />\n      <AddressItem label=\"Postal Code\" value={this.props.code} placeholder=\"\" readonly=\"true\" />\n      <AddressItem label=\"Country\" value={this.props.country} placeholder=\"\" readonly=\"true\" />\n      </div></div>\n    );\n  }\n} Continuing up the hierarchy, the AddressForm combines the whole input form along with submission buttons to do our validation. // app/src/AddressForm.js\nclass AddressForm extends Component {\n  render() {\n    return (\n        <div className=\"container\">\n          <AddressSuggest />\n            query=\"4168 S\"\n            />\n          <AddressInput\n            street=\"4168 Shattuck Ave\"\n            city=\"Berkeley\"\n            state=\"CA\"\n            code=\"94704\"\n            country=\"USA\"\n            />\n          <br/>\n          <button type=\"submit\" className=\"btn btn-primary\">Check</button>\n          <button type=\"submit\" className=\"btn btn-outline-secondary\">Clear</button>\n        </div>\n      );\n  }\n} As you can see we just hard-coded some static values in as properties to see how our form will look before we need to deal with any interactive behaviors. Up next, we need to replace some of those properties with state. Tracking State Up to this point we’ve only used immutable properties. Now we want to go back and start tracking state. The minimal information we want to track: search query entered by the user which changes over time postal address can be computed, but can also change over time by user input The AddressForm is a common ancestor in the hierarchy for these two related components that we want to keep in sync. As the user starts typing text in the AddressSuggest we will query the HERE Geocoder Autocomplete API and update AddressInput. Looking at the HERE Autocompletion JavaScript Demo we see the required parameters of query , app_id , and app_code . Unlike that demo, we will use axios as the HTTP client for making requests. The constant variables APP_ID_HERE and APP_CODE_HERE also need to be defined to be referenced as seen in the code below. The AddressForm now looks like: class AddressForm extends Component {\n  constructor(props) {\n    super(props);\n\n    const address = this.getEmptyAddress();\n    this.state = {\n      'address': address,\n      'query': '',\n      'locationId': ''\n    }\n\n    this.onQuery = this.onQuery.bind(this);\n  }\n\n  onQuery(evt) {\n    const query = evt.target.value;\n    if (!query.length > 0) {\n      const address = this.getEmptyAddress();\n      return this.setState({\n        'address': address,\n        'query': '',\n        'locationId': ''\n        })\n    }\n\n    const self = this;\n    axios.get('https://autocomplete.geocoder.api.here.com/6.2/suggest.json', {\n      'params': {\n        'app_id': APP_ID_HERE,\n        'app_code': APP_CODE_HERE,\n        'query': query,\n        'maxresults': 1,\n      }}).then(function (response) {\n        const address = response.data.suggestions[0].address;\n        const id = response.data.suggestions[0].locationId;\n        self.setState({\n          'address': address,\n          'query': query,\n          'locationId': id,\n          });\n      });\n  }\n\n  render() {\n    return (\n      <div class=\"container\">\n        <AddressSuggest\n          query={this.state.query}\n          onChange={this.onQuery}\n          />\n        <AddressInput\n          street={this.state.address.street}\n          city={this.state.address.city}\n          state={this.state.address.state}\n          postalCode={this.state.address.postalCode}\n          country={this.state.address.country}\n          />\n        ...\n      );\n  }\n} The response from the Geocoder Autocomplete includes an array of suggestions. Two valuable pieces of information there include the locationId if we wanted to do a full geocoder lookup by id to get the latitude and longitude. Included is also an address block which details the city, country, street, state, and postalCode for display in our form. Inverse Data Flow You may have noticed that for our AddressSuggest component we added a onChange={this.onQuery} . This pushes this method down to lower-level components. Those lower level components need to respond to user input which should be easy now that we’ve passed a reference to this handler as a property as seen in the AddressSuggest component. return (\n    <AddressItem\n      label=\"Address\"\n      value={this.props.query}\n      onChange={this.props.onChange}\n      placeholder=\"start typing\" />\n); It is worth noting that each character typed by the user triggers this event. Since each event fires off a request to the Geocoder Autocomplete service we can quickly rack up many transactions. A final solution may make more efficient use of how these events are handled or display a lookahead of more than one suggestion at a time by changing maxresults=10 . Validation Up to this point we’ve helped the user by using their input as suggestions for guessing the correct address with less typing and errors. Once the address is input though, now we want to check it. We need to implement the behavior of our check and clear buttons using the HERE Geocoder . First, let’s modify our rendered elements to include a result and onClick event callbacks. { result }\n<button type=\"submit\" className=\"btn btn-primary\" onClick={this.onCheck}>Check</button>\n<button type=\"submit\" className=\"btn btn-outline-secondary\" onClick={this.onClear}>Clear</button> We also make sure that all of our event handlers are bound in the constructor. This makes sure that this is an available reference. We then have methods defined for each of these cases. // User has entered something in address suggest field\nthis.onQuery = this.onQuery.bind(this);\n// User has entered something in address field\nthis.onAddressChange = this.onAddressChange.bind(this);\n// User has clicked the check button\nthis.onCheck = this.onCheck.bind(this);\n// User has clicked the clear button\nthis.onClear = this.onClear.bind(this); The clear handler is pretty straightforward, just calling setState() for returning everything to the initial state as it was when constructor originally runs. The check handler is much more involved. Let’s look at it in a few pieces. This first section is initializing the parameters for the Geocoder service. If we used the Geocoder Autocomplete to find a suitable address, we should already have a LocationId that we can use. If we don’t have that or the user entered text into the various fields – then we’ll construct a search string with whatever details are provided. onCheck(evt) {\n  let params = {\n    'app_id': APP_ID_HERE,\n    'app_code': APP_CODE_HERE\n  }\n\n  if (this.state.locationId.length > 0) {\n    params['locationId'] = this.state.locationId;\n  } else {\n    params['searchtext'] = this.state.address.street\n      + this.state.address.city\n      + this.state.address.state\n      + this.state.address.postalCode\n      + this.state.address.country\n  }\n  ...\n} With the parameters in place, we again use axios to fetch a response from the geocoder REST API. If we get back a promised response with a matching location we can set the state to the appropriate success or error conditions. onCheck(evt) {\n  ...\n\n  const self = this;\n  axios.get('https://geocoder.api.here.com/6.2/geocode.json',\n    { 'params': params }\n  ).then(function(response) {\n    const view = response.data.Response.View\n    if (view.length > 0 && view[0].Result.length > 0) {\n      const location = view[0].Result[0].Location;\n\n      self.setState({\n        'isChecked': 'true',\n        'coords': {\n            'lat': location.DisplayPosition.Latitude,\n            'lon': location.DisplayPosition.Longitude\n        },\n        'address': {\n          'street': location.Address.HouseNumber + ' ' + location.Address.Street,\n          'city': location.Address.City,\n          'state': location.Address.State,\n          'postalCode': location.Address.PostalCode,\n          'country': location.Address.Country\n        }});\n    } else {\n      self.setState(\n        'isChecked': true,\n        'coords': null\n        );\n    }\n\n  })\n  ...\n} Getting a latitude and longitude alone is not the best indicator so it is also important to look at the MatchLevel, MatchType, and MatchQuality to evaluate whether the address is valid. \"Result\": [\n          {\n            \"Relevance\": 1,\n            \"MatchLevel\": \"houseNumber\",\n            \"MatchQuality\": {\n              \"State\": 1,\n              \"City\": 1,\n              \"Street\": [\n                1\n              ],\n              \"HouseNumber\": 1\n            },\n            \"MatchType\": \"pointAddress\",\n            ... You can learn more about the address details like this from the Geocoder Search Response documentation. For the full source listing, please review the GitHub repository HERE-react-address-validation . Summary This demonstration looked into how to think about creating components with React so that we could build a smart address form with the HERE Geocoder Autocomplete API . We also did some additional validation using the HERE Geocoder API to retrieve a latitude and longitude to help us test our match quality.  Street address validation for deliverability can be a complex subject but hope this gets you started. There are many other ways to do client-side address validation which haven’t been covered here but hope that seeing how to use a Geocoder as a component can be valuable for better user experience. If you use other libraries like Formik , react-final-form or informed and have other ideas about how to do address validation with React let me know in the comments. If you found this article helpful, check out the post HERE with React - Location Based TODO App for more #ReactJS #JavaScript examples.", "date": "2018-10-28"},
{"website": "Here", "title": "Process CSV Address Information with Golang and the HERE Geocoder API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/process-csv-address-information-with-golang-and-the-here-geocoder-api", "abstract": "Have you ever been given a comma separated value (CSV) file filled with people information where the data is only partially complete and you’re the one tasked with filling in the blanks? What if specifically you’re given data where the address information is incomplete? Do you, by hand, gather the information which could take X amount of time or do you try to automate the process? Not too long ago, I wrote about a similar scenario I faced in a tutorial titled, Simple Data Processing with JavaScript and the HERE API . However, in that experience I demonstrated using Node.js. In this tutorial we’re going to see how to parse a CSV file using the Go programming language (Golang) and clean up the address information using the HERE Geocoder API . To make things more interesting we’re going to follow best practices for concurrency to give the application the best possible performance. The anticipated results should look something like the following image: The above image doesn’t explain everything. For example, we have two lines in our CSV file and the location data for those lines is very vague. Think “Tracy, CA” and “Berlin”. When running our application, more sense is made of that location data. Mapping REST Responses and the General Application Data Model Before applying any application logic, we need to add our Golang boilerplate code and define the data models we wish to use. The most obvious of the data models is that of the actual HERE API response. Create a main.go file within the $GOPATH and include the following: package main\n\nimport (\n    \"bufio\"\n    \"encoding/csv\"\n    \"encoding/json\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n    \"sync\"\n)\n\ntype Address struct {\n    Label       string `json:\"Label,omitempty\"`\n    Country     string `json:\"Country,omitempty\"`\n    State       string `json:\"State,omitempty\"`\n    County      string `json:\"County,omitempty\"`\n    City        string `json:\"City,omitempty\"`\n    District    string `json:\"District,omitempty\"`\n    Street      string `json:\"Street,omitempty\"`\n    HouseNumber string `json:\"HouseNumber,omitempty\"`\n    PostalCode  string `json:\"PostalCode,omitempty\"`\n}\n\ntype GeoData struct {\n    Response struct {\n        View []struct {\n            Type   string `json:\"_type\"`\n            Result []struct {\n                Location struct {\n                    Address         Address `json:\"Address\"`\n                    DisplayPosition struct {\n                        Latitude  float64 `json:\"Latitude\"`\n                        Longitude float64 `json:\"Longitude\"`\n                    } `json:\"DisplayPosition\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n}\n\ntype LeadData struct {\n    Firstname string  `json:\"first_name\"`\n    Lastname  string  `json:\"last_name\"`\n    Company   string  `json:\"company\"`\n    Email     string  `json:\"email\"`\n    Location  string  `json:\"location,omitempty\"`\n    Address   Address `json:\"address,omitempty\"`\n}\n\ntype Geocoder struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\ntype ParsedLeadData struct {\n    mux  sync.Mutex\n    data []LeadData\n}\n\nvar waitGroup sync.WaitGroup\nvar geocoder Geocoder\nvar leadData chan LeadData\nvar parsedLeadData ParsedLeadData\n\nfunc main() {} The code above looks worse than it actually is. The Address data structure will hold all our information about an address. There are JSON annotations because of how it will be used with an actual response. The omitempty reference is there to avoid displaying null or empty values when we print out our data. The GeoData data structure is the actual response from the HERE API. The GeoData data structure uses the previously defined Address data structure and is actually far from complete. Looking at the documentation , there are other properties returned, but the properties we modeled are all that we really care about. The LeadData data structure represents the model of our CSV data. It is simple, but specific. The CSV data will have information about a person as well as a generic location that could be as complete or as incomplete as the user wants to make of it. The Address data structure is present because that is where we’ll store the geocoded data. The Geocoder is where we’ll store the app id and app code values obtained from a free HERE developer account . This information will be critical towards using the API. The ParsedLeadData data structure may be the most confusing if you’re a novice user of Golang. Because we plan to use concurrent goroutines in our application, things will happen in parallel. We cannot add our geocoded data asynchronously to a slice in Go, so we need to use a Mutex so that we can lock the slice from other goroutines trying to write to it at the same time. var waitGroup sync.WaitGroup\nvar geocoder Geocoder\nvar leadData chan LeadData\nvar parsedLeadData ParsedLeadData The above variables will be used throughout the application. The waitGroup variable will keep track of our worker goroutines, the geocoder will store our API credentials, the leadData will contain each line of our CSV file, and the parsedLeadData will hold our finalized results. Using the HERE Geocoder API via HTTP Requests It may be difficult to believe, but the easiest part of this application is the geocoder functionality. The reason for this is because we are only making an HTTP request to the HERE API. Within your project’s main.go file, include the following function: func (geocoder *Geocoder) geocode(query string) (GeoData, error) {\n    endpoint, _ := url.Parse(\"https://geocoder.api.here.com/6.2/geocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"searchtext\", query)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeoData{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geoData GeoData\n        json.Unmarshal(data, &geoData)\n        return geoData, nil\n    }\n} In the above function, we are taking the API credentials as well as a query string with a potentially complex address. Using that information we can construct an HTTP request. After executing the HTTP request, we store the response in a GeoData variable and return it to where this function was called. As long as our GeoData is modeled how we want it, gaining access to this information is easy because the API does all the heavy lifting. Loading Data from a CSV File With the model and API functionality in place, we need to be able to collect data from a CSV file. Golang does have some nice CSV functionality baked in to make our lives easier. Open the project’s main.go file and include the following: func LoadCSV(filepath string) error {\n    csvFile, _ := os.Open(filepath)\n    reader := csv.NewReader(bufio.NewReader(csvFile))\n    for {\n        line, err := reader.Read()\n        if err == io.EOF {\n            break\n        } else if err != nil {\n            return err\n        }\n        leadData <- LeadData{\n            Firstname: line[0],\n            Lastname:  line[1],\n            Company:   line[2],\n            Email:     line[3],\n            Location:  line[4],\n        }\n    }\n    return nil\n} In the above function, we are expecting a file path. With the file path, we open the file and start reading it as a CSV file. For each line of the CSV file, until we hit the end of the file, we convert the columns to a LeadData object and add it to our channel to be used concurrently by our worker threads. The workers will read from the channel in the same order that it was added. You can learn more about reading CSV data with Golang in a previous tutorial I wrote titled, Parse CSV Data using the Go Programming Language . Designing Workers for Concurrent Go Development With the CSV function reading lines of the CSV file into our channel, we need to determine what each of our workers will do with that data. Take the following worker function for example: func worker() {\n    defer waitGroup.Done()\n    for {\n        lead, ok := <-leadData\n        if !ok {\n            break\n        }\n        address, _ := geocoder.geocode(lead.Location)\n        if len(address.Response.View) > 0 && len(address.Response.View[0].Result) > 0 {\n            lead.Address = address.Response.View[0].Result[0].Location.Address\n            lead.Location = \"\"\n        }\n        parsedLeadData.mux.Lock()\n        parsedLeadData.data = append(parsedLeadData.data, lead)\n        parsedLeadData.mux.Unlock()\n    }\n} When the worker is started, it will remain running until the channel is empty. When the channel is empty, the loop is broken and the waitGroup variable is alerted. You’ll see the importance of the waitGroup soon. Assuming the channel is not empty, the generic location string from the CSV file is passed to our geocode function and the API response is obtained. If the API response has address data, it is added to our lead and the location is cleared out. To write our parsed data, we first lock our slice, append the parsed data, then unlock the slice so the next thread can access it. Parsing Address Information in Parallel with Goroutines With all our functions in place, we really just need to bring it all together. When the application is launched, we need to collect user input and determine how to set up our workers. Take the following main function: func main() {\n    filepath := flag.String(\"p\", \"data.csv\", \"Path to CSV Data\")\n    workers := flag.Int(\"w\", 5, \"Worker Thread Count\")\n    flag.Parse()\n    leadData = make(chan LeadData)\n    geocoder = Geocoder{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    for i := 0; i < *workers; i++ {\n        waitGroup.Add(1)\n        go worker()\n    }\n    LoadCSV(*filepath)\n    close(leadData)\n    waitGroup.Wait()\n    output, _ := json.Marshal(parsedLeadData.data)\n    fmt.Println(string(output))\n} We are accepting two user input flags and defaulting them if they are not present. These flags determine the file path and how many workers to use. Depending on the size of your CSV file and the power of your computer should determine how many workers you use. I probably wouldn’t recommend more than 20. After initializing our variables, we start our goroutines. Notice how we are adding one to the waitGroup for each worker. This tells the application that we need the waitGroup to be zero for the application to end. We’re doing this so our application doesn’t exit before our asynchronous processes complete. When every worker ends, the waitGroup subtracts. With the workers waiting for data, we call the LoadCSV function and populate the channel that the workers use. Now we actually wait until the workers are done. When the workers are done, we convert our parsed data into bytes and print it on the screen. Conclusion You just saw how to parse potentially massive amounts of CSV location data using Golang and the HERE Geocoder API . In this example, we read from a CSV and made requests for location data in parallel, depending on how many worker threads were available. This tutorial was an alternative to a previous tutorial that I had written in Node.js. There are a few things to note that I hadn’t covered in this tutorial. The HERE Geocoder API could return more than one result for a given query string. The more vague the query, the more likely for more results. I also ignored many of the errors that could have been produced throughout the tutorial. In a production application, don’t ignore them with an underscore. If you’d like to see how to reverse geocode data, as in take latitude and longitude coordinates and convert them into addresses using Golang, check out a tutorial I wrote titled, Reverse Geocoding Coordinates to Addresses with the Go Programming Language .", "date": "2018-11-01"},
{"website": "Here", "title": "How To Migrate KML to HERE Maps", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/how-to-migrate-kml-from-google-to-here-maps-and-xyz", "abstract": "If you’ve used Google Maps to store custom places or create a map in the past, you may be wondering what you can do with that data now. The good news is that Google has provided a helpful tool to export your data to KML or KMZ which you can use to Switch to HERE. KML Keyhole Markup Language (KML) is an Open Geospatial Consortium (OGC) standard that specifies an XML language focused on geographic visualization, including annotation of maps and images. The (KMZ) extension is just a zip file to compress larger KML data sets. You can find the option to export your map like this: Looking at the contents of this downloaded file you can find markers represented as Placemark elements with geometry described by its shape ( Point ) and location ( coordinates ). <Placemark>\n        <name>Joe Montana</name>\n        <description>Jun 11, 1956 New Eagle, PA</description>\n        <styleUrl>#icon-22</styleUrl>\n        <Point>\n          <coordinates>\n            -79.953003,40.20405,0\n          </coordinates>\n        </Point>\n      </Placemark> Other types of geometry are supported as well so you can learn more about KML from a few of these resources: http://www.opengeospatial.org/standards/kml http://schemas.opengis.net/kml/ https://en.wikipedia.org/wiki/Keyhole_Markup_Language HERE Map The HERE Maps API for JavaScript supports reading KML data directly. If you’ve exported your KML data to work with, let’s put it on a HERE map. Start with some simple boilerplate like you may find in our Getting Started with Maps API examples. The one difference to note is including the mapsjs-core.js library which has the KML functionality we’ll need. <!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1526040296\" />\n\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-data.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\"></script>\n<script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"></script>\n\n</head>\n<body>\n\n   <div id=\"map\" style=\"width: 100%; height: 400px; background: grey;\" />\n   <script  type=\"text/javascript\" charset=\"UTF-8\" src=\"index.js\"></script>\n\n</body>\n</html> The index.js is where most of the logic will be written. You’ll find these steps to be a familiar pattern with many of the other tutorials in our documentation. The first step is to initialize the platform with the app_id and app_code you get when you sign up for an account at https://developer.here.com . You also initialize the layers for instantiating the map that can be centered wherever you like. const platform = new H.service.Platform({\n  app_id: APP_ID_HERE,\n  app_code: APP_CODE_HERE,\n})\n\nconst layers = platform.createDefaultLayers();\nconst map = new H.Map(\n  document.getElementById('map'),\n  layers.normal.map,\n  {\n    center: {lat: 40.4406, lng: -79.9958},\n    zoom: 4,\n  }); If you stopped there a map would be displayed, but if you want a slippy interactive map like many users might expect you’ll add in some more events and behaviors that you can customize. We won’t do too much customization in this example and just use the defaults, but I encourage you to explore the many options to generate a map that expresses your own brand or design preferences. const events = new H.mapevents.MapEvents(map);\nconst behavior = new H.mapevents.Behavior(events);\nconst ui = H.ui.UI.createDefault(map, layers); So far this is pretty standard boilerplate for working with HERE interactive maps. Next we’ll look at the Data Reader classes which is what we need for migrating our map. Data Reader The JavaScript H.data defines a few classes intended to help you work with different types of geospatial data such as GeoJSON or KML. The data I exported from Google Maps displayed a marker at the birthplace for all of the National Football League’s Hall of Fame Quarterbacks in the modern era. It was split up into 3 separate layers: Hall of Famers born in Western Pennsylvania represented with star icons Hall of Famers born elsewhere represented with football icons Likely Hall of Famers who are not yet elligible represented with diamond icons To read the exported KML, I initialize a H.data.kml.Reader object and pass it the filename that is served from the same web server. let reader = new H.data.kml.Reader('hof-qb.kml');\nreader.parse(); kml = reader.getLayer(); map.addLayer(kml); That last point about serving from a web server is important. Personally, I run python -m SimpleHTTPServer or python -m http.server while in development but use whatever your preference. If you try to load your index.html as a local file you may run into an error like this: mapsjs-core.js:164 Access to XMLHttpRequest at ‘file:///Users/delancey/hof-qb.kml’ from origin ‘null’ has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https. After reading in the KML we can add it as a layer on our map. At this point we should be able to render a map with the KML layers displayed. InfoBubbles There is one more piece of functionality to add. When clicking on a marker we may want to popup an info bubble to give the details that were exported such as the players name and birthdate. kml.getProvider().addEventListener('tap', function(ev) {\n\n  const info = ev.target.getData();\n\n  let content = '<b>' + info.name + '</b><br/>';\n  content += info.description;\n\n  let bubble =  new H.ui.InfoBubble(ev.target.getPosition(), {\n    content: content\n  });\n  ui.addBubble(bubble);\n}); We haven’t added any additional styling so the result will look like this: XYZ Studio With the beta launch of HERE XYZ we have an alternative path for quickly creating maps in the first place. If you missed the news about HERE XYZ , it is an open, interoperable and real-time location data management service that includes interactive tools to enable anybody to make a map easier and faster. With the layer editor you can draw on a map to create or edit content . The data table allows you to edit metadata directly with whatever useful information you want to display on a card. Summary With just a little bit of JavaScript code, you can take any geospatial data you have in a KML format, such as data exported from Google Maps, and display it on a HERE map.  It is also worth considering using HERE XYZ on your next mapping project as a way to quickly edit geospatial data directly on the map. With the KML exported and rendered on our map, we can see that there is a statistically significant number of Hall of Fame quarterbacks that were born in Western Pennsylvania. Read More If you want to learn more about how to switch to HERE, there are a number of other articles and tutorials to help you make the change. HERE Topples Google to Become the #1 Location Platform How to Migrate from Google Maps to HERE on iOS How to Migrate from Google Map Markers to HERE How to Migrate from Google Routes to HERE Routing How to Migrate from Google Places to HERE Geocoder Search How to Create a HERE Dynamic Map", "date": "2018-11-03"},
{"website": "Here", "title": "Geocoding Address Data in Batch Quantities with HERE and Golang", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/geocoding-address-data-in-batch-quantities-with-here-and-golang", "abstract": "If you’re a larger organization processing massive amounts of address information, you’re probably going to burn through your HERE API transactions pretty quickly and rack up a nice bill. The good news is that you can easily prevent this by batching your requests into fewer transactions using the HERE Batch Geocoder API . With the Batch Geocoder API you can send up to one million addresses to be geocoded in a single transaction. This could potentially save you a lot of money in the long term, depending on the needs of your application. We’re going to see how to use the HERE Batch Geocoder API with Golang to process a potentially large amount of data, check on the status, and download results to a file. Building Native Data Structures for the HTTP Response Rather than trying to use a generic Go interface{} for all of our responses and data, we should probably more accurately model our data so it is easier to work with in the long term. If you take a look at the documentation , you’ll notice that all responses of the Batch Geocoder API are of the same format. This is good for us because it limits the work we need to do. Create a main.go file somewhere in your $GOPATH and include the following: package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"encoding/xml\"\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n)\n\ntype BatchResponse struct {\n    Response struct {\n        MetaInfo struct {\n            RequestId string `xml:\"RequestId\" json:\"RequestId\"`\n        } `xml:\"MetaInfo\" json:\"MetaInfo\"`\n        Status         string `xml:\"Status\" json:\"Status\"`\n        TotalCount     int    `xml:\"TotalCount\" json:\"TotalCount\"`\n        ValidCount     int    `xml:\"ValidCount\" json:\"ValidCount\"`\n        InvalidCount   int    `xml:\"InvalidCount\" json:\"InvalidCount\"`\n        ProcessedCount int    `xml:\"ProcessedCount\" json:\"ProcessedCount\"`\n        PendingCount   int    `xml:\"PendingCount\" json:\"PendingCount\"`\n        SuccessCount   int    `xml:\"SuccessCount\" json:\"SuccessCount\"`\n        ErrorCount     int    `xml:\"ErrorCount\" json:\"ErrorCount\"`\n    } `xml:\"Response\" json:\"Response\"`\n}\n\ntype Geocoder struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\nfunc main() { } A lot of the code above is boilerplate Go code, but we have two data structures. The first data structure is a model of the potential response. Per the documentation, the response is XML, which isn’t exactly the nicest format to work with. Lucky for us, Go makes it easy to switch between formats using XML and JSON annotations. The annotations allow us to map the response to an object with no manual intervention. More information on working with XML data in Go can be found in a previous tutorial I wrote titled, Parse XML Data in a Golang Application . The Geocoder data structure will hold our app id and app code found in the HERE Developer Portal. To use this API you must have a developer account, which is free. Developing Functions for the HERE Batch Geocoder API Requests With the data models in place, we can focus on developing functions that will process our requests. As of now there is no Golang SDK for the HERE services, but REST is available and not difficult to use. Using the HERE Batch Geocoder API is a multi-step process. This means that no single request will allow us to upload data and get a geocoded response back. Instead, there are a few things to do, the first of which is upload data and start the process. Take a look at the following batch function: func (geocoder *Geocoder) batch(payload []byte) (BatchResponse, error) {\n    endpoint, _ := url.Parse(\"https://batch.geocoder.api.here.com/6.2/jobs\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"indelim\", \"|\")\n    queryParams.Set(\"outdelim\", \"|\")\n    queryParams.Set(\"outcols\", \"displayLatitude,displayLongitude,locationLabel,houseNumber,street,district,city,postalCode,county,state,country\")\n    queryParams.Set(\"outputcombined\", \"false\")\n    queryParams.Set(\"action\", \"run\")\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Post(endpoint.String(), \"text/plain\", bytes.NewBuffer(payload))\n    if err != nil {\n        return BatchResponse{}, err\n    } else {\n        data, err := ioutil.ReadAll(response.Body)\n        if err != nil {\n            return BatchResponse{}, err\n        }\n        var batchResponse BatchResponse\n        xml.Unmarshal(data, &batchResponse)\n        return batchResponse, nil\n    }\n} Most of the above code is around constructing a request. The batch function does require a payload to be provided. The payload in this circumstance is the byte data for a CSV file. After setting the query parameters, a POST request is made, passing the CSV file in the request. When the request is successful, the XML body that is returned is stored in the BatchResponse variable. Without getting too far ahead of ourselves, the final outcome for this request might look something like the following image: If everything went smooth, you’d be given a RequestId and a message saying the request was accepted. The RequestId will be used in future requests for checking the status or downloading the results. With the batch process running remotely, we’d want to check the status with a status function like this: func (geocoder *Geocoder) status(id string) (BatchResponse, error) {\n    endpoint, _ := url.Parse(\"https://batch.geocoder.api.here.com/6.2/jobs/\" + id)\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"action\", \"status\")\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return BatchResponse{}, err\n    } else {\n        data, err := ioutil.ReadAll(response.Body)\n        if err != nil {\n            return BatchResponse{}, err\n        }\n        var batchResponse BatchResponse\n        xml.Unmarshal(data, &batchResponse)\n        return batchResponse, nil\n    }\n} In the above code, the request is a little different. Instead of a POST request, we’re doing a GET request and the RequestId is expected. Assuming all went well, the response will be parsed into a BatchResponse object and returned. In the end, it might look something like the following image: Between the status response and the batch response, they are more or less the same, with the exception that the status has information about the process. When the process has completed, you’ll have information about the data and be able to download it. The final step in the process is to download a ZIP archive of the data. We can create a data function that looks like the following: func (geocoder *Geocoder) data(id string) ([]byte, error) {\n    endpoint, _ := url.Parse(\"https://batch.geocoder.api.here.com/6.2/jobs/\" + id + \"/result\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return nil, err\n    } else {\n        return ioutil.ReadAll(response.Body)\n    }\n} We cannot create a response model for this function because we’re getting binary data back. In the end we’ll want to take the binary data and save it to a file on the computer. So how do we use each of these functions that we had created? Establishing a CLI for Executing Requests Against the API The final part of this project is to bring everything together. We’re actually going to build our own little CLI, so we’re going to define some possible flags and how to react to them. Let’s have a look at the main function: func main() {\n    filepath := flag.String(\"p\", \"\", \"Path to CSV Data\")\n    status := flag.String(\"s\", \"\", \"Id for status of batch process\")\n    download := flag.String(\"d\", \"\", \"Id for download of batch process\")\n    flag.Parse()\n    geocoder := Geocoder{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    if *filepath != \"\" {\n\n    } else if *status != \"\" {\n\n    } else if *download != \"\" {\n\n    }\n} In the main function, we are defining three possible flags when the application is ran. A path to a CSV file, a status flag which is an id, and a download flag which is also an id. When the application is ran, we do a simple conditional statement to see which flag was provided. In this example we’re assuming only one flag is available per run. If the filepath is present, we can execute the following: if *filepath != \"\" {\n    data, _ := ioutil.ReadFile(*filepath)\n    result, err := geocoder.batch(data)\n    if err != nil {\n        fmt.Printf(\"The HTTP request failed with error %s\\n\", err)\n        return\n    }\n    jsonData, _ := json.Marshal(result)\n    fmt.Println(string(jsonData))\n} The CSV file is read and the byte data is passed as a payload to the batch function. The response is then converted into JSON and presented in the Terminal. It was pretty printed in the example images because of an optional Python tool. If the status is present, we can execute the following: if *status != \"\" {\n    result, err := geocoder.status(*status)\n    if err != nil {\n        fmt.Printf(\"The HTTP request failed with error %s\\n\", err)\n        return\n    }\n    jsonData, _ := json.Marshal(result)\n    fmt.Println(string(jsonData))\n} In the above code, we are taking the provided RequestId and passing it to the status function for an update. The result is also converted into JSON and printed in the Terminal. Finally, we have the last part of the process: if *download != \"\" {\n    result, err := geocoder.data(*download)\n    if err != nil {\n        fmt.Printf(\"The HTTP request failed with error %s\\n\", err)\n        return\n    }\n    fmt.Print(string(result))\n} In the above code, we pass the RequestId to the data function and the binary data that is returned, is printed in the Terminal. Using the binary data, we can save it to a file like so: go run *.go -d yCQBgMSQgdXhxnwkdMqjMec3doxeZl2v >> output.zip If you’d rather not pipe the response into a file, you could always implement some file logic within the Go application directly. From a scripting perspective, I thought it’d be more valuable to allow piping of the data. Conclusion You just saw how to use the HERE Batch Geocoder API in your Golang application. While batching requests might not be useful in every possible scenario, given the correct scenario, it could save your company a lot of money in API transactions. If you’d like to see how to use the Geocoder API without batching requests in Go, check out a previous tutorial I wrote on the topic titled, Process CSV Address Information with Golang and the HERE Geocoder API .", "date": "2018-11-06"},
{"website": "Here", "title": "Include a customized map with XYZ Studio in your WIX website", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/include-a-customized-map-with-xyz-studios-in-your-wix-website", "abstract": "The love for traveling runs in my family!  As a kid, I traveled to a new place twice a year and continue this tradition by making small trips every now and then. Not to brag about it (maybe a little), I keep a note of all the cities I have visited. And what good is it if I can't flaunt it?  I thus wanted to make a visual representation of this list on my WIX powered website. With XYZ Studio you can do this with little or no coding. To plot places on the map, you need two things: A map Geo-coordinates of the places you need to plot If you are interested in knowing what geo coordinates are, this article gives a good explanation. In short, If you draw vertical parallel lines on the globe joining the North and the South Pole, and horizontal parallel lines going East to West, that makes the base for the co-ordinate system. Depending on where the place lies w.r.t. these lines, it gets geo coordinates in the form of Latitude: N 52° 31' 51.096\", Longitude: E 13° 23' 5.064\" . Yes, the Earth isn't flat! The base map The first thing to do would be, sign up for a freemium account on developer.here.com and generate your app_id and app_code. With this account, sign in to the XYZ Studio and create a new project. You will already see a base map and options to customize your base map. Here you name your project and chose from 3 base map themes. You will then have to add a layer of data to this map. This data will contain the names of the places you wish to display, the geo co-ordinates of those locations, and any additional data you may want to display. You can upload this data in GeoJSON, JSON, CSV and Shapefile formats in the XYZ Studio. *(If you are uploading a csv file, make sure the columns containing the geo co-ordinates are labelled Latitude and Longitude.) Getting the data To generate a file of your data in one of the given formats , we first have to acquire the data. One way to do it is to just list down the names of places that you want to display in either a text file or a spread sheet. Once you have the names of the places, we now need their geo-coordinates. There can be multiple ways of doing this. Let us take a look at them. With no coding whatsoever: If you have no experience in coding, or want a quick fix to display a few places on the map, simply copy the name of the place and enter it in the search box on the here we go website. Click on the location pin and you will find the Latitude and Longitude of the place in the address bar . Enter these co-ordinates in their respective columns in your spreadsheet. Add other columns that you wish to like data of visit, country name etc. and save the file with the extension .csv and upload it into your XYZ project. If you want to convert the file into a GeoJSON file, you can use an online converter to do so. After uploading the file, default circles will appear on the map according to the input data. You can then customize these circles to different sizes and different colors or change them to markers like icons for food, travel, nature, etc. With little coding If you have a longer list of places and do not want to manually enter the Latitude and Longitude for each one of them, use the HERE Batch Geocoder REST API and get the result in the form of a text file. You can use a tool like POSTMAN to use this API in the following manner: Send a POST request as below and use the app_id and app_code obtained during sign up for the same. https://batch.geocoder.api.here.com/6.2/jobs\n?action=run\n&app_id={{app_id}}\n&app_code={{app_code}}\n&mailto={{email_id_personal}}\n&indelim=,\n&outdelim=,\n&outcols=City,Latitude,Longitude,country\n&outputcombined=false The body of the Post should be like: recId,City,Country\n1,Stockholm,Sweden\n2,Göteborg,Sweden\n3,Antwerp,Belgium\n4,Copenhagen,Denmark\n5,Santa Cruz de Tenerife,Spain\n6,Mallorca,Spain\n7,Rennes,France\n8,Paris,France The result of this post will be a job id which you will receive on your mentioned email id. To get the Latiude and Longitude from this job, you need to send a GET request with the job ID and the same app_id and app_code used for the POST request. https://batch.geocoder.api.here.com/6.2/jobs/{{YOUR_JOB_ID}}/result\n?app_id={{app_id}}\n&app_code={{app_code}} Download the resulting zip file. It will contain a text file with Latitude and Longitude of the input location. Save this file as a .csv file (possible as we used a comma ',' as the delimiter). You can insert additional columns of data and then upload the file or add the additional columns once you  upload the data to the XYZ studio. With a little more coding The result file received from the GET request can be parsed with a simple script and converted into a GeoJSON file or a CSV file. from geojson import Point, Feature, FeatureCollection, dump\nfeatures = []\nfile = open(\"result_out.txt\", \"r\") # enter the name of the file received in the downloaded folder\nfile.readline()\nfor line in file.readlines():\n    fname = line.rstrip().split(',') #using rstrip to remove the \\n\n    Latitude,Longitude= map(float, (fname[4], fname[5]))\n    # in my result_out file, 4th and 5th values were Latitude and Longitude\n    features.append(Feature(\n    geometry=Point((Longitude,Latitude)),\n\t# note that the format is Longitude and then Latitude\n    properties={\n    \"City\": fname[3],\n    \"Country\": fname[6]\n                }\n            )\n        )\n    feature_collection = FeatureCollection(features)\n    with open('places.geojson', 'w') as f:\n        dump(feature_collection, f) Use the palces.geojson as your data to upload into your XYZ studio project. Embedding the map into your website Once you upload your data layers onto your map and decorate it as per your taste and publish the map by going to project settings. You will also find an option to bookmark certain parts of your map so that the part is visible as soon as you open the map. On publishing the map, you will get the URL of the published map and the embed code of the same. On your WIX website editor, chose a place where you want to display the map. Click on the '+' sign to add an element and go to the 'more' section. Chose the 'Embed a site' option. Click on the 'Enter a Website Address' button and enter the url of the published map. You will be able to see your XYZ map on your website! Incase you want to use the HTML frame widget, paste the 'Embed' code that you get once you publish the map in the XYZ Studio. You can customize this map with multiple layers of data, each layer having a different marker. I have embedded one right in this blog. Take a look at it, scroll, pan zoom and have fun making maps!", "date": "2018-11-07"},
{"website": "Here", "title": "Isoline Routing in an Angular Application using the HERE Routing API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/isoline-routing-in-an-angular-application-using-the-here-routing-api", "abstract": "Have you ever needed to search for locations that were in range to a starting point based on certain criteria? For example, maybe you wanted to find all the Starbucks that are within a driving distance of 5 minutes or less based on current traffic conditions. This can be accomplished using what is known as Isoline Routing. Not too long ago, Richard Sueselbeck wrote a great article on Isoline Routing. In his article titled, Finding my Dream Home with Isoline Routing , he wrote about house hunting in a traffic congested area where he wanted to be within a certain travel time from his work place. You can’t search a radius because not all points in the radius might qualify based on the criteria, given there might be unknown traffic situations, rivers, or lack of roads. In this tutorial, we won’t be house hunting, but we will be taking a look at how to calculate Isoline routes using Angular and the HERE Routing API for JavaScript . Take a look at the following animated image to get an idea of what we hope to accomplish: As you can see, we are displaying a map and two search boxes. The first search box is an address with no specific completeness and the second search box is a numeric value which represents the range in seconds. The goal is to convert the address to a latitude and longitude set of coordinates and use it as a starting point to find all possible ending locations that can be reached within the time range. All possible locations are displayed on the map to get an idea of what is accessible during that time frame. Generating an Angular Application with a HERE Map The first step in being successful with this project is to create a new Angular project. If you’ve been keeping up, I’ve already written several tutorials that make use of Angular and HERE Maps. For example, Display HERE Maps within your Angular Web Application shows how to display a map in Angular and Transportation Routing and Directions in an Angular Application with the HERE Routing API gives an introduction to the Routing API for JavaScript with Angular. Both tutorials, plus others are going to play a part in terms of getting us up to speed for Isoline Routing. The goal is not to reinvent the wheel in terms of tutorials too much. That said, assuming your Angular CLI is ready to go, execute the following: ng new demo The above command will create a new Angular project. We will be creating a component to hold our map, but before we do, we need to include the various HERE JavaScript libraries into the project’s src/index.html file: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HERE with Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> With the libraries in place, the map component can be created using the Angular CLI. This map component will not only handle the visual aspect of things, but all the functions that relate to the map such as geocoding and routing. From the Angular CLI, execute the following: ng g component here-map The above command will create a TypeScript file, HTML file, and CSS file within the project. Rather than explaining line for line what everything does in our map component, we’re going to just get up to speed from the other tutorials. Open the project’s src/app/here-map/here-map.component.html file and include the following HTML markup: <div #map [style.width]=\"width\" [style.height]=\"height\" style=\"float: left\"></div> With the container element in place when it comes to loading our map after the application renders, we can include the TypeScript that works with that UI element. Open the project’s src/app/here-map/here-map.component.ts and include the following TypeScript: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public width: any;\n\n    @Input()\n    public height: any;\n\n    private platform: any;\n    private map: any;\n    private router: any;\n    private geocoder: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        this.router = this.platform.getRoutingService();\n        this.geocoder = this.platform.getGeocodingService();\n    }\n\n    public ngAfterViewInit() {\n        let defaultLayers = this.platform.createDefaultLayers();\n        this.map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.normal.map,\n            {\n                zoom: 4,\n                center: { lat: \"37.0902\", lng: \"-95.7129\" }\n            }\n        );\n    }\n\n} The above code is essentially initializing the HERE platform in the ngOnInit method along with the services that will be used. Then in the ngAfterViewInit method, a map is created from the referenced UI container and displayed with a certain position and zoom. I cannot stress this enough, it is worth checking out my previous tutorial if you’re having trouble making sense of the above component code and markup. With the component in place, let’s focus on the bulk of what this tutorial hopes to accomplish. Geocoding an Address to Latitude and Longitude Coordinates with Angular When working with the HERE Routing API , we cannot use string addresses when identifying starting points or waypoints. Instead we need to use latitude and longitude coordinates, but memorizing those coordinates probably isn’t feasible for a lot of applications. This is where the HERE Geocoder API comes into play. I previously wrote a tutorial titled, Using the HERE Geocoder API for JavaScript in an Angular Application which demonstrated geocoding, so we’ll use some of it as inspiration for this tutorial. Open the project’s src/app/here-map/here-map.component.ts file and create the following function: private getCoordinates(query: string) {\n    return new Promise((resolve, reject) => {\n        this.geocoder.geocode({ searchText: query }, result => {\n            if(result.Response.View.length > 0) {\n                if(result.Response.View[0].Result.length > 0) {\n                    resolve(result.Response.View[0].Result);\n                } else {\n                    reject({ message: \"no results found\" });\n                }\n            } else {\n                reject({ message: \"no results found\" });\n            }\n        }, error => {\n            reject(error);\n        });\n    });\n} Using the geocoder that was initialized earlier, we can take a query string and use it to get location information which includes latitude and longitude coordinates. The query string could be as vague as “Tracy, CA” or much more complete. The HERE Geocoder API will do great things to make sense of the data provided. With a function in place for geocoding data, we can focus on calculating an Isoline route. Calculating Isoline Coordinates Accessible on a Time-Based Range Much of the code we see here will be taken directly from the JavaScript documentation for the HERE Routing API . We’re just going to make it Angular friendly so it becomes nicer to work with. Within your project’s src/app/here-map/here-map.component.ts file, include the following function: public route(start: string, range: string) {\n    let params = {\n        \"mode\": \"fastest;car;traffic:enabled\",\n        \"range\": range,\n        \"rangetype\": \"time\",\n        \"departure\": \"now\"\n    }\n    this.map.removeObjects(this.map.getObjects());\n    this.getCoordinates(start).then(geocoderResult => {\n        params[\"start\"] = geocoderResult[0].Location.DisplayPosition.Latitude + \",\" + geocoderResult[0].Location.DisplayPosition.Longitude;\n        this.router.calculateIsoline(params, data => {\n            if(data.response) {\n                let center = new H.geo.Point(data.response.center.latitude, data.response.center.longitude),\n                    isolineCoords = data.response.isoline[0].component[0].shape,\n                    linestring = new H.geo.LineString(),\n                    isolinePolygon,\n                    isolineCenter;\n                isolineCoords.forEach(coords => {\n                    linestring.pushLatLngAlt.apply(linestring, coords.split(','));\n                });\n                isolinePolygon = new H.map.Polygon(linestring);\n                isolineCenter = new H.map.Marker(center);\n                this.map.addObjects([isolineCenter, isolinePolygon]);\n                this.map.setViewBounds(isolinePolygon.getBounds());\n            }\n        }, error => {\n            console.error(error);\n        });\n    }, error => {\n        console.error(error);\n    });\n} In the above route function, a few things are happening. First we are defining a few parameters. For example, we want to specify the criteria for an Isoline route. Our criteria is that we want the fastest route by car and we want traffic data to be used in the calculation. We’ll be accepting the range from the user and we want to specify that the range is a time in seconds. We also want to specify that the departure time is now, rather than some time in the future or past. After we define a few of our parameters, we can clear the map of all previous objects which include polygons and markers. With the map clear, we can get the coordinate information for our provided address. This coordinate information will act as center point, or ground zero, for the Isoline route. With the coordinates, we can set the final parameter which would be the starting position. Next we calculate the Isoline route based on the parameters. Again, the result of the calculation was taken from the documentation. Essentially we are looping through each of the Isoline coordinates returned and creating a polygon from them. A marker is placed at our starting point and the map is centered so everything fits in the view. There isn’t a lot of code here, but we’re accomplishing something very amazing. Making the Map Component Functional with the Application Now that we have a map component with geocoder and Isoline logic, we need to bring it together and use it in the application. In Angular, binding with forms is disabled by default. Because we’ll be accepting user input via forms, we need to enable it. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from \"@angular/forms\";\n\nimport { AppComponent } from './app.component';\nimport { HereMapComponent } from './here-map/here-map.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        HereMapComponent\n    ],\n    imports: [\n        BrowserModule,\n        FormsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } Essentially we’ve just imported FormsModule and added it to the imports array of the @NgModule block. Now that we have forms support, we can use them in our application, but before we explore the HTML, we should probably quickly take care of the TypeScript. Open the project’s src/app/app.component.ts file and include the following: import { Component, OnInit } from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    public start: string;\n    public range: string;\n\n    public constructor() {\n        this.start = \"Tracy CA\";\n        this.range = \"300\";\n    }\n\n    public ngOnInit() { }\n\n} In order to bind data to a form, we need to initialize the variables that we plan to use. In the above code we have a public start and a public range variable that will be bound to the form. Each of these variables have a default value to help us out. Now open the project’s src/app/app.component.html file and include the following HTML markup: <div style=\"padding-bottom: 20px\">\n    <div>\n        <label class=\"searchLabel\">Start</label>\n        <input type=\"text\" [(ngModel)]=\"start\" />\n        <label class=\"searchLabel\" style=\"margin-left: 10px\">Range</label>\n        <input type=\"text\" [(ngModel)]=\"range\" style=\"margin-left: 10px\" />\n        <button (click)=\"map.route(start, range)\" style=\"margin-left: 5px\">Search</button>\n    </div>\n</div>\n<here-map\n    #map\n    appId=\"APP-ID-HERE\"\n    appCode=\"APP-CODE-HERE\"\n    width=\"75%\"\n    height=\"630px\">\n</here-map> There are a fiew things to note in the above code. First, we have to input fields, both bound to the public variables we had just created. Then we have a button that once clicked, calls the map.route function we had defined in the map component. The variables being passed are the values from the form. So what is the map variable? Well, that is a template variable that we’re using the here-map tag. The #map attribute represents a variable for that particular map instance, which we’re using in the button. Make sure that you swap the appId and appCode with those found in your HERE developer account. Conclusion You just saw how to use Isoline Routing in your Angular application. If it still isn’t obvious the value that Isoline Routing offers, let me throw a few more examples at you: Finding houses, condos, or apartments that are reachable within a certain travel distance or time. Could be valuable when purchasing housing near enough to your work place. Hailing a ride share driver that is of a certain distance or time from you with more accuracy than a radius from your coordinates. Determining an exit strategy in the event of a natural disaster or similar. The examples are limitless, but just remember that Isoline Routing offers a better solution than using a radius or calculating a route for every possible point manually.", "date": "2018-10-25"},
{"website": "Here", "title": "Calculate and Visualize Navigation Routes with HERE, JavaScript, and Vue.js", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/calculate-and-visualize-navigation-routes-with-here-javascript-and-vue.js", "abstract": "When you think of maps, you might think of turn-by-turn navigation, like those features offered in your car, on your phone, or even within your smart watch, to get you from point A to point B. Creating an algorithm for routing between two points is difficult, but it is substantially more difficult when you try to calculate the fastest route given different circumstances, like being on foot versus being in a car. The good news is that route calculation isn’t difficult when you’re using the HERE Routing API for JavaScript . In fact, to accomplish the task, you only really need to provide a set of points, whether that be the start and finish point, or other waypoints in-between. We’re going to see how to use the Vue.js JavaScript framework to build a web application that allows a user to calculate a route between points and display that route, along with turn-by-turn directions on the map. Take a look at the following animated image to get an idea on what we hope to accomplish: The user will be able to provide two addresses. Behind the scenes, those addresses will be converted into coordinates and a route is established. Using the route information, lines are created and rendered at the paths and the turn-by-turn directions associated are displayed. Excluding all the boilerplate code for Vue.js, all of this will happen in just a few lines of code. Getting Started with Vue.js and HERE Location Services This isn’t the first time that I’ve discussed using the HERE Location Services (HLS) with Vue.js. I’ve written Showing a HERE Map with the Vue.js JavaScript Framework for displaying maps, and I’ve written Searching for Points of Interest with the HERE Places API in a Vue.js Application for searching maps. Much of this tutorial will take from the previous tutorials, so to save us some time and explanation, the deeper details from the previous won’t be revisited. I encourage you to view the previous two tutorials if you want the deeper details on displaying a map or placing markers. Our focus is around routing for this tutorial. Assuming you have the Vue CLI installed and a free HERE developer account , execute the following to create a new project: vue create here-routing-project The above command will start the CLI wizard and create a new project. In reality, this is a simple project, so go ahead and use the defaults when prompted by the CLI. With the project created, we need to import the HERE JavaScript libraries. Open the project’s public/index.html file and include the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>HERE Maps with Vue</title>\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but vue-map doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> The mapsjs-core and mapsjs-service libraries were included in the above HTML markup. In an effort to continue getting up to speed from the previous tutorials, we can work on our maps component. Create a src/components/HereMap.vue file within your project that contains the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width + '%', height: height }\" style=\"float: left\"></div>\n        <ol v-bind:style=\"{ width: (100 - width - 5) + '%'}\" style=\"float: right; min-height: 530px; margin-left: 20px; margin-top: 0\">\n            <li></li>\n        </ol>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                map: {},\n                platform: {},\n                geocoder: {}\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            lat: String,\n            lng: String,\n            width: String,\n            height: String\n        },\n        created() {\n            this.platform = new H.service.Platform({\n                \"app_id\": this.appId,\n                \"app_code\": this.appCode\n            });\n            this.geocoder = this.platform.getGeocodingService();\n        },\n        mounted() {\n            this.map = new H.Map(\n                this.$refs.map,\n                this.platform.createDefaultLayers().normal.map,\n                {\n                    zoom: 10,\n                    center: { lng: this.lng, lat: this.lat }\n                }\n            );\n        },\n        methods: { }\n    }\n</script>\n\n<style scoped></style> The above code is more or less where we left off at with the previous tutorials for the component, with the exception of the <template> block. In the <template> block, we have the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width + '%', height: height }\" style=\"float: left\"></div>\n        <ol v-bind:style=\"{ width: (100 - width - 5) + '%'}\" style=\"float: right; min-height: 530px; margin-left: 20px; margin-top: 0\">\n            <li></li>\n        </ol>\n    </div>\n</template> In the above we have a container for our map as well as an ordered list for our turn-by-turn instructions. Both HTML components have a dynamic style which isn’t too relevant to the final outcome of the tutorial. Basically, if a user assigns a certain width or height to the component as a whole, the two UI components will scale properly. You could easily just set a hard coded value for this tutorial instead. Inside the <script> block we are defining our variables as well as component properties, initializing HLS, and displaying a map when the view has rendered. When it comes to routing, most of our magic will happen in the methods object. Geocoding Addresses into Latitude and Longitude Coordinates Now that we’re up to speed with our map component, we can start adding the logic that will be used towards routing. When trying to route between two or more waypoints, the HERE Routing API expects latitude and longitude coordinates. Chances are no human being is going to remember coordinates when they want to route between two points, so we’re going to have to geocode some addresses. For code optimization, we should probably create a function for this. Within your project’s src/components/HereMap.vue file, include the following in the methods object: methods: {\n    geocode(query) {\n        return new Promise((resolve, reject) => {\n            this.geocoder.geocode({ searchText: query }, data => {\n                if(data.Response.View[0].Result.length > 0) {\n                    data = data.Response.View[0].Result.map(location => {\n                        return {\n                            lat: location.Location.DisplayPosition.Latitude,\n                            lng: location.Location.DisplayPosition.Longitude\n                        };\n                    });\n                    resolve(data);\n                } else {\n                    reject({ \"message\": \"No data found\" });\n                }\n            }, error => {\n                reject(error);\n            });\n        });\n    },\n} Remember, we had already initialized the geocoder in the previous step. Now we’re creating a geocode method that takes a query string that will be an address. We’re going to plan ahead and use promises rather than callbacks which will help us drastically. Using the geocoder we can pass our query string and return only a latitude and longitude if results exist. If no results exist, we’ll just reject the promise with an error. Now we can take this information to create waypoints for our router. Routing Between Two Points on a Map with Turn-by-Turn Directions The HERE Routing API can calculate routes between two or more waypoints. For this example we have a start address and a destination address, meaning we have two waypoints. Often there are use-cases where you might need to add a “pitstop”, but we won’t worry about that here. However, adding an extra waypoint wouldn’t take more than a few lines of markup to work. Before we start using the HERE Routing API, we need to initialize it in our application and add a few variables for holding data. Within your project’s src/components/HereMap.vue file, include the following in the data method: data() {\n    return {\n        map: {},\n        platform: {},\n        router: {},\n        geocoder: {},\n        directions: []\n    }\n}, The router variable will hold our initialized router and the directions variable will hold our turn by turn directions. With those variables in place, we can initialize the router in the created method: created() {\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.router = this.platform.getRoutingService();\n    this.geocoder = this.platform.getGeocodingService();\n}, With the router initialized, we can work on our method that will perform all the heavy lifting. Even though in reality, the HERE Routing API will be doing the heavy lifting remotely. We’re just parsing the results. Within the methods object, add the following method: route(start, finish) {\n    var params = {\n        \"mode\": \"fastest;car\",\n        \"representation\": \"display\"\n    }\n    var waypoints = [];\n    this.map.removeObjects(this.map.getObjects());\n    this.directions = [];\n    waypoints = [this.geocode(start), this.geocode(finish)];\n    Promise.all(waypoints).then(result => {\n        var markers = [];\n        for(var i = 0; i < result.length; i++) {\n            params[\"waypoint\" + i] = result[i][0].lat + \",\" + result[i][0].lng;\n            markers.push(new H.map.Marker(result[i][0]));\n        }\n        this.router.calculateRoute(params, data => {\n            if(data.response) {\n                for(var i = 0; i < data.response.route[0].leg.length; i++) {\n                    this.directions = this.directions.concat(data.response.route[0].leg[i].maneuver);\n                }\n                data = data.response.route[0];\n                var lineString = new H.geo.LineString();\n                data.shape.forEach(point => {\n                    var parts = point.split(\",\");\n                    lineString.pushLatLngAlt(parts[0], parts[1]);\n                });\n                var routeLine = new H.map.Polyline(lineString, {\n                    style: { strokeColor: \"blue\", lineWidth: 5 }\n                });\n                this.map.addObjects([routeLine, ...markers]);\n                this.map.setViewBounds(routeLine.getBounds());\n            }\n        }, error => {\n            console.error(error);\n        });\n    });\n} There is a lot going on in the above method so we need to break it down to figure it out. First we are defining that we want to find the fastest route by car, rather than by foot or something else. Next we are removing all previous map objects such as lines and markers from the map to prevent any kind of overlap if multiple searches are performed. We’re also emptying the directions array to prevent overlap as well. Remember, the HERE Routing API expects coordinates for waypoints, not addresses. The HERE Geocoder API is asynchronous and we wrapped it in a promise. We need to make sure all our waypoints have been calculated before we attempt to route between them. This is why we are creating a waypoints array of promises. By using the Promise.all method, we can execute all the promises in our array and only when they have finished, we proceed to calculating the routes. When the coordinate data is available, we alter the params variable to include waypoints as well as markers for each of the source or destinations. With that information in hand, we can call the calculateRoute method of the router. The turn-by-turn instructions from the response are stored in the directions variable and lines are calculated from each of the parts of the route. Finally, all the map objects, whether it be lines, markers, etc., are added to the map and the map is re-centered on the visual route. I think my explanation might sound more complicated than it actually is. Remember, we’re essentially just doing a lot of parsing of a response. Before we can say that the component is complete, we need to update our <template> block. Our turn-by-turn instructions list is empty as of now. It should look more like the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" v-bind:style=\"{ width: width + '%', height: height }\" style=\"float: left\"></div>\n        <ol v-bind:style=\"{ width: (100 - width - 5) + '%'}\" style=\"float: right; min-height: 530px; margin-left: 20px; margin-top: 0\">\n            <li v-for=\"direction in directions\">\n                <p v-html=\"direction.instruction\"></p>\n            </li>\n        </ol>\n    </div>\n</template> The instructions from the API are HTML so we need to bind the data as HTML to the list items. Otherwise we’re going to see a bunch of tags in our output. Using the Map Component for Geocoding and Routing With the map component ready to go for routing, it is time to bring everything together and try it out. We need to have a form for user data and we need to call the methods from our component. Open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <div style=\"padding: 10px 0\">\n            <div>\n                <label style=\"display: inline-block; width: 60px; color: #FFF\">Start</label>\n                <input type=\"text\" v-model=\"start\" />\n            </div>\n            <div>\n                <label style=\"display: inline-block; width: 60px; color: #FFF\">Finish</label>\n                <input type=\"text\" v-model=\"finish\" />\n            </div>\n            <button type=\"button\" v-on:click=\"route()\">Route</button>\n        </div>\n        <HereMap ref=\"map\" appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\" width=\"60\" height=\"530px\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from \"./components/HereMap.vue\"\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        },\n        data() {\n            return {\n                start: \"\",\n                finish: \"\"\n            }\n        },\n        methods: {\n            route() {\n                this.$refs.map.route(this.start, this.finish);\n            }\n        }\n    }\n</script>\n\n<style>\n    body {\n        margin: 20px;\n        background-color: #1d232d;\n    }\n</style> Let’s start by looking at the <script> block. We are defining two variables that will be bound to our form elements. We are also defining a route method which will call the route method of our map based on the reference we make in the HTML. It is not a requirement that the parent and child methods be named the same, it was just coincidence. Looking at the HTML, we have our two form elements bound to our component variables. We also have a button that is bound to our method when clicked. The map component which includes a map as well as directions is added with a reference variable that we use in our method. If you were to try this in your own application, don’t forget to swap the app id and app code with your own. Conclusion You just saw how to calculate complex routes and display them on the map as polylines as well as turn-by-turn text instructions using the HERE Routing API for JavaScript along with Vue.js . It may seem like we did a lot in this particular tutorial, but much of it was around getting up to speed with previous tutorials or adding boilerplate Vue.js code. In case you’d prefer to use Angular, I wrote a similar tutorial previously titled, Transportation Routing and Directions in an Angular Application with the HERE Routing API on the subject.", "date": "2018-10-30"},
{"website": "Here", "title": "Develop a Cross-Platform Desktop Maps Application with Electron, Vue.js, and HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/develop-a-cross-platform-desktop-maps-application-with-electron-vue.js-and-here", "abstract": "Have you ever wanted to build your own desktop application for working with maps, similar to how Apple Maps functions on macOS? How about building a mapping application that works cross-platform and not just for macOS, all while using much more reliable maps? All of this can be accomplished with JavaScript, Electron, and HERE ! I’ve been writing a lot of tutorials around Vue.js and Angular that demonstrate different development strategies for working with maps, whether that be routing, searching, or something else. About a month ago, I even demonstrated using Electron in a tutorial titled, Developing a Cross-Platform Desktop Maps Application with Electron, Angular, and HERE , which focused on Angular and the HERE Places API. This time around I thought it would be a great idea to explore something similar, but using the Vue.js JavaScript framework instead. We’re going to see how to build a cross-platform desktop application that works for Mac, Windows, and Linux, and uses the HERE Routing API to calculate Isoline routes with Vue.js . To get an idea of what we want to accomplish, check out the animated image below: As you can see in the above image, we have a desktop application with a full screen map. We also have a set of user defined inputs that accept an address and a range in seconds. The point behind Isoline routing is the ability to take a starting set of coordinates and a range to determine the coverage that can be reached. For example, let’s say you use your work address. You want to buy a house that is within a 15 minute (900 seconds) drive to the office. Rather than randomly checking a potentially large amount of addresses, or using a radius that can be inaccurate due to road coverage and traffic, you can create an Isoline route. This is just one of many possible use cases for Isoline Routing. Build a Vue.js Application with a HERE Map Component The first step of this project will involve creating a Vue.js application using the Vue CLI . While the Vue CLI isn’t a requirement of using Vue.js, it will be for this particular project. With the Vue CLI installed, execute the following command: vue create demo The Vue CLI will ask questions as part of the project configuration wizard. This project will use the defaults, so don’t bother with Vuex or similar. Going forward, it is important to note that I’ve already explored much of this content in past tutorials. For example, my tutorial titled, Showing a HERE Map with the Vue.js JavaScript Framework demonstrates how to create a map component with Vue.js. I had also written a tutorial titled, Calculate and Visualize Navigation Routes with HERE, JavaScript, and Vue.js which demonstrates standard waypoint routing with Vue.js. For these reasons, much of the deeper details will be skipped to get us up to speed with a map component. What we’re going to focus on is Isoline Routing and configuring Electron . In the project that was created, open the public/index.html file and include the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>HERE with Vue</title>\n        <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\">\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1533195059\">\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but vue-electron doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\"></script>\n        <script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\"></script>\n    </body>\n</html> We’ve imported quite a few JavaScript and CSS libraries, all related to HERE for mapping and location services and Bootstrap for a nice application theme. With our libraries in place, we can build our map component. The project should already contain a src/components/HelloWorld.vue file. Rename that file to src/components/HereMap.vue and include the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" id=\"map\"></div>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                map: {},\n                platform: {},\n                router: {},\n                geocoder: {},\n                directions: [],\n                ui: {}\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            lat: String,\n            lng: String\n        },\n        created() {\n            this.platform = new H.service.Platform({\n                \"app_id\": this.appId,\n                \"app_code\": this.appCode\n            });\n            this.router = this.platform.getRoutingService();\n            this.geocoder = this.platform.getGeocodingService();\n        },\n        mounted() {\n            var pixelRatio = window.devicePixelRatio || 1;\n            let defaultLayers = this.platform.createDefaultLayers({\n                tileSize: pixelRatio === 1 ? 256 : 512,\n                ppi: pixelRatio === 1 ? undefined : 320\n            });\n            this.map = new H.Map(\n                this.$refs.map,\n                defaultLayers.normal.map,\n                {\n                    zoom: 10,\n                    center: { lng: this.lng, lat: this.lat },\n                    pixelRatio: pixelRatio\n                }\n            );\n            let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n            this.ui = H.ui.UI.createDefault(this.map, defaultLayers);\n        },\n        methods: { }\n    }\n</script>\n\n<style scoped></style> Again, this code was discussed in detail in previous tutorials that I wrote. In short, we’re creating an HTML container for the map referenced by a map variable. In the <script> block we are initializing our variables, defining our attribute properties, initializing the HERE platform and services, and then displaying a map using the reference variable in the HTML container. To use this map component to display a map, open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <HereMap\n            ref=\"map\"\n            appId=\"APP-ID-HERE\"\n            appCode=\"APP-CODE-HERE\"\n            lat=\"37.7397\"\n            lng=\"-121.4252\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from './components/HereMap.vue'\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style></style> Notice that we’ve changed the old HelloWorld component to the new HereMap component. We’ve also added the <HereMap> tag to the UI. For this project to work you will need to use your own app id and app code values. These can be found after creating a free HERE developer account . Before we jump into the core of our material, let’s add the CSS to make everything look nice. Within the project’s src/App.vue file, include the following in the <style> block: body {\n    background-color: #262626;\n}\n\n#searchbar {\n    position: fixed;\n    z-index: 1;\n    top: 10px;\n    left: 50%;\n    transform: translateX(-50%);\n    background-color: #262626;\n    padding: 15px;\n    width: 50%;\n    border-radius: 5px;\n}\n\n#map {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n} I am not a CSS or design wizard. I’m confident that you’re much more talented than I am and can come up with a more attractive looking application. My applications are more about function than anything. Since we have an application that should run in the browser, we are ready to configure it to be deployed as a desktop application with Electron. Configure Electron for Deployments on Mac, Windows, and Linux Packaging this application won’t be difficult. In fact, most of what you see here will come directly from the Electron documentation . Before we create configuration files, let’s install Electron as a development dependency. From the command line, execute the following: npm install electron --save-dev With Electron available to us, we can create an Electron configuration file. At the root of your project, create an electron.js file with the following JavaScript code: const {app, BrowserWindow} = require('electron')\n\nlet win\n\nfunction createWindow () {\n    win = new BrowserWindow({width: 1200, height: 750, resizable: false})\n\n    win.loadFile('dist/index.html')\n\n    win.on('closed', () => {\n        win = null\n    })\n}\n\napp.on('ready', createWindow)\n\napp.on('window-all-closed', () => {\n    if (process.platform !== 'darwin') {\n        app.quit()\n    }\n})\n\napp.on('activate', () => {\n    if (win === null) {\n        createWindow()\n    }\n}) Minus the comments, I took 99% of the above code from the Electron documentation. What I did change is the HTML file that is loaded. The goal with Electron is to package a production build. When building a Vue.js application, output is placed in the dist directory. With the configuration file in place, it needs to be linked in the package.json file. Include the following in your package.json file without clearing out what already exists: // ...\n\"main\": \"electron.js\",\n\"scripts\": {\n    // ...\n    \"electron\": \"vue-cli-service build; electron .\"\n},\n// ... The main property must point to the electron.js file we just created. We are also creating a build script for Electron that first builds the Vue.js project and then launches it with Electron. You can create your own script to bundle the application to be standalone using similar steps. To run the application, execute the following: npm run electron If you run the above command you’ll probably run into several resource errors. Errors exist because of the relative and absolute paths that are a result of the Webpack process. This can be fixed using a Vue.js configuration file. Create a vue.config.js file at the root of your project with the following: module.exports = {\n    baseUrl: process.env.NODE_ENV === 'production' ? './' : '/'\n} When you build your project, the vue.config.js file will be used and the paths will be updated so that Electron can make sense of them. If you ran the application now, it should show your basic map. Now that we have a basic Vue.js application with Electron support, we can start giving it some functionality. Geocoding Addresses to Latitude and Longitude Coordinates with HERE, JavaScript, and Vue.js We’ll be creating a starting point to our Isoline routes, but that starting point needs to be a latitude and longitude position, not an address that is much more easy to understand. Rather than guessing a bunch of coordinates, we can make use of the HERE Geocoder API for JavaScript and gather positions from the addresses. In the project’s src/components/HereMap.vue you’ll probably remember a methods object. We need to create a method for geocoding our data. Include the following JavaScript to get the job done: getCoordinates(query) {\n    return new Promise((resolve, reject) => {\n        this.geocoder.geocode({ searchText: query }, data => {\n            if(data.Response.View[0].Result.length > 0) {\n                data = data.Response.View[0].Result.map(location => {\n                    return {\n                        lat: location.Location.DisplayPosition.Latitude,\n                        lng: location.Location.DisplayPosition.Longitude\n                    };\n                });\n                resolve(data);\n            } else {\n                reject({ \"message\": \"No data found\" });\n            }\n        }, error => {\n            reject(error);\n        });\n    });\n}, The HERE Geocoder API does quite a bit with very little, but we’re only interested in coordinate information. For this reason, we’re going to format our own very specific response for the next function to consume. If there was no data found for the information provided or there was an error, the promise will be rejected. With geocoding in place, Isoline routes can become the focus. Isoline Routing for Finding Reachable Routes within a Range Isoline Routing accomplishes a lot with very little. Given a starting location and other minor search criteria, a nice overlay can be created to show the furthest regions that meet the criteria provided. This saves you from having to create X number of requests to the standard routing API. Within the project’s src/components/HereMap.vue file, we need to create another JavaScript method: route(start, range) {\n    var params = {\n        \"mode\": \"fastest;car;traffic:enabled\",\n        \"range\": range,\n        \"rangetype\": \"time\",\n        \"departure\": \"now\"\n    }\n    this.map.removeObjects(this.map.getObjects());\n    this.getCoordinates(start).then(geocoderResult => {\n        params[\"start\"] = geocoderResult[0].lat + \",\" + geocoderResult[0].lng;\n        this.router.calculateIsoline(params, data => {\n            if(data.response) {\n                var center = new H.geo.Point(data.response.center.latitude, data.response.center.longitude),\n                    isolineCoords = data.response.isoline[0].component[0].shape,\n                    linestring = new H.geo.LineString(),\n                    isolinePolygon,\n                    isolineCenter;\n                isolineCoords.forEach(coords => {\n                    linestring.pushLatLngAlt.apply(linestring, coords.split(','));\n                });\n                isolinePolygon = new H.map.Polygon(linestring);\n                isolineCenter = new H.map.Marker(center);\n                this.map.addObjects([isolineCenter, isolinePolygon]);\n                this.map.setViewBounds(isolinePolygon.getBounds());\n            }\n        }, error => {\n            console.error(error);\n        });\n    }, error => {\n        console.error(error);\n    });\n} In the route method, we define a few parameters. For example, we want the Isoline result to be for car transportation with traffic enabled. We also want it to be based on time, not distance or fuel consumption. When calculating the route, first we clear the map of any existing data. One the map is cleared, we convert an address to coordinates and use it as the final property in our parameters. The rest of the code was taken directly from the HERE Isoline Routing documentation . Essentially, we’re using the parameters that were previously defined, getting all the Isoline coordinates, and displaying them on the map as polygons that are filled. With the functions in place, we can configure the final part of our UI. Open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <div id=\"searchbar\">\n            <form class=\"form-inline\">\n                <div class=\"form-group input-group-sm w-50\">\n                    <label for=\"location\" class=\"sr-only\">Location...</label>\n                    <input type=\"text\" v-model=\"query\" class=\"form-control w-100\" id=\"location\" placeholder=\"Starting location...\">\n                </div>\n                <div class=\"form-group input-group-sm mx-sm-3 w-25\">\n                    <label for=\"range\" class=\"sr-only\">Range</label>\n                    <input type=\"text\" v-model=\"range\" class=\"form-control w-100\" id=\"range\" placeholder=\"Range (seconds)\">\n                </div>\n                <button type=\"button\" v-on:click=\"$refs.map.route(query, range)\" class=\"btn btn-primary btn-sm w-10\">Search</button>\n            </form>\n        </div>\n        <HereMap\n        ref=\"map\"\n        appId=\"APP-ID-HERE\"\n        appCode=\"APP-CODE-HERE\"\n        lat=\"37.7397\"\n        lng=\"-121.4252\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from './components/HereMap.vue'\n\n    export default {\n        name: 'app',\n        components: {\n            HereMap\n        },\n        data() {\n            return {\n                query: \"\",\n                range: \"\"\n            };\n        }\n    }\n</script>\n\n<style>\n    body {\n        background-color: #262626;\n    }\n\n    #searchbar {\n        position: fixed;\n        z-index: 1;\n        top: 10px;\n        left: 50%;\n        transform: translateX(-50%);\n        background-color: #262626;\n        padding: 15px;\n        width: 50%;\n        border-radius: 5px;\n    }\n\n    #map {\n        position: fixed;\n        width: 100%;\n        height: 100%;\n    }\n</style> In the above code you might be wondering what exactly changed. In reality, we’ve just added a few floating search boxes as seen in the following HTML markup: <div id=\"searchbar\">\n    <form class=\"form-inline\">\n        <div class=\"form-group input-group-sm w-50\">\n            <label for=\"location\" class=\"sr-only\">Location...</label>\n            <input type=\"text\" v-model=\"query\" class=\"form-control w-100\" id=\"location\" placeholder=\"Starting location...\">\n        </div>\n        <div class=\"form-group input-group-sm mx-sm-3 w-25\">\n            <label for=\"range\" class=\"sr-only\">Range</label>\n            <input type=\"text\" v-model=\"range\" class=\"form-control w-100\" id=\"range\" placeholder=\"Range (seconds)\">\n        </div>\n        <button type=\"button\" v-on:click=\"$refs.map.route(query, range)\" class=\"btn btn-primary btn-sm w-10\">Search</button>\n    </form>\n</div> Each input field is bound to a variable using the v-model attribute. When we want to search, we grab reference to the map and call its route method, passing each of the bound variables. If you ran the application for either web or Electron, it should work great. Conclusion You just saw how to create a mapping application for Mac, Linux, and Windows using Electron , HERE, and Vue.js. Even though Electron played a very small role in terms of configuration, it was easy to meet our goals of creating an application with Vue.js that did Isoline Routing. If you’re interested in Isoline Routing with Angular, I had written a tutorial titled, Isoline Routing in an Angular Application using the HERE Routing API which demonstrates that, without the Electron part of course.", "date": "2018-11-13"},
{"website": "Here", "title": "November 2018 Release Highlights", "author": ["Denis Panov"], "link": "https://developer.here.com/blog/november-release-highlights", "abstract": "All services receive content updates weekly, but we will call out a few noteworthy highlights related to the following services: Fleet Telematics , Geovisualization , Routing , and HERE XYZ . There were minor updates and fixes across many other services which were related to regular maintenance releases. View the API Version History for previous updates including change log and release notes for all of the APIs. HERE XYZ (beta) Store, manage, and edit geospatial data in XYZ Hub. Visualize data in XYZ Studio, the XYZ Maps renderer, or bring your own. Learn more... You can change the color of geometry in a layer by specifying HEX values from XYZ Studio Sort data by numerical values in XYZ Studio Data Hub Give the tools a try and report any issues and provide feedback on your experiences. Fleet Telematics Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Learn more... Version 2.5.10 Can use &alignToGpsTime=1 to keep travel time in sync with GPS trace time in responses For route match mode has new warning attributes toTracePointSeqNum , duration (for detected stops) and truckRestrictionCategoryCode (for waiting at truck bans) Using &jsonattributes=73 and returnelevation=true will return link shape point elevations along the route Use &ignoreWaypointVehicleRestriction=1000 to avoid all admin truck restrictions and time-based link-level truck restrictions within 1000 meters around each waypoint Geovisualization Geovisualization is a cloud-based API toolkit for developing sophisticated visualizations of geographically-related data, accessible in a web browser. Learn more... Version 2.7.1 Deprecation of url / direct file based ingestion in favor of a new recipe based workflow for larger and complex data sources Routing Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Learn more... Version 7.2.98 Response attributes for time dependent restrictions timeDependentRestriction in linkAttributes parameter, RouteType , RouteLinkType ValidityPeriod added to ConditionalTruckRestrictionType", "date": "2018-11-12"},
{"website": "Here", "title": "November Event Radar", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/november-event-radar", "abstract": "After attending numerous events in October, we actually thought it could be a Seinfeld binge-watch November , but I guess there is always a developer who needs our support somewhere. And make no mistake, that developer will learn plenty about location services by December ( the holidays month, right? 🤔). Want to know more about our upcoming events? Well, keep reading! Cal Hacks | November 2 | Berkeley, USA We are sponsoring this college hackathon hosted at UC Berkeley.  If you are a student there, meet our team and good luck on your project! Phoenix Mobile Festival | November 3 | Phoenix, USA We are sponsoring this one-day event with more than 20 talks! Make sure you drop by and meet Michael. Web Summit | November 5 – 8 | Lisbon, Portugal Not sure if anybody would need any other reason than pastel de nata to visit Lisbon, but if you are like us you might want to take this opportunity to go there and attend one of the best technology conferences in the world! DeveloperWeek | November 6 – 8 | Austin, USA Jayson will be having a workshop on our newest service: XYZ . If you are a mapping enthusiast or developer who likes working with geospatial data, you don’t want to miss this. SigSpatial | November 6 – 9 | Seattle, USA We will be at SigSpatial talking about XYZ . Make sure you visit our booth and ask us anything about it. Leon Hackathon | November 9 – 10 | Leon, Mexico We are bringing together Leon’s most active names in the ecosystem for our hackathon! You wouldn’t want to miss this opportunity to learn more about how to use location technology in your apps, meet with HERE people, discover the UTL campus and meet many more technology enthusiasts! To learn more, visit the website ! Map_IT! | November 17 – 18 | Krakow, Poland It gets a little more personal and we tend to throw a few mama bear hashtags your way when we organize our own hackathons! You’ve been warned! If you're reading this, come and hack with us at Map_IT! hackathon in Krakow. You can still register here . Our evangelists and local team onsite will be there to help you 24/7. There will be top-notch mentors, a little amnesia and a lot of fun! Droidcon SF | November 19 – 20 | San Francisco, USA It’s traditional for you to see us at almost droidcon event – so, we will be at SF part as well! Make sure you drop by our booth and say hi! RunderTischGIS Hackathon | November 23 -24 | Augsburg, Germany Sprechen Sie Deutsch? If not, it might get a little tricky - but, we have a team that can speak around 10+ languages (ok, I combined all of us). If you are in Augsburg make sure you drop by and hack with us. AWS re:Invent | November 26-30 | Las Vegas, USA Look for our booth in the IoT area where Jayson will be doing a chalk talk and IoT demonstration Interneting all of the Things.  Make sure you drop by and say hi. TechCrunch Disrupt Berlin | November 29 – 30 | Berlin, Germany We will be closing the month with Disrupt Berlin! And, no German is required. Make sure you visit our booth and say hi.", "date": "2018-11-01"},
{"website": "Here", "title": "Detect Location with a Web Browser and Reverse Geocode it to an Address with HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/detect-location-with-a-web-browser-and-reverse-geocode-it-to-an-address-with-here", "abstract": "Have you ever wondered how certain websites or businesses are able to track you from your computer web browser and then target you with certain advertisements or content that you may or may not actually want? A lot of times you’re being tracked by the general location of your IP address, but there are other circumstances where you’ve probably given permission through one of those browser notifications. With simple JavaScript, most modern web browsers are able to prompt for permission to access your location where the location is a latitude and longitude coordinate that is more accurate than you might think. However, a latitude and longitude coordinate isn’t always the most useful to a lot of users. We’re going to see how to get the users current location from the web browser and reverse geocode it to the nearest address using the HERE Reverse Geocoder API . Finding the Browser Latitude and Longitude with HTML5 and JavaScript There aren’t any requirements beyond basic JavaScript to get the HTML Geolocation API functional in a project. The only requirement is to have a web browser that supports it. Lucky for us, most browsers support it as of now. Create a new index.html file somewhere on your computer and include the following: <html>\n    <head>\n        <title>Browser Location</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\">\n            if(navigator.geolocation) {\n                navigator.geolocation.getCurrentPosition(position => {\n                    console.log(position.coords);\n                });\n            } else {\n                console.error(\"Geolocation is not supported by this browser!\");\n            }\n        </script>\n    </body>\n</html> The magic here is actually in the JavaScript. First we check to make sure the current web browser supports the HTML Geolocation API. If it does not, we’re going to throw an error in the logs. If the API is supported we’re going to get the current position and print the coordinates to the logs. When running this code, the user will be prompted for permission in their web browser. If permission is granted, you’ll have a latitude and longitude to work with. We’re going to take this to the next level with HERE. Reverse Geocoding a Latitude and Longitude Position with HERE To use the HERE APIs you’ll need a free developer account . Create a project within your developer account and maintain a copy of the API key associated with the JavaScript and REST APIs. Within the index.html file, we need to include two scripts: <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script> With the HERE JavaScript libraries included in the project, initialize a platform object: var platform = new H.service.Platform({\n  'apikey': 'API_KEY'\n}); You’ll want to swap out the API_KEY with the one you find in your developer dashboard. With the platform initialized, the geocoder needs to be initialized and it can be done with the following: var geocoder = platform.getGeocodingService(); To reverse geocode something, all we need is the latitude and longitude coordinates, which we have from the HTML Geolocation API. The actual process of reverse geocoding with HERE looks like the following: geocoder.reverseGeocode(\n    {\n        mode: \"retrieveAddresses\",\n        maxresults: 1,\n        prox: latitude + \",\" + longitude\n    }, data => {\n        alert(\"The nearest address to your location is:\\n\" + data.items[0].address.label);\n    }, error => {\n        console.error(error);\n    }\n); A lot of possible information comes back with every request to the API. We only care about the label for this example which includes as much information as the API found. For example, with coordinates, the label would have the street address, city, state, and country. Information may vary depending on the country where the result resides. The final code might look something like this: <html>\n    <head>\n        <title>Browser Location</title>\n    </head>\n    <body>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script type=\"text/javascript\">\n            var platform = new H.service.Platform({\n                \"apikey\": \"API_KEY\"\n            });\n            var geocoder = platform.getSearchService();\n            if(navigator.geolocation) {\n                navigator.geolocation.getCurrentPosition(position => {\n                    geocoder.reverseGeocode(\n                        {\n                            limit: 1,\n                            at: position.coords.latitude + \",\" + position.coords.longitude\n                        }, data => {\n                            alert(\"The nearest address to your location is:\\n\" + data.items[0].address.label);\n                        }, error => {\n                            console.error(error);\n                        }\n                    );\n                });\n            } else {\n                console.error(\"Geolocation is not supported by this browser!\");\n            }\n        </script>\n    </body>\n</html> The code above uses plain HTML and vanilla JavaScript to accomplish the task. It wasn’t necessary to use any frameworks like jQuery, Angular, React.js, or Vue.js to get the job done. Conclusion You just saw how to detect the users coordinate location within the web browser and then convert those latitude and longitude coordinates into an address using the HERE Reverse Geocoder API for JavaScript. This could be useful in your web applications for numerous reasons beyond just advertising purposes. For example, you could develop a heat map for certain cities using your application and create priorities based on the results. Of course with a little imagination, you could come up with much better use cases than the one mentioned.", "date": "2018-11-08"},
{"website": "Here", "title": "Searching Location with the Command Line, WLAN Information, and the HERE Positioning API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/searching-location-with-the-command-line-wlan-information-and-the-here-positioning-api", "abstract": "If you’ve been keeping up with my tutorials, you’ll probably remember that I recently demonstrated how to find the users location using a web browser and the HTML5 Geolocation API . Have you ever wondered how it was possible to do such a thing from only a web browser? Jayson DeLancey had written a tutorial titled, Know Your Location — Voiding My Firefox Warranty that dug into what the web browser was doing behind the scenes. In summary, the HTML5 Geolocation API, at least for Firefox, gathers information from nearby WLAN broadcasts and sends it to the Google Geolocation API to be converted to latitude and longitude coordinates. Did you know that HERE can accomplish the same with the HERE Positioning API? We’re going to see how to collect WLAN data from outside of a web browser and send it to the HERE Positioning API to be converted into a position estimate. This is all going to be done from the command line. Before going forward, it is important to note that some of these commands will be specific to macOS. The idea can be easily translated to Windows or Linux. Using the HERE Positioning API The idea behind the HERE Positioning API is that if you give it information around WLAN, cellular, or Bluetooth, it will return an estimate of your latitude and longitude coordinates. You can mix and match this input data or use strictly one or the other. Each will give you varying results in terms of accuracy, but to me it is pure magic in how it works. So let’s assume that the only information we have is WLAN information. Per the documentation, we can create a request like the following: curl -X POST \\\n    'https://pos.api.here.com/positioning/v1/locate?app_id=APP-ID-HERE&app_code=APP-CODE-HERE' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n        \"wlan\": [\n            {\"mac\": \"88-e9-fe-79-be-20\"},\n            {\"mac\": \"8C-1A-BF-20-66-AD\"},\n            {\"mac\": \"A0-E4-53-E9-66-A7\"},\n            {\"mac\": \"AC-4B-C8-34-F7-01\"},\n            {\"mac\": \"A0-21-95-57-79-06\"},\n            {\"mac\": \"00-18-56-51-54-FB\"},\n            {\"mac\": \"10-30-47-D2-54-55\"},\n            {\"mac\": \"B8-6B-23-09-87-B1\"},\n            {\"mac\": \"F4-55-95-11-2C-C1\"}\n        ]\n    }\n' In the above example, make sure you swap the app_id and app_code with your own found in your HERE Developer Dashboard. However, notice that we’ve provided the hardware address (MAC) for numerous WLAN access points. To be clear, these are access points or routers, not the hardware addresses to the network interfaces found in your devices. When sent to the HERE Positioning API, an estimate of your location will be returned based on the registered location of each of these access points. A more accurate estimate can be determined if the power level is provided with each hardware address. The power level helps determine how far you are from each access point. Upon success, the following might be returned: {\n    \"location\": {\n        \"lat\": 52.5185857,\n        \"lng\": 13.37622989,\n        \"accuracy\": 100\n    }\n} This is great, but we’ve just used data that was provided to us. We want to find our actual location and we want to do it without using a web browser. So what do we do? Finding WLAN Information from Nearby Access Points As a user of pretty much any modern computer, we can view all the networks that are in range to us, even if we can’t connect to them due to password reasons. This means that we can gather meta information about how those networks are exposed. This is where that macOS specific logic comes into play. Take the following command: /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s The above command will scan for all nearby WLAN access points, hence the -s flag. If ran successfully, you should end up with results similar to the following: SSID        BSSID               RSSI    CHANNEL HT CC SECURITY (auth/unicast/group)\nEXAMPLE1    XX:XX:XX:XX:XX:XX   -83     11      Y  US WPA2(PSK/AES/AES)\nEXAMPLE2    YY:YY:YY:YY:YY:YY   -84     64      Y  US WPA2(PSK/AES/AES)\nEXAMPLE3    ZZ:ZZ:ZZ:ZZ:ZZ:ZZ   -80     11      Y  US NONE\nEXAMPLE4    AA:AA:AA:AA:AA:AA   -79     11      Y  US WPA(PSK/AES,TKIP/TKIP) WPA2(PSK/AES,TKIP/TKIP) As you can tell the SSID and BSSID information above was fabricated. I’m not going to share where I live, even if it is just a really good estimate. In reality, when I ran the scan, I ended up with about 20 results. Yours may vary depending on where you live. So the above output is great. What’s great as well is that there are similar commands for Linux and Windows. However, we know what the HERE Positioning API expects and the above output isn’t quite that. Parsing Access Point Data for Hardware Addresses and Power Levels Since we’re restricting this example to the command line, we should probably pull out the books and start looking at parsing our data with some shell commands. The only information we care about is the BSSID and the RSSI value, where RSSI is the power value. There are many ways to parse data with the command line, but we’re going to make use of awk and sed for the job. Take a look at the following awk command: awk -F ' ' 'match($2, /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/) {printf \"{ \\\"mac\\\": \\\"%s\\\", \\\"powrx\\\": %s },\", $2, $3}' The above command would potentially take the scan output and parse it by the space characters. This will give us some nice column data to work with. With column data, we can do a regular expression on the second column, which is the BSSID values. We want to make sure the BSSID is a proper hardware address separated by colon or hyphen characters. If our second column matches this criteria, we want to format the line as a JSON object. To be fair, I snagged the regular expression from Stack Overflow . I want to make sure I give credit where credit is due because I am terrible at regular expressions. So we’ve potentially got a result now that looks like this: {\"mac\": \"XX:XX:XX:XX:XX:XX\", \"powrx\": -83},\n{\"mac\": \"YY:YY:YY:YY:YY:YY\", \"powrx\": -84},\n{\"mac\": \"ZZ:ZZ:ZZ:ZZ:ZZ:ZZ\", \"powrx\": -80},\n{\"mac\": \"AA:AA:AA:AA:AA:AA\", \"powrx\": -79}, This is great, but we have a problem. The last object has a training comma character which will give us some bad POST bodies in the future. We need to strip out the training comma to be on good terms. To strip out the trailing comma we can use a variety of tricks, but the following should work: sed '$s/,$//' The sed command will strip out the last comma and return the rest. Again, to be fair, I ripped the above sed command from another Stack Overflow answer. So as of now we probably have something that looked like the previous output, but without the trailing comma. This is great, but we’re still not where we need to be in terms of a request. With the output, we can use it in the following awk command: awk '{printf \"{ \\\"wlan\\\": [ %s ] }\", $0}' The above command will take our output, which is only one column, and wrap it in the other necessary parts of the request. This means that as of now, provided you ran each of the commands in order with the data, we have a body that can be sent to the HERE Positioning API. Search Your Location in a Single Command Line Request We have a bunch of script commands now. To finish things, we want to tie everything together and make a request all with a single command. To do this, we can execute the following from the command line: /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s | awk -F ' ' 'match($2, /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/) {printf \"{ \\\"mac\\\": \\\"%s\\\", \\\"powrx\\\": %s },\", $2, $3}' | sed '$s/,$//' | awk '{printf \"{ \\\"wlan\\\": [ %s ] }\", $0}' | curl --silent -H \"content-type: application/json\" -X POST -d @- \"https://pos.api.here.com/positioning/v1/locate?app_id=APP-ID-HERE&app_code=APP-CODE-HERE\" In the above command, notice that we’ve taken each of our script commands and used a pipe character. The results of each command will be piped into the next, leading us to the actual cURL request: curl --silent \\\n    -H \"content-type: application/json\" \\\n    -X POST \\\n    -d @- \\\n    \"https://pos.api.here.com/positioning/v1/locate?app_id=APP-ID-HERE&app_code=APP-CODE-HERE\" Assuming you’re using a Mac and assuming that you’ve replaced the app_id and app_code values, you should get a response with an estimate of your location. Conclusion You just saw how to use the HERE Positioning API to calculate an estimate of your location using nothing more than the command line and surrounding WLAN access points. So how could this be useful? Maybe you are building some kind of Internet of Things (IoT) project where GPS and cellular aren’t options, but you have WiFi and need a location estimate. There are plenty of use cases, all of which won’t have too difficult of time with WLAN positioning.", "date": "2018-11-20"},
{"website": "Here", "title": "Geocode Addresses with Amazon Alexa, Golang, and the HERE Geocoder API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/geocode-addresses-with-amazon-alexa-golang-and-the-here-geocoder-api", "abstract": "I’m a big advocate of the Amazon Echo line and Alexa. I have an Echo in pretty much every room of my house and have even published a Skill in the past called BART Control which gives information on the Bay Area Rapid Transit system. Most skills, not all, make use of AWS Lambda and Functions as a Service (FaaS) to operate. Essentially, you create a function, it executes some code, and it returns a response. In Amazon Alexa lingo, you give it a request which is your voice command, it executes some code, and it gives a response which is a voice response. With the concept of Lambda in mind, we can create a function that does pretty much anything, including working with some of the HERE APIs. We’re going to explore creating our own Amazon Alexa Skill using a Lambda function written in Golang that takes an address in the command and returns a latitude and longitude coordinate generated by the HERE Geocoder API . Build an AWS Lambda Function with the Go Programming Language As of recently, AWS Lambda started officially supporting Golang as a technology for creating functions. We’ll be able to leverage the Lambda SDK for Golang to do most of our work. However, we’ll also need to create our own data structures for working with Alexa requests and responses. Let’s start by obtaining the AWS Lambda SDK for Golang. From the command line, execute the following: go get github.com/aws/aws-lambda-go/lambda The above command assumes that you have Go installed and your $GOPATH configured already. With the Lambda SDK available, we can start creating our function. Within your $GOPATH path, create a main.go file with the following code: package main\n\nimport (\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"strconv\"\n    \"fmt\"\n    \"github.com/aws/aws-lambda-go/lambda\"\n)\n\nfunc Handler() (string, error) {\n    return fmt.Sprintf(\"Hello World\"), nil\n}\n\nfunc main() {\n    lambda.Start(Handler)\n} The above code is the most basic of functions. When this is uploaded to Lambda and ran, the main function will start our only Handler function which will just return a string. While it isn’t exactly useful, we now know it doesn’t take much to use Lambda. Before we even think about including Amazon Alexa into the mix, we should probably get our geocoding functional. Convert Addresses to Latitude and Longitude Positions with the HERE Geocoder API This isn’t the first time that I’ve written about using the HERE Geocoder API with Golang. If you’re interested in what you can do with HERE and Golang, you might want to check out my tutorial titled, Process CSV Address Information with Golang and the HERE Geocoder API . We’re going to reuse a lot of the logic that’s been seen in one of my many other Golang related tutorials. To start, we’re going to focus on creating native data structures to hold information about the HERE platform as well as the response data. In the main.go file, include the following: type HerePlatform struct {\n    AppId   string\n    AppCode string\n}\n\ntype GeocoderResponse struct {\n    Response struct {\n        View []struct {\n            Type   string `json:\"_type\"`\n            Result []struct {\n                Location struct {\n                    Address struct {\n                        Label       string `json:\"Label,omitempty\"`\n                        Country     string `json:\"Country,omitempty\"`\n                        State       string `json:\"State,omitempty\"`\n                        County      string `json:\"County,omitempty\"`\n                        City        string `json:\"City,omitempty\"`\n                        District    string `json:\"District,omitempty\"`\n                        Street      string `json:\"Street,omitempty\"`\n                        HouseNumber string `json:\"HouseNumber,omitempty\"`\n                        PostalCode  string `json:\"PostalCode,omitempty\"`\n                    } `json:\"Address\"`\n                    DisplayPosition struct {\n                        Latitude  float64 `json:\"Latitude\"`\n                        Longitude float64 `json:\"Longitude\"`\n                    } `json:\"DisplayPosition\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n} We have two different data structures in the above code. The HerePlatform data structure is designed to hold our application id and application code that can be obtained with a free HERE account. The GeocoderResponse is modeled after the response for the REST API. It doesn’t include everything, but it includes the things we care about for this example. In the main function, we can update our code to look like the following: var platform HerePlatform\n\nfunc main() {\n    platform = HerePlatform{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    lambda.Start(Handler)\n} Notice that we are now configuring the HERE platform with our API tokens. Rather than creating some messy code, we should probably create a function that is responsible for making requests agains the API. Within the main.go file, include the following function: func (platform *HerePlatform) Geocode(query string) (GeocoderResponse, error) {\n    endpoint, _ := url.Parse(\"https://geocoder.api.here.com/6.2/geocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", platform.AppId)\n    queryParams.Set(\"app_code\", platform.AppCode)\n    queryParams.Set(\"searchtext\", query)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeocoderResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geocoderResponse GeocoderResponse\n        json.Unmarshal(data, &geocoderResponse)\n        return geocoderResponse, nil\n    }\n} The above Geocode function models the expectations of the HERE Geocoder API. We provide it the application id and application code that was previously defined and construct the request with a user defined query, which should be an address. If the request to this function is successful, a properly modeled GeocoderResponse will be returned. We can make use of this function by altering the Handler function: func Handler() (string, error) {\n    geocoderResponse, _ := platform.Geocode(\"Tracy, CA\")\n    return fmt.Sprintf(\"%f, %f\", geocoderResponse.Response.View[0].Result[0].Location.DisplayPosition.Latitude, geocoderResponse.Response.View[0].Result[0].Location.DisplayPosition.Longitude), nil\n} We didn’t do any error validation, but we’re assuming data was found for the query and as a response, the latitude and longitude is returned to the caller of this Lambda function. To build this application for Lambda, execute the following: GOOS=linux go build\nzip handler.zip ./alexa-geocoder There is an assumption with the above two commands. The assumption is that your project is called alexa-geocoder and that you’re using an operating system that has the zip command. Feel free to change it a bit or ZIP the binary however works best for you. The above commands worked fine for me on a Mac. If we wanted to, we could upload this ZIP archive to AWS Lambda. Go through the steps of creating a Lambda function in your AWS Console and when prompted, say that you’re using Golang as the development technology. Eventually you’ll end up at a screen that looks like the one above. Add Alexa Skills Kit as a trigger and upload the ZIP file as your function code. You can test the function by creating a test case in the top menu. It should return some latitude and longitude coordinates when you’re done. Building, Uploading, and Testing the Application as an Alexa Skill Now that we have a working Lambda function that makes use of the HERE Geocoder API, we can design it to work with Amazon Alexa. While Alexa can use Lambda, there are some configurations that must take place to make it successful. Previously we returned a string as the response to our function. Alexa expects something a little different. I recommend installing the following package: go get github.com/arienmalec/alexa-go While not absolutely necessary, the above package acts as a solid blueprint for Alexa requests and responses. You could create your own as well, it is up to you. Each Alexa Skill will have many different operations. This means our function needs to be able to process different requests. This is best solved by creating a type of dispatcher function that routes to other functions based on the incoming request. Take the following: func IntentDispatcher(request alexa.Request) alexa.Response {\n    var response alexa.Response\n    switch request.Body.Intent.Name {\n    case \"AddressIntent\":\n        response = HandleAddressIntent(request)\n    case \"AboutIntent\":\n        response = HandleAboutIntent(request)\n    default:\n        response = HandleAboutIntent(request)\n    }\n    return response\n} The above dispatcher will route to two potential functions containing logic. We’ll have an AboutIntent and an AddressIntent , both of which will do different things. The intent is determined by Amazon when receiving a request from the user. To call the IntentDispatcher function, our Handler function needs to change a bit: func Handler(request alexa.Request) (alexa.Response, error) {\n    return IntentDispatcher(request), nil\n} Notice that in both circumstances, we are now accepting an alexa.Request and returning an alexa.Response . These are both defined as part of the package that we downloaded. Let’s start by creating the simplest of the two intents. Create a HandleAboutIntent as defined in the IntentDispatcher function: func HandleAboutIntent(request alexa.Request) alexa.Response {\n    return alexa.NewSimpleResponse(\"About\", \"Geocoder was created by Nic Raboy in Tracy, California\")\n} When invoked, we just respond with a simple message. The NewSimpleResponse accepts two parameters. While Alexa only reads the second, two exist for populating card content within the Alexa mobile application. Before we start working on the AddressIntent , we know what the HERE Geocoder API returns. We know that the latitude and longitude data is in float format, which isn’t the easiest to work with. Instead, we should create a function to convert that data. func FloatToString(value float64) string {\n    return strconv.FormatFloat(value, 'f', -1, 64)\n} The above function will convert our floats into strings. With that out of the way, let’s create an AddressIntent for working with user provided addresses and convert them into coordinates. func HandleAddressIntent(request alexa.Request) alexa.Response {\n    address := request.Body.Intent.Slots[\"Address\"].Value\n    if address == \"\" {\n        return alexa.NewSimpleResponse(\"Geocoded Address\", \"An address is required, but was not found\")\n    }\n    geocoderResponse, err := platform.Geocode(address)\n    if err != nil {\n        return alexa.NewSimpleResponse(\"Geocoded Address\", err.Error())\n    }\n    if len(geocoderResponse.Response.View) == 0 || len(geocoderResponse.Response.View[0].Result) == 0 {\n        return alexa.NewSimpleResponse(\"Geocoded Address\", \"No results found for \"+address)\n    }\n    return alexa.NewSimpleResponse(\"Geocoded Address\", FloatToString(geocoderResponse.Response.View[0].Result[0].Location.DisplayPosition.Latitude)+\", \"+FloatToString(geocoderResponse.Response.View[0].Result[0].Location.DisplayPosition.Longitude))\n} The setup of the HandleAddressIntent is the same, but now we’re working with slot data. The only slot for this intent is the actual address the user gives us. If it doesn’t exist, we will have Alexa say so. If it does exist, we will make a request to the HERE Geocoder API. If no result exists, we will return an error for Alexa to read. Otherwise, if everything looks good, we’ll return the latitude and longitude coordinate data. Go ahead and build the application again. At this point we can upload the application in Lambda, and start connecting Alexa to the Lambda function. After uploading the function, go to the Alexa Developer Console and create a new Skill. As seen above, there will be a skill builder checklist of things that must be done before you can test and publish. Start by giving your Skill an invocation name, noting that it should be something Alexa will be able to understand when spoken. Next you’ll want to create two custom intents to match what we have in our Go application. The intents should be named to match, so create an AboutIntent and an AddressIntent . Each intent will need a list of sample utterances. It is very important to list any and every possible utterance you can think of for calling these intents. The more sample sentences you provide, the more reliable your Skill will be. For my AboutIntent , I’ve included the following: who made this skill\nwho made this application\ngive me information\nfor some information I’ve only listed a few, but you should have a lot more than that. The idea is that the Skill will be invoked with something like: Alexa, ask [name] for some information The sample utterance data will be slightly different for the AddressIntent because we have some slot information to provide. For the slot, we should name it Address and it should be of type AMAZON.StreetAddress . The utterances should look like the following: get me the position of {Address}\ngive me the position of {Address}\nfind the coordinates of {Address}\nfind the position of {Address} Notice that the above utterances have a variable defined by curly brackets. This variable must match the previously defined slot. The idea is that the user will be able to invoke the Skill with something like: Alexa, ask [name] to get me the position of Tracy, California The slot data can be much more complex than my example. Remember, Alexa is expecting any kind of address information. After defining your intents, you need to link up the Skill with Lambda. In Lambda, you’ll have access to the id for your function. Copy it and provide it to the Alexa Skill. When you’re done, you can build the Skill for testing. Assuming everything went as plan, go ahead and either type or say some commands in the test area. The simulator should respond with actual answers as seen in the image above. If you’re satisfied with everything that happened, you can publish your Skill. Conclusion You just saw how to create an Amazon Alexa Skill that takes address information and geocodes it to latitude and longitude coordinate information using Golang , AWS Lamda , and the HERE Geocoder API . As someone who has developed and published Skills, the most difficult part is the deployment process, not the development process. This is similar to releasing a mobile application. There are a lot of steps involved. In terms of development, we just created some Golang functions that included HTTP request logic.", "date": "2018-11-15"},
{"website": "Here", "title": "Use HERE Interactive Maps with ReactJS to Pick a Theme", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/use-here-interactive-maps-with-reactjs-to-pick-a-theme", "abstract": "Many developers struggle when trying to integrate HERE Maps into their ReactJS application.  Typically, when trying to adapt the Quick Start Maps API for JavaScript it is very easy to stumble into some of the challenges of using third party libraries like ours with React.  Once you are aware of these pitfalls though, you can build an app to select a custom map theme and style from the Map Tile API . Project For this project, we want to display an interactive map that allows the user to choose a theme. A slippy map like this that allows the user to pan and zoom around is one of the most common maps on the web. Since it may not be straightforward how to fetch raster tiles and build the standard behaviors into a UI, using the Maps JavaScript SDK is invaluable for a consistent experience. By clicking one of the thumbnail images, the interactive map will update with a new tile service provider as demonstrated in this gif: Basic React For a basic single-page app, you might start by including the React and HERE libraries from a CDN directly in your index.html . <script src=\"https://unpkg.com/react@16/umd/react.development.js\" crossorigin></script>\n<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\" crossorigin></script> Create a simple ES6 class called SimpleHereMap . The componentDidMount() method runs after the render() method per the React Component Lifecycle which means we can more or less include the HERE JavaScript Quick Start code just as is. const e = React.createElement;\n\nclass SimpleHereMap extends React.Component {\n  componentDidMount() {\n    var platform = new H.service.Platform({\n        app_id: 'APP_ID_HERE',\n        app_code: 'APP_CODE_HERE',\n        })\n\n    var layers = platform.createDefaultLayers();\n    var map = new H.Map(\n        document.getElementById('map'),\n        layers.normal.map,\n        {\n            center: {lat: 42.345978, lng: -83.0405},\n            zoom: 12,\n        });\n\n    var events = new H.mapevents.MapEvents(map);\n    var behavior = new H.mapevents.Behavior(events);\n    var ui = H.ui.UI.createDefault(map, layers);\n  }\n\n  render() {\n      return e('div', {\"id\": \"map\"});\n  }\n}\n\nconst domContainer = document.querySelector('#app');\nReactDOM.render(e(SimpleHereMap), domContainer); This example works if you use it standalone in a single index.html file but doesn’t make use of JSX and falls apart if you try to use create-react-app . If you use that tool as described in a few of the other ReactJS posts you may see the next error. ‘H’ is not defined no-undef Adapting the above example for create-react-app requires a few minor changes. Move the includes of the HERE script libraries into public/index.html Create a Map.js with the SimpleHereMap class. Update the render() method to use JSX to place the <div/> element. If you make those changes and npm start you will likely see the following error in your console: ‘H’ is not defined no-undef The initialization of H.service.Platform() is causing an error because H is not in scope. This is not unique to HERE and is generally the case with any 3rd party code you try to include with React. Using create-react-app implies using its toolchain including webpack as a module bundler, eslint for checking syntax, and Babel to transpile JSX. Any library like the HERE JavaScript SDK that has a global variable like H might run into a similar problem during compilation (jQuery, Leaflet, etc.). By referencing non-imported code like this, the syntax linter which is platform agnostic will complain because it doesn’t know that the page will ultimately be rendered in a web browser. The simple fix is to reference window.H instead. Unfortunately, this does violate one of the basic principles of building modular JavaScript applications by tightly coupling our <script> includes with our component but it works. public/index.html The script libraries are simply included in the public index.html. @@ -4,6 +4,14 @@\n     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n+\n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1526040296\" />\n+\n+    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\"></script>\n+    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\"></script>\n+    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\"></script>\n+    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"></script>\n+ src/Map.js The Map component defines the rendered map. We’ll be making a few more changes to this class later once we get to the theme selection.  We're storing a lot of the properties like lat, long, zoom, and app credentials as state so that they can be changed dynamically. class Map extends Component {\n    constructor(props) {\n        super(props);\n\n        this.platform = null;\n        this.map = null;\n\n        this.state = {\n            app_id: props.app_id,\n            app_code: props.app_code,\n            center: {\n                lat: props.lat,\n                lng: props.lng,\n            },\n            zoom: props.zoom,\n            theme: props.theme,\n            style: props.style,\n        }\n    }\n\n    // TODO: Add theme selection discussed later HERE\n\n    componentDidMount() {\n        this.platform = new window.H.service.Platform(this.state);\n\n        var layer = this.platform.createDefaultLayers();\n        var container = document.getElementById('here-map');\n\n        this.map = new window.H.Map(container, layer.normal.map, {\n            center: this.state.center,\n            zoom: this.state.zoom,\n          })\n\n        var events = new window.H.mapevents.MapEvents(this.map);\n        // eslint-disable-next-line\n        var behavior = new window.H.mapevents.Behavior(events);\n        // eslint-disable-next-line\n        var ui = new window.H.ui.UI.createDefault(this.map, layer)\n    }    \n\n    render() {\n        return (\n            <div id=\"here-map\" style={{width: '100%', height: '400px', background: 'grey' }} />\n        );\n    }\n} At this point though we have a working and extensible ReactJS component that is ready to display a HERE Interactive Maps. Themes Since a map can be an extension to a brand or preferences, there are many themes and styles available for how to present a map on a page. The following image depicts some of the examples of maps you can use from the Maps Tile API. The src/ThemeSelector.js component is simply intended to provide a listing of thumbnail images the user can choose from. It includes some of the more popular themes: class ThemeSelector extends Component {\n    render() {\n        var themes = [\n            'normal.day',\n            'normal.day.grey',\n            'normal.day.transit',\n            'normal.night',\n            'normal.night.grey',\n            'reduced.night',\n            'reduced.day',\n            'pedestrian.day',\n            'pedestrian.night',\n        ];\n\n        var thumbnails = [];\n        var onChange = this.props.changeTheme;\n        themes.forEach(function(theme) {\n            thumbnails.push(<img key={ theme } src={ 'images/' + theme + '.thumb.png' } onClick= { onChange } alt={ theme } id={ theme } />);\n        });\n\n        return (\n            <div>\n            { thumbnails }\n            </div>\n        );\n\n    }\n} To make the click event work, we’re going to add a bit more to our src/Map.js component. The changeTheme method described below is an example like you’d find for most any HERE JavaScript implementation. changeTheme(theme, style) {\n    var tiles = this.platform.getMapTileService({'type': 'base'});\n    var layer = tiles.createTileLayer(\n        'maptile',\n        theme,\n        256,\n        'png',\n        {'style': style}\n    );\n    this.map.setBaseLayer(layer);\n} We will call this method from the shouldComponentUpdate() method. From the React Component Lifecycle, this method is called when state changes occur in order to determine if it’s necessary to re-render the component. When we select a new theme, we call the setBaseLayer method and can update the map without requiring React to make a more costly re-render of the entire DOM. shouldComponentUpdate(props, state) {\n    this.changeTheme(props.theme, props.style);\n    return false;\n} App Putting it all together, we use src/App.js to track state for the theme selection as the common ancestor to both the Map and ThemeSelector components. The source code looks like this: import Map from './Map.js';\nimport ThemeSelector from './ThemeSelector.js';\n\nclass App extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            theme: 'normal.day',\n        }\n\n        this.onChange = this.onChange.bind(this);\n    }\n\n    onChange(evt) {\n        evt.preventDefault();\n\n        var change = evt.target.id;\n        this.setState({\n            \"theme\": change,\n        });\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <SimpleHereMap\n                    app_id=\"APP_ID_HERE\"\n                    app_code=\"APP_CODE_HERE\"\n                    lat=\"42.345978\"\n                    lng=\"-83.0405\"\n                    zoom=\"12\"\n                    theme={ this.state.theme }\n                />\n                <ThemeSelector changeTheme={ this.onChange } />\n            </div>\n        );\n    }\n} Summary Ideally we’d like to include an npm package that encapsulates the HERE Map API s as React components for use in our applications. There are some community projects to create these packages but your experience may vary depending on which one you choose to use. It would be good to know what you’ve used successfully, so leave a note in the comments. For everybody else just looking for a quick way to get compatibility with many of the other JavaScript API examples hopefully the window.H trick is what you were looking for. You can find the source code for this project on GitHub. If you found this article helpful, check out the post HERE with React - Location Based TODO App for more #ReactJS #JavaScript examples.", "date": "2018-11-14"},
{"website": "Here", "title": "Android Premium SDK - Speed Limit Warning Example", "author": ["Mariusz Karpicki"], "link": "https://developer.here.com/blog/android-premium-sdk-speed-limit-warning-example", "abstract": "The Android Premium SDK If you want to build full-featured native apps, we provide an Android Mobile SDK with both a Starter version with a smaller memory footprint for basic maps and a Premium version that has a wide-range of location features .  Both are available in the Freemium plan, so in this project we'll walk through an example of the Android Premium SDK to display our current velocity and the speed limit of the road that we are currently on to warn us if we are speeding. The result will look like this: Before We Start Acquire SDK Credentials The first thing we need to do is to get credentials. In order to do that, let's create a HERE account and sign up for a Freemium plan . After signing up, we land on the project details page, where we can generate credentials for the platforms that we want to develop on.  In our case, we are interested in the Premium SDK for Android.  After entering a package name we can download the SDK. This flow is also described with other Android SDK examples on Github . Create Android Studio Project Please follow the steps described on our documentation to create a template for our app with the HERE SDK. Step 1. Update of AndroidManifest.xml First, please open the AndroidManifest.xml file and add some permissions that our app will need: <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /> We will not focus on requesting permissions itself but the code example in the repository includes a requesting method that can be used for SDK Version > 22 . More information can be found here . As you can also read in our documentation , you should insert the credentials that you generated into the <application> tag: <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"{SAMPLE_APP_ID}\"/>\n    <meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"{SAMPLE_APP_CODE}\"/>\n    <meta-data android:name=\"com.here.android.maps.license.key\" android:value=\"{SAMPLE_LICENSE}\"/> The last snippet that we will add to the AndroidManifest.xml file, is the definition of MapService . <service\n        android:name=\"com.here.android.mpa.service.MapService\"\n        android:label=\"HereMapService\"\n        android:process=\"global.Here.Map.Service.v3\"\n        android:exported=\"true\" >\n        <intent-filter>\n            <action android:name=\"com.here.android.mpa.service.MapService.v3\" >\n            </action>\n        </intent-filter>\n    </service> Step 2. Initializing HERE SDK The documentation section, that we used for creating simple app also describes how to initialize the Map Fragment. As our application will not need a Map Fragment rendered on the UI, we will use MapEngine Class , which is another way of initializing the HERE SDK. Go to your MainActivity class and implement the onCreate method: import com.here.android.mpa.common.ApplicationContext;\nimport com.here.android.mpa.common.MapEngine;\nimport com.here.android.mpa.common.OnEngineInitListener;\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        /* \n        as mentioned before, for Android SDK Version  > 22 \n        we would have to request permissions and call initSDK() when\n        permissions will be granted\n        */\n        initSDK();\n\n    }\n\n    private void initSDK() {\n        ApplicationContext appContext = new ApplicationContext(this);\n\n        MapEngine.getInstance().init(appContext, new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(Error error) {\n                if (error == Error.NONE) {\n\n                    MapEngine.getInstance().onResume();\n\n                } else {\n                    //handle error here\n                }\n            }\n        });\n    }\n} Step 3. Initializing Positioning and Navigation Managers The HERE SDK is now initialized, so we can enable some functionality that our application will rely on. First, let's import the required packages: import com.here.android.mpa.common.PositioningManager;\nimport com.here.android.mpa.guidance.NavigationManager; More detailed information about both packages can be found in the HERE Android SDK API reference . private void startPositioningManager() {\n        boolean positioningManagerStarted = PositioningManager.getInstance().start(PositioningManager.LocationMethod.GPS_NETWORK);\n\n        if (!positioningManagerStarted) {\n            //handle error here\n        }\n    }\n\n    private void startNavigationManager() {\n        NavigationManager.Error navError = NavigationManager.getInstance().startTracking();\n\n        if (navError != NavigationManager.Error.NONE) {\n            //handle error navError.toString());\n        }\n    } At the end, when we know SDK was initialized properly, let's call both methods : private void initSDK() {\n        ApplicationContext appContext = new ApplicationContext(this);\n\n        MapEngine.getInstance().init(appContext, new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(Error error) {\n                if (error == Error.NONE) {\n\n                    MapEngine.getInstance().onResume();\n                    startPositioningManager();\n                    startNavigationManager();\n\n                } else {\n                    //handle error here\n                }\n            }\n        });\n    } Step 4. Speed Limit Fragment In this step we will create a class that will extend the Fragment class. Our SpeedLimitFragment will be responsible for the main logic of our application. We will be watching for the device's position updates. Based on our current position, we will then try to get information about the speed limit on the road. To make this happen, we will define PositioningManager.OnPositionChangedListener : PositioningManager.OnPositionChangedListener positionLister = new PositioningManager.OnPositionChangedListener() {\n        @Override\n        public void onPositionUpdated(PositioningManager.LocationMethod locationMethod,\n                                      GeoPosition geoPosition, boolean b) {\n\n                /* logic responsible for accessing data will go here */\n\n            }\n            @Override\n            public void onPositionFixChanged(PositioningManager.LocationMethod locationMethod,\n                                                 PositioningManager.LocationStatus locationStatus) {\n\n            }\n        }; Adding listener to PositioningManager must happen when the HERE SDK is ready. We could add listener into the onCreate method of our Fragment and create it programmatically when MainActivity knows that the HERE SDK is ready, but to keep our example simple we will define Fragment directly in the template and expose the method to MainActivity that will be responsible for adding listener . public void startListeners() {\n        PositioningManager.getInstance().addListener(new WeakReference<>(positionLister));\n    } More information about PositioningManager can be found in User Guide and API Reference . Step 5. Adding Fragment to Activity First, as mentioned already, we add the fragment into activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:keepScreenOn=\"true\"\n    tools:context=\".MainActivity\">\n\n    <fragment\n        class=\"com.here.example.speedlimit.SpeedLimitFragment\"\n        android:id=\"@+id/speedLimitFragment\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n\n</android.support.constraint.ConstraintLayout> As we may want to use our application when driving, we added android:keepScreenOn=\"true\" to our Layout Now that we have the fragment in place, we will activate its listener from MainActivity when the HERE SDK is initialized. To do that, we will create a private method in MainActivity : private void activateSpeedLimitFragment() {\n        SpeedLimitFragment speedLimitFragment = (SpeedLimitFragment)\n                getSupportFragmentManager().findFragmentById(R.id.speedLimitFragment);\n\n        if (speedLimitFragment != null) {\n            speedLimitFragment.startListeners();\n        }\n    } And we will call it with our previously defined methods when the SDK is ready: private void initSDK() {\n        ApplicationContext appContext = new ApplicationContext(this);\n\n        MapEngine.getInstance().init(appContext, new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(Error error) {\n                if (error == Error.NONE) {\n\n                    MapEngine.getInstance().onResume();\n\n                    startPositioningManager();\n                    startNavigationManager();\n                    activateSpeedLimitFragment();\n\n                } else {\n                    //handle error here\n                }\n            }\n        });\n    } Step 6. Adding logic into the Fragment As the goal of this tutorial is to explore the HERE SDK's functionality, we will skip the part responsible for the UI-related implementation of SpeedLimitFragment . However, the code is available in the repository. Let's come back to the SpeedLimitFragment code and the body of the onPositionUpdated method. One of the params that will be passed into the method is geoPosition . If the position is valid and if the object is a instance of com.here.android.mpa.common.MatchedGeoPosition , we can access the information that we are looking for: if (geoPosition.isValid() && geoPosition instanceof MatchedGeoPosition) {\n\n        MatchedGeoPosition mgp = (MatchedGeoPosition) geoPosition;\n\n        double currentSpeed = mgp.getSpeed();\n        double currentSpeedLimit = 0;\n\n        if (mgp.getRoadElement() != null) {\n            currentSpeedLimit = mgp.getRoadElement().getSpeedLimit();\n        }\n\n    } else {\n        //handle error\n    } As the current speed and speed limit come in meters per second we also may want to format it to display as a more human-readable value: private int meterPerSecToKmPerHour (double speed) {\n        return (int) (speed * 3.6);\n    }\n\n    private int meterPerSecToMilesPerHour (double speed) {\n        return (int) (speed * 2.23694);\n    } If you are already writing an application that uses the HERE Map Data Download feature, this may be enough to achieve our goal. In case your application does not have the Map Data downloaded, you may need to fetch local map data, in order to be able to access the RoadElement . Fetching data Let's define prefetcherListener in SpeedLimitFragment and some boolean as Semaphore to know when fetching is in progress: private boolean fetchingDataInProgress = false;\n\n    MapDataPrefetcher.Adapter prefetcherListener = new MapDataPrefetcher.Adapter() {\n        @Override\n        public void onStatus(int requestId, PrefetchStatus status) {\n            if(status != PrefetchStatus.PREFETCH_IN_PROGRESS) {\n                fetchingDataInProgress = false;\n            }\n        }\n    }; Next what we should do is to add this listener to MapDataPrefetcher , we can do it in the startListeners method: public void startListeners() {\n        PositioningManager.getInstance().addListener(new WeakReference<>(positionLister));\n        MapDataPrefetcher.getInstance().addListener(prefetcherListener);\n    } And as we want to fetch data when the position has changed, we can fetch a GeoBoundingBox around the device's geoPosition . This is how onPositionUpdated can look like: @Override\n    public void onPositionUpdated(PositioningManager.LocationMethod locationMethod,\n                                  GeoPosition geoPosition, boolean b) {\n\n        if (PositioningManager.getInstance().getRoadElement() == null && !fetchingDataInProgress) {\n            GeoBoundingBox areaAround = new GeoBoundingBox(geoPosition.getCoordinate(), 500, 500);\n            MapDataPrefetcher.getInstance().fetchMapData(areaAround);\n            fetchingDataInProgress = true;\n        }\n\n        if (geoPosition.isValid() && geoPosition instanceof MatchedGeoPosition) {\n\n            MatchedGeoPosition mgp = (MatchedGeoPosition) geoPosition;\n\n            double currentSpeed = mgp.getSpeed();\n            double currentSpeedLimit = 0;\n\n            if (mgp.getRoadElement() != null) {\n                currentSpeedLimit = mgp.getRoadElement().getSpeedLimit();                    \n            }\n\n        } else {\n            //handle error\n        }\n    } What next? This tutorial did not cover the application's life cycle and impact on used SDK objects. To learn more on that subject, read here . We also did not focus on UI implementation - a simple version of it is in the Github repository (tested with HERE Android SDK 3.8 and Android 5 and 7.1). The described example is ready to display the current speed and speed limit on the Activity's UI when the application starts. As the user may want to use other applications while driving, it makes sense to go further and possibly implement your own Fragment as a Floating widget, so it can always be on screen even while just sitting at my desk. Happy coding!", "date": "2018-11-21"},
{"website": "Here", "title": "Building an Alexa Skill with JavaScript and HERE Location Services", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/building-an-alexa-skill-with-javascript-and-here-location-services", "abstract": "Having a voice assistant compatible application is a necessity of a lot of modern organizations. With Amazon Alexa powered devices in millions of homes, it makes sense to support these devices. Many applications require location features of some sort whether that be tracking, positioning, or something else. Did you know that you could include location services in your Alexa Skills with HERE? About a week ago I had written a tutorial titled, Geocode Addresses with Amazon Alexa, Golang, and the HERE Geocoder API which focused on Golang, but what if we wanted to explore another common technology like JavaScript? We’re going to see how to build an Amazon Alexa Skill using Node.js and simple JavaScript while including HERE Location Services (HLS). Creating a New Node.js Project with the Dependencies The core of this application will be JavaScript with Node.js and it will be hosted on AWS Lambda as a Functions as a Service (FaaS) application. The first step for success is to create a new project. From the command line, execute the following: npm init -y\nnpm install ask-sdk --save\nnpm install request --save\nnpm install request-promise --save The above commands will create a new package.json file and install three project dependencies. The first dependency, ask-sdk is the Alexa Skills Kit SDK, and it will allow us to accept requests and return properly formatted Alexa responses. Because we’ll be using HERE, we need a way to make HTTP requests, so the request and request-promise packages will do the job. The last thing to do to get us started is to create a file that will hold all of our code. Create a main.js file within your project with the following code: const Alexa = require(\"ask-sdk-core\");\nconst Request = require(\"request-promise\");\n\nconst appId = \"APP-ID-HERE\";\nconst appCode = \"APP-CODE-HERE\";\n\nvar skill;\n\nexports.handler = async (event, context) => { }; The above code imports our packages and creates our single handler function that will be called by AWS Lambda. We’re also laying the groundwork when it comes to our variables. Because we’ll be using the HLS platform, we need to have an application id and an application code. Both can be created for free from within the HERE Developer Portal. Developing an AWS Lambda Function with Multiple Intent Support Now that we have the basics in place, we can start developing our Amazon Alexa intents. Using the ASK SDK, our requests will be dispatched between multiple intents, each executing their own logic, all while using the same AWS Lambda function. Let’s look at a basic intent: const AboutHandler = {\n    canHandle(input) {\n        return input.requestEnvelope.request.type === \"IntentRequest\" && input.requestEnvelope.request.intent.name === \"AboutIntent\";\n    },\n    handle(input) {\n        return input.responseBuilder\n            .speak(\"Geocoder was created by Nic Raboy in Tracy, California\")\n            .withSimpleCard(\"About Geocoder\", \"Geocoder was created by Nic Raboy in Tracy, California\")\n            .getResponse();\n    }\n} The above AboutHandler object contains two functions. The first function checks to make sure that the request was for the AboutIntent and that it is in fact an IntentRequest . The second function executes logic assuming the canHandle function succeeded. We can build a response that contains things like what Alexa should speak or what should appear in the cards found in the mobile application. To have a well crafted Skill, we should also have an error handler: const ErrorHandler = {\n    canHandle(input) {\n        return true;\n    },\n    handle(input) {\n        return input.responseBuilder\n            .speak(\"Sorry, I couldn't understand what you asked. Please try again.\")\n            .reprompt(\"Sorry, I couldn't understand what you asked. Please try again.\")\n            .getResponse();\n    }\n} The above object has the same configuration as the previous AboutIntent , but this time the canHandle function always returns true. If any intents return an error, we’ll be configuring the ErrorHandler to take over. So let’s wire together what we have already. Remember, this is an AWS Lambda function so there will be a single point of entry. The single point of entry will be the handler function that we exported at the very beginning. We want it to look like the following: exports.handler = async (event, context) => {\n    if(!skill) {\n        skill = Alexa.SkillBuilders.custom()\n            .addRequestHandlers(\n                AboutHandler\n            )\n            .addErrorHandlers(ErrorHandler)\n            .create();\n    }\n    var response = await skill.invoke(event, context);\n    return response;\n}; Because the Lambda instance can already be active, we check to see if the skill variable is defined. If it is, the function is still active and we don’t need to recreate it. Otherwise, we add our handlers, define the error handler, and invoke what we have. For every intent we wish to create, it will be added to the .addRequestHandlers method. Now that we have a basic Alexa Skill, we need to add location services with HERE. For this example, we’re going to give Alexa an address and get a latitude and longitude coordinate back. Before we build the handler object, we need to construct our request to the HERE REST API. Take the following getPosition function: const getPosition = async (query) => {\n    try {\n        var result = await Request({\n            uri: \"https://geocoder.cit.api.here.com/6.2/geocode.json\",\n            qs: {\n                \"app_id\": appId,\n                \"app_code\": appCode,\n                \"searchtext\": query\n            },\n            json: true\n        });\n        if(result.Response.View.length > 0 && result.Response.View[0].Result.length > 0) {\n            return result.Response.View[0].Result[0].Location.DisplayPosition;\n        } else {\n            throw \"No results were returned\";\n        }\n    } catch (error) {\n        throw error;\n    }\n} In the above function we make a request to the API, providing the application id, the application code, and a query such as an address or similar. As a result, we’re going to return the DisplayPosition which contains the latitude and longitude position. From an intent perspective, we can build the following: const GeocodeHandler = {\n    canHandle(input) {\n        return input.requestEnvelope.request.type === \"IntentRequest\" && input.requestEnvelope.request.intent.name === \"GeocodeIntent\";\n    },\n    async handle(input) {\n        try {\n            var position = await getPosition(input.requestEnvelope.request.intent.slots.address.value);\n            return input.responseBuilder\n                .speak(position.Latitude + \", \" + position.Longitude)\n                .withSimpleCard(\"Address Position\", position.Latitude + \", \" + position.Longitude)\n                .getResponse();\n        } catch (error) {\n            throw error;\n        }\n    }\n} If the GeocodeIntent is requested, we can make a request to the getPosition function. The query is provided as slot values from the Alexa request. These slot values will be defined in the deployment phase. Building the response follows the same procedure as the previous intent. Packaging, Testing, and Deploying the Lambda Function as an Amazon Alexa Skill As of right now, we have a functional AWS Lambda function that uses the Alexa Skills Kit. As you’ve probably noticed, it is more or less just a few functions wrapped in a framework. The Skill could be more or less complex. We don’t have an Alexa Skill until we complete the process. The first part of the process is to package the function so it can be deployed. Execute the following command: zip -r handler.zip ./node_modules/* ./main.js If you don’t have the zip command in your Terminal, just ZIP the node_modules directory along with the main.js file. Had we been using native dependencies for Node.js, we would have had to take further steps. If you come to a scenario where native dependencies are required, take a look at the tutorial I wrote titled, Deploying Native Node.js Dependencies on AWS Lambda . Native dependencies are those that use C libraries that must be compiled on a per architecture and operating system basis. When deploying to AWS Lambda, make sure to choose Node.js as the function type and give it the Alexa Skills Kit as the trigger. You can then upload the ZIP archive to that particular trigger. Take note of the ARN value for the function as it will be used when defining the Skill. Head over to the Alexa Developer Portal and create a new Skill. During the process, you’ll be prompted with a checklist of things that must be completed, starting with the invocation name. Make sure the invocation name is something Alexa will be able to understand. This means don’t start making up words. After defining the invocation name, you need to define your intents and the sample utterances that power them. We should have two intents, the AboutIntent and the GeocodeIntent . For sample utterances, the AboutIntent should have something like the following: give me information\nwho made this skill\nwho made this application The above are three sample utterances. In reality, you’re going to want to create every possible phrase for your intent. The more you have, the better the user experience. So for the GeocodeIntent you might have the following: give me the position for {address}\nfind the position for {address}\nwhat are the coordinates for {address} Again, the more utterances you have, the better your Skill. However, notice the address variable in brackets. This is a slot that is used as query data for our getPosition function. Finish through the checklist and proceed to testing your Skill. Assuming your Skill runs appropriately in the simulator, it can be published. Conclusion You just saw how to build an Amazon Alexa Skill using Node.js that included the HERE Geocoder API for converting verbally spoken addresses to their latitude and longitude coordinates. Most of this tutorial was around the actual setup and deployment to AWS Lambda which is good, because using HERE Location Services should not be complicated or time consuming. If you’re interested in accomplishing the same with Golang, check out my previous tutorial titled, Geocode Addresses with Amazon Alexa, Golang, and the HERE Geocoder API .", "date": "2018-11-22"},
{"website": "Here", "title": "Available now on AWS Marketplace: HERE location APIs and services", "author": ["Ashutosh Badwe"], "link": "https://developer.here.com/blog/available-now-on-aws-marketplace-here-location-apis-and-services", "abstract": "Amazon Web Services Marketplace now offers best in class location APIs and services thanks to the HERE Location Suite . As a developer, you can log in and start using our platform directly within the AWS environment using your existing AWS account. We have heard time and again from AWS developers that they would like to get convenient self-service access to our location services in the development environment of their choice with minimal friction between trying, buying and using our services. Today we make this possible directly from AWS Marketplace . The HERE Location Suite includes our most advanced location services including our REST APIs like Map, Geocoding, Routing, Traffic, Positioning, Weather and Fleet Management and our popular JavaScript Maps API. For a full list of APIs, scroll down to the end of the post. We have a generous two tier offering specifically designed to enable implementation of complete location enablement use cases across all our APIs: The FREE Standard tier gives you 250K monthly transactions that can be used across any of our APIs in any environment. Whenever you feel the need, you can upgrade to the paid Professional tier with a few clicks and get 1M transactions every month across all offered APIs. What do you need to do? Once you are signed up for an AWS account or logged in to your existing account, from your AWS Console find the link to the AWS Marketplace or go to the AWS Marketplace and login with your AWS account. Simply start by searching for the HERE Location Suite . Click on the HERE Location Suite and it will bring you to the subscription overview and pricing page. You can also reach this page directly using this link: https://aws.amazon.com/marketplace/pp/B07JPLG9SR Click Continue to Subscribe and select the Standard or Professional tier on this page. Once you select your options and proceed, you will be redirected to setup your developer account with HERE or use your existing HERE developer portal account if you already have one. This account will let you login to our AWS Subscription management portal to retrieve your API Credentials at any time, view transaction consumption reports and more. This email address will also receive notifications in case you are approaching your subscription transaction limits so that you can take appropriate action. You can login to the HERE AWS Subscription management portal at any time to retrieve your APPID and APPCODE securely. These are two random strings that serve as API access credentials. At this point you are ready to invoke our APIs from your applications using the APPID and APPCODE. You can always get more details about the APIs from the Documentation tab and excellent technical support from HERE’s location experts and fellow developers like you is available on Stackoverflow . Oh and one more thing, notice the Resources tab at the top? This is where we have a few interesting tutorials to get you started. Whether you are an Alexa developer looking to add location to your Alexa skills, or wanting to make location aware Lex chatbots for internal or external customer service or an IoT developer looking add location awareness to non-GPS devices or wanting to build and deploy location aware Machine Learning models -- there is something in these tutorials for you. We will be constantly adding new tutorials and blogs, so keep watching this space! Happy coding and we look forward to hearing what you built with AWS and the HERE Location suite on marketplace! APIs available as part of Standard and Professional: JavaScript API for maps: HERE’s JavaScript APIs offers easy-to-use libraries of classes and methods with great processing speed and faster loading times for both desktop and mobile. REST APIs: Map Tile: Shows fresh day-time map tiles in multiple styles with rendered live-traffic tiles. Map Image: Access pre-rendered map images optimized for desktop and mobile devices. Venue Maps: Get venue maps through image tiles or/in JSON format. Routing: Get precise instructions to a destination using various transport modes, leveraging different algorithms. Geocoder: Convert street addresses to coordinates and vice-versa with batch, auto-correction processing. Places: Allow your users to search, discover and interact with Points of Interest. Traffic: Access real-time traffic flow incident data in XML and JSON. Weather: Show real-time weather astronomical forecasts. Transit: Access transmit routing features like search, next departure and access points. Intermodal Routing: Get alternative routes with drive, park, ride an walk to final destination. Positioning: Provide positioning estimates based on global Wi-Fi and cell coverage. Fleet Telematics: Access advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs, Custom Locations & Routes", "date": "2018-11-27"},
{"website": "Here", "title": "HERE Matrix Routing with ReactJS to Optimize Your Black Friday", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/here-matrix-routing-with-reactjs-to-optimize-your-black-friday", "abstract": "The annual tradition known as Black Friday leads many to go shopping at retail stores. Getting a route from your current location to another is a straight-forward navigation tool we’ve used many times. If we have multiple stops, how do we plan the most optimal route between them? That’s a job for Matrix Routing. Project Morpheus: Unfortunately, no one can be told what the Matrix is. You have to see it for yourself. For this project, we’ll demonstrate using the Places and Routing APIs with ReactJS to plan a series of stops. If you need to go to multiple stores such as Walmart, H-E-B, Gamestop and Kohl’s it may not matter which location or order you need to make the stops. To make the best use of your time as seen in the following screen capture, we can search for these stores and see the closest option highlighted in green when taking driving times and traffic into account. As we select a waypoint, the next closest store is highlighted from the remaining groups. Selecting multiple waypoints leads to an optimized shopping plan. As you build applications, taking into account where somebody is and where they are going can provide a much richer user experience by considering the context of location. Getting Started As with other ReactJS tutorials , we’ll start with create-react-app as a project structure. We’ll use a few other libraries as well, axios for making HTTP requests, react-bootstrap for ready-made react components of the Bootstrap library, and styled-components because what I’ve always felt like I was missing in my life was the ability to set CSS properties more easily in JavaScript (🖤 web development). Here are the commands to create the app, install the dependencies, and then start the development web server: create-react-bootstrap app\ncd app\nnpm install --save styled-components axios react-bootstrap\nnpm start https://github.com/facebook/create-react-app https://react-bootstrap.github.io/ https://www.styled-components.com/ Components We will develop a few React components that encapsulate the view and behavior of our user interface. StartLocation.js is a component that will display a form for describing the starting location. We can change the latitude and longitude in the form or click on the globe icon to use our current location. PlaceSearch.js is a component that displays a form to search for places near our starting location. The results are displayed in a list by distance so that the user can select one. PlacePlanner.js is a component that is used for planning a route across multiple place searches. It uses the Matrix Routing algorithm to find the next nearest waypoint. App.js is a component to wrap up everything into an application that includes the StartLocation and PlacePlanner . App Starting from the top most component, we define our App which is composed from the StartLocation and PlacePlanner components. We maintain the geocordinates of our origin as state in the App so that when it is changed by the StartLocation component we can keep things consistent in the PlacePlanner by passing them down as properties. You can see the view being defined by the render method: render() {\n    return (\n      <div className=\"App\">\n        <StartLocation\n            lat={this.state.start.lat}\n            lng={this.state.start.lng}\n            key=\"MyLocator\"\n            onChange={this.onLocationChanged}\n            onLocate={this.onLocate}\n            />\n\n        <Wrapper>\n          <p>Search for nearby places.</p>\n          <PlacePlanner\n            app_id={this.state.here.app_id}\n            app_code={this.state.here.app_code}\n            lat={this.state.start.lat}\n            lng={this.state.start.lng}\n          />\n        </Wrapper>\n      </div>\n    );\n  } The onLocationChanged() method passed to the StartLocation component is used for any changes made to the text forms. onLocationChanged(e) {\n    e.preventDefault();\n\n    let state = this.state;\n    state['start'][e.target.id] = e.target.value;\n    this.setState(state);\n  } The onLocate() method is there for handling HTML5 geolocation API to use the current location detected by the browser. onLocate(e) {\n      e.preventDefault();\n\n      const self = this;\n      navigator.geolocation.getCurrentPosition(function(position) {\n        self.setState({\n          start : {\n            lat: position.coords.latitude,\n            lng: position.coords.longitude,\n            }\n        });\n      });\n  } StartLocation The StartLocation is not much more than a simple Bootstrap form for collecting user input since the behaviors are passed in as properties. render() {\n  return (\n    <Wrapper>\n\n      <Grid>\n\n        <Row>\n\n        <Col xs={4} md={4}>\n          <ControlLabel>Latitude</ControlLabel>\n          <FormControl\n            type=\"text\"\n            bsSize=\"sm\"\n            id=\"lat\"\n            key=\"lat\"\n            value={this.props.lat}\n            onChange={ this.onChange }\n          />\n        </Col>\n\n        <Col xs={4} md={4}>\n          <ControlLabel>Longitude</ControlLabel>\n          <FormControl\n            type=\"text\"\n            bsSize=\"sm\"\n            id=\"lng\"\n            key=\"lng\"\n            value={this.props.lng}\n            onChange={ this.onChange }\n          />\n        </Col>\n\n        <Col xs={4} md={4}>\n          <br/>\n          <Button onClick={this.onLocate}>\n            <Glyphicon glyph=\"globe\"/>\n          </Button>\n        </Col>\n\n        </Row>\n\n        <Row>\n        <FormControl.Feedback />\n        </Row>\n\n        </Grid>\n    </Wrapper>\n  );\n} In order to render the Glyphicon you will need to update the public/index.html to pull in the bootstrap css from a CDN. The addition of the <Wrapper> was just a simple styled-component for additional presentation customization. const Wrapper = styled.section`\n  padding: 1em;\n  background: papayawhip;\n`; PlaceSearch We’re going to skip over the PlacePlanner component for a moment to take a closer look at the PlaceSearch component first. In this component we start making use of the HERE Location services to search for places. Digging into the render() method, we need a form that allows us to enter a search query. The onChange() and onKeyPress() are typical behavior of form entry so that state is maintained and the user can either click the search button or press return to trigger a places search. <FormGroup><InputGroup>\n        <FormControl\n          type=\"text\"\n          bsSize=\"sm\"\n          id={\"destination\" + this.props.idx}\n          key={\"destination\" + this.props.idx}\n          placeholder=\"Store Name\"\n          onChange={ this.onChange }\n          onKeyPress={ e => { if (e.key === 'Enter') { this.onSearch(e); }}}\n        />\n        <InputGroup.Addon>\n          <Glyphicon glyph=\"search\" onClick={ this.onSearch } />\n        </InputGroup.Addon>\n    </InputGroup></FormGroup> Additionally in the render() method we are displaying the search results but we’ll come back to that. The Places API can be used for finding specific places with a text string. Unlike with the HERE Geocoder, this is not matching by address but by the name of a place and returning a set of results. You can use the HERE Maps API for JS which includes functions for displaying places. You’d use the same trick of window.H as described in the tutorial on how to Use HERE Interactive Maps with ReactJS to make it work. Since this project isn’t displaying a map and is just a simple GET request, I am using axios . onSearch(e) {\n        const self = this;\n        axios.get(\n          'https://places.api.here.com/places/v1/discover/search',\n          {'params': {\n            'app_id': self.props.app_id,\n            'app_code': self.props.app_code,\n            'q': self.state.q,\n            'size': 10,\n            'at': self.props.lat + ',' + self.props.lng\n          }}).then(function (response) {\n            self.setState({results: response.data.results.items});\n            self.addPlaces(self.props.idx, response.data.results.items, self.props.lat, self.props.lng);\n          });\n    } A few notes about the parameters. You need the app_id and app_code typically used with any HERE developer account. The text query is given by the q parameter. I’ve limited the size to the 10 closest matches based on distance and given the at as the location from which to do a proximity search. Once the results are fetched from the request, we call setState which triggers the component to re-render as part of the typical React lifecycle. The rest of the render() method will use these results to display the search result listings. We have a helper method called decodeVicinity() to help process our Places response . The attribute typically has a HTML <br/> element which we don’t want so can strip it out. const decodeVicinity = function(raw) {\n  var e = document.createElement('div');\n  e.innerHTML = raw;\n  return e.childNodes[0].nodeValue;\n} In our render() implementation we also loop over the results to make a list of items. Each item represents a place from our search in a list. In addition to simply listing all the matches there are two cases to handle. First, if the user has made a selection the className can be set to active which will cause it to be highlighted by Boostrap. Second, if the item is the next closest destination we will color it green by using the bsStyle attribute and setting it to success . // Build up listing of locations that match query\nlet destinations = [];\nif (self.state.results.length > 0) {\n  self.state.results.forEach(function(item) {\n    let option = (\n      <ListGroupItem\n          id={item.id}\n          key={item.id}\n          onClick={self.onSelect}\n          header={item.title}\n          className={self.state.selected === item.id ? \"active\" : \"\"}\n          bsStyle={self.props.nearest === item.id ? \"success\" : \"info\" }\n          >\n      <Fragment>{decodeVicinity(item.vicinity)}</Fragment>\n      </ListGroupItem>\n    );\n    destinations.push(option);\n    // ({item.position[0]}, {item.position[1]})\n  });\n} These items are then simply included in a <ListGroup> . <ListGroup>\n  { destinations }\n</ListGroup> When a user selects one of the destinations, in addition to highlighting it making it active there is some behavior. By making a selection of a waypoint, this should trigger a new search for the next closest destination among remaining groups. onSelect(e) {\n        this.setState({'selected': e.currentTarget.id});\n        this.props.findNearest(this.props.idx);\n    } The findNearest() method is defined in the PlacePlanner component and passed down as a property so we’ll look at that component next. PlacePlanner The PlacePlanner component handles the optimization of our path by using the Matrix Routing algorithm across multiple places. The render() method makes use of our reusable <PlaceSearch/> component. A few properties are passed down for its behaviors as well as the methods defined in this component for identifying the next nearest destination and maintaining state of which places have been selected. The full definition of this method can be found in the full source code listing from the github repository. <PlaceSearch\n        idx={0}\n        app_id={ this.state.app_id }\n        app_code={ this.state.app_code }\n        lat={ this.props.lat}\n        lng={ this.props.lng}\n        nearest={ this.state.nearest.id }\n        addPlaces={ this.addPlaces }\n        findNearest={ this.findNearest }\n        /> The addPlaces() method is called from the PlaceSearch component to maintain a list of all potential destinations. That is, from our starting location by searching for “Walmart” we found 10 possible locations of Walmart we could go to. As we search for “H-E-B” we identify 10 more possible locations for a total of 20 different options to choose from. The selected state is being maintained because once we’ve identified a single Walmart to go to, we limit our list of remaining options to the 10 H-E-B locations. That’s what the following snippet demonstrates. addPlaces(idx, results, lat, lng) {\n\n        // Update places with new search results\n        let places = this.state.places;\n        places[idx] = results;\n\n        // Combine all results across searched places where a selection has\n        // not yet been made as our options for the next destination\n        let options = [];\n        for (var p in places) {\n            if (typeof this.state.selected[p] === 'undefined') {\n                for (var o in places[p]) {\n                    options.push({\n                        lat: places[p][o].position[0],\n                        lng: places[p][o].position[1],\n                        id: places[p][o].id,\n                    });\n                }\n            }\n        }\n\n        // If there are no more options then we are done searching\n        if (options.length === 0) {\n            return;\n        }\n\n        // To be continued\n        ...\n    } Given a list of 40 potential options, how do I get started? The HERE Routing API supports Requesting a Matrix of Routes . This means that given N starting locations and M destination locations we can query the cost factor of going to each as a matrix. The cost factor is a representation in our case of the time it would take by driving in traffic to get to a given location. From the destination with the lowest cost factor, we can make a recommendation for the optimized path across multiple places. Once at that next destination, we can further compute from the remaining options the next best location to route to. In our case, we are looking at a 1:M query as demonstrated in the next snippet: addPlaces(idx, results, lat, lng) {\n\n        ...\n        // continuing from above\n\n\n        // Will build parameters including all of the potential destinations\n        let params = {\n            'app_id': this.state.app_id,\n            'app_code': this.state.app_code,\n            'mode': 'fastest;car;traffic:enabled',\n            'matrixAttributes': 'ix,su',\n            'summaryattributes': 'all',\n            'start0': lat + ',' + lng,\n        }\n        for (var i = 0; i < options.length; i++) {\n            params['destination' + i] = options[i].lat + ',' + options[i].lng;\n        }\n\n        // Calculate matrix routing among options to make a recommendation\n        const self = this;\n        axios.get(\n            'https://matrix.route.api.here.com/routing/7.2/calculatematrix.json',\n            {'params': params}).then(function(response) {\n                const matrix = response.data.response.matrixEntry;\n\n                let nearest = matrix[0].summary;\n                nearest['id'] = options[0].id;\n\n                for (var i = 0; i < matrix.length; i++) {\n                    if (matrix[i].summary.costFactor < nearest.costFactor) {\n                        nearest = matrix[i].summary;\n                        nearest.id = options[i].id;\n                    }\n                }\n                self.setState({\n                    nearest: nearest\n                })\n            });\n      this.setState({places: places});\n    } We are using the location id from our options so that the property can be used in our PlaceSearch component for highlighting. Summary Neo: I’m going to show them a world without you. A world without rules and controls, without borders or boundaries. A world where anything is possible. Where we go from there is a choice I leave to you. This is not a ready-made production application but hopefully gives you a flavor of how and why to start using some of the HERE Location Services like Places and Routing in your applications. An obvious next step would be to display a map like described in Use HERE Interactive Maps with ReactJS to place markers and the route. You can find source code listings for the components mentioned in this post on GitHub . For further reading, see How HERE is helping your taxi arrive faster for real-world examples of how Matrix Routing can be used to help with mobility use cases.  You can also check out A Location Based TODO App for more examples of using ReactJS with HERE services that inspired this post.", "date": "2018-11-25"},
{"website": "Here", "title": "Tracking Device Location with Golang, WLAN Access Points, and the HERE Positioning API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/tracking-device-location-with-golang-wlan-access-points-and-the-here-positioning-api", "abstract": "When most people, including myself, think of positioning, the first thing that comes to mind is GPS. However, did you know that you can calculate position by using cellular data or by triangulating WLAN access points? Over the past few weeks I’ve written about tracking position in a web browser as well as tracking position with complex shell scripts . What if we wanted to track position with a popular programming technology using WLAN access points? We’re going to see how to use Golang to leverage operating system applications to find nearby WLAN access points and convert the data to latitude and longitude positions using the HERE Positioning API . Understanding the HERE Positioning API Before we start developing an application with the Go programming language, we need to take a step back to figure out how the HERE Positioning API works. Given cellular information, or WLAN information, or both, we can calculate a location. Cellular information isn’t typically available to us unless we’re on a mobile phone or have a SIM enabled device, so we’re going to rely strictly on WLAN information. When I say WLAN, I’m referring to router information, not the chipsets that might exist within your scanning device. Per the HERE documentation , we can execute a command like the following: curl -X POST \\\n    'https://pos.api.here.com/positioning/v1/locate?app_id=APP-ID-HERE&app_code=APP-CODE-HERE' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\n        \"wlan\": [\n            {\"mac\": \"88-e9-fe-79-be-20\"},\n            {\"mac\": \"8C-1A-BF-20-66-AD\"},\n            {\"mac\": \"A0-E4-53-E9-66-A7\"},\n            {\"mac\": \"AC-4B-C8-34-F7-01\"},\n            {\"mac\": \"A0-21-95-57-79-06\"},\n            {\"mac\": \"00-18-56-51-54-FB\"},\n            {\"mac\": \"10-30-47-D2-54-55\"},\n            {\"mac\": \"B8-6B-23-09-87-B1\"},\n            {\"mac\": \"F4-55-95-11-2C-C1\"}\n        ]\n    }\n' Using X number of hardware addresses to nearby access points, we can make a request to the HERE API. Don’t forget to swap the app_id and app_code values with those found in your HERE Developer Dashboard. Optionally, if we had a power level to each access point, we could include that in the request. The power level can act as a good indicator for distance from each access point, giving us a more reliable estimate in position. The response to the above command might look something like this: {\n    \"location\": {\n        \"lat\": 52.5185858,\n        \"lng\": 13.37622638,\n        \"accuracy\": 175\n    }\n} Now that we know the requirements for this example, we can work towards gathering the data we need to be successful with tracking our location. Scanning for WLAN Access Points with Mac and Linux To scan for nearby WLAN access points in Golang, we have pretty much just one option. While we could put a lot of energy into making our own Go package for the job, the recommended solution online is to leverage operating system software through Go. So how do we use the available operating system software? Before we focus on Go, let’s take a look at what is available to us. On Mac, you might be familiar with the following command: /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s The above command will scan for all access points within proximity using the airport module on Mac. It is what I had demonstrated in my previous example using the command line. Similarly, if you’re using Linux, you can execute the following: iwlist wlan0 scan For both commands, the results will be very different in format, even though they contain the same data. The bulk of our work in Go will be to parse the data and make sense of it. While I’m sure Windows has a similar command, I only have access to Mac and Linux, with pretty much no familiarity of Windows. If you’re aware of the proper command, we can include it in the Golang application to come. Developing a Location Tracker with the Go Programming Language Now that we have a general idea behind scanning for networks and using the HERE Positioning API, we can put our knowledge to good use within a Go application. Assuming you have Go installed and configured, create a main.go file somewhere within your $GOPATH . Open the main.go file and start by including the following boilerplate code: package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"os/exec\"\n    \"regexp\"\n    \"runtime\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype HerePlatform struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\nfunc main() {\n    fmt.Println(\"Starting the application...\")\n    platform := HerePlatform{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n} As you can see, we’ve just created a native structure for holding our app_id and app_code values found in the HERE Developer Dashboard. Because we anticipate making HTTP requests and working with different data requirements, it makes sense to create a few other native data structures. Based on our short exploration of the HERE Positioning API, we know that it is going to expect hardware addresses as well as power levels. With that in mind, we can create the following: type WlanInfo struct {\n    BSSID string `json:\"mac\"`\n    Power int    `json:\"powrx,omitempty\"`\n} However, when we get ready to send the data, the format expectation is slightly different. We need to create an array of access points and that can be done with the following: type AccessPoints struct {\n    Wlan []WlanInfo `json:\"wlan\"`\n} The important part of all the native data structures so far and those to come are the JSON annotations. The JSON annotations will map our request payloads to the expectation as well as map the response payloads to something we can work with. In our previous exploration, we also saw the response format of the HERE Positioning API. With that information in mind, we can create the following: type PositionResponse struct {\n    Location struct {\n        Latitude  float64 `json:\"lat\"`\n        Longitude float64 `json:\"lng\"`\n        Accuracy  int     `json:\"accuracy\"`\n    } `json:\"location\"`\n} To give this example some extra flair, we’re going to kick it up a notch. Once we have a latitude and longitude position, we’re going to use the HERE Reverse Geocoder API to convert it into an address. We’re going to leverage a previous tutorial I wrote titled, Reverse Geocoding Coordinates to Addresses with the Go Programming Language , but before we do, we need to create something to hold the response. type GeocoderResponse struct {\n    Response struct {\n        MetaInfo struct {\n            TimeStamp string `json:\"TimeStamp\"`\n        } `json:\"MetaInfo\"`\n        View []struct {\n            Result []struct {\n                MatchLevel string `json:\"MatchLevel\"`\n                Location   struct {\n                    Address struct {\n                        Label       string `json:\"Label\"`\n                        Country     string `json:\"Country\"`\n                        State       string `json:\"State\"`\n                        County      string `json:\"County\"`\n                        City        string `json:\"City\"`\n                        District    string `json:\"District\"`\n                        Street      string `json:\"Street\"`\n                        HouseNumber string `json:\"HouseNumber\"`\n                        PostalCode  string `json:\"PostalCode\"`\n                    } `json:\"Address\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n} If you’re familiar with the HERE Geocoder and HERE Reverse Geocoder APIs, you’ll recognize that the response data structure above is nowhere near complete. However, it does contain the data that we care about, which is address data. With the data structures designed, we can work on phase one of the application, scanning for WLAN access points. Within the main function, add the following: var accessPoints AccessPoints\nif runtime.GOOS == \"darwin\" {\n    airportCmd := exec.Command(\"/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport\", \"-s\")\n    airportCmdOutput, err := airportCmd.Output()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    lines := strings.Split(string(airportCmdOutput), \"\\n\")\n    var wlans []WlanInfo\n    for _, line := range lines {\n        columns := strings.Fields(line)\n        if len(columns) > 0 {\n            match, _ := regexp.MatchString(\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", columns[1])\n            if match == true {\n                power, _ := strconv.Atoi(columns[2])\n                wlan := WlanInfo{\n                    BSSID: columns[1],\n                    Power: power,\n                }\n                wlans = append(wlans, wlan)\n            }\n        }\n    }\n    accessPoints = AccessPoints{Wlan: wlans}\n} else if runtime.GOOS == \"linux\" {\n    iwlistCmd := exec.Command(\"iwlist\", \"wlan0\", \"scan\")\n    iwlistCmdOutput, err := iwlistCmd.Output()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    lines := strings.Split(string(iwlistCmdOutput), \"\\n\")\n    var wlans []WlanInfo\n    for _, line := range lines {\n        columns := strings.Fields(line)\n        if len(columns) == 5 {\n            match, _ := regexp.MatchString(\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", columns[4])\n            if match == true {\n                wlan := WlanInfo{\n                    BSSID: columns[4],\n                }\n                wlans = append(wlans, wlan)\n            }\n        }\n    }\n    accessPoints = AccessPoints{Wlan: wlans}\n} else {\n    fmt.Println(\"An unsupported operating system was detected.\")\n    return\n} The above code could definitely be optimized, but let’s figure out what it is doing. The first step is to check to see what operating system we’re using. We only plan to support Mac and Linux for this tutorial, but if you’re a Windows guru, you could add support for Windows as well. Depending on the runtime operating system, we execute the appropriate scan command. In both circumstances, the response to the scan commands will return multiple lines. We need to split these lines and parse each line one at a time. For each line that we’re working with, we need to split it by whitespace characters. Because we’re going to have a lot of cruft data and not every line will be the same, we need to check to see if a certain column of the line is a hardware address: match, _ := regexp.MatchString(\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", columns[1]) The column will vary depending on the operating system. To give credit where credit is deserved, the regular expression was taken from Stack Overflow . Assuming the regular expression was a match for a hardware address, we can add it as a valid WLAN. Your parsing logic for Mac and Linux could probably be much better than mine. At this point in time, we should have an accessPoints variable full of WLAN access point information. We need to create functions that will make requests against the HERE APIs. Create a position function like the following: func (platform *HerePlatform) position(payload []byte) (PositionResponse, error) {\n    endpoint, _ := url.Parse(\"https://pos.api.here.com/positioning/v1/locate\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", platform.AppId)\n    queryParams.Set(\"app_code\", platform.AppCode)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Post(endpoint.String(), \"application/json\", bytes.NewBuffer(payload))\n    if err != nil {\n        return PositionResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var positionResponse PositionResponse\n        json.Unmarshal(data, &positionResponse)\n        return positionResponse, nil\n    }\n} The API endpoint expects a POST request, but the function mostly just formats the request. The payload comes from the previously created accessPoints object and the query parameters are formed from the platform information we supplied earlier. If successful, we’ll return a PositionResponse which has our latitude and longitude coordinates. It also makes sense to create a reverseGeocode function: func (platform *HerePlatform) reverseGeocode(position PositionResponse) (GeocoderResponse, error) {\n    endpoint, _ := url.Parse(\"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", platform.AppId)\n    queryParams.Set(\"app_code\", platform.AppCode)\n    queryParams.Set(\"mode\", \"retrieveAddresses\")\n    queryParams.Set(\"prox\", strconv.FormatFloat(position.Location.Latitude, 'f', -1, 64)+\",\"+strconv.FormatFloat(position.Location.Longitude, 'f', -1, 64))\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeocoderResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geocoderResponse GeocoderResponse\n        json.Unmarshal(data, &geocoderResponse)\n        return geocoderResponse, nil\n    }\n} The reverseGeocode function will take PositionResponse information to make a request. The response will be of GeocoderResponse format. With our functions in place, we can make use of them. Towards the end of the main function, we can put the position and reverseGeocode functions to good use: payload, _ := json.Marshal(accessPoints)\npositionResponse, _ := platform.position(payload)\nfmt.Println(positionResponse)\ngeocoderResponse, _ := platform.reverseGeocode(positionResponse)\nfmt.Println(geocoderResponse.Response.View[0].Result[0].Location.Address.Label) Running the application on either Mac or Linux should result in a position being discovered and that position being converted into a nearest possible address. The more WLAN access points discovered, the more likely and more accurate a position of your device. Conclusion You just saw how to build a Go application that scans for WLAN access points on Mac or Linux and determines the the position of the scanning device using the HERE Positioning API . Using the location, we used the HERE Reverse Geocoder API to convert it into an address. There are other ways to scan for access points on these operating systems and probably better ways to parse the data as well, however, what I’ve done should give you some ideas. If you’re having trouble cross-compiling your application, check out this previous tutorial I wrote on the subject.", "date": "2018-11-29"},
{"website": "Here", "title": "Building an App for Routing to Nearby Water Fountains with HERE XYZ", "author": ["Boris Guenebaut"], "link": "https://developer.here.com/blog/building-an-app-routing-to-water-fountains-here-xyz", "abstract": "As a software engineer in the Highly Automated Driving division, I spend most days working on an Android app that helps our HERE True Car drivers monitor the health of our data collection hardware. Helping drivers navigate on specific routes to collect fresh data is a big part of what that application does. Recently, a new product called HERE XYZ went into Beta as a simple solution to store geospatial data. I sat down with Jayson DeLa ncey to review and discuss a project I built to try out the new tools. What is Thirst Free? As a regular runner too annoyed to carry a flask with me on the move, I occasionally get thirsty and have to use my fuzzy brain to remember the closest drinking water fountain. I figured it would be nice to have a simple web application to show nearby drinking water to reduce time wandering about. I think it could be useful for dog owners and hikers as well. Here’s an example of some of the water fountains in a nearby state park that can get pretty hot in the summer: How did you find water fountain data in the first place? There are many data sources such as the Seattle Parks & Recreation and California Open Data Portal that can be useful for projects. In this case, I used a tool called overpass turbo (MIT License) to filter Open Street Map data where “amenity=drinking_water” for North America and exported it as GeoJSON. Since HERE XYZ organizes data into Spaces , it keeps licensing around data cleanly separated depending on need and terms of use. I used the Swagger API Tools to explore the API for reading and editing a space. Without XYZ Hub, I would have needed to store the GeoJSON data in a file which for large data sets is memory intensive to read and impacts the end user experience of the app. For example, this HTTP request will return some details on my space such as the ID I will need later: curl -X GET \"https://xyz.api.here.com/hub/spaces\" -H \"accept: */*\" -H \"Authorization: Bearer AXoqaCXh6cAqoz0nDxEzUCo\"\n[\n  {\n    \"id\": \"jaz191md\",\n    \"title\": \"water_fountains_usa.geojson\",\n    \"description\": \"Extracted from http://overpass-turbo.eu\",\n    \"shared\": true,\n    \"owner\": \"xjmyiygJapVIgnffuM6w\"\n  },\n  ...\n] Should we think of HERE XYZ as just GeoJSON file storage? That’s just how data is uploaded. Additionally, the XYZ JavaScript library and particularly the here.xyz.maps.layers.TileLayer was great to encapsulate the filtering at the server level so that the client would only need to display the retrieved items. This makes a large dataset such as every water fountain in North America perform better since it is really just a bbox as a spatial filter of the contents of a Space. For example, the following code shows an object being returned which fetches data from an XYZ space such as the water fountain dataset. You just need to identify the space provider with space id and access token. The data can then be styled with any custom icons or other CSS properties. return new here.xyz.maps.layers.TileLayer({\n   name: 'WaterFountains',\n   min: 8,\n   max: 20,\n   provider: new here.xyz.maps.providers.SpaceProvider({\n     name: 'WaterFountainsProvider',\n     level: 6,\n     space: 'Tyd31ZuT',\n     credentials: {\n       access_token: WATER_FOUNTAINS_TOKEN\n     }\n   }),\n   style: {\n     styleGroups: {\n       pointStyle: [{\n         zIndex: 3,\n         type: \"Circle\",\n         radius: 8,\n         fill: \"cyan\"\n       },{\n         zIndex: 4,\n         type: \"Image\",\n         src: \"img/drop.png\",\n         width: 16,\n         height: 16\n       }]\n     },\n     assign: function(feature, zoomlevel) {\n       return \"pointStyle\";\n     }\n   }\n }) This is just a layer that can be overlayed on top of map tiles. For example, we can use the same TileLayer with an image provider such as the terrain style from the HERE Map Tile API like this: var layers = [\n  new here.xyz.maps.layers.TileLayer({\n    name: 'Image Layer',\n    min: 1,\n    max: 20,\n    provider: new here.xyz.maps.providers.ImageProvider({\n      name: 'Live Map',\n      url: 'https://1.aerial.maps.api.here.com/maptile/2.1/maptile/newest/terrain.day/{z}/{x}/{y}/512/png8?ppi=500&app_id=' + APP_ID + '&app_code=' + APP_CODE\n    })\n  })\n]; How did you integrate in routing? I built the app in iterative phases, ensuring the current iteration worked at each step before adding more: I took care of preparing and uploading the dataset. I forked one of the XYZ JavaScript examples to have something functional right away. I made a few changes like putting my credentials, updating the map display. I configured the JavaScript code to access the dataset from my space to be able to load the drinking water fountains when zooming/panning. After making sure all the above was working, I added positioning. The use of HTML5 Geolocation APIs are pretty well documented so that should be easy for anyone to get started. Something developers don’t do enough though, including myself, is the handling of error cases, e.g. if the user denies sharing the location or if the location fetching fails for any reason. Finally, I added the routing part from the current position to a clicked drinking water fountain. The documentation gives a description of how to Interact with your data by using addEventListener . That is just combined with examples online with the HERE Routing API . The method to updateRoute() looks like the following: function updateRoute() {\n  if (currentPositionFeature && currentFountainFeature) {\n    var start = currentPositionFeature.geometry.coordinates[1] + ',' + currentPositionFeature.geometry.coordinates[0];\n    var destination = currentFountainFeature.geometry.coordinates[1] + ',' + currentFountainFeature.geometry.coordinates[0];\n    var routeRequestParams = {\n      mode: 'shortest;pedestrian',\n      representation: 'display',\n      waypoint0: start,\n      waypoint1: destination,\n      routeattributes: 'waypoints,summary,shape,legs',\n      maneuverattributes: 'direction,action'\n    };\n\n    router.calculateRoute(\n      routeRequestParams,\n      onRouteCalculationSuccess,\n      onRouteCalculationError\n    );\n  }\n} I recommend doing the very first request for routing with the least number of parameters, e.g. mode, start, destination and get a successful result before then looking at more granular parameters to tweak the request. Personally, I focused on pedestrian and going for the shortest distance. What’s next for you and this project? I will go back to working on my day job. I am obviously pretty excited by the autonomous driving field and the work we do at HERE Technologies as I believe it will tremendously improve people’s lives. I’m confident the more autonomous cars on the roads, ultimately the safer and less trafficked those roads will be. Definitely a fun project hacking something together with XYZ. I had in mind to display turn-by-turn maneuvers, hence using the parameter maneuverattributes but didn’t get a chance to implement this yet. Some other future directions on a project like this include integrating into a fitness app like Garmin, Nike+, Strava, Fitbit, etc. It might also be a good idea to create a mechanism to update water fountain data and push it back to OpenStreetMap to create a virtuous cycle. You can find the complete source code for this here-xyz-thirst-free project on GitHub.", "date": "2018-12-05"},
{"website": "Here", "title": "Suggesting Places with jQuery, Geolocation, and HERE Maps, Part 2", "author": ["Chris Hamaide"], "link": "https://developer.here.com/blog/suggesting-places-with-jquery-geolocation-and-here-maps-part-2", "abstract": "A few weeks ago, Nic Raboy had published an article describing how to suggest places around a location using HERE Maps Places API , combined with jQuery . In this tutorial, we will see how one can also make use of HERE Geocoder Autocomplete REST API , and even combine both Places and Geocoder for best results. While Nic was using Handlebars.js to compile HTML and Typeahead.js for the typeahead logic, we’ll use this time jQuery UI , which is a natural fit with jQuery. To do so, you’ll have to include in the header section of your HTML file the following link: <link rel=\"stylesheet\" href=\"https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css\"> And at the end of the body section this library: <script src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script> While we’re at it, let’s also put our javascript code in a separate file, index.js , for sake of clarity: <script src=\"index.js\"></script> Our index.html is therefore this: <html>\n    <head>\n        <title>HERE Auto-complete</title>\n        <link rel=\"stylesheet\" href=\"https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css\">\n    </head>\n    <body>\n        <div>\n            <p id=\"coords\">Location: searching....</p>\n            <input size=\"40\" id=\"place\" type=\"text\" placeholder=\"Search a Place...\">\n            <input size=\"40\" id=\"address\" type=\"text\" placeholder=\"Search an Address...\">\n            <input size=\"40\" id=\"full\" type=\"text\" placeholder=\"Search Something...\">\n        </div>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\"></script>\n        <script src=\"https://code.jquery.com/ui/1.12.1/jquery-ui.js\"></script>\n        <script src=\"index.js\"></script>\n    </body>\n</html> Hmm, but Wait! Why 3 input fields, identified by place , address and full ? Well, in order to compare the results from Place Autosuggest , HERE Geocoder Autocomplete and the combination of the two , this example will allow you to compare the results of each option. Nice, no? Let’s go now to the JavaScript part, with a bit of help from jQuery. Remember that in order to provide the suggestion from Places autosuggest API, the source of typeahead autocomplete was the following: source: function (query, callback) {\n  $.getJSON(\"https://places.cit.api.here.com/places/v1/autosuggest?at=\" + coordinates + \"&q=\" + query + \"&app_id=APP_ID_HERE&app_code=APP_CODE_HERE\", function (data) {\n       var places = data.results.filter(place => place.vicinity);\n       places = places.map(place => {\n       place.title = place.title.replace(/<br\\/>/g, \", \");\n       place.vicinity = place.vicinity.replace(/<br\\/>/g, \", \");\n       return place;\n  });\n  return callback(places);\n}); With jQuery Autocomplete, the mechanism is very much similar, only difference being, that you have to provide the following information: title : what is displayed in the list of suggestions value : what is displayed in the input field when you have selected a suggestion So let’s transform above code into this: source: function (query, callback) {\n  $.getJSON(\"https://places.cit.api.here.com/places/v1/autosuggest?at=\" + coordinates + \"&q=\" + query.term + \"&app_id=\" + APP_ID_HERE + \"&app_code=\" + APP_CODE_HERE, function (data) {\n       let places = data.results.filter(place => place.vicinity);\n       places = places.map(place => {\n       return {\n            title: place.title,\n            value: place.title + ', ' + place.vicinity.replace(/<br\\/>/g, \", \") + ' (' + place.category + ')',\n            id: place.id\n       };\n  });\n  return callback(places);\n}); And we’re good to go with jQuery Autocomplete. Wait, wait wait! Why are we replacing return place with return {title:…, value:…, id:…} ? Well, Place contains a lot of various lengthy fields, so let’s ease the task of jQuery UI… Wait, wait wait! What is this id field ? This field bears a unique identifier, which one can later use as an input for the HERE geocoder to get the latitude, longitude of the selection. But that will be for another tutorial… We now bind the first input field to the jQuery autocomplete as such: $(\"#place\").autocomplete({\n  source: placeAC,\n  minLength: 3,\n  select: function (event, ui) {\n       console.log(\"Selected: \" + ui.item.value + \" with LocationId \" + ui.item.id);\n  }\n}); And the function placeAC is what we’ve seen above: function placeAC(query, callback) {\n  $.getJSON(\"https://places.cit.api.here.com/places/v1/autosuggest?at=\" + coordinates + \"&q=\" + query.term + \"&app_id=\" + APP_ID_HERE + \"&app_code=\" + APP_CODE_HERE, function (data) {\n       let places = data.results.filter(place => place.vicinity);\n       places = places.map(place => {\n       return {\n            title: place.title,\n            value: place.title + ', ' + place.vicinity.replace(/<br\\/>/g, \", \") + ' (' + place.category + ')',\n            id: place.id\n       };\n  });\n  return callback(places);\n}); Note that once a suggestion is selected, the function is called: select: function (event, ui) {\n    console.log(\"Selected: \" + ui.item.value + \" with LocationId \" + ui.item.id);\n} Here, we just display the value and the unique Location id. One would ultimately use this to trigger the geocoding of the suggestion. Let’s Now Bring the Geocoder Autocomplete Now let’s consider the HERE geocoder autocomplete. It is very efficient at finding full addresses, and works extra fast. You can find its full information on developer.here.com . Usage is extremely similar to the Places autosuggest API: the query term is to be put into query parameter, the center of the search into prox , the array of results are provided into the field suggestion Here you are: function addressAC(query, callback) {\n  $.getJSON(\"https://autocomplete.geocoder.api.here.com/6.2/suggest.json?prox=\" + coordinates + \"&query=\" + query.term + \"&app_id=\" + APP_ID_HERE + \"&app_code=\" + APP_CODE_HERE, function (data) {\n       let addresses = data.suggestions;\n       addresses = addresses.map(addr => {\n       return {\n            title: addr.label,\n            value: addr.label,\n            id: addr.locationId\n       };\n  });\n  return callback(addresses);\n}); And to bind the autocomplete with this source function to the second input field: $(\"#address\").autocomplete({\n  source: addressAC,\n  minLength: 2,\n  select: function (event, ui) {\n       console.log(\"Selected: \" + ui.item.value + \" with LocationId \" + ui.item.id);\n  }\n}); So far so good ? Great, let’s combine the two together. What we want to achieve is to combine the result of the two asynchronous functions $.getJSON , one fetching data from HERE Places autosuggest API, the other one from HERE Geocoder autocomplete API. jQuery provides a convenient function for this: $.when let p1 = $.getJSON(….)\nlet p2 = $.getJSON(…)\n$.when(p1, p2).done(function (data1, data2) {\n  // data1[0] contains the result of the first $.getJSON,\n  // data2[0] contains the result of the second $.getJSON\n}); So, let’s build the arrays as before, one called places , managing the result of Places autosuggest, the other one called addresses with the result of the Geocoder autocomplete API: let places = data1[0].results.filter(place => place.vicinity);\nplaces = places.map(place => {\n  return {\n       title: place.title,\n       value: place.title + ',' + place.vicinity.replace(/<br\\/>/g, \", \") + '(' + place.category + ')',\n       distance: place.distance,\n       id: place.id\n  };\n});\n\n// data2 is from address autocomplete\nlet addresses = data2[0].suggestions;\naddresses = addresses.map(addr => {\n  return {\n       title: addr.label,\n       value: addr.label + ' (address)',\n       distance: addr.distance,\n       id: addr.locationId\n  };\n}); Now, let’s merge the two arrays into one: $.merge(places, addresses); The results go into the first array, places . Let’s sort the array by distance. Notice that both Places and Geocoder provides you with the distance of each suggestion to the center of the query. Convenient, no? places.sort(function (p1, p2) { return p1.distance - p2.distance }); And in order to limit the number of suggestions to a decent number (would you say 10 ?), let’s return a slice of the array: return callback(places.slice(0, 10)); Once you have bound the third input field to the jQuery autocomplete, you’re good to grab a cup of coffee and admire your work! Congratulation, You did it! You may find the two files index.html and index.js on Github for you to download and experiment. Happy Coding ! PS : Nic, you owe me one…", "date": "2018-11-28"},
{"website": "Here", "title": "Getting Started with HERE Maps in an Android Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/getting-started-with-here-maps-in-an-android-application", "abstract": "There are plenty of use-cases as to why you’d want to include maps and location services in your Android application. Maybe you want to build the next great ride sharing application or maybe you need to track dolphins in the ocean in real-time. Including maps in your Android applications has never been easier with the HERE Android SDK and Java. We’re going to see how to get started with HERE by including a simple, but interactive map in an Android application using Java and Android Studio . To get an idea of what we hope to accomplish, take a look at the following image: As you can see, there is a map within a fragment on the screen. What isn’t obvious is that pan and zoom works on the map, making it interactive. Creating a New Android Project with Android Studio There are many ways to create Android applications, but we’re going to focus on the most popular which is with Android Studio. Assuming that you have Android Studio installed and the appropriate Android Developer Toolkit (ADT) available, we can create a new project. Choose to create a new project in Android Studio. The first step is rather important for using the HERE Android SDK. Each application that uses the HERE Android SDK must have an appropriately registered Android package name. In our example, the package name is com.example.raboy.myapplication . If you decide to change it, fine, but whatever you choose will have to be supplied to HERE to get your developer tokens. All of this project linking can be done for free with a HERE developer account. The next step is to define the deployment platforms. Even though you can still create projects for Android 4.0, you’ll need to be supporting a minimum API of 16 if you wish to use HERE. As of right now the maximum supported API doesn’t really matter. After defining the target, the next step is to add an activity. For simplicity, we are going to use an Empty Activity , but feel free to choose whatever makes the most sense to you. When it comes to development, we’re going to include the map as a Fragment within the Activity. The final step towards creating a new Android project is to name the Activity. The defaults are fine for the naming in this example. Before we start including the HERE Android SDK, we should probably make a few revisions to the project’s AndroidManifest.xml file: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.raboy.myapplication\">\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"\n        android:hardwareAccelerated=\"true\">\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest> In the above XML, a few things were added, in particular around the application permissions. The following permissions are required when using HERE Location Services (HLS) in your application: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/> In addition to various permissions, the application also needs hardware acceleration enabled, which is disabled by default. In the <application> there is the android:hardwareAccelerated=\"true\" attribute which will enable acceleration. Now we can consider the new Android project ready for the next step of including the HERE Android SDK. Downloading and Configuring the HERE Android SDK To use HERE within your Android application, the package name that was previously created must be registered in your HERE Developer Portal . Having a HERE account is free and very easy to configure. After providing your package name, you’ll be given an application id and an application code to be used in the project. However, we’re not going to skip ahead quite yet. Instead, we need to download the SDK from the portal. Within the archive that was downloaded, there should be a HERE-sdk.aar file, probably within the libs directory. The HERE-sdk.aar file should be placed in your project’s app/libs directory. With the SDK in place, we need to apply the application id and application code values found in the portal. Open the project’s AndroidManifest.xml file and include the following lines: <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n<meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-CODE-HERE\"/> These lines should be placed within the <application> tags, but not as attributes. To get an idea of what your final AndroidManifest.xml file should look like, see the XML below. <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.raboy.myapplication\">\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"\n        android:hardwareAccelerated=\"true\">\n        <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n        <meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-CODE-HERE\"/>\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest> We’re not quite done configuring the HERE Android SDK. While it is in our project and the appropriate tokens are in place, it hasn’t been imported to be used in our code. To import the AAR file, it needs to be included in our Gradle configuration. Open the project’s .build.gradle file and include the following: apply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"com.example.raboy.myapplication\"\n        minSdkVersion 16\n        targetSdkVersion 28\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n    implementation(name:'HERE-sdk', ext:'aar')\n    implementation 'org.locationtech.jts:jts-core:1.15.0'\n    implementation 'com.google.code.gson:gson:2.8.0'\n} To be clear on what has changed between our version and the original, we first added a path as a possible repository for libraries: repositories {\n    flatDir {\n        dirs 'libs'\n    }\n} What we’re doing is we’re saying that Gradle should look in the libs directory when building in addition to any of the remote repositories that are configured by default. Now that the libs directory is linked up to Gradle, we need to define the AAR library that we had moved over: implementation(name:'HERE-sdk', ext:'aar') At this point in time the SDK is installed, configured, and ready for development. To sum it up, we applied our package name, copied our application id and application code, downloaded the AAR file, and configured Gradle to use the AAR file as a local dependency. Displaying an Interactive Map within the Mobile Application The difficult part, in regards to configuring our project, is behind us. Now we can focus on actually developing with HERE, and it actually isn’t very difficult. As of right now we have a single Activity. This Activity has XML as well as Java. Starting with the XML, we need to create a Fragment to hold our map. Open the project’s activity_main.xml file and include the following: <LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    android:orientation=\"vertical\" >\n\n    <fragment\n        class=\"com.here.android.mpa.mapping.MapFragment\"\n        android:id=\"@+id/mapfragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n\n</LinearLayout> Take note of the class and the id that we’ve given the Fragment. Using this information, we can take a look at the corresponding MainActivity.java file. Inside the Java file, include the following: package com.example.raboy.myapplication;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\n\nimport com.here.android.mpa.common.GeoCoordinate;\nimport com.here.android.mpa.common.OnEngineInitListener;\nimport com.here.android.mpa.mapping.Map;\nimport com.here.android.mpa.mapping.MapFragment;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private Map map = null;\n    private MapFragment mapFragment = null;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mapFragment = (MapFragment) getFragmentManager().findFragmentById(R.id.mapfragment);\n        mapFragment.init(new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n                if (error == OnEngineInitListener.Error.NONE) {\n                    map = mapFragment.getMap();\n                    map.setCenter(new GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE);\n                    map.setZoomLevel((map.getMaxZoomLevel() + map.getMinZoomLevel()) / 2);\n                }\n            }\n        });\n    }\n\n} Inside the onCreate method we are setting the view of our XML file and we are obtaining the Fragment of our map based on the id. Just because we have a map Fragment doesn’t mean that it is immediately ready for use. We need to call the init method and listen for when the map is ready. @Override\npublic void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n    if (error == OnEngineInitListener.Error.NONE) {\n        map = mapFragment.getMap();\n        map.setCenter(new GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE);\n        map.setZoomLevel((map.getMaxZoomLevel() + map.getMinZoomLevel()) / 2);\n    }\n} When the map is ready, assuming that the engine received no errors, we can set the center coordinates as well as the zoom. While this example doesn’t drop any markers on the map, we do end up with a map that we can pan and zoom with as part of the user experience. Conclusion You just saw how to get started with the HERE Android SDK for mobile development. A lot of the material found in the above tutorial was taken from the official documentation, but I’ve added my own spin on it from experiencing the setup myself. Like I mentioned previously, the most consuming part is configuring the SDK itself, not necessarily trying to develop with HERE Location Services.", "date": "2018-12-03"},
{"website": "Here", "title": "Tracking a Raspberry Pi with WLAN and Golang, then Displaying the Results with HERE XYZ", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/tracking-a-raspberry-pi-with-wlan-and-golang-then-displaying-the-results-with-here-xyz", "abstract": "Over the past few weeks I’ve been exploring how to track device position using nothing more than the meta information of nearby wireless access points. For example, in my tutorial titled, Tracking Device Location with Golang, WLAN Access Points, and the HERE Positioning API I demonstrated how to use Golang and the HERE Positioning API to get a a position estimate of a Mac or Linux device. However, in this example it was very sandboxed and didn’t serve a huge use-case. What if we wanted to continuously track location and then make sense of the data using a tool with a user interface? In this tutorial we’re going to see how to continuously try to position a Raspberry Pi device and then map the data using HERE XYZ Studio so it can be further analyzed. Before we start development, I want to share a further breakdown of what I accomplished and hope to share. Take the following picture: I have this Raspberry Pi 3 which runs Linux and is powered by the same battery pack I use to recharge my mobile phone. After installing the Golang application that we’re going to build, I started to roam around my neighborhood. Did I look like a crazy person carrying this thing around the neighborhood? I sure did, but I didn’t care. After spending a good 15 minutes outside, I came back in and harvested the data from my Raspberry Pi. The Raspberry Pi had been collecting WLAN information from around the neighborhood and had been sending it to HERE for a position whenever it had an internet connection. The data I later harvested was the latitude and longitude information. I then uploaded the latitude and longitude information to HERE XYZ Studio to make sense of it: Latitude and longitude data isn’t the most pleasant to look at, so a visualization tool is great. Looking at the plotted points of my neighborhood journey, I can see that my Internet of Things (IoT) experiment was successful. Given that the WLAN positioning is only an estimate, the coverage was still in the area I traveled. Creating a Golang Application with Boilerplate Code The first step of this project is to get some boilerplate Golang code in place. This code should include our data structures as well as any imports that will be used. Assuming you have Go installed and configured, create a main.go file somewhere in your $GOPATH path that includes the following: package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n    \"os/exec\"\n    \"regexp\"\n    \"runtime\"\n    \"strconv\"\n    \"strings\"\n    \"sync\"\n    \"time\"\n)\n\ntype HerePlatform struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\ntype PositionResponse struct {\n    Location struct {\n        Latitude  float64 `json:\"lat\"`\n        Longitude float64 `json:\"lng\"`\n        Accuracy  int     `json:\"accuracy\"`\n    } `json:\"location\"`\n}\n\ntype WlanInfo struct {\n    BSSID string `json:\"mac\"`\n}\n\ntype AccessPoints struct {\n    Wlan []WlanInfo `json:\"wlan\"`\n}\n\ntype AccessPointData struct {\n    mux  sync.Mutex\n    data []AccessPoints\n}\n\nvar waitGroup sync.WaitGroup\nvar platform HerePlatform\nvar accessPointData AccessPointData\n\nfunc main() {\n    fmt.Println(\"Starting the application...\")\n} The HerePlatform data structure will hold our application id and application code values obtained from the HERE Developer Dashboard. These values will be used when making requests to the HERE Positioning API. The PositionResponse data structure is what is returned from the HERE Positioning API. It will be what we use when plotting our points in XYZ Studio. The goal of our scanner is to pick up the BSSID values of WLAN access points, hence the WlanInfo data structure. When we send the WLAN information, we need to format it like the AccessPoints data structure. Finally, since we will be scanning and tracking position in parallel, we need to create an AccessPointData data structure with a sync.Mutex in it. Since two threads will be accessing our scan data, we need to lock it while it is in use, hence the sync.Mutex . With the foundation of our application in place, we can start adding logic. Developing a WLAN Access Point Scanner with Golang The second step in being successful with this tutorial is to implement some network scanning functionality with Golang. Since this tutorial is more of a next step in a series of tutorials, I strongly encourage you to read Tracking Device Location with Golang, WLAN Access Points, and the HERE Positioning API and Searching Location with the Command Line, WLAN Information, and the HERE Positioning API if you haven’t already. Take the following WlanScanner function: func WlanScanner() {\n    defer waitGroup.Done()\n    for {\n        if runtime.GOOS == \"linux\" {\n            iwlistCmd := exec.Command(\"iwlist\", \"wlan0\", \"scan\")\n            iwlistCmdOutput, err := iwlistCmd.Output()\n            if err != nil {\n                fmt.Println(err)\n                return\n            }\n            lines := strings.Split(string(iwlistCmdOutput), \"\\n\")\n            var wlans []WlanInfo\n            for _, line := range lines {\n                columns := strings.Fields(line)\n                if len(columns) == 5 {\n                    match, _ := regexp.MatchString(\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", columns[4])\n                    if match == true {\n                        wlan := WlanInfo{\n                            BSSID: columns[4],\n                        }\n                        wlans = append(wlans, wlan)\n                    }\n                }\n            }\n            accessPointData.mux.Lock()\n            accessPointData.data = append(accessPointData.data, AccessPoints{Wlan: wlans})\n            accessPointData.mux.Unlock()\n        } else {\n            fmt.Println(\"An unsupported operating system was detected.\")\n            return\n        }\n        time.Sleep(2000 * time.Millisecond)\n    }\n} The WlanScanner function will be called as part of a goroutine which is a type of parallel operation. When and if the goroutine ever finishes, it will tell the main thread that it has done so via the waitGroup.Done() . For as long as this function is running, it will check to make sure we are using Linux. If we’re using Mac or Windows, we’ll exit because the goal is to use a Raspberry Pi which uses Linux. If we’re using Linux, we can use the operating system level iwlist command to scan for networks. With the network information found, we can parse it for the BSSID values as demonstrated in the previous tutorials. If you’re a champion with regular expressions and parsing, you might try to collect the signal strength for more accurate position estimates. When the WLAN information has been collected, our accessPointData variable is locked, data is appended to it, then it is unlocked so it can be accessed by other goroutines. To prevent scanning more than we need to, we can sleep the goroutine. I’ve chosen to sleep the goroutine for 2 seconds between operations, but you might sleep it for longer. The main function can be updated to the following: func main() {\n    fmt.Println(\"Starting the application...\")\n    waitGroup.Add(1)\n    go WlanScanner()\n    waitGroup.Wait()\n    fmt.Println(\"Done\")\n} In the above function, we are saying that there is one item to wait on and the goroutine is started. When we’re no longer waiting, we can then close the application. This prevents the application from closing prematurely. At this point, the application will continuously scan for networks every two seconds. Determine Position Estimates from WLAN Data with the HERE Positioning API Now that we have scanning happening, we can make periodic requests to convert the scans into positions. However, before we make those periodic requests, let’s define how we’re going to use the HERE Positioning API with Golang. Let’s create the following position function: func (platform *HerePlatform) position(payload []byte) (PositionResponse, error) {\n    endpoint, _ := url.Parse(\"https://pos.api.here.com/positioning/v1/locate\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", platform.AppId)\n    queryParams.Set(\"app_code\", platform.AppCode)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Post(endpoint.String(), \"application/json\", bytes.NewBuffer(payload))\n    if err != nil {\n        return PositionResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var positionResponse PositionResponse\n        json.Unmarshal(data, &positionResponse)\n        return positionResponse, nil\n    }\n} Using a WLAN payload and user defined application id and application code values, we can make a POST request to the API. The response will be a latitude, longitude, and accuracy radius in meters. With an API function defined, we can create our goroutine which will periodically make requests: func DevicePositioner() {\n    defer waitGroup.Done()\n    for {\n        time.Sleep(5000 * time.Millisecond)\n        accessPointData.mux.Lock()\n        if len(accessPointData.data) > 0 {\n            if len(accessPointData.data[0].Wlan) > 0 {\n                _, err := http.Get(\"http://clients3.google.com/generate_204\")\n                if err == nil {\n                    payload, _ := json.Marshal(accessPointData.data[0])\n                    positionResponse, err := platform.position(payload)\n                    if err == nil {\n                        data, _ := json.Marshal(positionResponse)\n                        fmt.Println(string(data))\n                        accessPointData.data = accessPointData.data[1:]\n                    }\n                }\n            } else {\n                accessPointData.data = accessPointData.data[1:]\n            }\n        } else {\n            fmt.Println(\"No WLAN data to zero in on!\")\n            break\n        }\n        accessPointData.mux.Unlock()\n    }\n} Like with the other goroutine, this will also potentially run forever, assuming there is data to work with. We want to wait a little longer than the scan so that way there is data to work with. This is why we sleep at the start rather than the end. In every iteration, we lock the slice that has our data to avoid deadlocks and corruption. If we have data and that data isn’t null, we need to make sure we have a connection to the internet before attempting to make a request to the API. If everything checks out, we can create a payload from our WLAN information. If our request is successful, we are going to remove the data from our queue. Remember, we’ll potentially have more scan data than requests for positioning, so we use it as a queue. With the goroutine finished, we can update the main function to the following: func main() {\n    fmt.Println(\"Starting the application...\")\n    waitGroup.Add(1)\n    go WlanScanner()\n    waitGroup.Add(1)\n    platform = HerePlatform{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    go DevicePositioner()\n    waitGroup.Wait()\n    fmt.Println(\"Done\")\n} We’ve just started our other goroutine and defined our HERE platform information. If you felt like I did a lot of handwaving in this tutorial thus far, it is because I have. I strongly encourage you to check out my previous tutorials in this series to get all the information around scanning and making requests to the API. As of now, the only difference is that we’re using goroutines to continuously run each of these operations. After you’ve build a binary for your Raspberry Pi, you can run it with the following: sudo nohup ./raspberry-pi-tracker > output.out & The above command will run it in the background and send all output to an output.out file. The output will contain the data we need for XYZ Studio. If you’re having trouble cross-compiling the application for the Raspberry Pi, check out a previous tutorial I wrote titled, Cross Compiling Golang Applications for use on a Raspberry Pi . Making Sense of Custom Latitude and Longitude Data with HERE XYZ Studio If everything thus far has been successful with your Go application and Raspberry Pi, you should have several lines of data in the following format: {\"location\":{\"lat\":10.713308,\"lng\":3.4509832,\"accuracy\":88}} Unfortunately, this format is not a supported format by XYZ Studio. We need to be using CSV or preferably GeoJSON format. We could have designed this output in Golang, but that is a topic for a different day. Instead, you can make use of an online conversion utility or do it yourself. When I did my conversions, I used two different online tools, none of which are officially supported by HERE. First, I took my output and ran it through a JSON to CSV tool by Eric Mill. I then changed the format of the CSV to the following: lat,lng\n10.713308,3.4509832 With the CSV data in hand, I ran it through another converter to make it GeoJSON format. The CSV to GeoJSON tool gave me what I needed to visualize. In HERE XYZ Studio , I chose to create a new project and add a new dataset via a file upload. After uploading the GeoJSON dataset, points were immediately displayed on the map, giving me something to make sense of. The beauty of XYZ Studio is that I can give my data to someone non-technical and they can analyze it very easily. Conclusion You just saw me walk through a simple project that I was experimenting with. I had written a Golang application, installed it to my Raspberry Pi , wandered my neighborhood to collect WLAN information, exchanged the WLAN information with coordinates, then plotted those coordinates on a map with XYZ Studio. The goal was to demonstrate how to use the HERE Positioning API and how easily HERE XYZ Studio could be used. The concepts of this tutorial can be taken beyond Raspberry Pi and into other IoT applications. For example, what if fitness trackers that didn’t include GPS started to track your runs via WLAN information. I personally think that would be pretty awesome.", "date": "2018-12-06"},
{"website": "Here", "title": "Picking an Interactive Map Theme with Vue.js", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/picking-an-interactive-map-theme-with-vue.js", "abstract": "A few weeks ago Jayson Delancey had written an awesome tutorial around switching between visual themes for a map on demand using React. This is useful when it comes to scenarios such as switching between day and night mode on a map depending on the local time or similar. The problem with this is that his tutorial was written with React when there are a bunch of other popular web frameworks available. In this tutorial, we’re going to see almost the same material that Jayson demonstrated, but this time using the Vue.js JavaScript framework. Before getting too far ahead of ourselves, what we plan to accomplish can be seen in the following animated image: The above image only scratches the surface of what can be accomplished, but as you can see we have a map with a set of buttons below it. Clicking each of the buttons will give the map a different visual theme. Building a Map Component with the Vue.js Framework Showing a map with Vue.js isn’t new. I had written about the basics in a tutorial titled, Showing a HERE Map with the Vue.js JavaScript Framework , and it accomplishes half of what we’re trying to do. Rather than going through the steps in detail numerous times, we’re going to get a project up and running with a map component without the details. With the Vue CLI installed and configured, execute the following: vue create theme-switcher Choose the defaults when creating the project and when it is created, open the project’s public/index.html file and change it to contain the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>theme-switcher</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1526040296\" />\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but theme-switcher doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\"></script>\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\"></script>\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\"></script>\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\"></script>\n    </body>\n</html> With the appropriate stylesheets and JavaScript libraries included, the map component can be created. Create a src/components/HereMap.vue file within the project and include the following: <template>\n    <div class=\"here-map\">\n        <div ref=\"map\" style=\"width: 75%; height: 600px\"></div>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereMap\",\n        data() {\n            return {\n                platform: {},\n                map: {}\n            };\n        },\n        props: {\n            appId: String,\n            appCode: String\n        },\n        mounted() {\n            this.platform = new H.service.Platform({\n                app_id: this.appId,\n                app_code: this.appCode,\n            });\n            var layers = this.platform.createDefaultLayers();\n            this.map = new H.Map(\n                this.$refs.map,\n                layers.normal.map,\n                {\n                    center: {lat: 37.73987, lng: -121.42618},\n                    zoom: 14,\n                }\n            );\n            var events = new H.mapevents.MapEvents(this.map);\n            var behavior = new H.mapevents.Behavior(events);\n            var ui = H.ui.UI.createDefault(this.map, layers);\n        }\n    }\n</script>\n\n<style scoped></style> The above component, when used, will give you an interactive map centered on a location. To use this component, open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <HereMap appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" />\n    </div>\n</template>\n\n<script>\n    import HereMap from './components/HereMap.vue'\n\n    export default {\n        name: \"app\",\n        components: {\n            HereMap\n        }\n    }\n</script>\n\n<style>\n    body {\n        background-color: #F0F0F0;\n    }\n</style> At this point in time we’re caught up. If you run the application, a map should appear, assuming that you’ve changed the placeholder appId and appCode values with your own from the HERE Developer Portal . If you’d like to get more details on anything that we did above, I encourage you to read the previous tutorial that I wrote on the subject. Watching for Changes to a Component Property and Reacting With the map component functional, we want to be able to change the theme on demand. There are many ways to do this, but to remain as similar to the React example as possible, we’re going to watch our properties for changes and update the theme when changes happen. In the project’s src/components/HereMap.vue file, you’re going to want to add another possible props to the list: props: {\n    theme: String,\n    appId: String,\n    appCode: String\n}, The theme will be our current active theme. To watch for changes to this variable and react to them, we can make use of the watch object in Vue.js: watch: {\n    theme(newVal, oldVal) {\n        var tiles = this.platform.getMapTileService({ \"type\": \"base\" });\n        var layer = tiles.createTileLayer(\n            \"maptile\",\n            newVal,\n            256,\n            \"png\",\n            { \"style\": \"default\" }\n        );\n        this.map.setBaseLayer(layer);\n    }\n} When a change to the theme variable happens, we are going to create a new tile layer with the selected theme and default style. There are quite a few styles that can be chosen beyond the default. To see these changes in action, we can revisit the src/App.vue file. In the src/App.vue file, make it look like the following: <template>\n    <div id=\"app\">\n        <HereMap :theme=\"theme\" appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" />\n        <br />\n        <button v-on:click=\"switchTheme('normal.day')\">Normal - Day</button>\n        <button v-on:click=\"switchTheme('normal.day.grey')\">Normal - Day (Grey)</button>\n        <button v-on:click=\"switchTheme('normal.day.transit')\">Normal - Day (Transit)</button>\n        <button v-on:click=\"switchTheme('normal.night')\">Normal - Night</button>\n        <button v-on:click=\"switchTheme('normal.night.grey')\">Normal - Night (Grey)</button>\n        <button v-on:click=\"switchTheme('reduced.night')\">Reduced - Night</button>\n        <button v-on:click=\"switchTheme('reduced.day')\">Reduced - Day</button>\n    </div>\n</template>\n\n<script>\n    import HereMap from './components/HereMap.vue'\n\n    export default {\n        name: \"app\",\n        data() {\n            return {\n                theme: \"normal.day\"\n            };\n        },\n        components: {\n            HereMap\n        },\n        methods: {\n            switchTheme(theme) {\n                this.theme = theme;\n            }\n        }\n    }\n</script>\n\n<style>\n    body {\n        background-color: #F0F0F0;\n    }\n</style> A few things have been added since we last modified this file. We’ve created a theme variable with a default value. This theme variable is not directly connected to the theme property we saw in the component, it is just coincidentally named the same. The switchTheme method will set this variable to something new. Within the HTML, we have several buttons with string values to be passed to the switchTheme method. Because the theme variable is bound to the theme property, when changes happen, the watch will trigger within the component itself. Conclusion You just saw how to use Vue.js to dynamically switch between HERE map themes. As previously mentioned, this tutorial takes Jayson Delancey’s example to new places because it uses Vue.js instead of React.js. In the future we’ll explore doing the same, but with Angular.", "date": "2018-12-13"},
{"website": "Here", "title": "December 2018 Release Highlights", "author": ["Denis Panov"], "link": "https://developer.here.com/blog/december-2018-release-highlights", "abstract": "All services receive content updates frequently, but we will call out a few noteworthy highlights related to the following services: Fleet Telematics API , Places API , and Mobile SDK . There were minor updates and fixes across many other services which were releated to regular maintenance releases. View the API Version History for preious updates including change log and release notes for all of the APIs. Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Learn more... Version 2.5.11 calculateroute warnings when waiting for truck bans or similar admin wide restrictions got additional attributes \"isoCountryCode\" and \"duration\" calculateroute has new request paramter &vehicleCostOnFerry to override the vehicle_cost (per km) while riding a ferry Places API Find (e.g., search for name, type, category), discover (e.g., look into address, contact info) and interact with POI information (e.g., enable user reviews, photos). Learn more... Version 2.69.0 \"Sight\" and \"sights\" added as synonyms to the Sights & Museum category. The Place report feature is discontinued. A sample of the many many reported data issues resolved such as... duplicated Target stores in North Bergen, NJ invalid Washington Mutual in San Antonio, TX uninformative address details for Frankfurt Airport in Germany search for Friseur in Paris, France invalid Wilko place in Coventry, UK ...and many more.  Use the HERE Map Creator to report if you observe any other issues. Mobile SDK User Interface (UI) Kit The HERE Mobile SDK UI Kit for iOS and Android provides ready-to-use UI components for the HERE Mobile SDK. Version 1.4 Now available on GitHub for Android and iOS . Also a note that some Mobile SDK customers appear to still be using outdated offline maps.  This can lead to negative user experiences. Maps Data for Korea Note that because of legal restrictions, map data is only available from within South Korea. Version 8.30.89.501 Major road updates Lane attribute coding applied to 80k+ intersections", "date": "2018-12-07"},
{"website": "Here", "title": "Placing Markers on a Map in Android with HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/placing-markers-on-a-map-in-android-with-here", "abstract": "About a week ago I had written a tutorial for including a HERE map within your Android mobile application in the form of an Android Fragment. While that tutorial was a basic getting started guide, it left more to be desired in terms of what you can do with an interactive map component. We’re going to continue our mapping adventure and explore dropping map markers using both custom marker images as well as default marker images in an Android with Java application. To get an idea of what we want to accomplish, check out the following image: In the above image, you’ll notice that there are two different markers. One marker is what you’d expect because it is a globally recognizable indicator for modern maps. The other marker is a picture of me. There are scenarios where you might want to use either the default marker image or something custom like I did. Showing Markers with Default or Custom Images Rather than going through the process of configuring an Android application to use the HERE Android SDK, as previously demonstrated in my tutorial titled, Getting Started with HERE Maps in an Android Application , we’re going to focus strictly on the marker aspect of things. If you are stuck with getting up and running with a HERE map, I suggest checking out my previous tutorial. Let’s start with the basics. If you’ve set up your project and are displaying a map, you probably have something that looks like the following: package com.example.raboy.map_project;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.util.Log;\n\nimport com.here.android.mpa.common.GeoCoordinate;\nimport com.here.android.mpa.common.Image;\nimport com.here.android.mpa.common.OnEngineInitListener;\nimport com.here.android.mpa.mapping.Map;\nimport com.here.android.mpa.mapping.MapFragment;\nimport com.here.android.mpa.mapping.MapMarker;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private Map map = null;\n    private MapFragment mapFragment = null;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mapFragment = (MapFragment) getFragmentManager().findFragmentById(R.id.mapfragment);\n\n        mapFragment.init(new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n                if (error == OnEngineInitListener.Error.NONE) {\n                    map = mapFragment.getMap();\n                    map.setCenter(new GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE);\n                    map.setZoomLevel((map.getMaxZoomLevel() + map.getMinZoomLevel()) / 2);\n                }\n            }\n        });\n    }\n\n\n} In the above code, we are displaying a map and centering on a particular set of latitude and longitude coordinates. When it comes to application logic, the next thing the user might want to see is a marker representing where the map is centered on. Within the onEngineInitializationCompleted method, add the following: MapMarker defaultMarker = new MapMarker();\ndefaultMarker.setCoordinate(new GeoCoordinate(37.7397, -121.4252, 0.0));\nmap.addMapObject(defaultMarker); The above marker will have the default blue graphic attached to it. This might be valuable to show the center of the map, which could also be the users actual position. Now there could be other circumstances where you need to place markers that represent certain buildings or objectives. If you’re a gamer like I am, you might have played Marvel’s Spider-Man on Playstation 4 and recognize that each objective within the game on the fictional map has a different icon. That map and game has no relation to HERE, but you can get an idea of how different marker graphics could be useful. A more realistic example might be a parental tracking application where the marker is the child’s face, so you can see where all your children are. Of course, the examples aren’t limited to the few that I listed. Find an image that you’d like to use as a marker. Remember to follow the rules when it comes to sizing information for different Android screen densities. When you’ve got your image, you can choose to place it in the app/src/main/res/drawable directory or place various sizes in each of the appropriate directories. In your Java application, add the following code: try {\n    Image image = new Image();\n    image.setImageResource(R.drawable.nraboy);\n    MapMarker customMarker = new MapMarker(new GeoCoordinate(37.7397, -121.4252, 0.0), image);\n    map.addMapObject(customMarker);\n} catch (Exception e) {\n    Log.e(\"HERE\", e.getMessage());\n} The above code should go in the onEngineInitializationCompleted method like the other default marker code. This time around I’m getting my drawable image which is named nraboy and I’m using it as the graphic for my marker. Conclusion You just saw how to add markers to your HERE map using Android and Java. When it comes to markers, you can use your own custom images or you can use the default marker image that is provided by HERE. As previously mentioned, if you need help setting up your Android application with the HERE Maps SDK for Android, check out my previous tutorial on the subject.", "date": "2018-12-04"},
{"website": "Here", "title": "Geocoding Addresses with HERE in an Android Mobile Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/geocoding-addresses-with-here-in-an-android-mobile-application", "abstract": "Over the past week or so I’ve been writing about using the HERE Location Services (HLS) within an Android mobile application. I started with a tutorial titled, Getting Started with HERE Maps in an Android Application which focused strictly on the configuration towards displaying a map, and then I wrote a tutorial titled Placing Markers on a Map in Android with HERE which focused on showing markers on that map based on latitude and longitude coordinates. Memorizing latitude and longitude coordinates probably isn’t feasible for most people, so how do you do the same with address information? We’re going to take a look at using the HERE Geocoder API for Android to convert user defined addresses into positions and then drop markers on the map at those positions. To get an idea of what we plan to accomplish, take a look at the following animated image: In the above example, the user will enter a query. The geocoder will find a best match for a position and place it as a marker. Rather than going through the steps of configuring HERE in your Android project, we’re going to assume you’ve already configured it and are already displaying a map. Finding the Latitude and Longitude Coordinates to an Address This particular tutorial is going to focus on two parts, the first being the actual geocoding of addresses to positions. Within your Activity, include the following variables: private Map map = null;\nprivate MapFragment mapFragment = null;\nprivate EditText editText = null;\nprivate MapMarker marker; Some of the variables will probably already look familiar, but we’ve added an editText for our text field and a marker for the current marker that we have on the map. In this example we’re only going to display one marker. Within the same Activity, include the following dropMarker method: public void dropMarker(String query) {\n    if(marker != null) {\n        map.removeMapObject(marker);\n    }\n    GeoCoordinate tracy = new GeoCoordinate( 37.7397,-121.4252);\n    GeocodeRequest2 request = new GeocodeRequest2(query).setSearchArea(tracy, 5000);\n    request.execute(new ResultListener<List<GeocodeResult>>() {\n        @Override\n        public void onCompleted(List<GeocodeResult> results, ErrorCode error) {\n            if (error != ErrorCode.NONE) {\n                Log.e(\"HERE\", error.toString());\n            } else {\n                for (GeocodeResult result : results) {\n                    marker = new MapMarker();\n                    marker.setCoordinate(new GeoCoordinate(result.getLocation().getCoordinate().getLatitude(), result.getLocation().getCoordinate().getLongitude(), 0.0));\n                    map.addMapObject(marker);\n                }\n            }\n        }\n    });\n} Let’s break down what is happening in the above method. First we are checking to see if a marker exists. If it does, we need to use it to clear the map to start with a fresh slate. After clearing the map, we set a baseline position to geocode around. In reality, you’d probably want to use your device location rather than hard code a value. With a baseline, we can take a query string and search based on a range parameter. When we execute the geocoder, we wait until it completes. When the listener triggers that it is complete, we check for errors and if no errors exist, we can loop through the results and place the marker based on the position. Not too bad right? Now we need to figure out how to get the query to this dropMarker method. Listening for User Provided Search Queries There are many solutions towards getting a query to the geocoder and none of them are wrong. Our solution will be to have a text field for user input and when the enter or done key is pressed, the geocoder starts working. Before we look at the Java logic, we need to update the XML layout: <LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    android:orientation=\"vertical\" >\n\n    <EditText\n        android:id=\"@+id/query\"\n        android:hint=\"Query...\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"match_parent\"\n        android:inputType=\"text\"/>\n\n    <fragment\n        class=\"com.here.android.mpa.mapping.MapFragment\"\n        android:id=\"@+id/mapfragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n\n</LinearLayout> Take note that our EditText has an id of query which will be used within the Java file. Inside the onCreate method, where we have the map initialization, we need to add the following: editText = (EditText) findViewById(R.id.query);\n\neditText.setOnKeyListener(new View.OnKeyListener() {\n    public boolean onKey(View view, int keyCode, KeyEvent keyevent) {\n        if ((keyevent.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {\n            dropMarker(editText.getText().toString());\n            editText.setText(\"\");\n            return true;\n        }\n        return false;\n    }\n}); The above code will bind our variable to the view component and create a keyboard listener. If there is an event for a key press and that key is the enter key, we will call the dropMarker method and pass the content of the input. After calling the dropMarker method, the input will be cleared. Conclusion You just saw how to use the HERE Geocoder API within an Android mobile application. What we did was take an address query, defined by the user, and convert it into a latitude and longitude position which was then placed on the map as a marker. Of course more complicated things could come out of a geocoder, but this is just one of many examples. This particular tutorial didn’t revisit any of the configuration steps of the HERE Location Services in Android. If you are stuck and need help configuring a HERE map in Android, check out my previous tutorial on the subject.", "date": "2018-12-11"},
{"website": "Here", "title": "The landscape of Outdoor Mapping and Location Services by Gartner", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/the-landscape-of-outdoor-mapping-and-location-services-by-gartner", "abstract": "Global research firm Gartner recognizes HERE Technologies as a provider in the Outdoor Mapping and Location Services market in the latest “The Competitive Landscape: Outdoor Mapping and Location Services” report.     Find out how the competitive landscape looks when it comes to developer offering. Gartner Inc. is an independent research and advisory firm which has been providing insights and strategic advice to companies large and small for nearly 40 years with more than 15,000 client organizations in 100 countries. When Gartner speaks, the industry listens. “The Competitive Landscape: Outdoor Mapping and Location Services” report published in November 2018, includes a list of vendors in the location services market.  According to Gartner, the market for mapping and location software and services is defined by a set of vendor offerings that have one or more of the following attributes and capabilities: Base Map data creation and provisioning Data visualization Map App Creation Maps/location services Interoperability As one of the leading providers of location data and services to the auto industry, our growing list of automotive partners include BMW, Daimler, Audi, and Jaguar Land Rover. Nevertheless, the data and tools HERE offers aren’t solely for enterprise companies and big players. HERE data is available for any level of developer, for any sized project. By offering APIs and SDKs that utilize our full data services to a massive developer community, we enable developers, SMBs and organizations far and wide to create applications that can do anything from managing fleets and organizing delivery services, to providing high precision maps and data to consumer applications. Read the full “Competitive Landscape: Outdoor Mapping and Location Services Report for 2018”, here. Gartner, Competitive Landscape: Outdoor Mapping and Location Services, 30 November 2018. Gartner does not endorse any vendor, product or service depicted in its research publications, and does not advise technology users to select only those vendors with the highest ratings or other designation. Gartner research publications consist of the opinions of Gartner’s research organization and should not be construed as statements of fact. Gartner disclaims all warranties, express or implied, with respect to this research, including any warranties of merchantability or fitness for a particular purpose.", "date": "2018-12-17"},
{"website": "Here", "title": "Positions to Addresses with Gesture Events and HERE in Android", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/positions-to-addresses-with-gesture-events-and-here-in-android", "abstract": "I’ve been writing a few tutorials on using the HERE Location Services (HLS) platform with Android. These tutorials have included showing a map, dropping markers, and geocoding address information to latitude and longitude position information. This time around we’re going to take things to the next level by converting latitude and longitude position information to address information within an Android application. To be specific in what we plan to accomplish, take a look at the following animated image. As you can see, we are able to place a marker on the map at any given touch location. After tapping the marker, an address is displayed in the form of a Toast notification. From a technical perspective, all this is accomplished by finding the latitude and longitude position from a gesture listener and that coordinate is converted to an address with the HERE Reverse Geocoder API for Android. So let’s take a look at how we can actually accomplish this. Getting the Latitude and Longitude Coordinates of a Touch Event Listener To get the latitude and longitude coordinates from a HERE map based on a tap event, we need to create a gesture listener. A gesture listener can track any kind of gesture on our map, not limited to tap, long tap, and double tap events. Assuming you’ve got HERE configured within your Android application, you could add the following after the initialization of the map engine has completed: mapFragment.getMapGesture().addOnGestureListener(new MapGesture.OnGestureListener.OnGestureListenerAdapter() {\n    @Override\n    public boolean onTapEvent(PointF p) {\n        GeoCoordinate position = map.pixelToGeo(p);\n        return false;\n    }\n\n    @Override\n    public boolean onLongPressEvent(PointF p) {\n        GeoCoordinate position = map.pixelToGeo(p);\n        return false;\n    }\n}); In the above example, mapFragment is the variable that is actually connected to our Fragment defined in the XML. Only two of the many possible events are overridden, and in our example so far, they accomplish the same thing, which is taking the point on the map and converting it to the latitude and longitude position equivalent. For clarity, both mapFragment and map should have been defined somewhere within your Activity like follows: private Map map;\nprivate MapFragment mapFragment; If you need help configuring HERE in your Android application and setting up the initial map, you might want to check out my previous tutorial titled, Getting Started with HERE Maps in an Android Application . Since we have our listener in place, we probably want a way to visually display our touch events, rather than spitting out log data. The simplest thing to do beyond log data is to drop a marker on the map. You can create a method called dropMarker that contains the following: public void dropMarker(GeoCoordinate position) {\n    if(marker != null) {\n        map.removeMapObject(marker);\n    }\n    marker = new MapMarker();\n    marker.setCoordinate(position);\n    map.addMapObject(marker);\n} If the above code looks familiar, it is because I had written about it in my tutorial titled, Placing Markers on a Map in Android with HERE . Essentially, we’d want to call the dropMarker function after we have the position from the touch event. Now that we have markers and a gesture event listener registered, we can focus on converting our positions to addresses. Reverse Geocoding Latitude and Longitude Positions to Addresses The concept behind a reverse geocoder is that we are providing a latitude and longitude and it is searching for a selection of addresses where the first result is the nearest match. With the address information, we’ll have access to a concatenated string of all information as well as separated pieces of information such as the city, state, street, etc. Take the following reverseGeocode method: public void reverseGeocode(GeoCoordinate position) {\n    ReverseGeocodeRequest request = new ReverseGeocodeRequest(position);\n    request.execute(new ResultListener<Address>() {\n        @Override\n        public void onCompleted(Address data, ErrorCode error) {\n            if (error != ErrorCode.NONE) {\n                Log.e(\"HERE\", error.toString());\n            } else {\n                Toast.makeText(getApplicationContext(), data.getText(), Toast.LENGTH_LONG).show();\n            }\n        }\n    });\n} When the reverse geocoding is complete, a Toast notification is displayed with the concatenated string of data. To clear up any loose ends, we can revisit the gesture listener and make it look like the following: mapFragment.getMapGesture().addOnGestureListener(new MapGesture.OnGestureListener.OnGestureListenerAdapter() {\n    @Override\n    public boolean onTapEvent(PointF p) {\n        ArrayList<ViewObject> viewObjectList = (ArrayList<ViewObject>) map.getSelectedObjects(p);\n        for (ViewObject viewObject : viewObjectList) {\n            if (viewObject.getBaseType() == ViewObject.Type.USER_OBJECT) {\n                MapObject mapObject = (MapObject) viewObject;\n                if (mapObject.getType() == MapObject.Type.MARKER) {\n                    MapMarker selectedMarker = ((MapMarker) mapObject);\n                    reverseGeocode(selectedMarker.getCoordinate());\n                }\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onLongPressEvent(PointF p) {\n        GeoCoordinate position = map.pixelToGeo(p);\n        dropMarker(position);\n        return false;\n    }\n}); When a long press is done, the latitude and longitude position is found and a marker is placed at that position with the dropMarker method. When a tap is done, we find all the objects on the map at that given set of pixels. These objects include markers and everything else that may be placed. Once we have that list, we can loop through them and figure out if they are a marker. If we are dealing with a marker that was tapped, we can reverse geocode the coordinate. To give credit where credit is due, I actually pulled the code for getting the selected map objects from Stack Overflow . Conclusion You just saw how to override gestures on a HERE map, place markers at a position based on a tap event, and reverse geocode latitude and longitude coordinates to addresses within an Android mobile application. As previously mentioned, this is just the next part in my series of tutorials in regards to using HERE within Android. If you’re curious on getting configured to use HERE with Android, I recommend you check out my previous tutorial . I also have a tutorial for converting addresses to coordinates in a tutorial titled, Geocoding Addresses with HERE in an Android Mobile Application .", "date": "2018-12-18"},
{"website": "Here", "title": "This holiday, use your mapping skills to help out others", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/holiday-mapping-for-non-profits-with-xyz", "abstract": "What if a map doesn't just get you around, but also helps you to help others? As a location platform and mapping company, we’re constantly searching for ways we can use our tech to improve the quality of life for everyone. One of the key values of HERE is giving back and we felt that this season is a good time to bring in our expertise in map making to let you help your local communities. We've recently established Chicago as our North America headquarters. Throughout this time, we've been working with the Greater Chicago Food Depository on some special projects (more on this soon!) and general volunteer opportunities. The Food Depository is the Chicago area's largest food bank. In its most recent fiscal year, the Food Depository was responsible for distributing nearly 70 million pounds of food, 38% of which was fresh produce. Every day they provide the equivalent of 159,000 meals to struggling families in our community. If you're based in the Chicago area and would like to get involved, the Food Depository has plenty on volunteer opportunities available. You can learn more about getting involved with the organization on their official website . In this tutorial, we’ll learn how to help non-profit organizations directly from your computer by creating a dedicated map with a special dataset: a list of volunteer opportunities at the Food Depository this holiday season. To create this map, we'll be using: HERE XYZ : a new cloud geo storage and visualization service. Tangram : an open-source vector renderer. This tutorial will consist of two different sections. The first section doesn't require any coding knowledge. We'll be using XYZ Studio to create a map with Food Depository volunteer opportunities simply by dragging and dropping our data. You'll even be able to share or embed this map on your personal website. The second part will require some basic knowledge around web programming and JavaScript. Don't worry, there won't be anything too advanced, so if you don't feel too comfortable with web programming, feel free to try and follow along. Let's get started! Part 1: XYZ Studio For those unfamiliar with XYZ Studio, let's take a quick tour. You can access XYZ Studio at xyz.here.com . If you don't already have an account, go ahead and make one--it's free. Once you've signed up or logged in, you should see this view: Let's cover some terminology within XYZ Studio: Projects: the different maps made with XYZ Studio. Data Hub: different datasets uploaded to XYZ Studio, which you can then use in your projects. To get started with our map, we're going to need get ahold of our data first. I've conveniently compiled a list of the Food Depository events in CSV format here . I got a hold of this dataset through manually scraping the Food Depository's website. Feel free to try and recreate this map with the charity of choice. You most likely can acquire similar datasets for your favorite charity on their website. Go ahead and download this file. Our dataset has the following columns: Day: the date of the volunteer opportunity Address: the plain text location of the volunteer opportunity Time Title Type: the different type of opportunity (kid's event, repack, etc.) Latitude and Longitude: the coordinates of the volunteer opportunity (geocoded from the address column) To upload it to XYZ Studio, all you need to do is navigate to the Data Hub tab in the top-level navigation. Once you're there, click Create new dataset and then upload the volunteer opportunity CSV. What's awesome about XYZ Studio is that it accepts a few different file formats for geo data. You can upload GeoJSON, CSV and Shapefiles. However, if you do choose to upload a CSV file, make sure it has longitude and latitude columns in the file. Once you are done uploading the CSV to the Data Hub, let's hop over to the Projects tab to create a new map. I've titled my map something simple for now: \"Holiday Map\". To add the volunteer opportunities to the map, I can click the button titled +Add and then select the recently uploaded file. And just like that, my map now contains my volunteer opportunity dataset! Using the tools sidebar on the left side, I can play around with the style of my map. I changed my map to a friendlier and more colorful theme, increased the marker size, and then added 'Food and Drink' icons inside the marker. In order to share the map, we'll need to bookmark the initial view. To do that, I can click the bookmark icon in the top center. Next, I'll click the large teal button titled Project Settings to kick off the sharing process. From this next view, I can grab the url or iframe for my newly created map. You can check out my map here: https://xyz.here.com/viewer/?project_id=2d549553-b61a-48fd-b847-b7b81571db7e In just a few minutes you were able to create a simple volunteer map inside of XYZ Studio. In the next section, we'll be using the same dataset to create a slightly more customized map with Tangram. Part 2: Tangram One of my favorite features about XYZ is XYZ Hub API Spaces . XYZ Hub is a real-time cloud-based location hub for discovering, storing, retrieving, manipulating and publishing private or public mapping data. So, in short, XYZ Spaces are a great place to store your geo data in the cloud. XYZ Spaces can return your data in GeoJSON or tiled MVT format. Awesome for vector maps! Whenever you upload a dataset to XYZ Studio inside of Data Hub, XYZ automatically creates a new Space for the dataset. What this means is that the data uploaded into XYZ Studio can also be accessed programmatically via API. This is exactly what we'll be doing with our Tangram map. To start, we're going to need two things: XYZ Space ID : this can be found in XYZ Studio in the Add Data view. XYZ Token : this can be found in the XYZ Token Manager . Once you've grabbed both of those codes, keep them somewhere handy. We'll be using them shortly. Let's start writing some code. We're going to be creating four files: an HTML file, a CSS file, a YAML file for our map styles, and a JavaScript file. Sorry React diehards, we're just writing plain old JavaScript today. Starting with our HTML file, let's create an index.html with the following content: <!DOCTYPE html> <html> <head> <title>Holiday Season Volunteer Map</title> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> <link rel=\"stylesheet\" href=\"index.css\" /> <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400\" rel=\"stylesheet\"> <script src=\"https://unpkg.com/leaflet@1.3.3/dist/leaflet.js\"></script> <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.0.1/dist/leaflet.css\" /> <script src=\"https://unpkg.com/tangram/dist/tangram.min.js\"></script> </head> <body> <div id=\"control\"> <div class=\"title\">Greater Chicago Food Depository Volunteer Calendar</div> <p class=\"subtitle\">An interactive map showing available <a href=\"https://www.chicagosfoodbank.org/get-involved/\" target=\"_blank\">GCFD volunteer opportunities</a> throughout the 2018 holiday calendar.</p> <p class=\"subtitle\">This map is purely for showcase purposes. If you are interested in volunteering with GCFD, please take a look at the <a href=\"https://volunteers.chicagosfoodbank.org/index.php?section=IndividualOpportunities&action=calendar\" target=\"_blank\">official volunteer calendar</a>.</p> <div>Key</div> <div> <div class=\"key-label\">‼️ Immediate Need</div> <div class=\"key-label\">🚚 Fresh Truck</div> <div class=\"key-label\">🌟 Special Events</div> <div class=\"key-label\">🍱 Repack</div> <div class=\"key-label\">👶 Kid Friendly Opportunities</div> </div> </div> <div id=\"map\"></div> <script src=\"index.js\"></script> </body> </html> There's nothing too special going on here, we're just laying out the scaffolding of our site with a map and sidebar (control) div. As for our CSS, let's create an index.css with the following content: body, html {\n   margin: 0;\n   padding: 0;\n   border: 0;\n   font-family: 'Montserrat', sans-serif;\n   color: #333;\n}\n\n#map {\n   height: 100vh;\n   width: 100vw;\n}\n\n#control {\n   background: white;\n   width: 300px;\n   padding: 20px;\n   margin: 20px;\n   right: 0;\n   position: absolute;\n   z-index: 50000;\n   border: 2px solid #0560FD;\n   border-radius: 4px;\n}\n\na {\n   color: #0560FD;\n   text-decoration: none;\n}\n\na:hover {\n   text-decoration: underline\n}\n\n#control .title {\n   font-size: 19px;\n}\n\n#control .subtitle {\n   color: gray;\n   font-size: 14px;\n   font-weight: 300;\n}\n\n.key-label {\n   color: gray;\n   font-weight: 400\n}\n\n.tooltip-title {\n   font-family: 'Montserrat';\n   font-size: 19px;\n   color: 333;\n}\n\n.tooltip-subtitle {\n   font-family: 'Montserrat';\n   color: gray;\n   font-size: 14px;\n   font-weight: 300;\n}\n\n.leaflet-popup-content-wrapper {\n   border: 2px solid #0560FD;\n}\n\ncanvas {\n   pointer-events: none;\n   position: absolute;\n   top: 0;\n   left: 0;\n   z-index: 500000\n} Once again, we're just performing some straightforward CSS styling to make sure our map is looking oh so so pretty ☺️. Onto our JavaScript file. Create an i ndex.js with the following: const map = L.map('map', {\n   center: [41.7317392281872, -87.51007854938509],\n   zoom: 11.4,\n   layers: [\n      Tangram.leafletLayer({\n         scene: 'scene.yaml',\n         events: {\n            hover: showTooltip,\n            click: showTooltip\n         }\n      })\n   ],\n   zoomControl: false\n});\n\nfunction showTooltip(selection) {\n   if (selection.feature) {\n      const tooltipHtml = `\n<div> class=\"tooltip-title\">${selection.feature.properties.Title}</div>\n<div> class=\"tooltip-subtitle\">${selection.feature.properties.Type}</div>\n<div> class=\"tooltip-subtitle\">${selection.feature.properties.Day} ${selection.feature.properties.Time}</div>\n<div> class=\"tooltip-subtitle\">${selection.feature.properties.Address}</div>`;\n      const popup = L.popup()\n         .setLatLng(selection.leaflet_event.latlng)\n         .setContent(tooltipHtml)\n         .openOn(map);\n   } else {\n      map.closePopup();\n   }\n} In the above code, we are initializing our Tangram map with the map variable. We've attached some hover and click events in order to fire up our tooltip when the user hovers or clicks on an icon. The showTooltip function does just that. We prepare some HTML to insert into the tooltip. When the user hovers or clicks on an icon on the map, we present the tooltip. When the hover or click on a map object other than an icon, we remove the tooltip. And by now you should know the drill. For the last file, we create a scene.yaml file with the following: import: refill-style/refill-style.yaml\n\ncameras:\n    camera1:\n        type: perspective\n\nlights:\n    light1:\n        type: directional\n        direction: [0, 1, -.5]\n        diffuse: .3\n        ambient: 1\n\nsources:\n    xyz_osm:\n        type: MVT\n        url: https://xyz.api.here.com/tiles/osmbase/256/all/{z}/{x}/{y}.mvt\n        max_zoom: 16\n    gcfd_events:\n        url: https://xyz.api.here.com/hub/spaces/YOUR-XYZ-SPACE-ID/tile/web/{z}_{x}_{y}\n        type: GeoJSON\n        url_params:\n            access_token: YOUR-XYZ-TOKEN\n\nlayers:\n    gcfd_events:\n        data: {source: gcfd_events}\n        draw:\n           text:\n              interactive: true\n              optional: false\n              collide: false\n              repeat_distance: 0\n              text_source: |\n                  function() {\n                       if (feature.Type === 'Immediate Need') {\n                          return '‼️';\n                       } else if (feature.Type === 'Fresh Truck') {\n                          return '🚚';\n                       } else if (feature.Type === 'Special Events') {\n                          return '🌟';\n                       } else if (feature.Type === 'Repack') {\n                          return '🍱';\n                       } else if (feature.Type === 'Kid Friendly Opportunities') {\n                          return '👶';\n                       }\n                    }\n              font:\n                  fill: black\n                  size: 35px\n\n                  stroke:\n                      color: white\n                      width: 2px The YAML file is the fun part! This is where you can write the styling rules for the Tangram map. Be sure to replace YOUR-XYZ-SPACE-ID and YOUR-XYZ-TOKEN with the codes we grabbed earlier in the section. Let's take a quick pause and dive deeper into this YAML file. At the top of the file, we are importing an external file from refill-style/refill-style.yaml . This refill style contains the blue map theme we are using. Important! Be sure to download this file and place it into your project directory. You can download the file here . In the Source section, we are importing two different data sources: our base map (from our friends at Tilezen and OpenStreetMap) and our GCFD volunteer opportunities from our XYZ Space. In Layers , we are specifying how we want to style the gcfd_events data. I decided to have some fun with this map and use emojis as icons. To determine which icon to use, I've embedded a JavaScript function inside the text_source key. Congratulations, we now have a functioning and style map showcasing the locations of GCFD volunteer opportunities. But let's not stop there... What is one more thing we can add to make add an extra special touch to this holiday map? Snow! ❄⛄️ To do so, we're going to include one extra JavaScript file: snow.js . Go ahead and download this file and then include it in our HTML right before we import index.js . Additionally, add a canvas element as the first element inside the body . <canvas id=\"canvas\"></canvas>\n<div id=\"control\">...</div>\n<div id=\"map\"></div>\n<script src=\"snow.js\"></script>\n<script src=\"index.js\"></script> To get the snow to show, all you have to do is call the makeItSnow function at the bottom of your JavaScript file. makeItSnow(); If you are interested in learning more about how the snow animation works, feel free to check out the original source on Codepen . Now we can see the beautiful snow falling down in Chicago! Wrapping things up... At this point, we've learned how to create a holiday map with two different tools: XYZ Studio and Tangram. XYZ Studio is a great tool for those with limited coding experience who quickly want to visualize data on a map and then share with friends and family. For those with a little bit more technical experience, Tangram is a great tool for creating rich, highly-customizable, and interactive web mapping experiences. On top of that, we've learned that maps can be a great tool for display all sorts of data; in this case, we've displayed location data of volunteer opportunities for the Food Depository as an alternate way for potential volunteers to find nearby opportunities. If you decide to create something cool, feel free to give us a shout on Twitter at @dbabbs or @heredev . We love seeing what you all build with maps 🌍 and HERE APIs. Happy Holidays!", "date": "2018-12-12"},
{"website": "Here", "title": "Insert static maps into chatbots, Alexa devices and emails with the Map Image API", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/insert-static-maps-into-chatbots-alexa-devices-and-emails-with-the-map-image-api", "abstract": "A few weeks ago, the HERE Developer Relations team participated in the AWS re:Invent Alexa Hack Day in Las Vegas, where we built an Alexa country challenge game. Team “Table 44” at the #Alexa Hack at @AWSreInvent testing out our skill using @heredev APIs. @here #reinvent #reInvent2018 pic.twitter.com/L1fS6sYz4I — J Michael Palermo IV (@palermo4) November 26, 2018 The game was pretty straightforward: using Alexa Presentation Language , our skill would present a map with a country highlighted on an Alexa device with a screen. The player of the game would then take a guess at the country's name from a list of multiple choice options. Usually, when we want to show a map in our applications, we recommend our native APIs and SDKs, like the JavaScript API , iOS SDK or Android SDK , which all provide interactive maps. But how about when you need to display a customized map with data overlays on a different platform? That's where the HERE Map Image API comes in. The Map Image API is RESTful API enabling the creation of customized maps--all returned in your favorite image format. The Map Image API isn't limited to just a normal map at any location around the globe. Here are some examples of things you can customize: map theme (satellite, dark, light, terrain, etc.) image size and format overlays with custom data (markers, points, polylines, and polygons) Since the Map Image API returns images, you can get pretty creative on where you can insert them: Chatbots. Don't just provide directions text from our Routing API, also throw in an image of the route. Alexa devices with screens (like us during the Alexa Hack Day). Automated emails. Ridesharing company? Provide a map of the route your customer took in the receipt email. Let's take a look at some examples. Map Image API with Terrain Style Map Image API with Polyline Map Image API with Custom Polygon from GeoJSON", "date": "2018-12-27"},
{"website": "Here", "title": "Interactive Visualization of 10M+ 3D Points with New Open-Source Python Package PPTK", "author": ["Victor Lu"], "link": "https://developer.here.com/blog/interactive-visualization-of-10m-3d-points-with-new-open-source-python-package-pptk", "abstract": "At HERE, we are continually pushing the speed and accuracy of automatic algorithms for extracting map features from 2D/3D point clouds such as GPS trajectories and LIDAR point clouds. To better work with data at this scale, engineers at HERE have developed a 3D point cloud viewer capable of interactively visualizing 10-100M 3D points directly in Python. This viewer is now included as part of a new open-source Python package called the Point Processing Tool Kit (PPTK) . In prototyping algorithms for this type of data, we are often faced with the need to quickly iterate between writing code and visualizing the results of applying such code. The Python programming language’s interactivity, conciseness, and vast collection of third-party packages allow us to implement sophisticated processing of point data in just a few lines of code, but it currently lacks support for interactively visualizing larger point clouds natively, such as the tens of millions of LIDAR points that HERE 3D mapping vehicles can produce every minute, or the millions of GPS trajectories that happen every day.  That's where PPTK comes in. Level of detail rendering for interactive visualization Upon being called, the PPTK viewer organizes the input points into an octree .  The octree is a tree data structure that represents a recursive partitioning of 3D space into increasing ly smaller sized cubes.  As the 3D viewpoint is being manipulated, the viewer uses this octree to approximate groups of faraway points as single points and to cull points that are outside the view frustum, thus greatly reducing the number of points that need to be rendered.  Once the viewpoint is no longer being changed, the viewer then performs an exact rendering of all the point. Point selection for data inspection and annotation The PPTK viewer supports coloring of points by per-point attributes, which is useful for visualizing, for example, the per-point probabilities computed by a classification algorithm, or the partitioning of points computed by a segmentation algorithm.  The viewer also supports single point selection or box selection for selecting multiple points.  The selected points can then be queried using the viewer.get () method in Python.  This is useful for annotation tasks required in creating training data for machine learning algorithms. Agnostic to file format The PPTK viewer is not tied to a specific file format.  The user may leverage one of many existing Python packages for reading from any of a number of file formats commonly encountered for storing point data ( e.g. .ply , .csv, .las, etc.).  Once loaded into a numpy array, the points can then be directly visualized using the pptk.viewer () function. Quick start On most platforms, PPTK is easy to install. >> pip install pptk In just a few lines of code, users can start viewing simple point clouds. >> import numpy \n>> import pptk \n>> P = numpy.random.rand(100, 3) \n>> v = pptk.viewer(P) \n>> v.set(point_size=0.01) Select points using Ctrl+LMB and deselect using Ctrl+Shift+LMB . Retrieve the selected points using the viewer.get() method >> v.get(‘selected’) Check out the tutorials for some more advanced examples including lidar point clouds, GPS trajectories, 2D polygons, and parametric surfaces to generate visuals like these: The bildstein1 Lidar point cloud from Semantic3D (left). Beijing GPS trajectories from Geolife (middle left). DistrictofColumbia.geojson 2-d polygons from US building footprints (middle right). A Mobius strip (right). Future work The PPTK viewer is part of a larger effort of developing a Python toolkit for not only visualizing but also processing point data . Already, PPTK provides a fully-parallelized k-d tree and a normal estimation routine. And existing Python packages, such as Numpy for matrix operations, and Tensorflow and PyTorch for deep learning, are also useful for processing point data.  However, m any point processing algorithms still suffer from significant performance penalties when written purely in Python, especially those that must loop over all neighborhoods in a point cloud. As we continue to grow PPTK, w e hope to continue address ing these inefficiencies (e.g. via Python bindings to C++ implementations of common point cloud algorithms) Git repository : https://github.com/heremaps/pptk Documentation : https://heremaps.github.io/pptk/index.html Installation : pip install pptk", "date": "2018-12-19"},
{"website": "Here", "title": "Locate Christmas markets with JavaScript, AJAX, external data source and HERE Isoline Routing", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/find-christmas-markets-with-javascript-ajax-external-data-source-and-here-isoline-routing", "abstract": "'Tis the season! Time to unwind with mulled wine and munch on Christmas cookies with the best company at one of Berlin's many Christmas markets. The German capital has a database of all its pop-up seasonal markets which we wanted to play around with. We will now see how to fetch this data using AJAX, display the markets on the map using our Geocoder and find the one that can be reached the fastest, practically, using Isoline routing. To use any of the HERE JavaScript APIs you need to get your App_ID and App_code by signing up for a Freemium account. To display a map and set a marker on a location, follow our Senior Evangelist Michael Palermo's tutorial . Once you have a basic map and a marker, we will use XMLHttpRequest to fetch the json file from the external data source. var xmlhttp = new XMLHttpRequest();\n\txmlhttp.open(\"GET\", \"https://www.berlin.de/sen/web/service/maerkte-feste/weihnachtsmaerkte/index.php/index/all.json?q=\", true); We need to now parse this data as a json object and extract the address of the markets. After scanning the dataset, I found that the required fields are strasse and plz_ort . These data fields are the search text for our geocoder. function addXmasMkts(){\n      var geocodingParams = {\n        searchText: ' '\n      };\n      var xmlhttp = new XMLHttpRequest();\n      xmlhttp.open(\"GET\", \"https://www.berlin.de/sen/web/service/maerkte-feste/weihnachtsmaerkte/index.php/index/all.json?q=\", true);\n      xmlhttp.onreadystatechange = function() \n      {\n        if (this.readyState == 4 && this.status == 200) \n        {\n          var myArr = JSON.parse(this.responseText);\n          var XmasDataString = '';\n\n          for(i = 0; i < myArr.results.count; i ++)\n          {\n            XmasDataString = myArr.index[i].strasse +','+ myArr.index[i].plz_ort\n            geocodingParams = {\n              searchText: XmasDataString\n            };\n            M.Geo.geocode(geocodingParams, onResult, function(e) {\n              alert(e);\n            });\n          }\n        }\n      };\n      xmlhttp.send();\n    }\n    \n    addXmasMkts(); The Geocoder API takes the address string as a parameter and gives the position of the searched location in terms of Latitude and Longitude. This position is marked by placing markers on the map //  A callback function to process the geocoding response and place markers at the obtained position:\n    var onResult = function(result) {\n    var locations = result.Response.View[0].Result,\n      position,\n      marker;\n    position = {\n      lat: locations[0].Location.DisplayPosition.Latitude,\n      lng: locations[0].Location.DisplayPosition.Longitude\n    };\n    marker = new H.map.Marker(position,{icon: iconXmas}) ;\n    M.Map.addObject(marker);\n\n  }; Once you have your position and the markets' positions marked, we check the markets nearest to us by drawing a circle of radius 5Km around our position. You will thus see all the markets in a 5km radius of your position. The radius here is in meters. var customStyle = {\n      strokeColor: 'dark green',\n      fillColor: 'rgba(0, 255, 100, 0.2)',\n      lineWidth: 1,\n    };\n\n    function drawCircle(){\n    var circle = new H.map.Circle({lat: M.Lat, lng: M.Lng},5000,{ style: customStyle });\n    M.Map.addObject(circle);}\n\n    drawCircle(); Although this gives a fair idea about which markets are nearest from you, they cannot necessarily be reached within a similar time given the time of the day, traffic and road conditions. To take these conditions into consideration and to get a realistic view of places that can be reached, we use the Isoline Routing API . The Isoline highlights an area which can be reached by car from your position in 10 minutes or less. Isoline also has a pedestrian mode. Lets take a look at the code for this one. // Get an instance of the routing service:\n    var router = M.Platform.getRoutingService();\n// save your location as a string of latitude and longitude\n    var myLoc = M.Lat + ',' + M.Lng;\n// set the routing parameters for Isoline routing\n    var routingParams = {\n      'mode': 'fastest;car;traffic:enabled',// traffic matters for our commute| you can also disable traffic\n      'start': myLoc,\n      'departure': '2018-12-14T17:00:00', // set the departure time\n      'range': '600', //10 (10x60secs) minutes of driving\n      'rangetype': 'time'\n    };\n\n    // Define a callback function to process the isoline response.\n    var onRoutingResult = function(result) {\n      var center = new H.geo.Point(\n          result.response.center.latitude,\n          result.response.center.longitude),\n        isolineCoords = result.response.isoline[0].component[0].shape,\n        linestring = new H.geo.LineString(),\n        isolinePolygon,\n        isolineCenter;\n        // Add the returned isoline coordinates to a linestring:\n         isolineCoords.forEach(function(coords) {\n         linestring.pushLatLngAlt.apply(linestring, coords.split(','));\n         });\n\n         // Create a polygon and a marker representing the isoline:\n         isolinePolygon = new H.map.Polygon(linestring);\n         // isolineCenter = new H.map.Marker(center);\n\n         // Add the polygon and marker to the map:\n         M.Map.addObject(isolinePolygon);\n\n         // Center and zoom the map so that the whole isoline polygon is\n         // in the viewport:\n        M.Map.setViewBounds(isolinePolygon.getBounds());\n       };\n\n       // // Call the Routing API to calculate an isoline:\n       router.calculateIsoline(\n         routingParams,\n         onRoutingResult,\n         function(error) {\n         alert(error.message);\n         }\n       ); You can try your hand at more routing parameters to refine your isoline area. Try swapping the 'rangetype': to 'distance' and the 'range': to '5000'//meters . You will clearly be able to see that there are still some places which were inside the circle but not reachable if you consider traffic and time using the isoline routing. With this tutorial, we have seen how to use external data sources, call the data using AJAX, parse the json file using JSON.parse , draw a circle on the map and calculate reachable places considering traffic and time with isoline routing. If you have any difficulties in following this tutorial, comment below and I will try to answer them. You can also ask us your doubts about any of our HERE APIs on stackoverflow with the tag 'here-api' and our team will answer your queries. Thats all from me for this year. Happy holidays! See you on the other side of 2018.", "date": "2018-12-20"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.1 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.1-release", "abstract": "Pipelines Changed Reduced the total processing downtime when upgrading a stream pipeline to a new pipeline version to under one minute. Increased the granularity of the Pipeline I/O, CPU, and Memory charts in the OLP Current Usage Dashboard. Fixed Fixed an issue where the pipeline job's state was null upon activating a pipeline version. Known Issues Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue Pipelines are not private to a user by default; they must be shared with exactly one group when created. Workaround Share the pipeline with a group containing only one user. Issue Pipelines can only be shared with users who belong to the same group. Workaround Share the pipeline with a group containing the specific set of users. Issue If multiple pipelines consuming data from a single stream layer all belong to the same group (pipeline permissions are managed via a group), then each of those pipelines will only receive a subset of the messages from the stream. This is due to the fact that the pipelines share the same Application ID. Workaround Use the Data Library to configure your pipelines to consume from a single stream. If your pipelines/applications use the Direct Kafka connector type, you can specify a Kafka consumer group ID per pipeline/application. If the Kafka consumer group IDs are unique, the pipelines/applications will consume all messages from the stream. If your pipelines use the HTTP connector type, we recommend that you create a new group for each pipeline/application, each with its own application ID. Data Added Added features that enable you to index and store metadata and data in a way that is optimized for batch processing. The new features are: Index Layer - A new layer type called \"index\" is, as its name suggests, an index of the layer’s data. The index has up to three user-defined attributes plus the required time attribute. For example, if you want to run a batch process daily to find all pothole detection events recorded that day in the area surrounding a given city, you can use an index layer to index the pothole detection events by event time, event type, and location, and then archive the data. You can then query the data every 24 hours for such events in that area as part of your batch process. Data Archiving Library - The Data Archiving Library is a new Java library in the OLP SDK that you can use to develop a pipeline that indexes data. The SDK includes a JAR file that serves as a template for an indexing pipeline. Index API - This new REST API can be used to query the index layer to find data that meets the query criteria. The API returns the data handle of the matching data which you can then use to get the data associated with each data handle. For more information, see the Data API Developer Guide and the [Data Archive Library Developer Guide]( https://developer.here.com/olp/documentation/data-archiving-library/dev_guide/index.html . Added support for specifying the digest algorithm used to calculate the checksums for each partition in versioned and volatile layers. This feature supports data integrity use cases where you need to ensure data has not changed during storage or transmission. You can create checksums in your own pipelines that publish to a volatile or versioned layer, then validate data integrity by comparing a checksum produced at a later time. This integrity check helps you meet standard data security compliance requirements driven by standards like ASIL. This feature is supported for new layers only. At this time you cannot specify a digest for existing layers. For more information, see the Data API Developer Guide topics Versioned Layer Settings and Volatile Layer Settings. Added an uptime SLA of 98.5% for reading from stream layers, writing to stream layers, and writing to versioned layers. Added the operational status of Portal and data service read and write operations to status.openlocation.here.com . Changed Improved performance for stream layers: Faster acknowledgements when you send data to the Ingest API. Faster responses to read requests via the Data Client using either the HTTP connect or the direct Kafka connector Faster data writes and reads when using pipelines in OLP. Known Issues Issue When creating an Index Layer and processing stream data in a data archive pipeline, it is possible to select Parquet as a data format. However, a corresponding Spark Connector is not available with this release, making it non-trivial to consume data in this format. As a mitigation, we recommend you not use Parquet format with this release. Issue Catalogs not associated with a realm are not visible in OLP. Issue Some older catalogs cannot be shared temporarily because the catalog owners don't have permissions assigned to them yet. This issue only applies to older catalogs. Contact us to report each occurrence as a bug. Issue Data encryption is limited to: Versioned data at rest Stream layer data Index layer data Notebooks In-flight data encryption is not consistently implemented across OLP. You should not send sensitive data or personal information to OLP at this time. Issue When you use the Data API or Data Library to create a catalog or layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog withother users, apps and groups. Notebooks Known Issues Issue Notebooks only support Python 3. Issue Neither platform.here.com nor Notebooks are compatible with Internet Explorer 11. Issue Notebooks do not support Flink. Issue Notebooks do not contain support for Stream Layers. Account & Permissions Added Added support for avatar images. Add your avatar by editing your HERE profile on the profile page . Known Issues Issue When updating permissions, it can take up to an hour for changes to take effect. Issue A finite number of access tokens (~250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue [Pipelines] Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Delete pipelines/pipeline templates to recover space. Issue [Pipelines] All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. HERE Optimized Map for Location Libraries HERE Optimized Map for Visualization v1 Deprecated The Optimized Map for Visualization v1 catalog has been deprecated and will not be updated. It will be retired on May 31, 2019. We recommend that you to start using the catalog Optimized Map for Visualization v2 (hrn:here:data:::here-optimized-map-for-visualization-2). The main difference between the two catalogs is in the data schema that is used for the vector tiles. The catalog now follows the open TileZen schema . Minor changes have been made to the content, including more building footprints and more carto attributes. If you have been using the Visualization Library that is bundled with the SDK, we recommend that you update to the latest version which will automatically point to Optimized Map for Visualization v2. If you were using Optimized Map for Visualization with a map renderer of your choice, then you may need to make some adaptations to your map styles. Marketplace Fixed Fixed an issue where Marketplace Consumer managers cannot revoke data access once it is granted to internal users. Fixed an issue where an info request record for a semi-private data listing would disappear from the Marketplace Consumer Request tab after the request was accepted by the provider. When a Marketplace Consumer manager shares their licensed data catalog with their internal users, there could be a delay before the internal users can see the data catalog in their data area. Known Issues Issue When a Marketplace Provider grants data access to a Marketplace Consumer, there could be a delay before the Consumer can see the data catalog in their licensed data area. Workaround Contact technical support if the Consumer Management Group cannot see the licensed data after more than 2 hours has passed. Issue Marketplace users do not receive stream data usage metrics when reading data from Kafka direct. Workaround You must write data to a stream layer using the Ingest REST API in order to receive usage metrics. You must use the Data Library configured to use the HTTP connector type in order to receive usage metrics and read data from a stream layer. Issue When the Splunk server gets busy, it is possible for the server to lose usage metrics. Workaround If you suspect you are losing usage metrics, contact technical support as soon as possible. We may be able to help rerun queries and validate data. Issue If you are a Workspace user and have pipelines that use the Kafka Direct connector to connect to stream data, no messages-in and bytes-in metrics can be collected. Workaround You can instrument your pipelines with custom messages-in and bytes-in metrics. Contact technical support if you need assistance. Issue After a Catalog is marked \"Marketplace Ready\", the Catalog may take up to 2 hours to show in the Provider Management Group's list of Catalogs. Workaround Contact technical support if the Provider Management Group cannot see the Marketplace Ready catalog after more than 2 hours has passed. Monitoring and Alerts Added [Data] Added Index Layer metrics to the Data, Catalog and Layer Metrics dashboard so you can review your usage of this new layer type. For more information, see Data, Catalog and Layer Metrics [Data] Improved the Ingestion Metrics dashboard to provide more robust and helpful monitoring of your OLP data ingestion. Note that the new dashboard does still include a number of SDIP (legacy ingestion mechanism) metrics to help early OLP adopters see metrics for both that system and OLP ingestion while migration from legacy systems to OLP is still in progress. For more information, see: Ingestion Metrics Added Data Service IO metrics to the Current Usage Metrics dashboard in Grafana. These metrics allow you to view and monitor data transfer (IO) to and from the platform For more information, see: Current Usage Metrics Known Issues Issue When the Splunk server gets busy, it is possible for the server to lose usage metrics. If you suspect that you are losing usage metrics, contact technical support as soon as possible. We may be able to help rerun queries and validate data. Issue Compute, Storage, and Transfer metrics are not fully available within Monitoring and Alerts. Issue [Pipelines] Any changes made by the user to the Pipeline Status Dashboard will be lost when updates to the dashboard are published in future releases. Workaround Duplicate the dashboard or create a new dashboard. Web & Portal Added Added an integrated tool for customer support. Now you can submit and edit tickets and check their status. To check out the new support tool, click Contact us in the support panel on platform.here.com . Added a knowledge base where you can search frequently-asked questions and suggest new topics. To check out the new knowledge base click Contact us in the support panel on platform.here.com . The set up process for a new organization on OLP has been automated. This once took a week, and now takes hours. Changed In usage reporting, the Cloud Service \"Versioned Storage\" has been renamed to \"Blob Storage”. Data (not metadata) for both versioned layers and the newly-launched index layers is stored in blob storage and accounted for in the Blob Storage line item in usage reporting. Moved the FAQ content that was previously available on openlocation.here.com to the new knowledge base. Fixed [Pipelines] Fixed an issue where the system forgets the number of executors, run-time environment, and entry point class name when a new JAR is uploaded to create a pipeline version. [Pipelines] Fixed an issue where the option to remove a pipeline version was available even when it was being activated. [Pipelines] Fixed an issue where a copy of an existing batch pipeline version could use the same catalog for both input and output. [Pipelines] Fixed an issue where a second pipeline version shows a job or operation failure if it was activated using the CLI, even though another pipeline version for that pipeline is already active. Removed Removed video tutorials previously available on openlocation.here.com . Known Issues Issue Some PDF documentation has formatting errors. Issue The Portal and notebooks are not compatible with Internet Explorer 11. Issue [Pipelines] The pipelines list page is sometimes slow to load. Issue [Pipelines] The Portal can't be used to delete pipeline templates. Workaround Use the CLI or API to delete pipeline templates. Issue [Pipelines] The Portal can't be used to force a batch pipeline version to run. It will run on its own when the input catalogs' version is updated. Workaround Use the CLI or API to force a batch pipeline version to run, or wait for the input catalogs' version to update. For more information, see the Troubleshooting section in the Pipelines Developer Guide . Issue [Pipelines] The custom runtime configuration for a pipeline version has a limit of 64 characters for the property name, and a limit of 255 characters for the value. Workaround For the property value, there is no workaround. For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. Issue [Pipelines] In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list. Issue [Data] Data visualization in the Portal is only available for versioned and volatile layers. Workaround Create your own visualization for your own schemas creating a GeoJSON renderer and making it part of that schema. Out of the box, however, only data can be visualized that is formatted according to the following schema formats: GeoJSON HERE Reality Index Topology HERE Reality Index Building Footprints HERE Reality Index Cartography HERE Traffic Flow SDII", "date": "2018-12-21"},
{"website": "Here", "title": "Search for Points of Interest in an Android Mobile Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/search-for-points-of-interest-in-an-android-mobile-application", "abstract": "I had recently written a tutorial that demonstrated geocoding addresses into latitude and longitude coordinates, then placing those coordinates on a HERE map as a marker in Android. This previous tutorial titled, Geocoding Addresses with HERE in an Android Mobile Application , focused on the HERE Geocoder API. What if we didn’t know the address that we wanted, but instead a place or point of interest? We’re going to see how to use the HERE Places API to search for points of interest and display them on a map within an Android mobile application. To get a better idea of what we hope to accomplish, take a look at the following animated image: The above image might look familiar in the sense that a lot of it was taken from the geocoding tutorial. We are accepting a search query and the HERE API will take that query and find possible matches which we then display as markers on the map. Searching with the HERE Places API for Android The first of the two parts of this tutorial is centered around searching. You’ll notice that we won’t be going into any detail around configuration of HERE in Android. If you’re interested in configuring HERE in Android, check out my previous tutorial titled, Getting Started with HERE Maps in an Android Application . Within our Activity, make sure the following variables exist in some form: private Map map = null;\nprivate MapFragment mapFragment = null;\nprivate EditText editText = null;\nprivate ArrayList<MapObject> markers = null; For the first part, the markers list will be important to us. The plan will be to clear the markers list every time we search and populate it with new objects from the search results. Take a look at the following search method: public void search(String query) {\n    if(!markers.isEmpty()) {\n        map.removeMapObjects(markers);\n        markers.clear();\n    }\n    try {\n        GeoCoordinate tracy = new GeoCoordinate(37.7397, -121.4252);\n        DiscoveryRequest request = new SearchRequest(query).setSearchCenter(tracy);\n        request.setCollectionSize(5);\n        ErrorCode error = request.execute(new ResultListener<DiscoveryResultPage>() {\n            @Override\n            public void onCompleted(DiscoveryResultPage discoveryResultPage, ErrorCode error) {\n                if (error != ErrorCode.NONE) {\n                    Log.e(\"HERE\", error.toString());\n                } else {\n                    for(DiscoveryResult discoveryResult : discoveryResultPage.getItems()) {\n                        if(discoveryResult.getResultType() == DiscoveryResult.ResultType.PLACE) {\n                            PlaceLink placeLink = (PlaceLink) discoveryResult;\n                            MapMarker marker = new MapMarker();\n                            marker.setCoordinate(placeLink.getPosition());\n                            markers.add(marker);\n                        }\n                    }\n                    map.addMapObjects(markers);\n                }\n            }\n        });\n        if( error != ErrorCode.NONE ) {\n            Log.e(\"HERE\", error.toString());\n        }\n    } catch (IllegalArgumentException ex) {\n        Log.e(\"HERE\", ex.getMessage());\n    }\n} There is a lot of code in the above snippet, but not a whole lot going on. After the markers list is cleared and the map is cleaned, we provide a set of coordinates to search around. We’ve hardcoded those coordinates, but in a more extravagant scenario, we’d probably use the coordinates from the device GPS. For the result, we’re saying we only want five points of interest to be returned. When the request is executed with our position and the search query, we wait for the results. When we have the results, we loop through them and check to make sure they are a place versus something else. If we have a place, we can create a new marker with the position and add it to the map. In the search method, the HERE Places API handles all of the heavy lifting for us. Responding to Key Events with the Android Key Listener With the not-so complicated stuff out of the way, we can focus on listening for key events which is also not at all complicated. The listener has nothing to do with HERE and is functionality of the Android SDK. Take a look at our onCreate method: @Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    mapFragment = (MapFragment) getFragmentManager().findFragmentById(R.id.mapfragment);\n    editText = (EditText) findViewById(R.id.query);\n\n    markers = new ArrayList<MapObject>();\n\n    editText.setOnKeyListener(new View.OnKeyListener() {\n        public boolean onKey(View view, int keyCode, KeyEvent keyevent) {\n            if ((keyevent.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {\n                search(editText.getText().toString());\n                editText.setText(\"\");\n                return true;\n            }\n            return false;\n        }\n    });\n\n    mapFragment.init(new OnEngineInitListener() {\n        @Override\n        public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n            if (error == OnEngineInitListener.Error.NONE) {\n                map = mapFragment.getMap();\n                map.setCenter(new GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE);\n                map.setZoomLevel((map.getMaxZoomLevel() + map.getMinZoomLevel()) / 2);\n            }\n        }\n    });\n} As you can see in the above code, we have our mapFragment as well as our editText loaded from the XML view. To get more perspective on what our XML looks like, it looks like the following: <LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    android:orientation=\"vertical\" >\n\n    <EditText\n        android:id=\"@+id/query\"\n        android:hint=\"Query...\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"match_parent\"\n        android:inputType=\"text\"/>\n\n    <fragment\n        class=\"com.here.android.mpa.mapping.MapFragment\"\n        android:id=\"@+id/mapfragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n\n</LinearLayout> In the above XML, we define both the EditText and Fragment giving them an id that can be used in the Java. Looking back at our Java code, we can look at the actual listener: editText.setOnKeyListener(new View.OnKeyListener() {\n    public boolean onKey(View view, int keyCode, KeyEvent keyevent) {\n        if ((keyevent.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {\n            search(editText.getText().toString());\n            editText.setText(\"\");\n            return true;\n        }\n        return false;\n    }\n}); In the listener, we are listening for key press events, but we want those events to be the enter or the done key. When those keys are pressed, we can obtain the text in the field and use it as our query string for the search. After searching we can empty the field to be searched again. Just like with the searching aspect of this tutorial, the listening of key events wasn’t any more difficult. Conclusion You just saw how to search for places such as restaurants, gas stations, etc., using the HERE Places API in an Android application. Being able to search for points of interest without knowing their position or address is a powerful feature that HERE offers. As previously mentioned, if you needed some help configuring your application to use HERE, check out my previous tutorial on the topic. In case you’re interested in taking this tutorial to the next level, check out my tutorial titled, Positions to Addresses with Gesture Events and HERE in Android , which should give you some new perspective on the things you can accomplish.", "date": "2018-12-20"},
{"website": "Here", "title": "Gathering the Android Device Position with the HERE Positioning API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/gathering-the-android-device-position-with-the-here-positioning-api", "abstract": "About a week ago I had written a tutorial that leveraged the HERE Places API for Android. This tutorial titled, Search for Points of Interest in an Android Mobile Application , searched for these points of interest using a fixed location relative to those places. In other words, the places found did not accurately reflect the distance from the actual device location. In a realistic, production ready, scenario, we’d want to find places relative to position of the actual Android device. Luckily, we can find the device position using the HERE Positioning API for Android. In this tutorial we’re going to revisit the previous tutorial regarding the HERE Places API, but we’re going to take it to the next level with the HERE Positioning API. To get an idea of what we want to accomplish, take a look at the following animated image: The application centers the map on our current position, made obvious with an indicator. We can then search for places nearby to the current position. In the simulator, we can change the position and the map will center itself again. This simulates what would happen if there was movement with the Android device. Before going forward, it is important to note that we won’t be discussing how to configure HERE without our Android project or how to display a map. If you’re stuck and need help with the setup, I encourage you to check out my previous tutorial titled, Getting Started with HERE Maps in an Android Application . Listening and Displaying Changes to the Device Location Rather than constantly checking to see if the position has changed for the mobile device, we’re going to configure a listener that triggers when these changes happen. However, before we do that, we need to add a few permission requirements to our manifest: <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/>\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/> If you’re targeting a more modern version of Android, you may also have to request permissions at runtime as well. With the permissions in place, we can start configuring a listener within our application. If you went through my previous tutorial, you should have the following variables or some variation of them: private Map map = null;\nprivate MapFragment mapFragment = null;\nprivate EditText editText = null;\nprivate ArrayList<MapObject> markers = null;\nprivate PositioningManager positioningManager = null;\nprivate PositioningManager.OnPositionChangedListener positionListener;\nprivate GeoCoordinate currentPosition = new GeoCoordinate(37.7397, -121.4252); The difference this time around is the positioningManager , positionListener and currentPosition variables. The positionListener will let us listen for changes, but the positioningManager will allow us to start and stop listening which could be useful when suspending or resuming the application. The currentPosition is created so we can globally keep track of the current position to be used when searching for points of interest. The next step is to configure the listener and start listening: mapFragment.init(new OnEngineInitListener() {\n    @Override\n    public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n        if (error == OnEngineInitListener.Error.NONE) {\n            map = mapFragment.getMap();\n            map.setCenter(new GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE);\n            map.setZoomLevel((map.getMaxZoomLevel() + map.getMinZoomLevel()) / 2);\n            positioningManager = PositioningManager.getInstance();\n            positionListener = new PositioningManager.OnPositionChangedListener() {\n                @Override\n                public void onPositionUpdated(PositioningManager.LocationMethod method, GeoPosition position, boolean isMapMatched) {\n                    currentPosition = position.getCoordinate();\n                    map.setCenter(position.getCoordinate(), Map.Animation.NONE);\n                }\n                @Override\n                public void onPositionFixChanged(PositioningManager.LocationMethod method, PositioningManager.LocationStatus status) { }\n            };\n\n            try {\n                positioningManager.addListener(new WeakReference<>(positionListener));\n                if(!positioningManager.start(PositioningManager.LocationMethod.GPS_NETWORK)) {\n                    Log.e(\"HERE\", \"PositioningManager.start: Failed to start...\");\n                }\n            } catch (Exception e) {\n                Log.e(\"HERE\", \"Caught: \" + e.getMessage());\n            }\n            map.getPositionIndicator().setVisible(true);\n        }\n    }\n}); After the mapping engine finishes the initialization, we can define the overrides for the onPositionUpdated and the onPositionFixChanged methods. The onPositionFixChanged is a method for if we change between GPS, and network, or other, while the onPositionUpdated is in actual changes to the latitude and longitude of the device. When the position changes we’re going to update the current position and center the map. Finally, we can add the listener to our positioningManager and start listening. Optionally, we can make the position indicator visible on the map. This takes us to the next step which is almost exactly what we’ve already seen. Searching for Places Relative to the Current Device Location With the current device position being tracked, we can make use of it in our search method that was defined in the previous tutorial . Take the new and improved search method: public void search(String query) {\n    if(!markers.isEmpty()) {\n        map.removeMapObjects(markers);\n        markers.clear();\n    }\n    try {\n        DiscoveryRequest request = new SearchRequest(query).setSearchCenter(currentPosition);\n        request.setCollectionSize(5);\n        ErrorCode error = request.execute(new ResultListener<DiscoveryResultPage>() {\n            @Override\n            public void onCompleted(DiscoveryResultPage discoveryResultPage, ErrorCode error) {\n                if (error != ErrorCode.NONE) {\n                    Log.e(\"HERE\", error.toString());\n                } else {\n                    for(DiscoveryResult discoveryResult : discoveryResultPage.getItems()) {\n                        if(discoveryResult.getResultType() == DiscoveryResult.ResultType.PLACE) {\n                            PlaceLink placeLink = (PlaceLink) discoveryResult;\n                            MapMarker marker = new MapMarker();\n                            marker.setCoordinate(placeLink.getPosition());\n                            markers.add(marker);\n                            map.addMapObjects(markers);\n                        }\n                    }\n                }\n            }\n        });\n        if( error != ErrorCode.NONE ) {\n            Log.e(\"HERE\", error.toString());\n        }\n    } catch (IllegalArgumentException ex) {\n        Log.e(\"HERE\", ex.getMessage());\n    }\n} In case you don’t see it, the only thing that changed is the following line: DiscoveryRequest request = new SearchRequest(query).setSearchCenter(currentPosition); Instead of hardcoding a current position to go with the query, we’re using the current position as defined by the HERE Positioning API . When performing the search completes, any places returned are added to the map as markers. The actual search is performed after the input field is populated and the enter key is pressed, as seen below: editText.setOnKeyListener(new View.OnKeyListener() {\n    public boolean onKey(View view, int keyCode, KeyEvent keyevent) {\n        if ((keyevent.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {\n            search(editText.getText().toString());\n            editText.setText(\"\");\n            return true;\n        }\n        return false;\n    }\n}); To clean up any loose ends, the editText and mapFragment are variables that are mapped to the components found in your XML layout. Conclusion You just saw how to use the HERE Positioning API within your Android mobile application. While the example was familiar, the emphasis was around configuring a listener position updates on the device and using that position to move on the map. As good practice, you should take into consideration the lifecycle events of Android. If you don’t specifically stop the listener when the application enters the background, battery consumption could be more than your users want.", "date": "2018-12-27"},
{"website": "Here", "title": "Location technology on the forefront of CES 2019", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/location-technology-on-the-forefront-of-ces-2019", "abstract": "CES 2019 was more than trends and more than hype – the show is where we brought our A-Game with the latest innovation in location technology. Last week, more than 182,000 people from 155 different countries swarmed in Las Vegas for the world’s largest and most famous consumer technology show, CES . Behind the shiny appearance and flashy new gadgets and appliances, CES is where you find innovative technologies that will power tomorrow’s services, which is the area where HERE brought our location technology. Beyond enterprise solutions and newly announced partnerships, we had our developer evangelists Nic Raboy and Jayson DeLancey on the ground presenting our developer portal and our public beta of HERE XYZ. By using the HERE Traffic Dashboard , we visualized what is possible with HERE Location Services. Using Isolines, a pretty neat feature hiding in our powerful Routing API, the dashboard reports real-time and anticipated congestion levels throughout the day in different cities across the world. What Isoline Routing does, is to give you an area that can be reached within a certain time frame or driving distance. In case you missed it, Richard Süselbeck wrote a step-by-step on finding your dream home using this API. In the coming weeks, look out for a behind the scenes look at how the team brought the HERE Traffic Dashboard to CES 2019. Finally, we let our booth visitors at CES 2019 explore a few of the maps we built together with Stamen to showcase how HERE XYZ will render big data sets onto maps quickly and easily. Right before we went on a well-deserved break before the show in Vegas, Dylan Babs posted how you can use HERE XYZ to ehlp others. Although the holidays are over, it is never too late to start using giving back to the community – read his tutorial to learn how. After a week jam-packed with action and kick-starting 2019 with a bang in Las Vegas, I am looking forward to a year full of exciting new technology for you to build with. I can't wait to share what's coming in the next months!", "date": "2019-01-15"},
{"website": "Here", "title": "Top Ten Developer Blog Posts of 2018", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/top-ten-2018", "abstract": "2018 proved to be quite a busy and productive year for us. From launching the most competitive freemium plan for location technology for developers on the market and giving you access to new ways for creating maps - this is our top 10 posts of the past 12 months. We are sharing our top articles in descending order - leading to the #1 developer blog post of 2018. 10: Making Maps with HERE XYZ In early October 2018, we announced a new real-time, cloud-based location management toolset called HERE XYZ . At #10 on our list is the blog post introducing HERE XYZ to developers. To learn more, visit our post Making Maps with HERE XYZ . 9: Run Circles Around GeoJSON, Beginner to Advanced with HERE XYZ With the announcement of HERE XYZ , a follow up blog post on getting developers up to speed on GeoJSON made it to #9. If you need a primer on GeoJSON, visit our post Run Circles Around GeoJSON, Beginner to Advanced with HERE XYZ . 8: Visualizing Large Scale 3D Terrain with Open Source Tools Learning how to create 3D terrain maps with open-source tools such a TIN Terrain made it to #8. If this topic interests you, visit our detailed post Visualizing Large Scale 3D Terrain with Open Source Tools . You may also like to browse similar posts featuring the tag #open-source . 7: Build your own Sightseeing App with Garmin Connect IQ and the HERE Location APIs For those interested in developing with Garmin Connect IQ, the post that made it to #7 takes you on a journey to build a sightseeing app using HERE location services. To learn more, visit our post Build your own Sightseeing App with Garmin Connect IQ and the HERE Location APIs . 6: HERE with React - A Location Based TODO App To provide direction for React developers, our #6 post is a walkthrough of creating a simple TODO app using React and our Map Image API . To learn more, visit our post HERE with React - A Location Based TODO App . 5: Our Platform Extensions are Getting a Makeover with the Fleet Telematics API Enhancements and new features to our Fleet Telematics API made #5 on our list. To learn more, visit our post Our Platform Extensions are getting a makeover with the Fleet Telematics API . 4: Displaying Places on a HERE Map in an Angular Web Application With the popularity of Angular web applications, it is no surprise that a walkthrough of how to use our location services in that context made it to #4 on our list. To learn more, visit our post Displaying Places on a HERE Map in an Angular Web Application . 3: Adding Alexa Voice Control to HERE Maps Voice interaction is becoming common place with more and more Amazon Alexa devices appearing in homes, cars, and offices. At #3 on our list is how to create an Alexa skill with logic powered by HERE location services. To learn more, visit our post Adding Alexa Voice Control to HERE Maps . 2: How to Migrate from Google Maps to HERE Dynamic Maps With a price change announcement from Google Maps in 2018, this prompted developers to explore other location service providers. With a large influx of developers switching from Google Maps to HERE, our #2 post provides guidance on how to make that switch. To learn more, visit our post How to Migrate from Google Maps to HERE Dynamic Maps . You may also like to browse all of our posts featuring the tag #SwitchToHERE 1: Our HERE Freemium Developer Plan in Detail The indisputable #1 blog post of 2018 was in connection with our announcement of a new Freemium plan for developers. A simpler registration process requiring no credit card up front and providing up to 250,000 transactions per month at no cost. If you do not have an account with HERE already, please visit our post to learn more Our HERE Freemium Developer Plan in Detail . Summary We enjoyed a busy year of activity. Do you want to learn more or keep up with our activities moving forward? Please visit our developer portal at http://developer.here.com . We look forward to even more developer engagement in 2019!", "date": "2019-01-03"},
{"website": "Here", "title": "The Mobile SDK UI Kit v2.0, Now With Navigation", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/mobile-ui-sdk-2.0-is-here-with-navigation", "abstract": "We know there’s no such thing as a complete location-enabled app without navigation. We heard you, so that’s why we went back to the drawing board and built a variety of beautiful UI components for both iOS and Android to give you access to the best in class navigation experiences today. Now, you can build your navigation enhanced apps, without compromising on the quality of the experience you provide while leveraging industry best mobile design principles. Navigation Components The HERE Mobile SDK UI Kit version 2.0 ( iOS | Android ), tailored for the HERE Mobile SDK , comes with brand new UI navigation components such as the maneuver panel, the actual speed and speed limit information components and the estimated arrival view to create compelling in-app dashboards for turn-by-turn audible and written instructions. Most of these elements are customizable, which means you can introduce any brand colors you want, change any label you need, but more importantly, change the sequence and logic of the UI screens available. And to assure that all the UI elements available in this kit stay fresh, consistent and always provide the best location experiences, we have also updated the route planer components, previously launched in version 1.0 , to improve several usage-related limitations. Available on GitHub In addition, we have greatly improved the distribution of the framework from ZIP file and a precompiled version, to a more independent and straight forward way of downloading the ZIP file through GitHub directly (but not precompiled). This switch to GitHub gives you more flexibility to use our code and apply your own customizations to the UI components through the use of the Apache 2.0 license. The HERE Mobile SDK UI Kit framework will be available via CocoaPods for iOS, or via Gradle for Android. For Android developers: https://github.com/heremaps/msdkui-android For iOS developers: https://github.com/heremaps/msdkui-ios Getting Started So, what are you getting with version 2.0? A variety of brand new UI navigation components, an uplift for the route planer components, a more straight forward open-source distribution platform and an increase in flexibility for customization. Check out the API documentation ( iOS | Android ) and Quick Start guides ( iOS | Android ) to get started.", "date": "2019-01-16"},
{"website": "Here", "title": "Interactive Isoline Grid with HERE + React + Leaflet", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/interactive-isoline-grid-with-here-react-leaflet", "abstract": "The HERE Routing API Isoline feature is great for calculating the area than can be reaching by traveling for a certain time or distance. A map isoline isn't just a normal circular radius, it is a radius calculated using the road network. For example, the following use cases can be solved with isoline routing: Which neighborhoods can I live in that are less than a 30-minute drive from my office? How far can my delivery trucks drive in any direction before they need to refuel? As a shipping management / logistics company, how can I check if my assets are within a 200-mile road network radius? In this tutorial, we'll be building a 3x3 map grid of isolines consisting of cities across the globe. The application will let a user explore travel times from a city's core based off the following parameters: radius in either distance (meters) or time (seconds) radius range traffic enabled or disabled The application will also let us change: the styles of all the maps the zoom levels of all the maps As for the tech stack, we'll be employing the help of a few different tools: HERE Maps Routing API for the isolines React for building and rendering the interface an abstraction of Leaflet via react-leaflet , a React wrapper of Leaflet HERE Map Tile API for the map tiles inside of Leaflet Why Leaflet? Leaflet is an open-source mapping library already adopted by many in the web mapping and GIS community. Many of the REST HERE Location Services are compatible with Leaflet, so it makes switching to HERE from another mapping stack easy. Let's get started! Installation To create the scaffolding for the React app, we'll be using create-react-app . Navigate to where you'd like to save your project and run the following commands in your machine's command line: npx create-react-app isoline-grid\ncd isoline-grid\nnpm start The project will require only two external packages: leaflet and react-leaflet . Go ahead and install them using npm: npm i leaflet react-leaflet react-leafet requires a quick hack to get the Leaflet CSS configured properly. Inside of public/index.html and the following line inside of <head></head> : <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" /> HERE & Location Services Next, let's go ahead and setup everything we'll need from the HERE side of things: an App Id and App Code, which can be obtained from the HERE Developer Portal . No credit card is required for sign up and requests are free up to 250K transactions per month. The HERE Map Tile API request url The HERE Routing API isoline request url Create a new file inside of the src directory called here.js : export const hereCredentials = {\n   id: 'YOUR-HERE-ID',\n   code: 'YOUR-HERE-CODE'\n}\n\nexport const hereIsolineUrl = (coords, options) => `https://isoline.route.api.here.com/routing/7.2/calculateisoline.json?app_id=${hereCredentials.id}&app_code=${hereCredentials.code}&mode=shortest;${options.mode};traffic:${options.traffic}&start=geo!${coords[0]},${coords[1]}&range=${options.range}&rangetype=${options.type}`\n\nexport const hereTileUrl = (style) => `https://2.base.maps.api.here.com/maptile/2.1/maptile/newest/${style}/{z}/{x}/{y}/512/png8?app_id=${hereCredentials.id}&app_code=${hereCredentials.code}&ppi=320`;\n\nexport const maxIsolineRangeLookup = {\n   time: 20000,\n   distance: 400000\n} Be sure to replace YOUR-HERE-ID and YOUR-HERE-CODE with the your own credentials! The functions hereIsolineUrl() and hereTileUrl() will return the appropriate request urls from the Routing API's isoline and the Map Tile API. We'll be passing options to both of these functions later on in the app. Styling create-react-app already includes a CSS file called app.css . Go ahead and delete everything in there and replace it with the following: .app {\n   height: 100%;\n   display: flex;\n   flex-direction: column;\n   position: absolute;\n}\n\n.controls {\n   box-sizing: border-box;\n   padding: 20px;\n   width: 100%;\n   display: grid;\n   grid-template-columns: repeat(6, 1fr);\n}\n\n.map-grid {\n   height: 100%;\n   width: 100vw;\n   display: grid;\n   grid: repeat(3, 1fr) / repeat(3, 1fr);\n   position: relative;\n   grid-gap: 3px;\n}\n\n.map {\n   border: 3px solid white;\n}\n\nlabel {\n   display: block;\n} map-grid is the container for all 9 of the maps. We are using CSS grid to easily create the 3 by 3 grid. Creating the Maps To house each one of our maps, we'll be creating a reusable component called MapContainer . Go ahead and create a new file titled MapContainer.js inside of the src directory. Inside of this file, we'll need to import a few things. Ensure the beginning of MapContainer.js looks like: import React from 'react';\nimport { Map, TileLayer, Marker, Polygon } from 'react-leaflet';\nimport { hereTileUrl } from './here'; Just like any other React project, we need to import react . Additionally, we are importing the react-leaflet module we will be using. We also import the hereTileUrl function to display the HERE tiles inside of Leaflet. The rest of the MapContainer component will look like: export class MapContainer extends React.Component {\n\n   constructor(props) {\n      super(props);\n      this.marker = React.createRef();\n   }\n\n   handleDrag = () => {\n      const coordinates = this.marker.current.leafletElement.getLatLng();\n      this.props.handleDrag(this.props.index, [coordinates.lat, coordinates.lng]);\n   }\n\n   render() {\n      return (\n            <Map\n               center={this.props.center}\n               zoom={parseInt(this.props.options.zoom)}\n               zoomControl={false}\n               attributionControl={this.props.index === 8}\n            >\n               <TileLayer\n                  url={hereTileUrl(this.props.style)}\n               />\n               <Marker\n                  position={this.props.center}\n                  draggable={true}\n                  onDragEnd={this.handleDrag}\n                  ref={this.marker}\n\n               />\n               {\n                  this.props.polygon.length > 0 &&\n                  <Polygon\n                     positions={this.props.polygon}\n                     color=\"#2DD5C9\"\n                  />\n               }\n            </Map>\n      )\n   }\n} Inside of render() , we are creating a few different react-leaflet components: <Map /> is the standard map controller. We are passing it the props center and zoom . attributionControl is set to only show attribution on the bottom right map, because we don't need 9 different attribution labels in our app. <TileLayer /> is where we pass the HERE Tile API url. We also pass the function the prop style , which is the style chosen by the user (day, night, normal, etc.) in the main application. <Marker /> is the blue marker on each map. This marker can be dragged to reset the position of isoline. <Polygon /> is the isoline polygon on each map. <Polygon /> is only shown if the props polygon has a length greater than 0. This is because each map's polygon array is set to an empty array before the initial call to the Routing API isoline is made (more on this in App.js ). The function handeDrag() is called when the user stops dragging the marker. This function grabs the updated position of the marker, and then sends it back up to the parent component, App.js , to update the isoline polygon with a new center. Constructing the parent component Now that we have the MapContainer all set up, let's start working on the parent component. create-react-app has already created the App.js file for us. Go ahead and delete everything in there. Add the following imports: import React from 'react';\nimport './App.css';\nimport { MapContainer } from './MapContainer';\nimport { hereIsolineUrl, maxIsolineRangeLookup } from './here'; Let's go ahead and setup the class's constructor: class App extends React.Component {\n\n   constructor(props) {\n      super(props);\n      this.state = {\n         //Coordinates are in format [Latitude, Longitude]\n         maps: [\n            {\n               name: 'Seattle, WA',\n               coordinates: [47.605779, -122.315744],\n               polygon: []\n            }, {\n               name: 'San Francisco, CA',\n               coordinates: [37.761732, -122.440343],\n               polygon: []\n            }, {\n               name: 'New York City, NY',\n               coordinates: [40.734238, -73.988188],\n               polygon: []\n            }, {\n               name: 'Berlin, Germany',\n               coordinates: [52.520609, 13.409321],\n               polygon: []\n            }, {\n               name: 'Chicago, IL',\n               coordinates: [41.884314, -87.630478],\n               polygon: []\n            }, {\n               name: 'Singapore, Singapore',\n               coordinates: [1.347920, 103.862097],\n               polygon: []\n            }, {\n               name: 'Buenos Aires, Argentina',\n               coordinates: [-34.609855, -58.443259],\n               polygon: []\n            }, {\n               name: 'Johannesburg, South Africa',\n               coordinates: [-26.205689, 28.042450],\n               polygon: []\n            }, {\n               name: 'Tokyo, Japan',\n               coordinates: [35.652832, 139.839478],\n               polygon: []\n            }\n         ],\n         options: {\n            zoom: 5,\n            type: 'distance',\n            range: 300000,\n            mode: 'car',\n            traffic: 'disabled',\n            style: 'reduced.day'\n         }\n      };\n   }\n} Inside of the constructor, we configure the initial state of the application. Inside of the state object, maps is an array of objects containing the configuration for each map. Each map object has the: name of the map (not used in the application code, just for context) coordinates: used for the center of the map view, the position of the marker, and the center of the isoline radius polygon: the array of coordinates consisting of the isoline polygon. This is an empty array for now because the initial API requests have not been made. Inside the state object, there is also another object called options . options will hold the information on the current state of the isoline and map settings. We will update this nested object when the user changes the inputs at the top of the map. Rendering the parent component Now that we've configured the initial state of the application, let's write some code on what the application should render. Inside of the App.js 's App Component, let's add a render function: render() {\n\n   const max = this.state.options.type === 'distance' ?\n      maxIsolineRangeLookup.distance :\n      maxIsolineRangeLookup.time;\n\n   const sliderVal = this.state.options.range > max ? max : this.state.options.range;\n\n   return (\n      <div className=\"app\">\n         <div className=\"controls\">\n            <div>\n               <label htmlFor=\"type\">Distance or Time</label>\n               <select\n                  id=\"type\"\n                  value={this.state.options.type}\n                  onChange={this.handleFormChange}\n               >\n                  <option value=\"time\">Seconds</option>\n                  <option value=\"distance\">Meters</option>\n               </select>\n\n            </div>\n            <div>\n               <label htmlFor=\"range\">\n                  Range ({parseInt(this.state.options.range).toLocaleString()})\n               </label>\n               <input\n                  id=\"range\"\n                  onChange={this.handleFormChange}\n                  type=\"range\"\n                  min=\"1\"\n                  max={max}\n                  value={sliderVal}\n               />\n            </div>\n            <div>\n               <label htmlFor=\"mode\">Mode</label>\n               <select\n                  id=\"mode\"\n                  onChange={this.handleFormChange}\n                  value={this.state.options.mode}\n               >\n                  <option value=\"car\">Car</option>\n                  <option value=\"pedestrian\">Pedestrian</option>\n               </select>\n            </div>\n            <div>\n               <label htmlFor=\"traffic\">Traffic</label>\n               <select\n                  id=\"traffic\"\n                  onChange={this.handleFormChange}\n                  value={this.state.options.traffic}\n               >\n                  <option value=\"enabled\">Traffic Enabled</option>\n                  <option value=\"disabled\">Traffic Disabled</option>\n               </select>\n            </div>\n            <div>\n               <label htmlFor=\"zoom\">Zoom Level ({this.state.options.zoom})</label>\n               <input\n                  id=\"zoom\"\n                  onChange={this.handleFormChange}\n                  type=\"range\"\n                  min=\"1\"\n                  max=\"16\"\n                  value={this.state.options.zoom}\n               />\n            </div>\n            <div>\n               <label htmlFor=\"style\">Map Style</label>\n                  <select\n                     id=\"style\"\n                     onChange={this.handleFormChange}\n                     value={this.state.options.style}\n                  >\n                     <option value=\"reduced.day\">Reduced Day </option>\n                     <option value=\"reduced.night\">Reduced Night</option>\n                     <option value=\"normal.day\">Normal Day</option>\n                     <option value=\"normal.night\">Normal Night</option>\n                  </select>\n            </div>\n         </div>\n         <div className=\"map-grid\">\n            {this.state.maps.map((map, index) =>\n               <MapContainer\n                  key={index}\n                  index={index}\n                  center={map.coordinates}\n                  options={this.state.options}\n                  handleDrag={this.handleDrag}\n                  polygon={map.polygon}\n                  style={this.state.options.style}\n               />\n            )}\n\n         </div>\n      </div>\n   );\n} Inside of render() , we are rendering the two main parts of the application: the controls area and the maps. Inside of the <div> with the className controls , we are rendering 6 different inputs. With each input, we have attached onChange events, so the maps can change dynamically based on these values (more on this soon). OPTIONAL NOTE: experienced React developers may notice that onChange will lead to a large queue of triggered API requests from the range slider. If you would like to modify the range slider's behavior to only trigger the API request once the range slider has stopped receiving input, consider d ebouncing `handleFormChange` . This tutorial does not require any action on this topic. Scroll down through the controls <div> until you find the map-grid <div> . Inside of this <div> is where we will render each of the nine maps. I used the .map() function to conveniently return each of the 9 maps with the required props. Some of the important props: handleDrag is the event handler prop for when the user drags the position of the marker polygon is the isoline polgyon data passed down to the map container to render Calling the Routing API for Isolines Inside of the App Component, paste the following code: updateIsolines = () => {\n   const promises = this.state.maps.map(m => fetch(hereIsolineUrl(m.coordinates, this.state.options)).then(x => x.json()));\n   Promise.all(promises).then(res => {\n      const copy = this.state.maps.map((x, i) => {\n         x.polygon = res[i].response.isoline[0].component[0].shape.map(x => [x.split(',')[0], x.split(',')[1]]);\n         return x;\n      });\n      this.setState({\n         maps: copy\n      });\n   });\n}\n\ncomponentDidMount = () => {\n   this.updateIsolines();\n} When the application starts, we'll want to call the Routing API for the isolines. With React, the appropriate lifecycle function for this is componentDidmount() . However, we will be writing code to update all the isolines at once later on in the application. For example, we'll need to update each map's isoline when the user changes a value through the inputs at the top of the page. Because of this, I decided to create a shared function called updateIsolines() . updateIsolines() will make a request to the Routing API and then update each state 's map polygon array with updated data. Whenever the application's state is updated, React will go ahead and update the application's UI. What about when I don't need to update every isoline at once? When the user drags a marker around on a map, we need to present a new isoline. However, when the user drags a marker on one map, it doesn't affect the other map's isolines. Due to this, it would be inefficient to call updateIsolines() on the marker drag event. Let's write some code to only update a single isoline at a time. Add the function handleDrag() to the App component: handleDrag = (index, coordinates) => {\n   fetch(hereIsolineUrl(coordinates, this.state.options))\n   .then(res => res.json())\n   .then(res => {\n      const copy = this.state.maps.slice();\n      if (res.hasOwnProperty('response')) {\n         copy[index].polygon = res.response.isoline[0].component[0].shape.map(x => [x.split(',')[0], x.split(',')[1]]);\n      } else {\n         copy[index].polygon = [];\n      }\n      copy[index].coordinates = coordinates;\n      this.setState({\n         maps: copy\n      });\n   });\n} handleDrag() is only called when a marker is moved on a map. The function works similar to updateIsolines() , except we only update one map's isoline. Additionally, I've added some basic error handling in the event the user drags a marker to an area where an isoline is not available, such as an ocean or a lake. Adding life to the control inputs Our app is currently rendering the input controls at the top of the page, but we haven't written any code to connect the inputs to the application. Inside of the App component, let's add our final function to the application: handleFormChange = (event) => {\n   const option = event.target.id;\n   const value = event.target.value;\n   const copy = this.state.options;\n   if (option === 'type' && this.state.options.range > maxIsolineRangeLookup[value]) {\n      copy.range = maxIsolineRangeLookup[value];\n   }\n   copy[option] = value;\n   this.setState({\n      options: copy\n   }, () => {\n      this.updateIsolines();\n   });\n\n} handleFormChange() is called whenever one of 6 inputs is changed. The function updates the app's state , specifically the options object. This function also contains some logic around limiting the max range value. The max range for a distance isoline is 400,000 meters, while the max range for a time isoline is 20,000 seconds, so we'll want to update the value of the range when switching between the two types of ranges to avoid any errors with passing too large of values to the Routing API isoline. Wrapping it all up By now, you will have a working isoline grid application. It's fun to play around and compare the possible travel radiuses between the different cities. Feel free to edit the default cities in the application's state to add some more relevant cities to you. Take a look at the live demo or project's the source code . Make anything cool with HERE location services? Be sure to share with us on Twitter at @dbabbs or @heredev . Happy coding!", "date": "2019-01-16"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.2.0 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.2.0-release", "abstract": "Highlights Account & Permissions Group Level Administration Any users can now create groups, reducing the burden on organization level Admin to administer all groups. The creator of the group becomes the default Group Admin, giving them permissions to administer the group, including: Add users and apps to the group Remove users and apps from the group Delegate other users in the group as Group Admins. With this change, the former Admin role is now an Org Admin. As before, Org Admins can manage group membership, but they also now receive the ability to delegate other users in a group to be Group Admins. Therefore, groups can now be administered by: the creator of the group a delegated Group Admin an Org Admin In the event that you created many Org Admins to distribute the administrative load, you can now reduce the number of Org Admins, relying instead of self-organizing groups to administer their own membership. Note that new users must be invited by an Org Admin, as before. Map Content Map data version is as follows: Global View, including: Asia Pacific (APAC) Middle east / Africa (MEA) India (RN) Antarctica (ANT) Taiwan (TWN) South America (SAM) Western Europe (WEU) Australia (AU) North America (NA) Eastern Europe (EEU) Pipelines Known Issues Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue If multiple pipelines consuming data from a single stream layer all belong to the same group (pipeline permissions are managed via a group), then each of those pipelines will only receive a subset of the messages from the stream. This is due to the fact that the pipelines share the same Application ID. Workaround Use the Data Library to configure your pipelines to consume from a single stream. If your pipelines/applications use the Direct Kafka connector type, you can specify a Kafka consumer group ID per pipeline/application. If the Kafka consumer group IDs are unique, the pipelines/applications will consume all messages from the stream. If your pipelines use the HTTP connector type, we recommend that you create a new group for each pipeline/application, each with its own application ID. Issue Pipelines are not private to a user by default; they must be shared with exactly one group when created. Workaround Share the pipeline with a group containing only one user. Issue Pipelines can only be shared with users who belong to the same group. Workaround Share the pipeline with a group containing the specific set of users. Data Added The HERE Live Weather Europe data catalog has increased coverage into Eastern Europe. Known Issues Issue Catalogs not associated with a realm are not visible in OLP. Issue Data encryption is limited to: Versioned data at rest Stream layer data Index layer data Notebooks In-flight data encryption is not consistently implemented across OLP. You should not send sensitive data or personal information to OLP at this time. Issue When you use the Data API or Data Library to create a catalog or layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps and groups. Issue When creating an Index Layer and processing stream data in a data archive pipeline, it is possible to select Parquet as a data format. However, a corresponding Spark Connector is not available with this release, making it non-trivial to consume data in this format. As a mitigation, we recommend you not use Parquet format with this release. Issue Some older catalogs cannot be shared temporarily because the catalog owners don't have permissions assigned to them yet. This issue only applies to older catalogs. Contact us to report each occurrence as a bug. Notebooks Known Issues Issue Notebooks do not support Flink. Issue Neither platform.here.com nor Notebooks are compatible with Internet Explorer 11. Issue Notebooks do not contain support for Stream Layers. Issue Notebooks only support Python 3. Account & Permissions Added Added feature for group level administration. Any users can now create groups. Groups are administered by the group creator, by designated group admins, and/or by organization admins. Known Issues Issue A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Delete pipelines/pipeline templates to recover space. Issue All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue When updating permissions, it can take up to an hour for changes to take effect. Map Content Added The following new layers have been introduced in HERE Map Content. HERE Map Content: HERE Places HERE Map Content: Places for HERE Essential Map HERE Map Content: Places Metadata Changed This section describes data format version changes. Old Version New Version Change v2:2.4.0 v2:2.5.0 Released Places protos v2:2.5.0 v2:2.6.0 Added SocialSignal message to Places proto HERE Map Content uses the following data formats: Data Format hrn:here:schema:::com.here.schema.rib:topology-geometry_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:road-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:address-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:administrative-places_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:placelocations_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:cartography_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:building-footprints_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:navigation-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:advanced-navigation-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:lane-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:street-names_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:road-traffic-pattern-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:adas-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:trasnport-attributes_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:meta_v2:2.6.0 hrn:here:schema:::com.here.schema.rib:places_v2:2.6.0 Known Issues Issue The coverage for the ADAS layer is initially limited to North America and Western Europe. Workaround Additional HERE Map Content coverage and inclusion details can be obtained by OLP Customer Solutions or OLP Technical Customer Support. Marketplace Known Issues Issue After a Catalog is marked \"Marketplace Ready\", the Catalog may take up to 2 hours to show in the Provider Management Group's list of Catalogs. Workaround Contact technical support if the Provider Management Group cannot see the Marketplace Ready catalog after more than 2 hours has passed. Issue When a Marketplace Provider grants data access to a Marketplace Consumer, there could be a delay before the Consumer can see the data catalog in their licensed data area. Workaround Contact technical support if the Consumer Management Group cannot see the licensed data after more than 2 hours has passed. Issue If you are a Workspace user and have pipelines that use the Kafka Direct connector to connect to stream data, no messages-in and bytes-in metrics can be collected. Workaround You can instrument your pipelines with custom messages-in and bytes-in metrics. Contact technical support if you need assistance. Issue Marketplace users do not receive stream data usage metrics when reading data from Kafka direct. Workaround You must write data to a stream layer using the Ingest REST API in order to receive usage metrics. You must use the Data Library configured to use the HTTP connector type in order to receive usage metrics and read data from a stream layer. Web & Portal Known Issues Issue Data visualization in the Portal is only available for versioned and volatile layers. Workaround Create your own visualization for your own schemas creating a GeoJSON renderer and making it part of that schema. Out of the box, however, only data can be visualized that is formatted according to the following schema formats: GeoJSON HERE Reality Index Topology HERE Reality Index Building Footprints HERE Reality Index Cartography HERE Traffic Flow SDII Issue Some PDF documentation has formatting errors. Issue The custom runtime configuration for a pipeline version has a limit of 64 characters for the property name, and a limit of 255 characters for the value. Workaround For the property value, there is no workaround. For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. Issue The Portal can't be used to delete pipeline templates. Workaround Use the CLI or API to delete pipeline templates. Issue In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list. Issue The Portal can't be used to force a batch pipeline version to run. It will run on its own when the input catalogs' version is updated. Workaround Use the CLI or API to force a batch pipeline version to run, or wait for the input catalogs' version to update. For more information, see the Troubleshooting section in the Pipelines Developer Guide . Issue The pipelines list page is sometimes slow to load. Issue Some older catalogs cannot be shared temporarily because the catalog owners don't have permissions assigned to them yet. This issue only applies to older catalogs. Contact us to report each occurrence as a bug.", "date": "2019-01-15"},
{"website": "Here", "title": "January 2019 Release Highlights", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/january-2019-release-highlights", "abstract": "All services receive map content updates frequently, but we will call out a few noteworthy highlights related to the following services: Positioning API , Routing API , Fleet Telematics API , Geocoder Autocomplete and HERE Android & iOS SDKs . There were minor updates and fixes across many other services which were related to regular maintenance releases.  View the API Version History for previous updates including change log and release notes for all of the APIs. Positioning API Provides positioning estimates based on global Wi-Fi and Cell coverage. Learn more... Version 1.7.0 Support for positioning based on a single WLAN access point.  The more access points you have the more accurate the fix, but previously a minimum of 3 was required which for some remote locations is not possible. Support for HTTP/2. Routing API Provide precise instructions to a destination using various transport modes (e.g. car, truck, public transit, bicycle) and leveraging different algorithms (e.g. matrix, isoline routing). Learn more... Version 7.2.100 Added support for license plate based restrictions in Indonesia and Phillippines. New option excludeZones and excludeZoneTypes can be used to specify areas that the route should avoid.  For example, certain roads have road pricing for the period of time a vehicle may use the road called a vignette .  You can route to avoid locations where this is required to use the affiliated roads.  See RoutingZoneTypeType for more examples. Fixed issue of single and tandem axle weight restrictions being evaluated as gross weight restrictions. Increased range of U-turn types avoided when requested to avoid difficult turns. Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Learn more... Version 2.5.11 New request parameter &ignoreWaypointVehicleRestriction to force routing to reach a waypoint despite vehicle access or weight restrictions along route. New Platform Data Extension (PDE) layer ENV_ZONE_RESTR that contains access restriction details for environmental zones.  This can be used for route planning and driver alert purposes. HERE Android SDK Full-featured, native apps on Android with our mapping platform. Learn more... Starter Edition Version 3.10 Updated for Android API 28 with deprecation of andorid.app.Fragment corresponding to deprecated com.here.android.mpa.mapping.MapFragment . Introduced com.here.android.mpa.mapping.SupportMapFragment to replace deprecated MapFragment. Premium Edition Version 3.10 In addition to the changes mentioned in the Starter Edition Implemented truck specific ETA calculation model. Enabled turn-by-turn guidance for bike routing. Implemented set/get course for any waypoints on the route. Additional error reporting when re-routing operations fail. Added customized stopover callbacks. Added feature to retrieve total distance on a route. Added feature to specify a wait time for each waypoint on a route. Enriched data with time to arrival (TTA) details for sublegs of a route. Autosuggest for place search is now supported in offline mode. Added feature to retrieve remaining distance during assisted guidance. Added possibility to customize upcoming part of the route. Configurable cache size (64MB - 1000MB). Maneuver restrictions on motorcycle turns implemented as cost table. Fixed positioning latency issues resolved. Improved map representation in Mercator Projection. Simplified the creation of MapMarker objects. HERE iOS SDK Full-featured, native apps on iOS with our mapping platform. Learn more... Starter Edition Version 3.10 Added support for new iPad Pro (released on Oct 30, 2018). Improved error handling. Premium Edition Version 3.10 In addition to the changes mentioned in the Starter Edition Implemented truck specific ETA calculation model. Enabled Turn by Turn guidance for bike routes. Implemented possibility to set/get course for all waypoints on the route. Added error reporting when re-routing fails. Added possibility to customize stopover reached callback. Added feature to retrieve distance on route. Added feature to specify wait time for each waypoint. Added possibility to retrieve TTA for specific subleg. Supported offline mode for Autosuggest. Added feature to retrieve remaining distance during guidance. Added possibility to customize upcoming part of the route. Added ability to configure cache size (64MB - 1000MB). Implemented maneuver restrictions on motorcycle turn cost tables. Fixed positioning latency issue. Improved MapLoader stability. Added support for new Apple iPad Pro. Added possibility to retrieve route element by duration. HERE Mobile SDK User Interface (UI) Kit Learn more about the v2.0 announcement described in more detail in The Mobile SDK UI Kit v2.0 is HERE with the Most Requested Component Navigation . Version 2.0 Completed guidance experience and components. Route planner improvements. Customization improvements. Integration of the HERE SDK 3.9. Support for XCode 10 and Swift 4.2. The project is now open source! Android: https://github.com/heremaps/msdkui-android iOS: https://github.com/heremaps/msdkui-ios Geocoder Autocomplete Correct misspellings and get better suggestions for your address search with fewer keystrokes. Learn more... For certain postal code queries, a list of cities encompassed by the postal code will be returned instead of a list of counties.  For example, a search for \" France, 78660 \" will include cities Orsonville , Boinville-le-Gaillard , Allainville , Ablis , etc. instead of only the county Yvelines .", "date": "2019-01-22"},
{"website": "Here", "title": "Getting Started with HERE using Kotlin and the Android SDK", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/getting-started-with-here-using-kotlin-and-the-android-sdk", "abstract": "About a month or so ago I had written a tutorial for getting started with HERE using Java and the Android SDK . Even though documentation for the job already existed, I wanted to put my own spin on the process to try to make it a little easier. While Java is great, it is becoming a relic of time and slowly being replaced with Kotlin , which is considered to be the new hotness. Kotlin can compile to bytecode for the JVM and in these circumstances we can reproduce all of our Java applications with Kotlin, an entirely different, but increasingly popular language. In this tutorial, we’re going to see how to build an Android application using Kotlin that displays a HERE map. To get some perspective, we’re going to try to accomplish the following: If you think the above image looks familiar, it is because it is the same example I used in my previous tutorial. We are literally just going to be displaying an interactive map. While it might sound easy, there is some configuration that must be done to make it possible. Creating a New Android Studio Project with Kotlin Support You don’t need Android Studio to work with Kotlin or to build Android applications, but it makes life a whole lot easier. For this reason, Android Studio will be the focus for our example. I’m using Android Studio 3.3, so if you’re using a different version you might have to fill in the gaps. To start things off, choose to create a new project. Because this is a very basic example, make sure to create a project with an empty activity. If you’re feeling adventurous, pick what you feel is the most appropriate or make an attempt to use your existing project. After choosing to use an empty activity, we need to define our API versions, package naming, and language. There are two very important things to take note of at this step. You need to carefully pick your package name and make note of it because this package name will need to be used in your HERE Developer Portal. Mismatching the package will cause your API keys to not work. You’ll also need to choose Kotlin as the language rather than Java. At this point your project should be created. Android Studio will probably spend a bit of time synchronizing your dependencies. Installing and Configuring the HERE Android SDK This is where we start integrating the HERE Android SDK so it can be used in development. If you don’t already have a HERE developer account, make sure you create one here . Don’t worry, developer accounts are free and you don’t even need to provide a credit card. You’ll want to create a new project in your developer account and generate a new Android SDK Starter . Remember to provide your Android package when generating your API tokens. After generating a new Android application in the portal, you’ll need to download the SDK. After downloading the SDK, locate the HERE-sdk.aar file and place it in your project’s app/libs directory. Within Android Studio, open the project’s build.gradle file and include the following: apply plugin: 'com.android.application'\n\napply plugin: 'kotlin-android'\n\napply plugin: 'kotlin-android-extensions'\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"com.example.raboy\"\n        minSdkVersion 21\n        targetSdkVersion 28\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    repositories {\n        flatDir {\n            dirs 'libs'\n        }\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation\"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n    implementation 'com.android.support:appcompat-v7:28.0.0'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.3'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n    implementation(name:'HERE-sdk', ext:'aar')\n    implementation 'org.locationtech.jts:jts-core:1.15.0'\n    implementation 'com.google.code.gson:gson:2.8.0'\n} Most of the above configuration already existed in our build.gradle file. We added the following so that we can use local libraries: buildTypes {\n    release {\n        minifyEnabled false\n        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n    }\n} After including our local libraries, we need to use them as dependencies, hence the following implementation lines: implementation(name:'HERE-sdk', ext:'aar')\nimplementation 'org.locationtech.jts:jts-core:1.15.0'\nimplementation 'com.google.code.gson:gson:2.8.0' As of now the HERE Android SDK has been included for use in our project, but not yet configured. The rest of the configuration will happen in the project’s AndroidManifest.xml file. Open the project’s AndroidManifest.xml file and include the following: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.raboy\">\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n    <application\n            android:allowBackup=\"true\"\n            android:icon=\"@mipmap/ic_launcher\"\n            android:label=\"@string/app_name\"\n            android:roundIcon=\"@mipmap/ic_launcher_round\"\n            android:supportsRtl=\"true\"\n            android:theme=\"@style/AppTheme\"\n            android:hardwareAccelerated=\"true\">\n        <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n        <meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-TOKEN-HERE\"/>\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n    </application>\n</manifest> There are a few things that we added to make using the HERE Android SDK possible. First we needed to define permissions so the application could use various location features on the device. These permissions are seen below: <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n<uses-permission android:name=\"android.permission.INTERNET\"/>\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/> After adding the appropriate permissions, we need to link our application to the credentials found in our HERE Developer Portal. This is where the app id and app code become important. <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n<meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-TOKEN-HERE\"/> Make sure that you use the tokens found in your account, otherwise the map will not display and you won’t have all the great features that HERE has to offer. Finally, you’ll notice that we have enabled hardware acceleration through the android:hardwareAccelerated=\"true\" line. We can start using the HERE Android SDK for development as of now. To be honest, most of the above configuration and setup was the same as the Java version found in my previous tutorial . Displaying an Interactive Map on the Screen with Kotlin Kotlin is great, but I’m far more fluent in Java and other programming languages. While everything you see next will work, go easy on me because I’m not a Kotlin professional and power user. I’m learning like everyone else, so if you find something that can be optimized, let me know. We’re going to start by creating our simple UI. Open the project’s activity_main.xml and include the following: <LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"fill_parent\"\n    android:layout_height=\"fill_parent\"\n    android:orientation=\"vertical\" >\n    <fragment\n        class=\"com.here.android.mpa.mapping.SupportMapFragment\"\n        android:id=\"@+id/mapfragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"/>\n</LinearLayout> Take note of the mapfragment fragment id because it will be used in our Kotlin code. With our super simple UI out of the way, let’s get into the bulk of our code. Open the project’s MainActivity.kt file and include the following: package com.example.raboy\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport com.here.android.mpa.common.GeoCoordinate\nimport com.here.android.mpa.common.OnEngineInitListener\nimport com.here.android.mpa.mapping.Map\nimport com.here.android.mpa.mapping.SupportMapFragment\n\nclass MainActivity : AppCompatActivity() {\n\n    private var map : Map = Map()\n    private var mapFragment : SupportMapFragment = SupportMapFragment()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        mapFragment = getSupportFragmentManager().findFragmentById(R.id.mapfragment) as SupportMapFragment\n        mapFragment.init { error ->\n            if (error == OnEngineInitListener.Error.NONE) {\n                map = mapFragment.map\n                map.setCenter(GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE)\n                map.zoomLevel = (map.maxZoomLevel + map.minZoomLevel) / 2\n            }\n        }\n    }\n} In the above code we are defining two private variables. The mapFragment variable will be tied to our UI component while the map variable will allow us to interact with the map component residing in the UI component. After the activity is created, we get our fragment and initialize it. If there are no errors, we can center the map and set the zoom level. Of course we could do other things such as find places, but this is a simple example. Run the application and see all of its simplistic glory! Conclusion You just saw how to use Kotlin and the HERE Android SDK to create an Android application with maps and location services support. For this particular example, most of the tutorial was preparation and it really wasn’t too different than the Java version that I had written about previously. However, the core application logic used Kotlin instead of Java.", "date": "2019-01-23"},
{"website": "Here", "title": "Exploring HERE Mobile SDK UI Kit 2.0 for iOS", "author": ["Thomas Lucka"], "link": "https://developer.here.com/blog/guide-me-to-here-exploring-here-mobile-sdk-ui-kit-2.0", "abstract": "Have you seen Groundhog Day ? Sometimes I feel like Phil Connors being caught in a time loop. Each day, before driving to HERE, I pull out my good old iPhone, lift it to the cup holder in my car, mumble the magic spell: “Hey, Siri, start HERE WeGo app.” and then – – – nothing more happens. The app has started, but that’s it. Again, I look at the display and then I begin to type in the same sequence of commands each day, all over again. Finding a destination, calculating car routes, selecting the fastest route, starting navigation. Too much repetition. Saving some additional time in the morning would be great, or? What if the app already knew where I want to go? Why not build my own guide to HERE? If you’ve read our last blog post , you may have heard already about the new HERE Mobile SDK UI Kit, v2.0 (MSDKUI). It is available for iOS and it looks like the perfect little helper to efficiently build user interfaces on top of the HERE Mobile SDK. User interfaces that look good on a variety of different devices and across different languages … sounds promising.  There is also an Android variant available with almost the same feature set. Now we have an idea for a new app to save you, me and everybody else with the same destination any time in the morning – and we have a promising new UI framework from HERE at our hands. For our app idea, we’ll also need the help of the HERE Mobile SDK to get directions and to perform or carry out the navigation – moreover, the MSDKUI framework is specifically designed to work in hand with the HERE Mobile SDK, so both kind of make up a dream team. If you are new to this dynamic duo, don’t worry. Following this blog post should inspire you into building your own time-saving apps in no matter of time. Let’s see how far we can get in a couple of minutes. Getting Started So, where to start? From a first quick look at the MSDKUI’s documentation , these three UI building blocks look promising: GuidanceManeuverView : To show instructions for the upcoming maneuvers. GuidanceSpeedView : To show the current speed and to indicate overspeeding. GuidanceSpeedLimitView To show possible speed limits along the way. Let’s keep it simple. Our app has just one purpose. It should guide the user to the HERE Berlin office (… yes, because this is where I work, but you can choose a different destination). As soon as the app opens, navigation begins. No user interaction, very Siri-friendly. Although this concept looks straightforward at first glance, there are some hurdles. The HERE Mobile SDK is headless, it does not contain any maneuver icons. The information about a route is pure data. How many different maneuver icons and instruction sets exist to guide a user safely while driving? How to parse the raw route data and extract information from it? And how to combine all that into a user-friendly UI? This sounds time-costly and we really don’t want to go into details here. Fortunately, this is where the MSDKUI comes in. We begin with an empty Xcode iOS project, using Xcode 10.1 and iOS 12. Xcode’s Single View App template is sufficient. As language, we select Swift. The next thing we want to do is to get the required dependencies into our project. CocoaPods is a great tool for that. In our case, we want to integrate the HERE Mobile SDK for iOS and its friendly tandem partner, the MSDKUI (HEREMapsUI) framework v2.0. Close Xcode and create a new Podfile with the following contents: target 'GuideMeToHERE' do\n    platform :ios, '12.0'\n    pod 'HEREMapsUI', '2.0'\nend Then navigate from the Terminal to your Xcode project folder and execute: pod install --repo-update This will do the magic and integrate not only the MSDKUI 2.0 into our empty project, but also the HERE Mobile SDK. If all goes well, you should see the HERE Mobile SDK in the new Pods folder in your project, including all the example apps, all the necessary documentation, and more. It’s time to go back to Xcode. Keep in mind that CocoaPods creates a new workspace. Don’t double-click the *.xcodeproj to open your project – always use *.xcworkspace . The last hurdle we have to take is to enter our HERE credentials. While the MSDKUI is free and open-source, it’s good news that the HERE Mobile SDK with the new Freemium plan is free too. It only requires registration at developer.here.com to get access to HERE’s excellent map data. Make sure to remember the bundle identifier you have used when registering your app. This bundle identifier should be set in the project’s Identity tab, right under the Display Name of your app. We have chosen: com.here.msdkui.example , but probably you want to change that. As for every iOS project, we have two Swift files: AppDelegate.swift and ViewController.swift . With the credentials at hand, open the AppDelegate and add the code to authenticate yourself. It should look like below: func application(_ application: UIApplication,\n                 didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    // Set credentials (based on bundle identifier).\n    let appId = \"YOUR_APP_ID\"\n    let appCode = \"YOUR_APP_CODE\"\n    let licenseKey = \"YOUR_LICENSE_KEY\"\n    let error = NMAApplicationContext.setAppId(appId, appCode: appCode, licenseKey: licenseKey)\n    assert(error == NMAApplicationContextError.none, \"Please make sure to set valid HERE credentials.\")\n    return true\n} Don’t forget to enter your own credentials and to add an import for the NMAKit at the top of the file. User Interface Layout Once done, it’s time to think about the app’s user interface and where to put our three shiny new MSDKUI v2.0 components. Since we want to use the app for our daily commuting to HERE, it should be easy to drop the phone upright to the car’s cup holder (if you’ve got one). And for that, it makes sense to choose Portrait in Xcode’s Deployment Info -> Device Orientation settings. For building beautiful layouts, it is convenient that the MSDKUI’s UI components behave just like any other UIView , in fact they are descendants of UIView . This helps to quickly stitch together our main view in Xcode’s Interface Builder . If you are new to working with Interface Builder , you can find a good introduction on Apple’s developer sites . This is how our layout looks like (of course, yours can be different): The layout in Xcode’s Interface Builder We have not done anything fancy here, it’s just our three UI components from the MSDKUI v2.0 library and a map view. The GuidanceManeuverView sits at the top edge and the speed views are at the lower left and right screen corners: Current speed indication is left and and the speed limit view on the right. Plus, there is not much MSDKUI specifics involved here. In Xcode’s Interface Builder , we open the library view, drag a UIView above the map view, and in Identity Inspector for Custom Class we type: GuidanceManeuverView in Class , and MSDKUI for Module . As a constraint, we set 128 px for height . Below, we set GuidanceSpeedView and GuidanceSpeedLimitView in a similar fashion. Note that you do not need to set the Module for the NMAMapView as it is part of the HERE Mobile SDK. In the screenshot above you can see the completed layout and the constraints we have used for each view (if you have sharp eyes, but feel free to use your own values). Typically, you’ll want to reference your views from code. This is achieved by Control-dragging each view to a ViewController . Open Main.storyboard to see the Interface Builder . In the upper right corner click the two circles to show the Assistant editor. This will allow you to see the layout and the ViewController code side by side. Now, on your keyboard hold down the Control-key and click with the left mouse button on one of your views. Then move the mouse to the ViewController and lift it. In the popup, you can enter a variable name of your choice. Once done, it should look like this: @IBOutlet weak var mapView: NMAMapView!\n@IBOutlet weak var guidanceManeuverView: GuidanceManeuverView!\n@IBOutlet weak var guidanceSpeedView: GuidanceSpeedView!\n@IBOutlet weak var guidanceSpeedLimitView: GuidanceSpeedLimitView! Xcode warns that it does not know these components, so we’ll add the required imports above the import for Apple’s UIKit: import MSDKUI // This is needed for the HERE Mobile SDK UI Kit framework.\nimport NMAKit // This is needed for the HERE Mobile SDK for iOS.\nimport UIKit Current Position As always, there’s one more thing. We already know that our app needs the user’s current position. Since this is sensitive data, iOS will prompt the user for permission. This can be requested by adding location-services to the UIRequiredDeviceCapabilities key in the app’s Info.plist , along with a NSLocationWhenInUseUsageDescription . You can inspect the Xcode project on GitHub for an example . So far, so good. That was all the preparation work. From now on we only have to write some Swift code and that’s gonna be pure coding fun, so lean back, take a deep breath and recap what we want to achieve: When the application starts, we want to find out the current position. Once we have a valid position, we calculate a route from that position to HERE’s Berlin office. If we have the route calculated, we start turn-by-turn navigation and expect the app to guide us safely to HERE. Step one: How can we find the user’s position? Since we already included the HERE Mobile SDK, we can simply start the NMAPositioningManager of the SDK. This step does not include any MSDKUI v2.0 code, so we’ll keep it short here and just introduce a convenient method called findCurrentPosition() that will just do what it says. Along with that, we also do some little map preparation work, like enabling visualization of 3D buildings by setting mapView.landmarksVisible = true . I think it looks cool to see some of Berlin’s iconic attractions like the Brandenburger Gate in 3D while getting stuck in a traffic jam. Note that all of this can be found in the accompanying example app , if you are interested. For example, if you’ll always want to start from the same location, then feel free to provide a hard-coded coordinate. If it’s your app, you can do with it what you want. Calculate Route Now, let’s go on to step two. We need to calculate the route we want to use for navigation. Let’s see how this could be implemented (as always there are many ways to Rome, errr …, HERE). The NMACoreRouter , as its name implies, does the job to calculate the desired route for us: private func calculateRoute(currentGeoCoordinates: NMAGeoCoordinates) {\n    let startWaypoint = NMAWaypoint(geoCoordinates: currentGeoCoordinates)\n    let destinationWaypoint = NMAWaypoint(geoCoordinates: geoCoordinatesOfHEREBerlin)\n    let waypoints = [startWaypoint, destinationWaypoint]\n\n    coreRouter = NMACoreRouter()\n    coreRouter.calculateRoute(withStops: waypoints, routingMode: NMARoutingMode()) { routeResult, error in\n        if error != NMARoutingError.none {\n            print(\"Error: Routing failed. Maybe you are overseas?\")\n            return\n        }\n\n        guard let route = routeResult?.routes?.first else {\n            print(\"Error: No route found.\")\n            return\n        }\n\n        // Use the route to set up UI and start guidance.\n    }\n} As you may know, HERE Berlin is located at Invalidenstraße 116, 10115 Berlin in Germany. The exact location is 52.53102 (latitude) and 13.3848 (longitude), which we stored as geoCoordinatesOfHEREBerlin . The user’s current position will serve as starting point and the HERE office as destination. If you are not working at HERE , don’t feel sad, you can adapt the coordinates. By default, the NMACoreRouter will calculate only one route ( routingMode.resultLimit = 1 ) and it’s using NMATransportMode.car as default transportMode . Once we have the route , there are two things to do, setting up our UI and – obviously – starting guidance. Before we look at the first one, let’s recap what we want to show on the screen. First off, there’s the GuidanceManeuverView on top of the map, plus we have two indicators for current speed and speed limit. We already placed all three MSDKUI views on the screen. The main question left is how to get our data into the view. How does this all fit together? Luckily, most MSDKUI components follow a simple pattern that consists of three elements: A monitor to get notified on new data, the data itself that can be inspected or altered and finally, the view where you can feed the data into. Since a view serves a specific purpose, its data will be specific too. Therefore, the MSDKUI provides dedicated classes to monitor and to provide that data. In our case, we need to provide maneuver data to show in the GuidanceManeuverView provide speed data to show in the GuidanceSpeedView provide speed limit data to show in the GuidanceSpeedLimitView Since the data for GuidanceSpeedView and GuidanceSpeedLimitView is quite similar, the MSDKUI provides the same monitor for both. Therefore, we only need to declare two different monitors: private var guidanceManeuverMonitor: GuidanceManeuverMonitor!\nprivate var guidanceSpeedMonitor: GuidanceSpeedMonitor! The guidanceManeuverMonitor notifies on new maneuver data. This data we can then pass to the GuidanceManeuverView . Similarly, the guidanceSpeedMonitor will deliver the speed information we can show in the GuidanceSpeedView and the GuidanceSpeedLimitView . Let’s begin with the GuidanceManeuverMonitor . At first, we need to create a new instance and pass the data object of interest: The route we have calculated in the previous step: guidanceManeuverMonitor = GuidanceManeuverMonitor(route: route)\nguidanceManeuverMonitor.delegate = self We also set our ViewController as delegate to receive the desired notifications. By conforming to the GuidanceManeuverMonitorDelegate we can fulfill the contract. This protocol defines two methods we must implement. We do that in an extension to our ViewController , which helps to keep related code together. extension ViewController: GuidanceManeuverMonitorDelegate {\n    func guidanceManeuverMonitor(_ monitor: GuidanceManeuverMonitor,\n                                 didUpdateData data: GuidanceManeuverData?) {\n        guidanceManeuverView.data = data\n    }\n\n    func guidanceManeuverMonitorDidReachDestination(_ monitor: GuidanceManeuverMonitor) {\n        guidanceManeuverView.highlightManeuver(textColor: .colorAccentLight)\n    }\n} And that’s it. No more work is needed. The first method is called when new maneuver data arrives. Note that GuidanceManeuverData is an optional value, so in case of errors, or when there is no data available – for example – during a tunnel, the data object may be nil . Here we are satisfied with the default behavior of the component. We pass the data, regardless if it is nil or not: This will show a status message, indicating that the component is trying to get data. The second callback informs us when the user has reached the destination. In this case, we customize the end maneuver with an accent color. Highlighted destination There are multiple ways to adapt the components to your own needs. Similarly, we can change the default look of the guidanceManeuverView by reversing the white-on-black font: guidanceManeuverView.foregroundColor = .colorForeground\nguidanceManeuverView.backgroundColor = .colorBackgroundViewLight The MSDKUI library already includes a set of predefined brand colors which we are using here. Speed Components Let’s move on and set up the speed components. guidanceSpeedView and guidanceSpeedLimitView allow for a variety of customization options. In essence, we can define what to show based on the current speed value. Furthermore, for the guidanceSpeedView we would like to indicate its speed value on a rounded background. Since the guidanceSpeedView is a UIView , we can tweak it as much we like: guidanceSpeedView.layer.cornerRadius = guidanceSpeedView.bounds.height / 2\nguidanceSpeedView.textAlignment = .center Since the speed view has equal width and height dimensions, we can round the view by setting the corner radius to half the height of the view. Secondly, we want to center the speed value and its unit within. The same rounding strategy we apply to the guidanceSpeedLimitView . Additionally, we specify a border, to give it a look similar to a traffic sign: guidanceSpeedLimitView.layer.cornerRadius = guidanceSpeedLimitView.bounds.height / 2\nguidanceSpeedLimitView.layer.borderWidth = 4\nguidanceSpeedLimitView.layer.borderColor =\n    UIColor(red: 208 / 255, green: 0, blue: 13 / 255, alpha: 1.0).cgColor Speed limit The guidanceSpeedLimitView will always look the same, but with varying values. The guidanceSpeedView , in opposition, should have two possible states depending on whether we are driving with overspeed, or below the current speed limit. We can easily create two custom view appearances by changing the backgroundColor , the speedValueTextColor and the speedUnitTextColor properties of the guidanceSpeedView . private func setDefaultSpeedColors() {\n    guidanceSpeedView.backgroundColor = .colorBackgroundViewLight\n    guidanceSpeedView.speedValueTextColor = .colorForeground\n    guidanceSpeedView.speedUnitTextColor = .colorForeground\n}\n\nprivate func setOverspeedColors() {\n    guidanceSpeedView.backgroundColor = .colorNegative\n    guidanceSpeedView.speedValueTextColor = .colorBackgroundViewLight\n    guidanceSpeedView.speedUnitTextColor = .colorBackgroundViewLight\n} By default, when we are driving according to the rules, it should be black font on white background. Looks like accurate speed, or? When overspeeding, it should be white font on an alerting red background. Oh no, are we too fast? Okay, these visuals seem to work. However, we still need to wire up the views with the incoming speed data. As a helping hand, the GuidanceSpeedMonitor delivers the required information. You may remember, we already declared the monitor above. Its constructor is empty as there is no need to provide a route. guidanceSpeedMonitor = GuidanceSpeedMonitor()\nguidanceSpeedMonitor.delegate = self Since no route is needed, we could use the GuidanceSpeedMonitor in tracking mode, too. For example, without following any route – just getting warned about speed limits while driving around … but hey, that may be a plan for another app. Again, we set the ViewController as delegate. This time we need to conform to the GuidanceSpeedMonitorDelegate protocol, which requires one method to be implemented: extension ViewController: GuidanceSpeedMonitorDelegate {\n    func guidanceSpeedMonitor(_ monitor: GuidanceSpeedMonitor,\n                              didUpdateCurrentSpeed currentSpeed: Measurement<UnitSpeed>,\n                              isSpeeding: Bool,\n                              speedLimit: Measurement<UnitSpeed>?) {\n\n        // Update the current speed view.\n        guidanceSpeedView.speed = currentSpeed\n        isSpeeding ? setOverspeedColors() : setDefaultSpeedColors()\n\n        // Update the speed limit view.\n        guidanceSpeedLimitView.speedLimit = speedLimit\n        guidanceSpeedLimitView.isHidden = speedLimit == nil\n    }\n} To update the current speed view, we check isSpeeding and call the respective methods to update the current speed view. Quite simple, isn’t it? For the speed limit view, it is even simpler as we just have to set the current speed limit. Since speedLimit is an optional value, we may want to check for nil to update the view’s visibility based on that. A nil value indicates that no information about speed limits is available. Start Navigation Guidance Now, our little app is almost complete. The one thing that is left is to start the trip (step three): private func startGuidance(route: NMARoute) {\n    mapView.add(mapObject: NMAMapRoute(route)!)\n    NMANavigationManager.sharedInstance().map = mapView\n    NMANavigationManager.sharedInstance().startTurnByTurnNavigation(route)\n} What is going on here? As we want to see our current route on the map, we simply have to add the route object to the mapView . Then we tell the NMANavigationManager which map to use and finally, we call startTurnByTurnNavigation() . This will not only start navigation, but also enable voice guidance (using the default language) and the obligatory beep sound when driving too fast. Both can be adapted, or even turned off, if desired. You can find out more about that in the documentation for the HERE Mobile SDK. On our way to HERE! During development of the app it may be useful to start guidance on a simulator (see the screenshot above – by the way, that’s also a safe way to test overspeeding without risking tickets). You can start simulated navigation by setting a custom data source for positioning. By default, it’s NMADevicePositionSource , but it can be changed to use a NMARoutePositionSource , so that the position follows the route with a custom driving speed. You can find an example for that in the example’s source code . Wrapping Up Now, all that is left is to get the app deployed onto a device and take the first ride to HERE. I hope this blog post was giving you enough confidence to start your own experiments with the new MSDKUI v2.0 framework. If for some reason, you got stuck along the way, you can find the complete Xcode project on GitHub . What’s next? For sure, there is plenty of room to improve our little app. For example, we could turn off that louche overspeeding beep to play our own funky sound instead – or we could enhance the driving experience by adding dynamic re-routing – or add additional navigation components, for example, a guidance dashboard showing the estimated arrival time. Whatever you may decide, there are a lot more MSDKUI building blocks waiting to be explored. And if that is not enough, the full MSDKUI’s source code is open to your contribution. It’s great to see that HERE gives so much trust into the open-source community. Millions of developers can’t be wrong. It’s in your hands. And for your next projects, you’ll never have to miss that compelling “You’ve reached your destination!” voice again – when driving to HERE or wherever you want to go.", "date": "2019-01-24"},
{"website": "Here", "title": "HD Live Maps for Automated Driving: An AI Approach", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/hd-live-maps-for-automated-driving-an-ai-approach", "abstract": "ACM SIGSPATIAL, the International Conference on Advances in Geographic Information Systems, has come and gone. I wasn't able to make the trip to attend, but Xin Chen generously spent some time to teach me a few of the insights that he shared with the crowd in his keynote: \" HD Live Maps for Automated Driving: An AI Approach \". Xin, what's your role with HERE? I am an engineering director in the Highly Automated Driving division. I lead the \"HD Perception\" team focused on automating HD live map product creation by developing state-of-the-art machine learning and 3D technologies. How long have you been working in the field on Automated Driving? I have worked at HERE since completing my doctorate at Notre Dame 12 years ago. I have worked in the Highly Automated Driving (HAD) division since it was formed a few years ago. Before HAD, I worked in the Research organization and transitioned to Platform and Core Map organizations each for a couple of years. To prepare you for this field, what did you study while at Notre Dame? I did my Master's and PhD in Computer Science and Engineering. They had a pretty good football season this year didn't they? Yeah, ND was in the playoffs with a perfect regular season! I went to the ND-Stanford and ND-Northwestern games this year with my wife Maria, who is also an alum. We have five ND degrees between us! HD Live Maps Looking at your Keynote title, for somebody that's not familiar with the term, what do you mean by HD Live Maps? How is that different from normal navigation maps that we use everyday to get from A to B? Traditional navigation maps contain road topology, road centerline geometry, and road-level attributes. These traditional maps are referred to as a Road Model -- one of the three layers in HD maps. Another layer in HD maps is the HD Lane Model , which contains lane topology data and lane-level geometry and attributes at centimeter level precision. The third layer coined the HD Localization Model include various features to support localization strategies to pin point a self-driving car to the exact lane and longitudinal location on an HD map. Essentially, we add two additional map layers to the Road Model layer available in a traditional map -- HD Lane Model and HD Localization Model -- resulting in much richer and more precise content. The HERE HD Live Map is a cloud-based service comprised of various tiled mapping layers that are highly accurate and continuously updated to support connected ADAS and highly or fully automated driving solutions. How does having an HD Map help a self-driving car? Wouldn't computer vision be enough?  A human driver travels to new places without an HD map. HD maps save human lives.  Sensors and Artificial Intelligence are never perfect and make mistakes which cost lives.  HD maps can mitigate risk by reducing the margin for error.  HD maps assist in planning beyond the sensor range.  HD maps also enhance sensor and AI capability to understand the environment, especially in uncommon and harsh conditions.  Most automated driving solutions recognize HD maps as the hub of key components of sensing, perception, and planning.  To use rich HD map information the car also needs to precisely pin point itself on the map and it needs localization.  GPS-based solution sometimes has errors of a few meters which could be well beyond a lane width.  By matching real time car perception and the HD map it can greatly enhance the localization accuracy. How do we make HD maps?  What are some of the challenges? To make centimeter level high precision and high accuracy maps on a global scale and keep them constantly up to date is technically challenging and expensive.  HD maps have never been successfully deployed before on a large scale so we are pioneers in the space, working closely with our customers and partners to iterate on integrating HD maps in automated driving systems. The cost to collect data, manage data, develop software (algorithms, tooling, pipeline, process), operate production is prohibitive for many.  We have to have a scalable production solution so that we don't break the bank.  High accuracy, global coverage, near real-time freshness, production scalability and map interoperability are common challenges. Wait, how can a map be interoperable? Interoperability means one HD maps rules all. Either the HD map content or the production platform can be adopted by heterogeneous automated driving solutions and by different customers/partners. It is not realistic to custom build an HD map for each automated driving solution or each customer/partner as there are too many of them and most are still in R&D stage with software and hardware evolving rapidly. Artificial Intelligence What are some of the Artificial Intelligence strategies you are using? Specifically computer vision, 3D data analysis, and machine learning.  These approaches work together to significantly automate the HD map creation process. The technology we use to build HD maps and the automated driving techniques in sensing and perception are two sides of a coin.  The former can afford to do post-processing with tight quality control to build out a base HD map while the latter requires real time performance.  The mapping sensors are typically more advanced / sophisticated at a higher cost than those on self-driving cars. What sensors do you have access to for mapping? We have DGPS, IMU, multiple industrial high resolution cameras and multi-beam LIDAR scanner.  The imagery and LIDAR point clouds are geo-referenced by DGPS and IMU and we extract HD map attributes from the imagery and LIDAR.  We also leverage other sources of data such as satellite and aerial imagery. LIDAR can be very expensive compared to something simple like cameras.  Why use LIDAR? LIDAR is still too expensive to deploy on a large scale but the trend is that it will become cheaper and smaller like cameras. I think that LIDAR is a must to make HD maps that guarantee centimeter level precision.  Stereo-based computer vision cannot reconstruct 3D to that precision level consistently and the errors grow quadratically with the distance from the object to the cameras. For example, if you have 1cm error within 10 meters range from a camera. The error will be 1 meter at 100 meters distance. While a typical LIDAR scanner can maintain 1-2 centimeter level accuracy within a couple of hundred meters which covers most of the roadside objects. A camera is also necessary and important as it provides color information that LIDAR doesn’t have and it has wider view angles and longer ranges. Most of the machine learning algorithms including deep neural net are developed for 2D images. ADAS and highly automated vehicles have cameras rather than LIDAR and their camera based real time feature detection is a great source to update HD maps due to its large quantity and high frequency. Getting back to software, you just mentioned deep neural nets, how do you use deep learning? It is a subcategory of the machine learning approach that I mentioned.  We use it to automatically extract features such as lane markings, signs, barriers and poles from imagery and LIDAR point cloud data. How does deep learning compare to computer vision? Deep learning can be used to solve many computer vision problems and it is scalable over many different features.  It often can achieve higher accuracy than traditional computer vision algorithms as long as there is sufficient training data and computing power. When training data is not sufficient for deep learning traditional computer vision or machine learning can still help. Do you build the AI algorithms in-house or do we leverage other open-source or commercial services? My team develops computer vision, deep neural nets, machine learning and 3D data analysis in house with the state-of-the-art techniques. Our \"secret sauce\" is our proprietary data and really our know-how developed over my time at HERE in mining that data. We have unique datasets that no one else has.  My team applies and develops state-of-the-art technologies customized to our datasets and optimized for HD mapping. With large scale training data it might be straight forward to get to an accuracy to 70, 80 some percent with an off-the-shelf deep neural net framework, but we strive to bring it up 10 to 20 percent more which requires deep expertise and experience. I believe that AI technology is also strategically critical for a mapping company. I have over 50 patent applications and I know a few colleagues at HERE who have even more patents than I do. Many other engineering organizations within HERE also use AI to create navigation maps, traffic intelligence, indoor mapping, mobility services and AR. My team works on building a machine learning services platform in house with a goal to democratize AI at HERE so that all engineers in the company, regardless of their machine learning background, can use this platform to train, evaluate, deploy and share their machine learning models. Does everything for that platform run in the cloud or do you also need edge processing? I have a team in Boulder who works on edge perception and localization. Their mission is to create reference implementations on how to use our HD maps for localization. It covers all key components of self-driving except for planning and control. It is built in consumer devices such as dashcams and smart phones for real time perception of road environment and localization of the car on HD maps. Career Path How does one get into the field -- who are the people on your team capable of doing this type of work? There are mainly three types of people on my team: research engineers who develop algorithms and push the envelope of the current state-of-the-art; software engineers who implement the algorithms in robust and efficient C++ and python software and maintain a common code base and library; production engineers who develop infrastructure and applications to run the AI software on a large scale in the cloud or on the edge . We have many PhD level research engineers from schools such as CMU, MIT, Purdue and several hard core C++ developers who came from the fintech industry from places like Citadel. How do you keep your skill set current with state of the art AI technologies since it is fast evolving and dynamic?  I'm a CMU grad myself but dating myself a bit at the time we were still trying to figure out OCR. Teaching forces me to really keep my skills current. I have developed and taught two AI courses at the Illinois Institute of Technology and Northwestern University every year since 2010. The syllabus evolves a great deal with each course - new algorithms, techniques, industry trends and software emerge every year. What sort of topics do you cover in your courses or what is unique about them compared to some of the popular Coursera or Udacity ones you can find online? I developed a course called “ Geospatial Vision and Visualization ” where students learn computer vision, big data analysis and machine learning in the geospatial intelligence context. Another course is “Biometrics” which was my PhD thesis topic. The students learn AI techniques through face, iris and fingerprint recognition. Biometrics is one of the most successful productization of machine learning technologies, while geospatial intelligence touches every aspect of human life from navigation mapping, traffic, energy efficiency to homeland security and self-driving – each is in great demand of machine learning for scalability and quality. Both improve human lives and at the same time raise ethical and privacy concerns that have significant social impact. My teaching philosophy involves allowing students to learn machine learning in the real world context by using real world data to consider real world examples and solve real world problems in class. I want to equip students with the knowledge, experience and a skillset highly desired by their future employers in dynamic industry settings. I took a look at the syllabus and it looks interesting covering lots of interesting topics like probe data, image enhancement, etc.  Do you find that teaching helps you in other ways beyond keeping your knowledge fresh? Absolutely. Many of my former students are my colleagues now at HERE across different departments and sites from Chicago to Mumbai. Teaching fosters a good relationship with local universities and several faculty and PhD students have worked on HERE-sponsored research projects in the past as a result. Illinois Institute of Technology is ranked #5 – only behind Carnegie Mellon University, Stanford University, and University of California–Berkeley - by The San Francisco Business Times in terms of universities who produce the most professionals focused on the driverless car industry. I hope that my course has contributed to this growth! Giving back is also a core value at HERE and I am proud to have taught over 1000 students in the AI domain in the past 8 years. Community How can the developer community benefit from your work or get involved in the space? There are many ways that we collaborate with the developer community interested in HD maps. For example, we provide HD map samples and we also work with a popular R&D programming platform to integrate HD map interface in their libraries.  There are also industry collaborations such as the OneMap Alliance . I have also advanced our work through formal collaboration with universities such as Northwestern, Columbia, Notre Dame and Carnegie Mellon. I have organized a few challenges and competitions in the research community to analyze mapping data. I am always looking for top talent to join our world-class team. Thanks Xin, we really appreciate you sharing your insights and the thought leadership you provide in the field.", "date": "2019-02-01"},
{"website": "Here", "title": "Geocoding Addresses with Kotlin and HERE in Android", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/geocoding-addresses-with-kotlin-and-here-in-android", "abstract": "About a month or so ago I had written a tutorial around geocoding addresses to their latitude and longitude equivalent and then displaying them on a map in Android using the HERE Geocoder API. In this previous tutorial , the HERE Android SDK was being used with Java. However, Java isn’t the only way to develop Android mobile applications and it is actually becoming lesser used than the alternatives. Instead Kotlin is becoming increasingly popular and is slowly becoming the recommended approach towards developing native Android applications. While different languages, Kotlin and Java are similar. In this tutorial, we’re going to learn how to display geocoded addresses on a map in Android using Kotlin and HERE . To get an idea of what we hope to accomplish, take a look at the following animated image: As you can see, nothing particularly fancy is happening. We’re accepting user input and we’re taking that input to display a marker on the map. In fact, this is the same thing we did in the previous tutorial which focused on Java. Developing an Android Application that Accepts User Input We’re going to assume that you already have a Kotlin based Android application that is configured to use the HERE Android SDK. If you haven’t configured the HERE Android SDK with Kotlin, check out my previous tutorial on the subject. As long as you’ve got a map displaying, we can jump right into the core points of this tutorial. We’re going to focus on interacting with an EditText component before we focus on the HERE functionality. This means the first step is to include such a component in our activity_main.xml file: <LinearLayout\n        xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:tools=\"http://schemas.android.com/tools\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:orientation=\"vertical\" >\n\n    <EditText\n            android:id=\"@+id/query\"\n            android:hint=\"Query...\"\n            android:layout_height=\"wrap_content\"\n            android:layout_width=\"match_parent\"\n            android:inputType=\"text\"/>\n\n    <fragment\n            class=\"com.here.android.mpa.mapping.SupportMapFragment\"\n            android:id=\"@+id/mapfragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"/>\n\n</LinearLayout> Notice that we’re included the EditText and given it a specific variable id. We’ll be referencing this component based on its id in the Kotlin code. With the XML updated for user input, let’s start editing the project’s MainActivity.kt file: package com.example.raboy\n\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport android.util.Log\nimport android.view.KeyEvent\nimport android.widget.EditText\nimport com.here.android.mpa.common.GeoCoordinate\nimport com.here.android.mpa.common.OnEngineInitListener\nimport com.here.android.mpa.mapping.Map\nimport com.here.android.mpa.mapping.SupportMapFragment\nimport com.here.android.mpa.mapping.MapMarker\nimport com.here.android.mpa.search.ErrorCode\nimport com.here.android.mpa.search.GeocodeRequest2\nimport android.view.View\n\n\nclass MainActivity : AppCompatActivity() {\n\n    private var map : Map = Map()\n    private var mapFragment : SupportMapFragment = SupportMapFragment()\n    private lateinit var editText : EditText\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        mapFragment = getSupportFragmentManager().findFragmentById(R.id.mapfragment) as SupportMapFragment\n        mapFragment.init { error ->\n            if (error == OnEngineInitListener.Error.NONE) {\n                map = mapFragment.map\n                map.setCenter(GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE)\n                map.zoomLevel = (map.maxZoomLevel + map.minZoomLevel) / 2\n            }\n        }\n        editText = findViewById(R.id.query)\n\n        editText.setOnKeyListener(View.OnKeyListener { _, keyCode, keyevent ->\n            if (keyCode == KeyEvent.KEYCODE_ENTER && keyevent.action == KeyEvent.ACTION_UP) {\n                // Logic to geocode here...\n                editText.setText(\"\")\n                return@OnKeyListener true\n            }\n            false\n        })\n    }\n} If you followed my previous Kotlin tutorial, much of the above code will look familiar. The difference here is that we’re including an editText variable that we’re setting in the onCreate function. The editText variable is connected to our XML component. Once we have reference to our component we can create a listener for key events: editText.setOnKeyListener(View.OnKeyListener { _, keyCode, keyevent ->\n    if (keyCode == KeyEvent.KEYCODE_ENTER && keyevent.action == KeyEvent.ACTION_UP) {\n        // Logic to geocode here...\n        editText.setText(\"\")\n        return@OnKeyListener true\n    }\n    false\n}) Using a lambda expression we can check to see if the enter key was pressed. If pressed, we can choose to do some geocoding logic and then clear out the field so further data can be input without having to erase manually. There wasn’t much to it when it comes to getting user input support. Now we can focus on taking that input and doing something with it. Using the HERE Geocoder API to Place Markers on a Map The idea is that when the enter key is pressed, we geocode the string and drop it on the map as a marker. To do this, we can create another function and some more class variables. class MainActivity : AppCompatActivity() {\n\n    private var map : Map = Map()\n    private var mapFragment : SupportMapFragment = SupportMapFragment()\n    private lateinit var marker : MapMarker\n    private lateinit var editText : EditText\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        mapFragment = getSupportFragmentManager().findFragmentById(R.id.mapfragment) as SupportMapFragment\n        mapFragment.init { error ->\n            if (error == OnEngineInitListener.Error.NONE) {\n                map = mapFragment.map\n                map.setCenter(GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE)\n                map.zoomLevel = (map.maxZoomLevel + map.minZoomLevel) / 2\n            }\n        }\n        editText = findViewById(R.id.query)\n\n        editText.setOnKeyListener(View.OnKeyListener { _, keyCode, keyevent ->\n            if (keyCode == KeyEvent.KEYCODE_ENTER && keyevent.action == KeyEvent.ACTION_UP) {\n                dropMarker(editText.text.toString())\n                editText.setText(\"\")\n                return@OnKeyListener true\n            }\n            false\n        })\n    }\n\n    fun dropMarker(query: String) {\n        if (::marker.isInitialized) {\n            map.removeMapObject(marker)\n        }\n        val tracy = GeoCoordinate(37.7397, -121.4252)\n        val request = GeocodeRequest2(query).setSearchArea(tracy, 5000)\n        request.execute { results, error ->\n            if (error != ErrorCode.NONE) {\n                Log.e(\"HERE\", error.toString())\n            } else {\n                for (result in results) {\n                    marker = MapMarker()\n                    marker.coordinate = GeoCoordinate(result.location.coordinate.latitude, result.location.coordinate.longitude, 0.0)\n                    map.addMapObject(marker)\n                }\n            }\n        }\n    }\n} This time we’ve created a marker variable. Since we don’t have any markers on the map when we launch our application, we don’t need to initialize this variable. All of our marker magic will take place in the dropMarker method. In the dropMarker method, if the marker has already been initialized, we need to remove it from the map. In this example we’ll only have one marker on the map at any given time. We’re also going to limit all of our geocoder requests to 5000 meters around the Tracy, CA area which is specified by a set of latitude and longitude coordinates. When it comes time to executing the geocoder, we’ll be left with potentially more than one result. Based on our logic, we’re going to loop through all the results, but only the last result will appear as a marker on the map. If you have a very specific query, you’ll likely only receive one result, but if you have a vague query like “elm”, the results might be more. Conclusion You just saw how to develop an Android application with Kotlin that made use of the HERE Geocoder API and various mapping features. Using Kotlin is an alternative to Java, which is what I demonstrated in a previous tutorial . If you got stuck configuring the HERE Android SDK with Kotlin, check out my previous tutorial on the topic titled, Getting Started with HERE using Kotlin and the Android SDK .", "date": "2019-01-29"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.2.1 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.2.1-release", "abstract": "Data Added Added a metadata solution to support the ability to get a list of volatile partitions that have changed since a provided timestamp: By including a timestamp into your volatile metadata query, you can now request a list of volatile partitions that have changed since that timestamp. When processing or downloading volatile data, you only need to request the changes rather than download all volatile data, and thus improving your workflow efficiency and data transmission costs. See related SDK release notes: \"Added: getVolatilePartitions method in QueryAPI \" API deprecation notice: Support of the existing functionality to get all volatile partitions that changed between version Vn and Vm will continue to exist for the next 6 months, after which point this support will be deprecated. Also note that as of this release, the result of that type of query is slightly different. The result now contains all the partitions that changed since the time Vn was committed. Fixed A new Spark Connector has been included in the SDK to support the consumption of Parquet, Avro and Protobuf formatted data from an Index Layer. See the SDK release notes for more information about this Connector. Marketplace Added Made improvements to the Marketplace subscription usage report making the information meaningful and easy to understand for OLP users. Improvements include: User friendly subscription heading and column titles Subscription heading is now the subscribed data catalog name Added data catalog HRN Added layer HRN next to the layer name Fixed Resolved the issue where when a Marketplace Provider grants data access to a Marketplace Consumer, there could be a delay before the Consumer sees the data catalog in their licensed data area, because the confirmation email is only sent after the consumer has accepted the subscription.", "date": "2019-01-31"},
{"website": "Here", "title": "Introduction to the SAPUI5 Workshop Using HERE APIs", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/introduction-to-the-sapui5-workshop-using-here-apis", "abstract": "In the latter part of 2018 we announced HERE services available on SAP Cloud . Developers can find our services at the SAP API Hub . The HERE location services include geocoding, routing, search, maps, and much more. What this post aims to do is provide more technical details for SAP developers who are interested in integrating HERE location services into their projects. Scope and Requirements The scope of this post is introductory, and will serve as the basic starting place for upcoming posts that go deeper. The front-end client app uses SAPUI5 - a development toolkit for creating rich user interfaces for modern web application development. The following are prerequisites for getting started: Some HTML experience (need help ?) Some JavaScript experience (need help ?) SAP Developer account ( http://api.sap.com ) HERE Developer account ( https://developer.here.com ) Overview of Tasks As stated above, this post will cover the essentials for getting started with using HERE APIs in the SAP Cloud. Once a foundation is established, adding new features from HERE API calls is very straightforward. What is involved in creating the foundation being addressed in this post? Discovery. How to locate and test which HERE APIs to use from the SAP API Hub . Integration. How to integrate specific HERE APIs into the SAP Cloud environment. Configuration. How to configure an SAPUI5 project to use HERE APIs and manage app ids and codes. Development. How to declaritively call HERE API from an XML View. The simple output of the initial project displays two images as seen here: Ready to get started? We invite you to go at your own pace at our SAPUI5 Workshop in Github . The workshop is a tutorial seperated into sections to easily progress from each major milestone - doing so one step at a time. The advantage of preserving the workshop at Github is maintaining it with updates and bug fixes (if any). Please try it out! Summary SAP developers can integrate HERE APIs into their SAPUI5 projects. Developers can start easily by following the SAPUI5 Workshop (Tutorial) in Github . For more information about HERE, please visit our developer portal at http://developer.here.com .", "date": "2019-02-01"},
{"website": "Here", "title": "HERE takes top spot in new Strategy Analytics report", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-takes-top-spot-in-new-strategy-analytics-report", "abstract": "HERE notched up the highest score, in Strategy Analytics’ latest assessment of the leading location-based service providers. It’s the fifth successive year during which HERE has secured the top spot in the firm’s benchmarking report and we couldn't be prouder! This edition saw Strategy Analytics overhaul its assessment criteria, introducing categories for openness and developers . “HERE has a strong automotive presence and is well suited to meeting the needs of this sector and large enterprises,” the report’s author Nitesh Patel explained. “Historically, HERE has not focused on long tail developers, but over the past 18-24 months has started initiatives like XYZ and introduced a Freemium location offer to encourage the longer tail of developers.” Patel said that competition across the industry remained fierce, while customer demands were continuing to evolve. “HERE continues to demonstrate leadership in key areas with its comprehensive 360 approach to map making, continued support of automakers’ strategic objectives, and innovative products and solutions across location use-cases,” he wrote. Patel also noted the steps HERE has taken over the last 12 months to improve its POI search and visualization capabilities. Industry analyst firms represent an importance source of information for our current and prospective customers and partners. That’s why we work hard to ensure their analysts have access to our executives and are kept abreast of developments at the company. The effort pays off: in the last six months, reports from multiple tech research houses have  recognized HERE as the industry-leading platform. You can find Strategy Analytics’ latest industry benchmarking in its new report “Automotive, Enterprise, IoT, and the Mobility Sector to Drive Future Location Sector Growth”. This, as well as available reports from other research firms, can be accessed here: https://www.here.com/en/company/industry-voices", "date": "2019-02-04"},
{"website": "Here", "title": "Visualizing Service Usage from Splunk Logs on a Map", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/visualizing-service-usage-from-splunk-logs-on-a-map", "abstract": "Like other organizations, HERE Technologies uses Splunk for log management.  These logs capture a variety of output, the details of which can be useful to keep the operations of web services running smoothly.  One such service is the HERE XYZ Hub API.  The team behind HERE XYZ decided to eat their own dog food and used the service itself to visualize on a map which map tiles were being requested during a beta phase. I spent some time with software engineers Marvin Gilbert and Max Chrzan to understand their project and roles related to this internal tool. Max explains what we're looking at: This is a company-owned dataset that is continuously generated by any users of the HERE XYZ tools, and to be more precise XYZ Studio.  It is highly dynamic which makes it interesting for analysis.  The UI shows the base tiles of maps used in XYZ Studio that were requested during an internal testing phase to visualize hotspots. You can learn more about HERE XYZ at https://explore.xyz.here.com but let's dig a little deeper into the project to understand what the data represents (Vector Map Tiles), the source of the data (Splunk), how data can be populated into HERE XYZ (Hub API), and finally the user interface (XYZ Splunk Visualizer) as demonstrated in the image above. Vector Map Tiles When storing data in HERE XYZ, the Hub API is a convenient way to fetch geospatial Features within a discrete area. A feature is composed of geometry and properties . Geometry can be things like points, lines, and polygons associated with geo-coordinate arrays. Properties are represented as a dictionary of key/value pairs that help make sense of what the feature describes. For example a label, name, resolution, author, etc. can all be properties. The XYZ Hub stores geospatial data in a space to optimize retrieval of these features within that space given by an identifying space id, level (z), longitude (x), and latitude (y). You can see this by looking at the format of a request. A call to the endpoint might look like: GET https://xyz.api.here.com/hub/spaces/{spaceid}/tile/web/{z}_{x}_{y} . If headers including the token are sent properly, the response would include a feature that could look like the following. {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n            -2.960847,\n            53.430828\n        ]\n    },\n    \"properties\": {\n        '@ns:com:here:xyz': {\n            \"tags\": [\n                \"date:2019-02-06\",\n                \"hour:09:00\"\n            ]\n        },\n        \"level\": 2,\n        \"resolution\": 10\n    }\n} At the risk of recursing indefinitely, this feature is itself a description of a service request for a feature. The XYZ Hub API supports Tagging for creating indexes on important data for quicker retrieval. In this case that’s the date and time, with additional properties like the zoom level and resolution of the request. Marvin explains: Currently we are only tagging the date and hour of the log entry – but the tags could be also used for all kind of information which is available in the logs. Having XYZ Tags is useful for filtering the dataset or for visualizing them in the UI. Splunk Logs Serving as many as 8000+ concurrent lambda functions and 100M+ API requests like we do with HERE XYZ can be tough to understand what is going on in the AWS environment. Splunk can help with that and is the source of the data set for this application. Max explains: You can collect with Splunk any kind of log data. Applications and services are forwarding their log data to the Splunk server as part of our infrastructure. The Splunk server is instantly indexing the incoming dataset. It is then possible to access the data near to real-time. Splunk provides a huge toolchain to analyze the datasets. Furthermore, you can create statistics including diagrams – in total a very cool piece of software. Splunk provides a powerful search engine that was used by Max and Marvin to narrow down their Splunk request. Not every service request is for the Hub API for example since there are other APIs, static sites, etc. being monitored with Splunk. The request to the Splunk endpoint looks similar to the following: var request = require('request');\nvar waiter = require('node_common/waiter');\n\nconst type = 'raw';\nconst token = 'authorization-token-for-splunk';\n\nlet search = 'search index=cpaws+role=vector-service+sourcetype=gunicorn+\\\".xyz\\\"';\nlet from = '-15m@m';\nlet to = 'now';\n\nvar options = {\n    'method': 'POST',\n    'url': 'api.splunk/services/search/jobs/export?output_mode=' + type,\n    'headers': {\n        'Authorization': 'Basic' + token,\n    },\n    'body': 'search=' + search\n        + ' earliest_time=' + from\n        + ' latest_time=' + to\n}\n\nrequest(options, w = waiter());\nvar response = w.wait(); A sample of what these logs results retrieved from Splunk look like is actually pretty straightforward. It is highly specific to our logging format so would vary depending on your project needs, but this path tells us the resolution, level, y, and x coordinates of a requested tile. [2019-02-04 08:34:50 +0000] GET /256/all/13/4256/2992.xyz\n[2019-02-04 08:34:49 +0000] GET /256/all/13/4254/2989.xyz\n[2019-02-04 08:34:49 +0000] GET /256/all/13/4254/2990.xyz\n[2019-02-04 08:34:50 +0000] GET /256/all/13/4258/2992.xyz\n[2019-02-04 08:34:49 +0000] GET /256/all/13/4254/2992.xyz\n[2019-02-04 08:24:03 +0000] GET /512/all/11/1076/675.xyz\n[2019-02-04 08:24:03 +0000] GET /512/all/11/1075/676.xyz\n[2019-02-04 08:34:50 +0000] GET /256/all/13/4255/2992.xyz\n[2019-02-04 08:34:49 +0000] GET /256/all/13/4257/2989.xyz\n[2019-02-04 08:34:50 +0000] GET /256/all/13/4257/2992.xyz\n[2019-02-04 08:24:03 +0000] GET /512/all/11/1077/676.xyz Marvin adds: It was our first time using the Splunk REST API. The API offers nice possibilities for automated log analysis which could be interesting for a lot of developers. You can learn more about how to export search results from Splunk from the splunk docs . Hub API Marvin recalls: Finding the correct Regular Expression to parse the log-data took the most time as usual :D Splunk includes some mapping functionality known as Geostats but it didn’t quite meet their needs. It couldn’t handle the volume of transactions as being generated by HERE XYZ but also is limited to latitude and longitude. In cases with the log data Marvin noted the need “to support every kind of geo-references (level, row, col, quadkey, morton code, …).” To make this data loader pipeline Marvin described: To provide and store the dynamic content to XYZ Hub, a periodically running pipeline was generated and triggered every 5 minutes by AWS CloudWatch Events. This way it was kept fresh with a live dataset in sync with XYZ Hub. To transform the log events… a small node script was deployed as an AWS Lambda. The key is using the Spaces API to add feature collections like the Feature described earlier: var options = {\n    'method': 'PUT',\n    'url': 'https://xyz.api.here.com/hub/spaces/' + spaceId + '/features',\n    'headers': {\n        'Authorization': 'Bearer ' + token,\n        'Content-Type': 'application/geo+json'\n    },\n    'body': JSON.stringify(featureCollection)\n};\n\nrequest(options, w = waiter());\nvar response = w.wait(); You can learn a bit more about the Edit Features endpoint which can be used to create or replace features, add tags, remove tags, etc XYZ Splunk Viewer Putting it all together, the final component is the user interface itself. Since vector rendering is Max’s specialty, he points out: The XYZ-Splunk Viewer, loads the data from XYZ Hub and visualizes it to the user. It provides the ability to select search parameters as date and time to select certain timeframes. For the actual UI, the viewer uses Tangram and Leaflet to visualize the XYZ spaces with the tagged data. To make the site available to everyone it is simply hosted on AWS S3. Max also noted: We used the datepicker library from jquery-ui (https://jqueryui.com/datepicker/) which is how we quickly implemented a simple but nice calendar UI. For a more detailed example of building a UI with Tangram and HERE XYZ you might want to check out the Green Amsterdam tutorial over at https://codelabs.here.xyz .  If you want to look at the complete source listings for this project you can find more detail in the repo - https://github.com/MarvGilb/xyz-hackweeek . Max and Marvin are both back-end developers and colleagues at the Frankfurt (Germany) office and have known each other for over 15 years.  Marvin works with microservices deployed in the AWS environment including AWS EC2, Lambda, CFN, MongoDB, Amazon Aurora, and Splunk.  Max primarily works on services for rendering that are community and customer focused, including the AWS portfolio EC2, ECS, SQS, SNS, RDS, Cloudfront, Cloudformation, S3, etc. and OGC compliant open-source projects.", "date": "2019-02-06"},
{"website": "Here", "title": "Designing Map Gesture Events in Kotlin and Android to Reverse Geocode Addresses with HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/designing-map-gesture-events-in-kotlin-and-android-to-reverse-geocode-addresses-with-here", "abstract": "Over the past few weeks I’ve been writing tutorials around Kotlin and Android that make use of the various HERE APIs. Remember, Java isn’t the only way to develop for Android and it may not be the most popular in the near future. In the last tutorial we saw how to geocode addresses and display them on a map using Kotlin. This is great for showing markers or other points of interest, but what if we want to know an address based on where the user taps on the map? How do you even determine coordinate information from a tap event on a screen? We’re going to see how to calculate addresses from where a user taps within an Android application using the HERE Android SDK and the Kotlin programming language. To get a more realistic idea of what we’re going to accomplish, take the following animated image. Doing a long-press event will drop a marker on the map after converting the pixel location to latitude and longitude coordinates. Doing a standard tap event on the marker will reverse geocode the coordinates and display an associated nearest address. Going into this tutorial, the assumption is that you already have the HERE Android SDK configured in your Kotlin application. If you don’t and need help, check out my previous tutorial titled, Getting Started with HERE using Kotlin and the Android SDK . Calculating Latitude and Longitude Coordinates from Pixel Locations Before we try to drop any markers or reverse geocode our coordinates, we first need to calculate those coordinates. We can actually make use of the OnGestureListenerAdapter to help us when it comes to gesture events and gathering the positions of those interactions. Take the following code for example: class MainActivity : AppCompatActivity() {\n\n    private lateinit var map : Map\n    private lateinit var mapFragment : SupportMapFragment\n    private lateinit var marker : MapMarker\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        mapFragment = getSupportFragmentManager().findFragmentById(R.id.mapfragment) as SupportMapFragment\n        mapFragment.init { error ->\n            if (error == OnEngineInitListener.Error.NONE) {\n                map = mapFragment.map\n                map.setCenter(GeoCoordinate(37.7397, -121.4252, 0.0), Map.Animation.NONE)\n                map.zoomLevel = (map.maxZoomLevel + map.minZoomLevel) / 2\n                mapFragment.mapGesture.addOnGestureListener(object : MapGesture.OnGestureListener.OnGestureListenerAdapter() {\n                    override fun onTapEvent(p: PointF?): Boolean {\n                        return false\n                    }\n                    override fun onLongPressEvent(p: PointF?): Boolean {\n                        return false\n                    }\n                })\n            }\n        }\n    }\n\n} You’ll notice a few things about the above code. First you’ll notice that we are not configuring our gesture listeners until after the map has initialized. If you try to configure your listeners before you have a functional map, you’re going to run into trouble. You’ll also notice that we’re not using a lambda expression for the various functions within the listener. There are numerous ways to handle interfaces with multiple functions, the approach above just being one of many. Had we only been using a single override, we could have easily used a lambda. We have the foundation of our gesture events in place, so lets jump forward for a moment and figure out what happens when we need to place a marker on the map. We might have a function like the following: fun dropMarker(position: GeoCoordinate) {\n    if (::marker.isInitialized) {\n        map.removeMapObject(marker)\n    }\n    marker = MapMarker()\n    marker.coordinate = position\n    map.addMapObject(marker)\n} Given a latitude and longitude coordinate, we see if a marker already exists on the map. If the marker exists, we remove it and then place a new marker based on the position. Nothing too fancy is happening here. Going back into our gesture listener, we can update it to the following: mapFragment.mapGesture.addOnGestureListener(object : MapGesture.OnGestureListener.OnGestureListenerAdapter() {\n   override fun onTapEvent(p: PointF?): Boolean {\n       return false\n   }\n   override fun onLongPressEvent(p: PointF?): Boolean {\n       val position = map.pixelToGeo(p)\n       dropMarker(position)\n       return false\n   }\n}) Using the pixelToGeo function we can get the latitude and longitude coordinates of our tap event. These coordinates are then passed to our dropMarker function. Reverse Geocoding Latitude and Longitude Coordinates to Addresses with HERE for Android Now that we have latitude and longitude information calculated from the previous step, we can work towards reverse geocoding it to human readable addresses. Before we investigate the onTapEvent in our gesture listener, let’s figure out what is involved in reverse geocoding some coordinates. fun reverseGeocode(position: GeoCoordinate) {\n    val request = ReverseGeocodeRequest(position)\n    request.execute { data, error ->\n        if (error != ErrorCode.NONE) {\n            Log.e(\"HERE\", error.toString())\n        } else {\n            Toast.makeText(applicationContext, data.text, Toast.LENGTH_LONG).show()\n        }\n    }\n} Given a position, we can make use of the ReverseGeocodeRequest class that is part of the HERE Android SDK. After executing a request, we’ll get information regarding the closest match to the coordinates provided. With this in mind, we can update our onTapEvent to contain the following: mapFragment.mapGesture.addOnGestureListener(object : MapGesture.OnGestureListener.OnGestureListenerAdapter() {\n    override fun onTapEvent(p: PointF?): Boolean {\n        val viewObjectList = map.getSelectedObjects(p) as ArrayList<ViewObject>\n        for (viewObject in viewObjectList) {\n            if (viewObject.baseType == ViewObject.Type.USER_OBJECT) {\n                val mapObject = viewObject as MapObject\n                if (mapObject.type == MapObject.Type.MARKER) {\n                    val selectedMarker = mapObject as MapMarker\n                    reverseGeocode(selectedMarker.coordinate)\n                }\n            }\n        }\n        return false\n    }\n    override fun onLongPressEvent(p: PointF?): Boolean {\n        val position = map.pixelToGeo(p)\n        dropMarker(position)\n        return false\n    }\n}) When we create a marker, the coordinate information is stored with the marker. Because we are choosing to get that information from the marker and not a pixel on the map, we need to loop through our map objects and figure out which one was tapped. Once we have that information we can call our reverseGeocode method. Conclusion You just saw how to reverse geocode latitude and longitude coordinates using Kotlin and the HERE Android SDK . The star of this tutorial was in the gesture events that are listened for. While we only made use of the OnTapEvent and the OnLongPressEvent there are quite a few other options. If you are stuck with the configuration of the HERE Android SDK, I encourage you to check out my previous tutorial on the topic. I’m not a Kotlin expert so if you think my Kotlin can be optimized, let me know in the comments.", "date": "2019-02-05"},
{"website": "Here", "title": "Display an Interactive HERE Map in an Ionic Framework Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/display-an-interactive-here-map-in-an-ionic-framework-application", "abstract": "Back when I first started at HERE I had written a tutorial titled, Display HERE Maps within your Angular Web Application . In fact it was my first official tutorial since starting and since then I’ve received several similar requests around it. One popular request has been around taking the Angular web application and making it compatible with Ionic Framework. In this tutorial we’re going to see how to build a progressive web application (PWA) using Ionic Framework that can be deployed on the web or on mobile devices running Android or iOS. Take the following animated image of what we plan to accomplish: As you can see, we have an interactive map available in both a web browser and on an Android device. This is the same application with the same code, running on both platforms. While we’re only showing an interactive map, it opens the door to further possibilities with the HERE JavaScript SDK. Start a New Ionic Framework Project with the Ionic CLI The first step towards being successful with this tutorial is to create a new project. We’re going to be using the Ionic CLI and we’re going to be building an Ionic 3.x application that uses Angular. Other versions of Ionic Framework will likely have different setup requirements. Assuming you have the Ionic CLI installed, execute the following command: ionic start HereMapProject blank The above command will create a blank project. While we won’t be using any Ionic plugins or third-party Angular dependencies, we will need to include some libraries to make use of HERE in our application. Open the project’s src/index.html and include the following HERE JavaScript SDK dependencies: <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script> These libraries should be included within the <body> tags, above the other libraries defined by the Ionic CLI. To get clarity of what our finished src/index.html file should look like, see the following: <!DOCTYPE html>\n<html lang=\"en\" dir=\"ltr\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>HERE Map Example</title>\n    <meta name=\"viewport\" content=\"viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"format-detection\" content=\"telephone=no\">\n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n    <link rel=\"icon\" type=\"image/x-icon\" href=\"assets/icon/favicon.ico\">\n    <link rel=\"manifest\" href=\"manifest.json\">\n    <meta name=\"theme-color\" content=\"#4e8ef7\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n    <script src=\"cordova.js\"></script>\n    <link href=\"build/main.css\" rel=\"stylesheet\">\n</head>\n<body>\n    <ion-app></ion-app>\n    <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"build/polyfills.js\"></script>\n    <script src=\"build/vendor.js\"></script>\n    <script src=\"build/main.js\"></script>\n</body>\n</html> Before proceeding to the next development steps, now would be a good opportunity to create a HERE developer account and obtain your application tokens. You’ll need both an app id and an app code for JavaScript to be able to use any of the HERE APIs. Creating a HERE Map Component with Angular and Ionic Framework Now that we have a basic project created for Ionic Framework, we need to create an Angular component to represent our HERE map. As seen in my previous tutorial , there are several ways to accomplish this in Angular, but for us, we should probably create an actual component that can be reused. From the Ionic CLI, execute the following: ionic generate component here-map The above command will create an Angular component, configured for Ionic Framework. Eventually we’ll be able to use <here-map> throughout the pages of our application. Open the project’s src/components/here-map/here-map.html file and include the following: <div #map style=\"width: 100%; height: 100%\"></div> The above line will act as a placeholder for our interactive map. We are giving it full height and width so that way it scales to the parent dimensions found in each of the pages that you create. The #map attribute will allow us to find it in our TypeScript code. Open the project’s src/components/here-map/here-map.ts file and include the following TypeScript logic: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: 'here-map.html'\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    public constructor() { }\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() {\n        let platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        let defaultLayers = platform.createDefaultLayers();\n        let map = new H.Map(\n            this.mapElement.nativeElement,\n            defaultLayers.normal.map,\n            {\n                zoom: 10,\n                center: { lat: this.lat, lng: this.lng }\n            }\n        );\n        let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n    }\n\n} If you think the above TypeScript looks familiar, it is because I took it exactly from the previous Angular tutorial that I had written. As a refresher, we’ll walk through it again to explain what everything means. First you’ll notice this line: declare var H: any; Because our JavaScript SDK doesn’t have any TypeScript type definitions, we need to declare the class we wish to use so we don’t get transpiler errors. Basically we’re saying to ignore the fact that H won’t be recognized in TypeScript. Remember that #map we had in the HTML? The following line will allow us to gain access to it: @ViewChild(\"map\")\npublic mapElement: ElementRef; The ViewChild matches the name, but the variable can be whatever you want. Each of the Input annotations will reflect possible tag attributes to be passed when we try to use the <here-map> tag. Because the map will render after our view has finished loading, we have to do all of our logic in the ngAfterViewInit method. In this method we configure the platform and display the map based on the information supplied as tag attributes. Before we can start using our new component, we need to wire it up to Ionic Framework. As of now it is only an Angular component. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { ErrorHandler, NgModule } from '@angular/core';\nimport { IonicApp, IonicErrorHandler, IonicModule } from 'ionic-angular';\nimport { SplashScreen } from '@ionic-native/splash-screen';\nimport { StatusBar } from '@ionic-native/status-bar';\n\nimport { ComponentsModule } from \"../components/components.module\";\n\nimport { MyApp } from './app.component';\nimport { HomePage } from '../pages/home/home';\n\n@NgModule({\n    declarations: [\n        MyApp,\n        HomePage\n    ],\n    imports: [\n        BrowserModule,\n        ComponentsModule,\n        IonicModule.forRoot(MyApp)\n    ],\n    bootstrap: [IonicApp],\n    entryComponents: [\n        MyApp,\n        HomePage\n    ],\n    providers: [\n        StatusBar,\n        SplashScreen,\n        {provide: ErrorHandler, useClass: IonicErrorHandler}\n    ]\n})\nexport class AppModule {} Notice in the above code that we have imported our ComponentsModule and then added it to the imports array of the @NgModule block. That is the only change we’ve made to this file. Use the Interactive HERE Map Component within Ionic Framework Pages With the map component under control, now we can start using it in the pages of our application. We’re working with a blank project so we’ll have a single page to work with. Your project may vary and you’re definitely not limited to just a single page. Open the project’s src/pages/home/home.html file and include the following: <ion-header>\n    <ion-navbar>\n        <ion-title>\n            HERE Maps Example\n        </ion-title>\n    </ion-navbar>\n</ion-header>\n\n<ion-content>\n    <here-map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\"></here-map>\n</ion-content> Take note of the <here-map> tag that we’re using. In this tag we’re passing our attributes which we’re catching on the other end. Just make sure you swap your app id and app code rather than use my placeholder values. Conclusion You just saw how to include an interactive HERE map in an Ionic Framework progressive web application (PWA). Out of the box you should be able to build for the web with the Ionic CLI, but if you wish to build for Android or iOS, you’ll need to have Apache Cordova and the various Apache Cordova requirements met. However, you won’t have to change any of your code once Apache Cordova is configured. For this example we were using the HERE JavaScript SDK rather than the HERE Android SDK or HERE iOS SDK.", "date": "2019-02-12"},
{"website": "Here", "title": "Getting Started with Geocoding Exif Image Metadata in Python 3", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/getting-started-with-geocoding-exif-image-metadata-in-python3", "abstract": "The Exchangeable image file format (Exif) is a standard that’s been around since 1998 to include metadata in image file formats like JPEG, WAV, HEIC, and WEBP. With the proliferation of digital cameras and smart phones with GPS receivers these images often include geolocation coordinates. We’re going to get started with how to read geotagged photographs using Python to make use of the data. This project will demonstrate how to extract Exif data from a JPEG, how to convert from Degrees Minutes Seconds (DMS) to decimal coordinates, how to group photos by location, and finally how to place a thumbnail image on a map like this. Let’s get started. Reading Exif with Python I’ll be working with Python 3.7 in the examples since it’s almost 2020 and Python 2.7 won't be supported for much longer. $ python -V\nPython 3.7.2 I use virtualenv and virtualenv_wrapper to keep my project dependencies straight and recommend you do as well if you run into any issues installing libraries. There are several options you can use for reading Exif data such as piexif and exifread that you might like to try. As a more general purpose image library, I find Pillow to be helpful and is an update for some of the code samples you may see from Python 2.x examples referencing PIL . The installation is straightforward with pip install Pillow . With just a few lines of code we can display the Exif data: #!/usr/bin/env python\n\nfrom PIL import Image\n\ndef get_exif(filename):\n    image = Image.open(filename)\n    image.verify()\n    return image._getexif()\n\nexif = get_exif('image.jpg')\nprint(exif) What you get back from this get_exif() function is a dictionary with numeric keys that correspond to various types of data.  It isn’t terribly useful unless you know what you are looking for. Fortunately, the library also makes it easy to identify these attributes with human readable labels. from PIL.ExifTags import TAGS\n\ndef get_labeled_exif(exif):\n    labeled = {}\n    for (key, val) in exif.items():\n        labeled[TAGS.get(key)] = val\n\n    return labeled\n\nexif = get_exif('image.jpg')\nlabeled = get_labeled_exif(exif)\nprint(labeled) The label GPSInfo is much more meaningful than 34853 which is the numeric code defined in the standard for identifying the GPS data in Exif. The tags also show a variety of other details like the camera used, image dimensions, settings, etc. beyond just the geotagging results. To get a full list of the tags the Exiv2 Metadata reference table is pretty handy. GPSInfo = {1: 'N', 2: ((36, 1), (7, 1), (5263, 100)), 3: 'W', 4: ((115, 1), (8, 1), (5789, 100)), 5: b'\\x00', 6: (241175, 391), 7: ((19, 1), (8, 1), (40, 1)), 12: 'K', 13: (0, 1), 16: 'T', 17: (1017664, 4813), 23: 'T', 24: (1017664, 4813), 29: '2019:01:11', 31: (65, 1)}\nMake = Apple\nModel = iPhone 8\nSoftware = 12.1.2\nShutterSpeedValue = (223247, 48685)\nDateTimeOriginal = 2019:01:11 11:08:47\nFocalLength = (399, 100)\nColorSpace = 65535\nExifImageWidth = 4032 In addition to this subset, there are fields like the MakerNote which can include just about any data hex encoded for various uses and is often where photo software might store IPTC or XP metadata like comments, tags, subjects, titles, etc. that you see in Desktop Applications. I just want the geotagging details for this project which have additional tag constant labels I can reference: from PIL.ExifTags import GPSTAGS\n\ndef get_geotagging(exif):\n    if not exif:\n        raise ValueError(\"No EXIF metadata found\")\n\n    geotagging = {}\n    for (idx, tag) in TAGS.items():\n        if tag == 'GPSInfo':\n            if idx not in exif:\n                raise ValueError(\"No EXIF geotagging found\")\n\n            for (key, val) in GPSTAGS.items():\n                if key in exif[idx]:\n                    geotagging[val] = exif[idx][key]\n\n    return geotagging\n\nexif = get_exif('image.jpg')\ngeotags = get_geotagging(exif)\nprint(geotags) I now have a dictionary of some key geographic attributes that I can use for this project: {\n    'GPSLatitudeRef': 'N',\n    'GPSLatitude': ((36, 1), (7, 1), (5263, 100)),\n    'GPSLongitudeRef': 'W',\n    'GPSLongitude': ((115, 1), (8, 1), (5789, 100)),\n    'GPSTimeStamp': ((19, 1), (8, 1), (40, 1)),\n    ...\n} If you are trying to make sense of the GPSLatitude and GPSLongitude values you’ll notice they are stored in degrees, minutes, and seconds format . It’ll be easier to use HERE Services available with your developer account when working in decimal units so we should do that conversion. EXIF uses rational64u to represent the DMS value which should be straightforward to convert with PIL which has already given us numerator and denominator components in a tuple: def get_decimal_from_dms(dms, ref):\n\n    degrees = dms[0][0] / dms[0][1]\n    minutes = dms[1][0] / dms[1][1] / 60.0\n    seconds = dms[2][0] / dms[2][1] / 3600.0\n\n    if ref in ['S', 'W']:\n        degrees = -degrees\n        minutes = -minutes\n        seconds = -seconds\n\n    return round(degrees + minutes + seconds, 5)\n\ndef get_coordinates(geotags):\n    lat = get_decimal_from_dms(geotags['GPSLatitude'], geotags['GPSLatitudeRef'])\n\n    lon = get_decimal_from_dms(geotags['GPSLongitude'], geotags['GPSLongitudeRef'])\n\n    return (lat,lon)\n\n\nexif = get_exif('image.jpg')\ngeotags = get_geotagging(exif)\nprint(get_coordinates(geotags)) At this point, given an image as the input I’ve produced a latitude and longitude (36.13372, -115.15228) result. To figure out where that is we can use the geocoding service. Reverse Geocoding In Turn Text Into HERE Maps with Python NLTK , I demonstrated how to use the Geocoder API to take a city like “Gryfino” and search to identify the latitude and longitude coordinates. Now, I want to do the opposite and reverse geocode the set of coordinates from my image to identify the location. If you’ve worked with HERE services before you should know all about your API_KEY from the developer projects dashboard. Personally, I like to store these values in a shell script to config my environment as demonstrated in this next snippet. import os\nimport requests\n\ndef get_location(geotags):\n    coords = get_coordinates(geotags)\n\n    uri = 'https://revgeocode.search.hereapi.com/v1/revgeocode'\n    headers = {}\n    params = {\n        'apiKey': os.environ['API_KEY'],\n        'at': \"%s,%s\" % coords,\n        'lang': 'en-US',\n        'limit': 1,\n    }\n\n    response = requests.get(uri, headers=headers, params=params)\n    try:\n        response.raise_for_status()\n        return response.json()\n\n    except requests.exceptions.HTTPError as e:\n        print(str(e))\n        return {}\n\nexif = get_exif('image.jpg')\ngeotags = get_geotagging(exif)\nlocation = get_location(geotags)\n\nprint(location['items'][0]['address']['label']) This is pretty much boilerplate use of the Python requests library to work with web services that you can get with a pip install requests . I’m then calling the Reverse Geocoder API endpoint with parameters to retrieve the closest address within 50 meters. This returns a JSON response that I can use to quickly label the photograph with Las Vegas, NV 89109, United States to create an album or whichever level of detail I find useful for an application. This is a good way for example to process and group your photos by city, state, country or zip code with just a little bit of batch sorting. Geopy An alternative approach that can simplify the code a bit is to use the geopy library that you can get with a pip install geopy . It depends on the level of detail and flexibility you want from a full REST request but for simple use cases can greatly reduce the complexity of your code. from geopy.geocoders import Here\n\nexif = get_exif('image.jpg')\ngeotags = get_geotagging(exif)\ncoords = get_coordinates(geotags)\ngeocoder = Here(apikey=os.environ['API_KEY'])\nprint(geocoder.reverse(\"%s,%s\" % coords)) The response using geopy in this example is: Location(1457 Silver Mesa Way, Las Vegas, NV 89169, United States, Las Vegas, NV 89169, USA, (36.13146, -115.1328, 0.0)) . This can be convenient but customizing your request to the REST endpoint gives you the most flexibility. Removing Exif from Photos What if you don’t want geotagging details in photos that you share or put on a public website? While using the above is handy when working with my own photographs – if trying to sell something on Facebook Marketplace, Craigslist, or eBay I might want to avoid giving away my home address. It’s pretty straightforward to remove the geotagging details by creating a new image and not copying the Exif metadata. This quick script is a useful metadata removal tool for purposes like that: import sys\nfrom PIL import Image\n\nfor filename in sys.argv[1:]:\n    print(filename)\n\n    image = Image.open(filename)\n    image_clean = Image.new(image.mode, image.size)\n    image_clean.putdata(list(image.getdata()))\n    image_clean.save('clean_' + filename) Placing Markers on a Map for Photos Switching things up for a moment we’ll turn to web maps. If you haven’t created an interactive map before the Quick Start and other blog posts should help you get started with the Maps API for JavaScript . I already have the coordinates for my image so all that is left is to generate a small thumbnail that I can use for the marker. def make_thumbnail(filename):\n    img = Image.open(filename)\n\n    (width, height) = img.size\n    if width > height:\n        ratio = 50.0 / width\n    else:\n        ratio = 50.0 / height\n\n    img.thumbnail((round(width * ratio), round(height * ratio)), Image.LANCZOS)\n    img.save('thumb_' + filename) This function generates a thumbnail with a max height or width of 50 pixels which is about right for a small icon. Taking the quick start JavaScript I only need to add the next few lines to initialize the icon, place a marker at the coordinates retrieved from Exif with the icon, and then add it for rendering on the map. thumbnail = new H.map.Icon('./thumb_image.jpg');\nmarker = new H.map.Marker({lat: 36.13372, lng: -115.15228}, {icon: thumbnail});\nmap.addObject(marker); I could even consider dynamically generating this JavaScript from Python if I had many images I'm working with.  Firing up a python web server we get our final result. $ ls\nindex.html  index.js  thumb_image.jpg\n$ python -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... That photo was of the doorway in between the Las Vegas Convention Center and Westgate, not nearly as exciting as the Valley of Fire State Park pictured initially. Wrapping Up Wrapping up, a few final notes that might be helpful. There is Exif support in image formats like WEBP commonly used by Chrome and HEIC (or HEIF) which is the new default on iOS. Some of the supporting Python libraries are still being updated to work with these newer image formats though so require some additional work. There is also the c++ library exiv2 that is made available in the Python3 package py3exiv2 for reading and writing Exif data but it proved challenging to install with boost-python3 on OSX recently. If you’ve had any luck with these other image formats or libraries, please do share in the comments. The example project here should demonstrate all the steps you need for an image processing pipeline that can extract geotagged details from photographs and organize by location or place the photo on a map much like you see in apps on a phone. Sign up for a developer account to make use of the Map Image and Geocoding APIs on your next project.", "date": "2019-02-13"},
{"website": "Here", "title": "February Release Highlights Including Searching for Fast Food Snack Places by Distance", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/searching-for-fast-food-snack-places-by-distance-and-other-february-release-highlights", "abstract": "All services receive map content updates frequently but we will call out a few noteworthy highlights in February 2019 related to the following services: Places API , Traffic API , and Fleet Telematics API . There were other minor updates and fixes across many other services as well which were related to regular maintenance releases. View the API Version History for specific monthly updates including change log and release notes for all of the APIs. Places API Find (e.g., search for name, type, category), discover (e.g., look into address, contact info) and interact with POI information (e.g., enable user reviews, photos). Learn more… Version 2.70.0 Query results for category “snacks-fast-food” are now sorted by distance. Example If you take the Discovering Places example for Category Searches: // H.service.Platform already initialized with app id / code\nvar explore = new H.places.Explore(platform.getPlacesService());\nvar params = {\n  'cat': 'snacks-fast-food',\n  'at': '39.82596,-105.14587',\n  'size': '10'\n};\nexplore.request(params, {}, onResult, onError); The Explore Entrypoint will typically order results for a category by popularity. Given the nature of snacks and fast food, it may make more sense to order by distance. The following results (title, distance in meters, and position) were returned for the `snacks-fast-food` category of places near the Apex Center in Arvada, CO: ('Panera Bread', 1427, [39.813306, -105.143065])\n('Burger King', 1563, [39.81263, -105.14005])\n('Firehouse Subs', 1594, [39.8136, -105.13641])\n(\"Arby's\", 1602, [39.81311, -105.13738])\n('Taco Bell', 1619, [39.81232, -105.13924])\n(\"Jimmy John's\", 1687, [39.81139, -105.14035])\n('Chipotle', 1721, [39.81127, -105.13953])\n('Subway', 1739, [39.81231, -105.13594])\n('Silver Mine Subs', 1931, [39.81372, -105.12983])\n(\"Wendy's\", 1996, [39.81292, -105.16193]) Traffic API Display map tiles with real-time traffic flow information overlays reflected as colored lines drawn on affected streets and roads and get access to real-time traffic flow and incident data in XML and JSON. Learn more… Version 6.0.85.5 Introduction of incidents coverage for the following new markets: Lithuania (E2C43), Thailand (F3219), Mexico (A5F36), Taiwan (F1D13), Portugal (E4842), Romania (E1E01), and Bulgaria (E1801) Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Learn more... Version 2.5.11 New routing feature &excludeCountries=DEU,NLD by using 3 letter ISO country codes prevents routes from crossing borders into specific countries.", "date": "2019-02-18"},
{"website": "Here", "title": "Interacting with a Leaflet Map in an Ionic Framework PWA", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/interacting-with-a-leaflet-map-in-an-ionic-framework-pwa", "abstract": "Upon popular request, I had recently written a tutorial that demonstrated using the HERE JavaScript SDK in an Ionic Framework progressive web application (PWA) that used Angular. This previous tutorial demonstrated showing an interactive map in a web application and mobile application using the same set of code and it used the default HERE interactive map renderer. However, HERE is very flexible when it comes to the tools and libraries that you can use with it. For example, you could use Leaflet , a popular renderer, with your HERE data, something I demonstrated in a tutorial titled, Render and Interact with HERE Location Data using Leaflet and Angular . This time around, we’re going to accomplish the same, but within a PWA using Ionic Framework . To get an idea of what we want to accomplish, take a look at the following animated image: As you can see, we have our application running in a web browser and in an Android simulator. The thing to note is that we’re using Leaflet to render our map tiles rather than the default renderer that is part of the HERE JavaScript SDK. Start a New Ionic Framework Project with the Leaflet Dependencies To keep this project simple and easy to understand, we’re going to start fresh. Something to note about this tutorial versus my previous tutorial is that we’re going to be using Ionic 4.x this time around where as in the previous we were using Ionic 3.x. Assuming you have the latest Ionic CLI installed, execute the following: ionic start HereMapProject blank We’re not going to explore anything too fancy so a blank project with a single page is fine for us. With the Ionic 4.x project created, we need to include the Leaflet JavaScript and CSS dependencies. Open the project’s src/index.html file and include the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Ionic HERE Map</title>\n        <base href=\"/\" />\n        <meta name=\"viewport\" content=\"viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n        <meta name=\"format-detection\" content=\"telephone=no\" />\n        <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n        <link rel=\"icon\" type=\"image/png\" href=\"assets/icon/favicon.png\" />\n        <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n        <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" crossorigin=\"\"/>\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\" crossorigin=\"\"></script>\n    </body>\n</html> In the above HTML markup you’ll notice that we didn’t include any of the HERE libraries. This is because we’ll be using the HERE RESTful API to feed our tile information into Leaflet . At this point in time our project is ready to begin actual development. Creating a Map Component to be Reusable within the Application There are numerous ways to get a map into your Ionic Framework project. However, since it uses Angular, it probably makes sense to create an Angular component out of the interactive map HTML and TypeScript. From the Ionic CLI, execute the following command: ionic generate component here-map The above command behaves like it would with the Angular CLI, but the Ionic CLI massages it into the Ionic Framework project correctly. With the component created, the first thing we probably want to do is get the HTML figured out. Open the project’s src/app/here-map/here-map.component.html and include the following: <div #map style=\"width: 100%; height: 100%;\"></div> In the above markup we are making reference to the element through the #map attribute. This will later be used in our TypeScript code. We are also setting the width and height to 100% because we want it to take the full size of the parent component that it resides in. With the short HTML out of the way, let’s look at the project’s src/app/here-map/here-map.component.ts file: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var L: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.scss']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    public constructor() { }\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() {\n        const map = L.map(this.mapElement.nativeElement, {\n            center: [this.lat, this.lng],\n            zoom: 10,\n            layers: [L.tileLayer(\"https://2.base.maps.api.here.com/maptile/2.1/maptile/newest/reduced.day/{z}/{x}/{y}/512/png8?app_id=\" + this.appId + \"&app_code=\" + this.appCode + \"&ppi=320\")],\n            zoomControl: true\n        });\n        setTimeout(() => {\n            map.invalidateSize();\n        }, 1000);\n    }\n\n} In the above TypeScript we are obtaining the #map reference from the HTML and storing it in a mapElement variable based on the ViewChild . Each of the @Input variables will represent potential values coming from the user as tag attributes. So how does Leaflet get what we need from HERE? In the ngAfterViewInit we plug in the HERE Map Tile API endpoint into the Leaflet function for layers. This API endpoint includes the app id and app code values that can be found in the HERE developer portal . There is a catch though. Because Ionic Framework does some things at load time prior to the views being built, Leaflet cannot determine the correct window sizing information immediately. Because of this, some or all tiles may be missing from the view. To correct this, we can set a short timeout and invalidate the map size causing it to refresh. Showing a Leaflet Map on the Screen with HERE Data With the component created, now it really comes down to displaying it on any given page within the application. We can’t just display custom components as we please. We first need to import them into the modules that we wish to use. For example, open the project’s src/app/home/home.module.ts file and include the following: import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { FormsModule } from '@angular/forms';\nimport { RouterModule } from '@angular/router';\n\nimport { HereMapComponent } from '../here-map/here-map.component';\n\nimport { HomePage } from './home.page';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        IonicModule,\n        RouterModule.forChild([\n            {\n                path: '',\n                component: HomePage\n            }\n        ])\n    ],\n    declarations: [HomePage, HereMapComponent],\n    exports: [HereMapComponent]\n})\nexport class HomePageModule {} Notice that we’ve imported our component and added it to the declarations array as well as the exports array of the @NgModule block. By doing this we are saying that we can now use this custom component in our home page, which is the only page of this particular application. With the module ready to go, open the project’s src/app/home/home.page.html file and include the following: <ion-header>\n    <ion-toolbar>\n        <ion-title>\n            Ionic HERE Map\n        </ion-title>\n    </ion-toolbar>\n</ion-header>\n\n<ion-content>\n    <here-map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\"></here-map>\n</ion-content> In the above HTML file we are adding our custom <here-map> tag with each of the possible attributes that we defined in the TypeScript code. Remember, you’ll need to get your app id and app code tokens from the HERE developer portal , otherwise nothing will render on your map. Conclusion You just saw how to include Leaflet in your Ionic Framework progressive web application (PWA). The steps to include Leaflet are really no different from including the default HERE renderer with the HERE JavaScript SDK. While this example demonstrated Ionic 4.x, I had written a previous example that demonstrated Ionic 3.x. Out of the box you’ll be able to deploy for web, but if you want to deploy on Android or iOS you’ll need to get the appropriate Apache Cordova dependencies and configure them for Ionic Framework. You won’t need to alter your code, but there may be some configuration changes on your computer.", "date": "2019-02-19"},
{"website": "Here", "title": "Isoline Mapping with HERE in an Ionic Framework Progressive Web Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/isoline-mapping-with-here-in-an-ionic-framework-progressive-web-application", "abstract": "I’ve been giving quite a few demonstrations of isoline graphs, both in person and through previous blog tutorials. It is in my opinion one of the most awesome features that HERE offers to developers because of how little is required from the developer while accomplishing so much. In case you’re unfamiliar, an isoline is a calculation from a starting point and some range value. Given this information we can visualize how long it might take us to get somewhere within that range or how far we can get. This is not to be confused with a radius which might be inaccurate based on traffic or roads that cannot be traveled. You might remember that I previously demonstrated how to work with isolines using strictly Angular, but this time around we’re going to take a look at working with isolines using the progressive web application framework, Ionic . To get an idea of what we hope to accomplish, take a look at the following animated image: To keep things simple, we’re only going to be worrying about displaying an isoline at our maps center rather than collecting user input as part of a search functionality. You’ll notice that this is compatible in the web as well as a mobile Android or iOS application. Building an Ionic Framework with HERE Maps Application To start this project we are going to create a new project. However, we’ll be using Ionic 4.x and a lot of this code will be recycled from a previous tutorial that was centered around Leaflet, which is a third party rendering library. In this particular tutorial we’ll use the default renderer rather than Leaflet. Assuming the Ionic CLI is installed, execute the following: ionic start HereMapsProject blank The above command will create a new blank project with only one page. We’re going for simplicity in an effort to eliminate any confusion that might come out of this subject material. Now that we have our project, we need to get up to speed with our mapping component. Because I already wrote extensively on the configuration, we’re going to breeze through this with minor detail. Open the project’s src/index.html file so we can include our HERE JavaScript SDK: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <title>Ionic HERE Map</title>\n        <base href=\"/\" />\n        <meta name=\"viewport\" content=\"viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n        <meta name=\"format-detection\" content=\"telephone=no\" />\n        <meta name=\"msapplication-tap-highlight\" content=\"no\" />\n        <link rel=\"icon\" type=\"image/png\" href=\"assets/icon/favicon.png\" />\n        <meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n        <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.0/mapsjs-ui.css?dp-version=1533195059\" />\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-places.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> To give us isoline functionality, we’ve included several of the JavaScript components as well as the CSS library. Different HERE functionality will require different components. With the JavaScript SDK in place, we need to create our map component by executing the following: ionic generate component here-map The above command will create several files, this first of which is for our HTML markup. Open the project’s src/app/here-map/here-map.component.html file and include the following: <div #map style=\"width: 100%; height: 100%;\"></div> With the container for our map in place, we can start developing the TypeScript logic to go with it. Open the project’s src/app/here-map/here-map.component.ts file and include the following: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.scss']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input()\n    public appId: any;\n\n    @Input()\n    public appCode: any;\n\n    @Input()\n    public lat: any;\n\n    @Input()\n    public lng: any;\n\n    private platform: any;\n    private map: any;\n    private router: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        this.router = this.platform.getRoutingService();\n    }\n\n    public ngAfterViewInit() {\n        setTimeout(() => {\n            let defaultLayers = this.platform.createDefaultLayers();\n            this.map = new H.Map(\n                this.mapElement.nativeElement,\n                defaultLayers.normal.map,\n                {\n                    zoom: 10,\n                    center: { lat: this.lat, lng: this.lng }\n                }\n            );\n            let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(this.map));\n        }, 100);\n    }\n\n    public isoline() { }\n\n} Everything should look pretty familiar up until now if you saw the previous tutorials I wrote. One difference between this code and the Leaflet code is how we are refreshing the component when the view has finished loading. You’ll notice that the entire ngAfterViewInit method is wrapped with a setTimeout . This is necessary because in Ionic Framework, the view size isn’t instantly ready, even in the lifecycle hooks that Angular offers. We could either add a timeout to the whole code, or we could optionally set a timeout like this: setTimeout(() => {\n    this.map.getViewPort().resize();\n}, 100); What you decide to use is totally up to you. The use of the resize method more similarly matches what I used in the Leaflet example where I used invalidateSize instead. Before we can start using the component in our pages, we need to add it to the module for the pages we wish to use it in. Open the project’s src/app/home/home.module.ts file and make it look like the following: import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { IonicModule } from '@ionic/angular';\nimport { FormsModule } from '@angular/forms';\nimport { RouterModule } from '@angular/router';\n\nimport { HereMapComponent } from '../here-map/here-map.component';\n\nimport { HomePage } from './home.page';\n\n@NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        IonicModule,\n        RouterModule.forChild([\n            {\n                path: '',\n                component: HomePage\n            }\n        ])\n    ],\n    declarations: [HomePage, HereMapComponent],\n    exports: [HereMapComponent]\n})\nexport class HomePageModule {} We’ve imported the HereMapComponent and added it to the @NgModule block. Finally we can use it in our page. Open the project’s src/app/home/home.page.html file and include the following: <ion-header>\n    <ion-toolbar>\n        <ion-title>\n            Ionic HERE Map\n        </ion-title>\n    </ion-toolbar>\n</ion-header>\n\n<ion-content>\n    <here-map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\" lat=\"37.7397\" lng=\"-121.4252\"></here-map>\n</ion-content> You’ll need to have registered a free account with HERE in order to get your app id and app code values. But notice that these are the expected inputs that are defined in the previous TypeScript file. The lat and lng values will also represent our center point on the map as well as the center point to our isoline. Just like I previously mentioned, the goal of this article was not to go in depth with showing HERE maps in an Ionic Framework application. This was already covered in my previous article titled, Interacting with a Leaflet Map in an Ionic Framework PWA . We just needed the foundation in place so we can work with isoline functionality. Calculating an Isoline with a Center Point and Range Variable With the application functional, we can worry about our isoline, which is actually just a few lines of code. Open the project’s src/app/here-map/here-map.component.ts file and include the following isoline method: public isoline() {\n    let params = {\n        \"mode\": \"fastest;car;traffic:enabled\",\n        \"range\": \"300\",\n        \"rangetype\": \"time\",\n        \"departure\": \"now\",\n        \"start\": this.lat + \",\" + this.lng\n    }\n    this.map.removeObjects(this.map.getObjects());\n    this.router.calculateIsoline(params, data => {\n        if(data.response) {\n            let center = new H.geo.Point(data.response.center.latitude, data.response.center.longitude),\n                isolineCoords = data.response.isoline[0].component[0].shape,\n                linestring = new H.geo.LineString(),\n                isolinePolygon,\n                isolineCenter;\n            isolineCoords.forEach(coords => {\n                linestring.pushLatLngAlt.apply(linestring, coords.split(','));\n            });\n            isolinePolygon = new H.map.Polygon(linestring);\n            isolineCenter = new H.map.Marker(center);\n            this.map.addObjects([isolineCenter, isolinePolygon]);\n            this.map.setViewBounds(isolinePolygon.getBounds());\n        }\n    }, error => {\n        console.error(error);\n    });\n} So what is happening in the above code? To calculate an isoline, a few parameters must be defined. We need to know how the isoline is being measured, which in our case is transport by car with traffic being monitored. We need to know the range that we’re measuring, which in our case is 300 seconds. Because traffic is involved, we need to specify a time to track where now is the current traffic conditions rather than a date in the past. The start point is the center of our isoline which for this example is the center of the map. Every time we run this method we are going to clear the map. When we calculate the isoline we are going to get the coordinate information necessary from the response in order to draw our polygons and lines. We’re also placing a marker at the given center of the isoline. The calculation through the API is quite simple in comparison to what it could be if you had to do all of this by hand. Conclusion You just saw how to work with isolines in an Ionic Framework application that works for both the web as well as mobile. This particular example used the default HERE map and Ionic 4.x. If you’re still using Ionic 3.x and you need help configuring your application to use HERE, you might check out my previous tutorial titled, Display an Interactive HERE Map in an Ionic Framework Application . This example should build for the web with no added dependencies. If you wish to build for Android or iOS, you’ll need Apache Cordova available to you. However, no changes to the code are necessary to cross build.", "date": "2019-02-26"},
{"website": "Here", "title": "Render and Interact with HERE Location Data using Leaflet and Angular", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/render-and-interact-with-here-location-data-using-leaflet-and-angular", "abstract": "When it comes to development, I’m all about choosing the right tool for the job. While HERE offers a great interactive map component as part of its JavaScript SDK, there might be reasons to explore other interactive map rendering options. Take Leaflet for example. With Leaflet you can provide your own tile layer while working with a very popular and easy to use open source library. In a past tutorial you’ll remember that I had demonstrated how to use Angular with HERE, but this time around we’re going to shake things up a bit. We’re going to use Angular with HERE data, but we’re going to display and interact with it using Leaflet. To get a better idea of what we plan to accomplish, take a look at the following animated image: We’re going to display an interactive map, geocode some addresses, and display those addresses on the map as markers using Leaflet, Angular, and the HERE RESTful API. Starting with a New Angular Project and the Leaflet Dependencies Before going forward, the assumption is that you have the Angular CLI installed and that you have a free HERE developer account . With these requirements met, go ahead and execute the following command: ng new leaflet-project The above command will create our new Angular project, but that project won’t be ready to use Leaflet. We have to first include the necessary JavaScript and CSS files. Open the project’s src/index.html file and make it look like the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>LeafletProject</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\"></script>\n    </body>\n</html> Notice that we’ve included the CSS library as well as the JavaScript library for Leaflet. Technically, this is all that is required to start using Leaflet with HERE in an Angular application. However, we’re going to do some more preparation work to set us up for some awesome features. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n    declarations: [\n        AppComponent\n    ],\n    imports: [\n        BrowserModule,\n        HttpClientModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } Because we are no longer using the HERE JavaScript SDK, we are now relying on HTTP requests to the RESTful API. By default, HTTP in Angular is disabled, so by including the HttpClientModule and adding it to the imports array of the @NgModule block, we are enabling it. While not absolutely necessary, we could also clean up the CSS a bit to allow us a full screen map. Open the project’s src/styles.css file and include the following: body {\n    margin: 0;\n} Now everything will take up the full width and height without the default margins. It may seem like we’ve done a lot as of now, but it has been strictly configuration. Now we’re going to get into the fun stuff, which is development with Leaflet and Angular. Create an Angular Component to Represent an Interactive HERE Map While there are many ways to start using maps in your project, the cleanest approach is to create a dedicated Angular component so the maps can be reused throughout the application. From the Angular CLI, execute the following: ng g component here-map The above command will generate several files for us that will represent our component. We’re going to start by opening the project’s src/app/here-map/here-map.component.html file and including the following markup: <div #map [style.height]=\"height\" style=\"width: 100%;\"></div> In the above markup you’ll notice the #map attribute. We’re going to use this as a reference so we can access this DOM element from our TypeScript code. You’ll also notice that we have a dynamic height and a static width. It is easy to full screen the width of a component, but you have to be a CSS wizard to full screen the height. To cheat, we’re going to use JavaScript to determine the height and set it as a variable after everything initializes. With the HTML in place, open then project’s src/app/here-map/here-map.component.ts file and include the following: import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\ndeclare var L: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: ElementRef;\n\n    @Input(\"appId\")\n    public appId: string;\n\n    @Input(\"appCode\")\n    public appCode: string;\n\n    private map: any;\n    public srcTiles: string;\n    public height: string;\n\n    public constructor(private http: HttpClient) {\n        this.height = window.innerHeight + \"px\";\n    }\n\n    public ngOnInit() {\n        this.srcTiles = \"https://2.base.maps.api.here.com/maptile/2.1/maptile/newest/reduced.day/{z}/{x}/{y}/512/png8?app_id=\" + this.appId + \"&app_code=\" + this.appCode + \"&ppi=320\";\n    }\n\n    public ngAfterViewInit() {\n        this.map = L.map(this.mapElement.nativeElement, {\n            center: [37.7397, -121.4252],\n            zoom: 10,\n            layers: [L.tileLayer(this.srcTiles)],\n            zoomControl: true\n        });\n    }\n\n    public dropMarker(address: string) {\n        this.http.get(\"https://geocoder.api.here.com/6.2/geocode.json\", {\n            params: {\n                app_id: this.appId,\n                app_code: this.appCode,\n                searchtext: address\n            }\n        }).subscribe(result => {\n            let location = result.Response.View[0].Result[0].Location.DisplayPosition;\n            let marker = new L.Marker([location.Latitude, location.Longitude]);\n            marker.addTo(this.map);\n        });\n    }\n\n} This file and the above code is the bulk of our project. To make things easier to understand, we’re going to look at the above code piece by piece. Within the HereMapComponent class, we have the following: @ViewChild(\"map\")\npublic mapElement: ElementRef;\n\n@Input(\"appId\")\npublic appId: string;\n\n@Input(\"appCode\")\npublic appCode: string; The ViewChild is referencing our #map attribute from the HTML. This is how we’re getting reference to the HTML component for further usage. Each of the @Input annotations represents a possible attribute that the user can provide. In our example the user will be providing the app id and app code found in their developer dashboard. Remember that dynamic height I was talking about. We’re setting it here: public constructor(private http: HttpClient) {\n    this.height = window.innerHeight + \"px\";\n} We are calculating the inner browser height and setting it using JavaScript. This way we can avoid all the tricky vertical height stuff that comes with standard CSS. Because we’re using Leaflet, we’re relying heavily on the various HERE RESTful APIs and this includes the Map Tile API . public ngOnInit() {\n    this.srcTiles = \"https://2.base.maps.api.here.com/maptile/2.1/maptile/newest/reduced.day/{z}/{x}/{y}/512/png8?app_id=\" + this.appId + \"&app_code=\" + this.appCode + \"&ppi=320\";\n} Using the provided app id and app code we can construct our URL for getting tiles from the API. This is set in the ngAfterViewInit when we initialize Leaflet. public ngAfterViewInit() {\n    this.map = L.map(this.mapElement.nativeElement, {\n        center: [37.7397, -121.4252],\n        zoom: 10,\n        layers: [L.tileLayer(this.srcTiles)],\n        zoomControl: true\n    });\n} When initializing Leaflet, we are using the HTML component that we referenced, are centering the map on certain coordinates, and are using our HERE Tile API for the layer. While we won’t be working with markers and geocoding by default, we’re going to lay the foundation within our component: public dropMarker(address: string) {\n    this.http.get(\"https://geocoder.api.here.com/6.2/geocode.json\", {\n        params: {\n            app_id: this.appId,\n            app_code: this.appCode,\n            searchtext: address\n        }\n    }).subscribe(result => {\n        let location = result.Response.View[0].Result[0].Location.DisplayPosition;\n        let marker = new L.Marker([location.Latitude, location.Longitude]);\n        marker.addTo(this.map);\n    });\n} When the dropMarker method is executed, we make a request to the HERE Geocoder API with a search query. In our scenario the search query is an address or location. The results are then used to create a marker which is added to the map. Before we can start using our new component, we need to wire it up. Open the project’s src/app/app.module.ts file and include the following: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HereMapComponent } from './here-map/here-map.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        HereMapComponent\n    ],\n    imports: [\n        BrowserModule,\n        HttpClientModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { } Notice that this time around we have imported our component and added it to the declarations array of the @NgModule block. The tough stuff is over and we can now work towards displaying our map. Displaying and Interacting with the Angular Map Component Since this is a simple project, we don’t have a router. Instead everything will be rendered inside the project’s src/app/app.component.html file. Open this file and include the following: <here-map #map appId=\"APP-ID-HERE\" appCode=\"APP-CODE-HERE\"></here-map> There are a few things to take note of in the above. First, it is only coincidence that we’ve added a #map attribute. We don’t truly need to add one and if we did, it doesn’t need to have the same name as the previous component. Second, notice the appId and appCode attributes. You’ll want to swap the placeholder values with your own tokens. Now open the project’s src/app/app.component.ts file and include the following: import { Component, OnInit, ElementRef, ViewChild } from '@angular/core';\nimport { HereMapComponent } from \"./here-map/here-map.component\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    @ViewChild(\"map\")\n    public mapElement: HereMapComponent;\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() {\n        this.mapElement.dropMarker(\"tracy, ca\");\n        this.mapElement.dropMarker(\"lathrop, ca\");\n    }\n\n} We want to be able to make use of the dropMarker function that sits in our map component. To do this we need to gain reference to our HTML component with the #map attribute. Once we have reference, then we can start calling the public functions that reside in it. In our example, we are adding two markers for two local cities in California. Conclusion You just saw how to use Leaflet in your Angular project to work with HERE data. HERE is flexible so you’re able to use whatever renderer you want to display your interactive maps. In my previous tutorial we used the default renderer, but this time we used Leaflet which is just one of many options.", "date": "2019-02-14"},
{"website": "Here", "title": "Creating a Chat Bot with Amazon Lex, Slack, and HERE", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/lets-chatbot-about-lex-slack-and-here", "abstract": "We are always in pursuit of an autonomous world - one that efficiently automates tasks both small and large. We are also human, and desire the best possible user experience. Developers are often mandated to provide a solution that meets these requirements. Today, we are happy to announce our new tutorial to aid developers in there quest to meet such demands. The tutorial is titled \"Extend the Capability of Amazon Lex with HERE Location Services\", and the link to it is posted at the end of this post. For now, we will provide an overview of what is covered, the major services used, and the possibilities of how developers could use skills learned moving forward. Overview The objective of the tutorial is to guide developers to create a chat bot within a collaborative environment to answer questions regarding the location of assets. Specifically, developers will create an AWS Lex chatbot for use within a Slack application, using HERE location services to determine the location of assets within the greater Seattle area. The following are prerequisites for getting started: Slack account ( https://api.slack.com ) AWS account ( https://aws.amazon.com ) HERE Developer account ( https://developer.here.com ) It is assumed developers are familiar with AWS, Slack, and have a basic understanding of development tools such as NPM. Now let's consider each major service used in the tutorial in more detail. Amazon Lex A chatbot is a service that allows automated real-time communication with a person via text or voice. In the tutorial, the service is text-based only. You will create an Amazon Lex chatbot to ask a simple question about the location of assets. The chatbot service will prompt the user for additional information when needed. If you have never developed a chatbot before, this is a great way to learn! Slack Here is how Slack describes itself: Slack is a collaboration hub for work, no matter what work you do. It’s a place where conversations happen, decisions are made, and information is always at your fingertips. With Slack, your team is better connected. In the tutorial, Slack is the environment you will invoke the chatbot from. HERE Location Services At the core of the chatbot intelligence is determining the location of assets. You will be guided to create an AWS Lambda that will be invoked by the chatbot to provide determine location based on geofencing . Although the assets never move (coordinates are statically added), the geofencing logic is called in real-time to determine location. At the end of the tutorial, developers could take any of the lessons learned to the next level. For example, with HERE location services, using the Positioning API to extract coordinates of actual assets. With Amazon Lex , adding more natural language elements to the conversation, or hosting in other collaborative environments. Call to Action We welcome you to now get started at our tutorial - Extend the Capability of Amazon Lex Chatbot with HERE Location Services. Also, please join us for our web inar on Tuesday March 12th for a technical review of this topic. Happy coding!", "date": "2019-02-22"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.3 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.3-release", "abstract": "Highlights Improvements to running Batch Pipelines on-demand As a Pipeline developer, you can now quickly iterate on your Pipeline logic by running Batch Pipelines on-demand, without waiting for the up-stream catalogs to change or making dummy updates to the catalogs. In addition, you can save time and effort by not having to provide the parameters that were previously required, including input and output Catalog versions, and processing type; these parameters are now optional. If these parameters are not provided, the Batch Pipeline will run using the latest input and output Catalog versions, and reprocess all input data. NOTE: This will not allow you to test Batch Pipelines that perform incremental processing, as these workloads require meaningful changes to the input catalogs. The best way to test Pipelines that perform incremental processing is still to trigger changes to the input Data Catalogs. NOTE: To run a Batch Pipeline on-demand that uses an Index Layer in the input or output Catalogs, a dummy version of that Catalog and processing type is needed. See the CLI documentation for more details. Save and edit draft Marketplace Listings As a Marketplace Provider, when preparing a Listing, you can now save an incomplete Listing as a draft, and then resume editing later. This also lets others in your Org to make edits to the draft before finally publishing to the Marketplace. With this, teams can work collaboratively on Listings, ensuring all of your subject matter experts can weigh in, provide the right information, and review works in progress. NOTE: Users must have Marketplace provider management access to create and edit Listings. Contact your account admin to verify if you have access. Grant permission to invite new users to the Org and Groups A new Org Inviter role has been added, giving selected users the permission to invite other users to the Org. Only an Org Admin can grant the permission to invite other users. This capability reduces the burden on organization level administrators to invite all users, and reduces the number of users in the organization that need to be Org Admins. If the user receiving the new permission (the \"Org Inviter\") is also a Group Admin, they have the ability to add the user directly to their Group. Develop visualization plugins using online Javascript editor The Data Inspector on the Inspect tab now features a rich online JavaScript editor, simplifying the development and testing of custom renderer plugins from the OLP Portal, and making it easier to enable other users in your Org to visualize data encoded by your custom schema. With this editor, you can write, fine-tune and then run your plugin code. The plugin converts your data into GeoJSON, which then renders your data on the base map. WIth this, you and others can visualize your custom data and more easily inspect results of your Pipelines. The plugin code can be downloaded for local development and visualization, or for publication to OLP through the Schema archetype so that others can also visualize your data. Pipelines Changed A scheduled batch pipeline version will not convert to an on-demand run, even if the input and output catalog versions, or the type of processing, are specified. When running batch pipelines on-demand, parameters that were previously required are now optional, including input and output catalog versions, and processing type. If these parameters are not provided, the batch pipeline will run using the latest input and output catalog versions, and reprocess all input data. With this change, you no longer have to wait for the input catalogs to change, or force updates to the input catalogs in order to tigger an immediate execution of the batch pipeline. Fixed Fixed an issue where the user couldn't specify array values for pipeline run-time configurations due to a parameter limitation. Fixed an issue where the Pipeline service marked a job as Failed at the same time as marking the pipeline version as Ready. Fixed an issue where a canceled job was stuck in a Running state. Fixed an issue where a Pipeline's Elapsed Time was different than the CPU consumption interval in Grafana. Known Issues Issue A scheduled Pipeline Version cannot be forced to run on-demand. Workaround Create a copy of the pipeline version and run the new pipeline version on-demand. Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue To run a Batch Pipeline on-demand that uses an Index Layer in the input or output Catalogs, a dummy version of that Catalog and processing type is needed. See the CLI documentation for more details. Issue Pipelines belonging to the same group also share the same application ID. If multiple pipelines in the same group consume data from the same stream layer, then each pipeline only receives a subset of the messages from the input stream. Workaround Configure your Pipelines to use the Direct Kafka connector type in the Data Client Library, and then specify a unique Kafka consumer group ID for each pipeline If your pipelines use the http connector type, you can create a new group for each pipeline; each will receive its own application ID. Issue A Pipeline Version can be activated even after an input catalog that it uses is deleted. Workaround The pipeline will fail when it starts running and will show the error message about missing catalog. Re-check the missing catalog or use a different catalog. Issue A Pipeline Version, created and run instantly, cannot be scheduled. Workaround Create a copy of the Pipeline Version and put the new pipeline version in schedule. Issue Only a finite number of permissions is allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and long names of actions defined. Workaround Delete Pipelines/Users to recover space. ​ Data Known Issues Issue Catalogs not associated with a realm are not visible in OLP. Issue Data encryption is limited to: Versioned data at rest Stream layer data Index layer data Notebooks In-flight data encryption is not consistently implemented across OLP. You should not send sensitive data or personal information to OLP at this time. Issue Visualization of Index Layer data is not yet supported. Issue When you use the Data API or Data Library to create a catalog or layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps and groups. Issue When creating an Index Layer and processing stream data in a data archive pipeline, it is possible to select Parquet as a data format. However, a corresponding Spark Connector is not available with this release, making it non-trivial to consume data in this format. As a mitigation, we recommend you not use Parquet format with this release. Issue Some older catalogs cannot be shared temporarily because the catalog owners don't have permissions assigned to them yet. This issue only applies to older catalogs. Contact us to report each occurrence as a bug. ​ Notebooks Known Issues Issue Notebooks do not support Flink. Issue Notebooks do not contain support for Stream Layers. ​ Account & Permissions Added Any user can now be granted permission to invite other users to the Org, reducing the burden on the organization-level Admin to invite all users. If the user receiving the new permission (the \"Org Inviter\") is also a Group Admin, they have the ability to add the user directly to their Group. ​ Known Issues Issue A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Delete pipelines/pipeline templates to recover space. Issue All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue When updating permissions, it can take up to an hour for changes to take effect. ​ Marketplace Added Added feature for save draft Listing. When preparing a Marketplace Listing, users can now save the Listing as draft and let others in their organization make edits before publishing to the Marketplace. The feature enables teams to work collaboratively when preparing to publish a Marketplace Listing, which can improve Listing quality and compliance by leveraging subject matter experts in their own organization. NOTE: The feature is available to users who have Marketplace provider management access. Contact your account admin to verify if you have access. ​ Fixed Resolved the issue where when a Marketplace Provider grants data access to a Marketplace Consumer, there could be a delay before the Consumer sees the data catalog in their licensed data area, because the confirmation email is only sent after the consumer has accepted the subscription. Known Issues Issue If you are a Workspace user and have pipelines that use the Kafka Direct connector to connect to stream data, no messages-in and bytes-in metrics can be collected. Workaround You can instrument your pipelines with custom messages-in and bytes-in metrics. Contact technical support if you need assistance. Issue When the Splunk server is busy, the server can lose usage metrics. Workaround If you suspect you are losing usage metrics, contact HERE technical support. We may be able to help rerun queries and validate data. ​ Web & Portal Added Run a batch pipeline Version on-demand, withouth providing input and output Catalog versions or processing times. Added new functionality that simplifies the development and testing of custom renderer plugins from the OLP Portal. The Data Inspector on the Inspect tab now features a rich online JavaScript editor. This allows you to write, fine-tune and run your plugin code to convert your OLP data into GeoJSON, visualize your data on the base map and review the results. The plugin code can be downloaded for local usage or for publication to OLP through the Schema archetype. Known Issues Issue Data visualization in the Portal is only available for versioned and volatile layers. Issue Data can be only be visualized if it is formatted according to the following schema formats: GeoJSON HERE Reality Index Topology HERE Reality Index Building Footprints HERE Reality Index Cartography HERE Traffic Flow SDII Workaround: Create a visualization for your schemas using a GeoJSON renderer. Issue The Portal and notebooks are not compatible with Internet Explorer 11. Issue The pipelines list page is sometimes slow to load. Issue The custom runtime configuration for a pipeline version has a limit of 64 characters for the property name, and a limit of 255 characters for the value. Workaround For the property value, there is no workaround. For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. Issue A Batch Pipeline Version using an Index Layer in the input or output Catalogs doesn't run on-demand from the Portal. It gets stuck in the Scheduled state. Workaround Use the CLI or API to run such a Batch Pipeline on-demand by specifying dummy version of the Catalogs with the Index Layer. Issue The Portal can't be used to delete pipeline templates. Workaround Use the CLI or API to delete pipeline templates. Issue In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list. Issue Some PDF documentation has formatting errors.", "date": "2019-02-26"},
{"website": "Here", "title": "Oracle augments its IoT Applications with HERE Location Suite", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/oracle-augments-its-iot-applications-with-here-location-suite", "abstract": "If you are a developer or a company using the Oracle IoT Cloud, your job just got better – now you can access HERE location solutions natively within the company's IoT services. For more than 15 years, we’ve partnered with Oracle to provide location intelligence solutions for their worldwide network of customers and developers. The tools we’ve brought include location technology  like mapping, geocoding , truck routing, and more. Today, we’re expanding those capabilities in a big way. The HERE Location Suite is now natively integrated into Oracle Internet of Things (IoT) Cloud . We’re extremely proud to take the next step in our partnership with Oracle, and excited at the opportunity to strengthen our partnership with one of the world’s largest software providers and empower even more of you out there to use the best location technology on the planet! IoT is expanding at a rapid rate as enterprises and vendors become more aware of the possibilities of connectivity. As IoT evolves and the world becomes increasingly connected, more precise, accurate location data has become an ever-more critical component to effective IoT operations. Accurately pinpointing assets reveals crucial information about their functioning and usage, which offers businesses more valuable information about their products. “As a trusted, longtime partner, HERE provides Oracle with complete global mapping coverage and high-quality geocoding for the precise location insights required for our IoT applications,” said Jai Suri, Senior Director, Product Management, IoT Cloud at Oracle. “The enhanced IoT functions from HERE location intelligence enable Oracle IoT Cloud customers to unlock greater business value from manufacturing, logistics and supply chain applications and transform business processes.” HERE Location Services is based on one of the industry’s strongest mapping platforms, known for its high level of detail, accuracy, reliability, robustness and flexibility. I can't wait to see what you build with it! Join Richard Süselbeck at Mobile World Congress on February 25-27th and discover what you can build with our Developer Portal in the HERE Tech Lounge at Plaça d’Europa. Book your meeting now , or follow our social media channels for our coverage of the event.", "date": "2019-02-19"},
{"website": "Here", "title": "Getting Started with Speed Limits and Fleet Telematics", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/getting-started-with-speed-limits-and-fleet-telematics", "abstract": "Navigating from Point A to Point B is one of the most common use cases we see in location services. If you’ve ever felt like the travel time estimate was wrong you might wonder why. One reason is that we don’t all drive the same way. Since estimates returned from navigation services are best guesses based on traffic conditions and average speeds it may not match your expectations. If you want an app that provides more accurate results, the custom speed profiles in the HERE Fleet Telematics REST API might help. I’m going to take a look at what Fleet Telematics is to demonstrate how to use the REST endpoint with curl and get back results based on a custom speed profile. What is Fleet Telematics What does the name Fleet Telematics mean? The first part of the name comes from Fleet , meaning a group of motor vehicles owned or leased by an organization rather than an individual. The typical examples of this are things like car rental companies, taxicabs, public utility vehicles, buses, delivery trucks, police and rescue vehicles, etc. The second part of the name Telematics is derived from the French telematique , a blended word of telecommunications and informatique (computer science). From the blog post Our Platform Extensions Are Getting a Makeover you learned a bit about why the Fleet Telematics API can be useful when your use case gets more advanced than the Routing API alone. Let’s start with the basics. Routing API The Routing API is perfect for quickly finding the route between two waypoints for most cases. Let’s look at an example navigating from Alamo Drafthouse Cinema in Austin, TX to The Alamo in San Antonio, TX. I setup a short script like the following (for Linux / OSX) which initializes my APP ID and APP CODE into my environment. You can find these values from the Projects dashboard: #!/bin/sh\n\nexport APP_ID_HERE=YOUR_APP_ID_HERE\nexport APP_CODE_HERE=YOUR_APP_CODE_HERE\nexport ROUTING_API_HERE='https://route.api.here.com/routing/7.2'\nexport FLEET_URI_HERE='https://fleet.api.here.com/2/' Then I can use curl and jq to pretty print the resulting JSON response and run some experiments: #!/bin/bash\n\ncurl \\\n  -X GET \\\n  -H 'Content-Type: *' \\\n  --get \"$ROUTING_API_HERE/calculateroute.json\" \\\n    --data-urlencode \"app_id=$APP_ID_HERE\" \\\n    --data-urlencode \"app_code=$APP_CODE_HERE\" \\\n    --data-urlencode 'waypoint0=geo!30.298363,-97.704712' \\\n    --data-urlencode 'waypoint1=geo!29.42561,-98.48653' \\\n    --data-urlencode 'mode=fastest;car;traffic:enabled' \\\n    --data-urlencode 'legattributes=li' \\\n| jq '.' The route from theater to museum is 131,419 meters (81 miles) with a travel time of 5,233 seconds (1 hour, 27 minutes).  This CalculateRouteResponseType as pictured below includes a set of instructions (or maneuvers) we can use from the response. I also included the legattributes=li which will include the RouteLinkAttributeType in the response. These links include the speed limit details that can be useful. \"maneuver\": [\n  {\n    \"position\": {\n      \"latitude\": 30.298262,\n      \"longitude\": -97.7047813\n    },\n    \"instruction\": \"Head toward <span class=\\\"toward_street\\\">Aldrich St</span> on <span class=\\\"street\\\">McBee St</span>. <span class=\\\"distance-description\\\">Go for <span class=\\\"length\\\">30 m</span>.</span>\",\n    \"travelTime\": 12,\n    \"length\": 30,\n    \"id\": \"M1\",\n    \"_type\": \"PrivateTransportManeuverType\"\n  },\n  ...\n  ],\n  \"link\": [\n    {\n    \"linkId\": \"+1217666399\",\n    \"shape\": [\n      \"30.2979004,-97.7089047\",\n      \"30.2980936,-97.7090549\",\n      \"30.2983189,-97.7092803\",\n      \"30.2985549,-97.7095056\",\n      \"30.2986085,-97.7095592\"\n    ],\n    \"speedLimit\": 20,\n    \"_type\": \"PrivateTransportLinkType\"\n  },\n  ... In the article Speed Limit Fragment for Android SDK , Mariusz taught us how to retrieve SpeedLimitFragments with the Android SDK. It’ll take a little bit of work to parse the JSON response from Routing API and REST alone to associate the speed limit of the link for each road segment maneuver. Fleet Telematics API There are a lot of parameters you can use to calculate a route with the Routing API but there are some limitations for more advanced use cases. The Fleet Telematics API helps with the scenarios through its own calculateroute resource to do things like: Define custom speed profiles for any FC class road in the HERE road network to calculate more appropriate ETAs Calculate routes considering driver rest times for any type of routes (eg, with/without waypoints, custom routes) Calculate routes based on desired arrival time and day to a destination while considering real-time or historical traffic Calculate fuel-/energy-optimized routes considering road conditions like uphill and downhill Calculate cost-optimized routes considering toll-cost information for various vehicle profiles It’s this first use case I’m going to look at a bit more. Speed Limits A bit of background about speed limits. In January 1974, the United States passed the Emergency Highway Energy Conservation Act that prohibited drivers from exceeding 55 miles per hour (90 km/h) on any roadway. The rationale for the law was fuel efficiency during the oil crisis and price spikes of the time. The National Motorists Association advocated for its repeal and was successful in 1995. The NMA position on speed limits is that they should be set according to the 85th percentile of free flowing traffic. The theory is that most drivers are rational so a “realistic” speed limit is one in which no more than 15% of the public exceeds through reasonable compliance. The Institute of Travel Engineers explains that “a speed study usually creates a speed distribution” for a segment of road and the speed can be set +/- 5mph of the 85th percentile unless engineering or other specific road conditions deem it unsafe. A Federal Highway Administration (FHA) study of nearly 200 roads in 22 states determined that 55% of traffic exceeded the posted speed limit. Even after speed limits were raised or lowered as much as 20mph, there was not much variation in speed and no significant changes in crashes. I’m going to see what happens when increasing the speed profile for this route. Custom Speed Profile If you take a look at the Fleet Telematics https://developer.here.com/documentation/fleet-telematics/dev_guide/index.html you can view the Routing & Route Matching specification. The request is pretty similar to the routing API but the URI differs and you must provide a vehiclecost or drivercost . #!/bin/bash\n\ncurl \\\n  -X GET \\\n  -H 'Content-Type: *' \\\n  --get \"$FLEET_URI_HERE/calculateroute.json\" \\\n    --data-urlencode \"app_id=$APP_ID_HERE\" \\\n    --data-urlencode \"app_code=$APP_CODE_HERE\" \\\n    --data-urlencode 'waypoint0=30.2983,-97.7047' \\\n    --data-urlencode 'waypoint1=29.4256,-98.6507' \\\n    --data-urlencode 'mode=fastest;car;traffic:enabled' \\\n    --data-urlencode 'vehicle_cost=1' \\\n| jq '.' I get back additional results from this query, including the links without requiring an extra parameter. To change the speed profile though I’m focusing on one parameter in particular: speedFcCat . speedFcCat Comma separated list of speeds driven per road functional class and speed category. Can contain empty entries (don’t change). Overrides router’s default driven speed values. The Geocoder API Speed Category is a useful reference to understand. The following example is to illustrate various speed categories that match up with the functional class of road. You can find the functional class from the link details: \"link\": [\n  {\n    \"linkId\": \"990240352\",\n    \"length\": 22,\n    \"remainDistance\": 144736,\n    \"remainTime\": 6386,\n    \"shape\": [\n      30.29801,\n      -97.70428,\n      30.29834,\n      -97.70494\n    ],\n    \"functionalClass\": 5 You can use one of the default speed tables for car, truck, 7.5 ton truck, 18 ton truck or give your own arbitrary speeds in kph. The trick is that you must provide something for each speed category and functional class. If you don’t specify a value the default will be used, but you still need the delimiter. For example, TX-130 has a speed limit of 85mph and is the fastest posted highway in the United States so the request might include a parameter like this modifying the first four speed categories and leaving the remaining four the defaults. --data-urlencode 'speedFcCat=137,129,121,105,,,,;137,129,121,105,,,,;137,129,121,105,,,,;137,129,121,105,,,,;137,129,121,105,,,,;137,129,121,105,,,,' \\ As might be expected, driving faster will reduce the total travel time in the response. Wrapping Up Custom speed profiles are only one way of getting started with the functionality available from the Fleet Telematics API. There are plenty of other projects involving truck routing, custom locations, geofencing, and more that can help build solutions by adjusting some of the parameters. Let us know how you are using it in the comments, but until then please drive safely and follow posted speed limits.", "date": "2019-02-28"},
{"website": "Here", "title": "Geofencing Regions with JavaScript and HERE", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/geofencing-regions-with-javascript-and-here", "abstract": "When it comes to maps and location services, being able to see if a position is within a particular region is often an important business need. The regions being tracked are known as geofences and they’re not difficult to produce and use. In this tutorial, we’re going to see how to create a geofence and then determine if a point falls within that geofence using JavaScript in combination with the HERE JavaScript SDK and HERE REST API. To get an idea of what we hope to accomplish, take the following animated image: The idea is that we’re going to draw a shape on the map and upload the geometry information for that shape to HERE. Then when we move the marker around on the map, we’re going to ask HERE if the marker falls in the geometry that we had uploaded. This is a simple example where we only have one geometry, but the uploaded information could easily have much more, making it easier than checking the boundary information by hand. Understanding Geofences and the Well-Known Text (WKT) Format So what exactly is happening with the geofence and what do we need to upload to HERE? To start, we need to to come up with a series of points that create a polygon of any complexity. Take the following points: [\n    { lat: 37, lng: -121 },\n    { lat: 37.2, lng: -121.002 },\n    { lat: 37.2, lng: -121.2 },\n    { lat: 37, lng: -121 },\n] The above points will create a triangle. Wait, don’t triangles only have three points? Yes, but because we’re creating a shape, we need to close the loop and bring the final vertex home. The first point and the final point are the same. So this is great, but an array of points of kind of useless to the HERE server. There is actual a format that must be followed which extends beyond HERE. We need to be supplying Well-Known Text (WKT) formatted data. If we wanted to convert our array of points to WKT, we can do something like this: POLYGON ((-121 37,-121.002 37.2,-121.2 37.2,-121 37)) Yes, in the above example the longitude comes first, but that is fine. The above POLYGON is a start, but it doesn’t complete the story for us. We need to use it correctly in a file. Take the following for example: NAME        WKT\nTriangle    POLYGON ((-121 37,-121.002 37.2,-121.2 37.2,-121 37)) The above would be valid WKT file data. We have a name for our fence, which we’re randomly calling triangle, and we have our shape. We could have any number of names and shapes in this file separated by new lines. However, it is important that this is a tab delimited file. Delimiting by space characters will not work. Now that you have a brief understanding of geofencing and WKT files, we can start development of a project. Developing a JavaScript Project with HERE To keep things simple, it is best we start by creating a new project. Once we have the foundation in place, we can add complexity with the geofence and WTK components. Somewhere on your computer, create the following two files: index.html\nheremap.js All of our HTML will go in the index.html file and most of the JavaScript will go in the heremap.js file. There will also be JavaScript in the index.html file, but you’re free to optimize your project however is best. Open the index.html file and include the following: <html>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh\"></div>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n        <script src=\"https://stuk.github.io/jszip/dist/jszip.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"heremap.js\"></script>\n        <script>\n            // JavaScript here...\n        </script>\n    </body>\n</html> In the above boilerplate code, we are creating an HTML placeholder element for our map. This placeholder element is identified with the id property. We are also importing several JavaScript libraries, three of which are part of the HERE JavaScript SDK. In addition to the HERE JavaScript SDK, we are also including axios for HTTP requests and JSZip for archiving our WKT file data. To send our WKT information, it must be done via HTTP and the WKT information must exist as part of a ZIP archive. There is no wrong way to do this, but I personally find it more convenient if we can create our geofences directly in our project, hence the two libraries. Now open the project’s heremap.js file and include the following: class HereMap {\n\n    constructor(appId, appCode, mapElement) { }\n    draw(mapObject) { }\n    polygonToWKT(polygon) { }\n    uploadGeofence(layerId, name, geometry) { }\n    fenceRequest(layerIds, position) { }\n\n} You can see we have a HereMap class with several functions, including a constructor method. Most of the heavy lifting will be accomplished in this class. Let’s start configuring our map within the constructor method: constructor(appId, appCode, mapElement) {\n    this.appId = appId;\n    this.appCode = appCode;\n    this.platform = new H.service.Platform({\n        \"app_id\": this.appId,\n        \"app_code\": this.appCode\n    });\n    this.map = new H.Map(\n        mapElement,\n        this.platform.createDefaultLayers().normal.map,\n        {\n            zoom: 10,\n            center: { lat: 37, lng: -121 }\n        }\n    );\n    const mapEvent = new H.mapevents.MapEvents(this.map);\n    const behavior = new H.mapevents.Behavior(mapEvent);\n    this.geofencing = this.platform.getGeofencingService();\n    this.currentPosition = new H.map.Marker({ lat: 37.21, lng: -121.21 });\n    this.map.addObject(this.currentPosition);\n} In the above constructor method, we are accepting an appId , an appCode , and a mapElement from the HTML file. Using the token information we can initialize the HERE platform and using the HERE platform along with the element information we can display the map. The app id and app code tokens can be found in the HERE Developer Portal . In addition to displaying the map, we area also making it interactive with pan and zoom controls. We are initializing the geofencing service and dropping a marker on the map. This marker will eventually move around. With the basics of the project done, open the index.html file and include the following in the <script> tag: <script>\n    const start = async () => {\n        const map = new HereMap(\"APP-ID-HERE\", \"APP-CODE-HERE\", document.getElementById(\"map\"));\n    };\n    start();\n</script> Assuming you’re using valid project tokens, the map should show on the screen with a marker near by. This is where things are going to start to get interesting. Creating and Uploading Geofence WKT Data to HERE In a realistic scenario, you’re going to want to create your geofence, possibly render it on the screen, and upload it to HERE, all without leaving your core project. We also don’t want to generate WKT files by hand. There is a solution! We can actually create any shape we want using the HERE JavaScript SDK, and as part of the SDK we can convert those shapes to WKT strings. Within the index.html file, add the following to your <script> tag: <script>\n    const start = async () => {\n        const map = new HereMap(\"APP-ID-HERE\", \"APP-CODE-HERE\", document.getElementById(\"map\"));\n        const lineString = new H.geo.LineString();\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.002 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.2 });\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        const polygon = new H.map.Polygon(lineString);\n    };\n    start();\n</script> Using the above code, we can create a LineString which can be used to create a Polygon shape. To convert the shape into WKT, we can create a function in our heremap.js file: polygonToWKT(polygon) {\n    const geometry = polygon.getGeometry();\n    return geometry.toString();\n} If we were to pass our polygon to this function, we would be returned the WKT formatted geometry information. Since it is also nice to draw this shape, we could also create a draw function in the heremap.js file: draw(mapObject) {\n    this.map.addObject(mapObject);\n} Again, you can format your project however you want. You could move everything into the JavaScript file or everything into the HTML file, it doesn’t matter. With the polygonToWKT and draw functions available, we can do the following from the index.html file: <script>\n    const start = async () => {\n        const map = new HereMap(\"APP-ID-HERE\", \"APP-CODE-HERE\", document.getElementById(\"map\"));\n        const lineString = new H.geo.LineString();\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.002 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.2 });\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        const polygon = new H.map.Polygon(lineString);\n        console.log(map.polygonToWKT(polygon));\n        map.draw(polygon);\n    };\n    start();\n</script> So we have the WKT information for our shape which should also be visible on our map. Now we need to upload that information to the HERE server. In the project’s heremap.js file, include the following uploadGeofence function: uploadGeofence(layerId, name, geometry) {\n    const zip = new JSZip();\n    zip.file(\"data.wkt\", \"NAME\\tWKT\\n\" + name + \"\\t\" + geometry);\n    return zip.generateAsync({ type:\"blob\" }).then(content => {\n        var formData = new FormData();\n        formData.append(\"zipfile\", content);\n        return axios.post(\"https://gfe.api.here.com/2/layers/upload.json\", formData, {\n            headers: {\n                \"content-type\": \"multipart/form-data\"\n            },\n            params: {\n                \"app_id\": this.appId,\n                \"app_code\": this.appCode,\n                \"layer_id\": layerId\n            }\n        });\n    });\n} This is probably our most complicated bit of code. We are accepting a layerId which can be thought of as a WKT id, a name, which can be thought of a a geofence name, and the geometry. The geofence name could be something like GameStop or an actual name representation for the fence. Remember, you can have multiple geofences as part of a WKT file, however, ours will only have one. Using JSZip , we can save our WKT information to a file and add it as a file to the ZIP archive. When we want to officially generate the ZIP archive, we can make it a BLOB so we can do an HTTP request when it is done. Using axios , we can take our form data which contains the file and issue an HTTP request to the HERE REST API. If all goes smooth, a simple 200 response should be returned. Going back to the index.html file, the following can be added: <script>\n    const start = async () => {\n        const map = new HereMap(\"APP-ID-HERE\", \"APP-CODE-HERE\", document.getElementById(\"map\"));\n        const lineString = new H.geo.LineString();\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.002 });\n        lineString.pushPoint({ lat: 37.2, lng: -121.2 });\n        lineString.pushPoint({ lat: 37, lng: -121 });\n        const polygon = new H.map.Polygon(lineString);\n        console.log(map.polygonToWKT(polygon));\n        map.draw(polygon);\n        const geofenceResponse = await map.uploadGeofence(\"1234\", \"Nic Secret Layer\", map.polygonToWKT(polygon));\n    };\n    start();\n</script> You can see that I’ve given a random id for the layer, provided a name for my geofence, and provided the geometry information for my polygon. As of right now, we should have an application that creates geofences, but doesn’t make use of them. Checking if a Position is within a Geofence The next step is to see if any given position is within a geofence. To do this we’ll need to provide a layer to check as well as a position. Remember, a layer can have more than one geofence which is useful if you have a lot of data that you need to check. In the heremap.js file, include the following function: fenceRequest(layerIds, position) {\n    return new Promise((resolve, reject) => {\n        this.geofencing.request(\n            H.service.extension.geofencing.Service.EntryPoint.SEARCH_PROXIMITY,\n            {\n                'layer_ids': layerIds,\n                'proximity': position.lat + \",\" + position.lng,\n                'key_attributes': ['NAME']\n            },\n            result => {\n                resolve(result);\n            }, error => {\n                reject(error);\n            }\n        );\n    });\n} Given an array of layer ids and a position, we can make a geofence request to see if we’re in the geofence. Not too difficult in comparison to what we’ve already accomplished. To see this fenceRequest function in action, let’s make some changes to the constructor method. After creating a marker, add the following: this.map.addEventListener(\"tap\", (ev) => {\n    var target = ev.target;\n    this.map.removeObject(this.currentPosition);\n    this.currentPosition = new H.map.Marker(this.map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY));\n    this.map.addObject(this.currentPosition);\n    this.fenceRequest([\"1234\"], this.currentPosition.getPosition()).then(result => {\n        if(result.geometries.length > 0) {\n            alert(\"You are within a geofence!\")\n        } else {\n            console.log(\"Not within a geofence!\");\n        }\n    });\n}, false); What we’re doing in the above code is we’re setting up a listener for tap events on the map. If the user taps on the map, we are converting the screen location to geolocation. Using that geolocation we can reset the marker and call the fenceRequest function. If we get a result, we are within the geofence. In the result you’ll have specific information towards which geofence was triggered. Conclusion You just saw how to use the HERE Geofencing API in a JavaScript web application. This is useful if you need to create geofences for numerous locations based on complex shapes. It will prevent you from having to manually check for collisions, but instead let the HERE APIs do all the heavy lifting.", "date": "2019-03-07"},
{"website": "Here", "title": "Bringing the power of the HERE Location Suite to China", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/bringing-the-power-of-the-here-location-suite-to-china", "abstract": "Our ongoing dedication to enhancing our offering and providing a consistent global offering to our developer community is now extended to China. We’re excited to announce a crucial milestone with the  launch of the HERE Location Services and Mobile SDK in China. As an extension of our longstanding partnership with Chinese mapping company NavInfo , we now offer you an even more seamless global mapping experience that expands to China through our HERE Location Suite available through pour developer portal. One of the world's biggest economies, China accounts for a third of global vehicle and smartphone volumes. Starting today, developers building global or regional applications can use HERE’s APIs to access location technologies and maps for China. To access available location features and function for China developers need to use separate service URLs and credentials specific for these services. These include the following: Mapping: China map coverage Map rendering 3D maps Routing Traffic-enabled routing Vehicle routing Pedestrian routing Bicycle routing Public transit routing Traffic Traffic tiles for incidents, real-time and Traffic flow data Traffic flow availability Transit Station search Coverage information Public transit routing with Pedestrian Connectivity & Pedestrian Routing Geocoding Forward geocoding and reverse-geocoding Offline geocoding Places POI search Places discovery Places description Navigation Hybrid and offline navigation Vehicle navigation Pedestrian navigation Dynamic information (e.g. signposts, street lane) Positioning Network positioning (Cell-IDs & WiFi) These services still face some local restrictions that customers should be aware of. Firstly, they can only be accessed within China’s borders; and secondly, separate access credentials are required for our worldwide offering that includes China. We continue to pursue further global collaboration opportunities with likeminded partners, and are always looking for ways to further explore the expansion of current partnerships in order to best serve our customers.", "date": "2019-03-01"},
{"website": "Here", "title": "Displaying an Interactive HERE Map with NativeScript and Angular", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/displaying-an-interactive-here-map-with-nativescript-and-angular", "abstract": "Over the past few months I’ve written several pieces of content around developing web applications using Angular that included interactive HERE maps as well as tutorials around using HERE maps in progressive web applications using Ionic Framework. In both these circumstances the HERE JavaScript SDK was highlighted because we were essentially building web applications, regardless if they were bundled for mobile or not. What if we wanted to change this and build a native Android or iOS application that made use of a cross-platform framework? In this tutorial we’re going to see how to develop an Android and iOS mobile application that makes use of NativeScript and Angular . Before going forward, I have to make it clear that there is no official NativeScript plugin or SDK for HERE . The plugin that I’ll be using in this tutorial was built by an awesome member of our community, Osei Fortune . With enough demand, I’m sure this plugin will get even better. What we plan to accomplish in this tutorial can be seen in the following animated image: As you can see, we’re displaying an interactive map, placing a marker, and interacting with that marker. The Angular code we use with NativeScript can be used in both Android and iOS to create a native application. Creating a Fresh NativeScript Project with the HERE Plugin Dependencies To keep this tutorial simple and easy to understand, we’re going to work with a new project. The assumption is that you’re using version 5.1.1 or higher of the Telerik NativeScript Shell (TNS). From the command line, execute the following: tns create here-project --template tns-template-blank-ng The above command will create a project that uses an Angular template. NativeScript supports other frameworks as well, but we won’t get into that here. With the project created, execute the following to install the community driven HERE plugin: tns plugin add nativescript-here More details on this plugin can be found on Osei Fortune’s official GitHub repository . Before we start showing and interacting with maps, we need to do some configuration steps. Open your project’s App_Resources/Android/src/main/AndroidManifest.xml file and include the following: <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n<meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-TOKEN-HERE\"/> The above lines should be placed within the <application> tags, but not as attributes. To get more perspective on how this AndroidManifest.xml file should look, see the following: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"__PACKAGE__\"\n    android:versionCode=\"10000\"\n    android:versionName=\"1.0\">\n    <supports-screens\n        android:smallScreens=\"true\"\n        android:normalScreens=\"true\"\n        android:largeScreens=\"true\"\n        android:xlargeScreens=\"true\"/>\n    <uses-sdk\n        android:minSdkVersion=\"17\"\n        android:targetSdkVersion=\"__APILEVEL__\"/>\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <application\n        android:name=\"com.tns.NativeScriptApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/icon\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\">\n        <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP-ID-HERE\"/>\n        <meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP-TOKEN-HERE\"/>\n        <activity\n            android:name=\"com.tns.NativeScriptActivity\"\n            android:label=\"@string/title_activity_kimera\"\n            android:configChanges=\"keyboardHidden|orientation|screenSize\"\n            android:theme=\"@style/LaunchScreenTheme\">\n            <meta-data android:name=\"SET_THEME_ON_LAUNCH\" android:resource=\"@style/AppTheme\" />\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <activity android:name=\"com.tns.ErrorReportActivity\"/>\n    </application>\n</manifest> The two lines that we’ve added have placeholder values for our tokens. You’ll need to create a free HERE developer account to obtain your tokens. When you obtain your tokens, make sure you generate them as Android and iOS, not REST and JavaScript. With the AndroidManifest.xml file out of the way, we need to make the plugin a little more Angular friendly. Open the project’s src/app/app.module.ts file and include the following two lines: import { registerElement } from \"nativescript-angular/element-registry\";\nregisterElement(\"HereMap\", () => require(\"nativescript-here\").Here); What we’re doing is we’re making the XML component a little easier to use. We’re registering the tag names so that we can use them with Angular. At this point in time the plugin is properly configured. We can now start development. Showing a HERE Map with NativeScript and Angular Because we’re using a basic project, we’re only going to have one page to work in and no additional routes. We’re going to add the TypeScript logic before we work with our XML. Open the project’s src/app/home/home.component.ts file and include the following: import { Component, OnInit } from \"@angular/core\";\nimport { HereMarker } from \"nativescript-here\";\n\n@Component({\n    selector: \"Home\",\n    moduleId: module.id,\n    templateUrl: \"./home.component.html\"\n})\nexport class HomeComponent implements OnInit {\n\n    public constructor() { }\n\n    public ngOnInit(): void { }\n\n    public onMapReady(event) {\n        const map = event.object;\n        map.addMarkers(<HereMarker[]>[{\n            id: 1,\n            latitude: 37.7397,\n            longitude: -121.4252,\n            title: \"Tracy, CA\",\n            description: \"The best place in California!\",\n            draggable: true,\n            onTap: (marker) => {\n                const updatedMarker = Object.assign({}, marker, {\n                    selected: !marker.selected\n                });\n                map.updateMarker(updatedMarker);\n            }\n        }]);\n    }\n\n} What we’re paying attention to is the onMapReady method. When using a HERE map, we can’t interact with it until it has fully initialized. When the map is ready, it will call this onMapReady method. In the onMapReady method we are adding a single marker and giving it information as well as a tap event. When we tap on this marker, the title and description will show. The onMapReady method is not absolutely necessary to show our map. To show our map, open the project’s src/app/home/home.component.html file and include the following: <ActionBar class=\"action-bar\">\n    <Label class=\"action-bar-title\" text=\"{N} HERE Example\"></Label>\n</ActionBar>\n\n<GridLayout class=\"page\">\n    <HereMap\n        mapStyle=\"normal\"\n        (mapReady)=\"onMapReady($event)\"\n        id=\"map\"\n        zoomLevel=\"10\"\n        disableZoom=\"false\"\n        disableScroll=\"false\"\n        latitude=\"37.7397\"\n        longitude=\"-121.4252\">\n    </HereMap>\n</GridLayout> Notice that we’re providing the onMapReady method as an XML attribute. We’re also providing basic setup information for showing the map in our application. Conclusion You just saw how to include a HERE map within your NativeScript based Android and iOS application. I have to reiterate that this is a plugin that is maintained by our community member, Osei Fortune , and he made an awesome first iteration at it. If you found it valuable, I encourage you to send him a message to thank him for his work! If you’re interested in the Ionic Framework alternative that I demonstrated, check out my tutorial titled, Display an Interactive HERE Map in an Ionic Framework Application .", "date": "2019-03-04"},
{"website": "Here", "title": "Truck Routing with the HERE Fleet Telematics APIs", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/dive-into-the-world-of-logistics-with-here-telematics-apis-part-1-truck-routing-and-restrictions", "abstract": "In a world of same-day deliveries, hyper-precise logistics are a standard, not a luxury. In this series, I will be pulling the curtain and showing you how you can utilize the HERE Fleet Telematics APIs to create applications for solving the specific needs of vehicles in logistics. The first part in this series is truck routing. Before a shipment lands at our doorstep, we often forget the long distances it traveled across cities, countries or even the entire globe. Moreover, the journey of a package involves trucks, motorways, roads with restrictions, as well as busy city roads. Logistics companies spend a lot of time and energy to schedule these deliveries and have to take into consideration numerous factors like availability of vehicles, location, traffic, malfunctions etc. While it is obvious that a car and a truck are different in many ways, the nuances between car and truck routing are often neglected which leave the truck drivers frustrated. Road restrictions on truck height, material carried, variable toll costs, and tunnels are a few of the many constraints to take into account for navigation of trucks. This leaves a great opportunity to create applications focusing on Truck Navigation. In this article, we will cover truck routing , and road restrictions that consider truck height , weight , trailer count , tunnels and the material that the trucks carry ( hazardous material). While discussing the Truck Routing API , I would like to discuss 3 distinct attributes : Route Mode , Truck Type , Truck Profile . Let's get into them one by one. To begin with, get your HERE credentials and get access to the developer portal . I have followed the routing example to set up an application which routes between two cities using the default car navigation which is written using the JavaScript API . You can also check out our Android SDK , iOS SDK and REST API . Mode: To observe the difference between car and truck navigation, change the mode in the routeRequestParameters to Truck. function calculateRouteFromAtoB (platform) {\n    var router = platform.getRoutingService(),\n      routeRequestParams = {\n        mode: 'fastest;truck;',\n        representation: 'display',\n        routeattributes : 'no,lg',\n        RouteLegAttributeType: 'wp,mn',\n        maneuverattributes: 'direction,action',\n        waypoint0: '51.0535,13.74079', \n        waypoint1: '54.07906,12.13216',  \n      };\n\n    router.calculateRoute(\n      routeRequestParams,\n      onSuccess,\n      onError\n    );\n  } Route with Car Route with Truck You can clearly see the difference in the two routes. The routing API can be described in the format Routing Type ; Transport Mode ; Traffic Mode ; Route Feature . In the code snippet above, the type of route requested is fastest. Depending on the requirement, it can be set to shortest or balanced (optimizes based on combination of travel time and distance). The transport mode here is set to truck . Depending on your application, it can be set to car , publicTransport , pedestrian , etc. The traffic mode can be enabled or disabled indicating whether traffic information is to be considered. Adding the start timing to the route request can give you different routes considering peak times in traffic. The route feature lets you choose a route with or without tunnels, if it can include motorways, dirt roads, tolls etc. You can also add weight to the emphasize the exclusion of any of the features. Read more about the weights of these features here . function calculateRouteFromAtoB (platform) {\n    var router = platform.getRoutingService(),\n      routeRequestParams = {\n        mode: 'fastest;truck;traffic:disabled;motorway:-2',\n        representation: 'display',\n        routeattributes: 'no,lg',\n        RouteLegAttributeType: 'wp,mn',\n        maneuverattributes: 'direction,action',\n        waypoint0: '52.5274,13.38936', \n        waypoint1: '52.51118,13.45179', \n      };\n\n    router.calculateRoute(\n      routeRequestParams,\n      onSuccess,\n      onError\n    );\n  } Try toggling the traffic mode and route features to see the changes in the routes. Truck Type This parameter lets you declare the type of the truck and goes further to mention the number of trailers attached to it. This feature is useful specially as the number of trailers affect the turning radius of the vehicle and not all roads are wide enough. function calculateRouteFromAtoB (platform) {\n    var router = platform.getRoutingService(),\n      routeRequestParams = {\n        mode: 'fastest;truck;traffic:disabled;',\n        representation: 'display',\n        routeattributes : 'no,lg',\n        RouteLegAttributeType: 'wp,mn',\n        maneuverattributes: 'direction,action',\n        waypoint0: '49.49205,8.42784', \n        waypoint1: '49.48739,8.46245',\n        truckType: 'tractorTruck',\n        trailersCount: '3'\n      };\n\n    router.calculateRoute(\n      routeRequestParams,\n      onSuccess,\n      onError\n    );\n  } Truck Profile This feature helps you further specify the truck and what it carries. The different parameters considered are: shippedHazardousGoods limitedWeight weightPerAxle height width length Consider the following example where the height of the truck is 5 meters. You will see that no valid route is found between the two waypoints for trucks that high. Try entering a lower number for height and a route will be returned for the same two waypoints. function calculateRouteFromAtoB (platform) {\n    var router = platform.getRoutingService(), \n    routeRequestParams = {\n        mode: 'fastest;truck;traffic:disabled;', \n        representation: 'display', \n        routeattributes : 'no,lg', \n        RouteLegAttributeType: 'wp,mn',\n        maneuverattributes: 'direction,action',\n        waypoint0: '51.0535,13.74079', \n        waypoint1: '54.07906,12.13216',\n        height:'5'\n    };\n    router.calculateRoute(\n        routeRequestParams,\n        onSuccess,\n        onError\n      );\n    } You can also specify the content of the trucks with ' shippedHazardousGoods:explosive/flammable '. This excludes roads prohibited for shipment of explosive and flammable materials from route calculation. After applying all parameters, you may find that no route is available between the entered waypoints. It is also possible that you have imprecise location in the first place. In such conditions to get an approximate route, you can set the truck restriction penalty to soft . Note that the soft penalty requires the route notes to be enabled in the response. You can read the violated restriction from the response and add a pop up to mention the restriction that is violated. Try the example here . We now have an overview of the different parameters that can be set for Truck navigation which sets it apart from car navigation. Try the different parameters and its values to get an idea of the effect it has for different routes. You will thus get distinct routes for your fleet of trucks. Now that we have talked about trucks, in the next article we will tackle a different aspect of Fleet Telematics - Custom locations. Until then, keep coding!", "date": "2019-03-15"},
{"website": "Here", "title": "Requesting a HERE Map Image with HTTP and Golang", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/requesting-a-here-map-image-with-http-and-golang", "abstract": "At events I often get asked about generating map images using server side technologies, or basically any technology that isn’t client facing like JavaScript, Android, and iOS. For example, a common request is around providing criteria for a map to be generated as part of a script, report, or similar. Let me show you how. HERE does have a REST API known as the HERE Map Image API and it is consumed through HTTP requests. This API can generate standard map images or map images that include map objects such as polylines, polygons, or similar. Essentially, if you can produce it with the JavaScript SDK on an interactive map, you can produce it on a map image. While REST APIs can be consumed in pretty much any technology, we’re going to have a look at using the Go programming language to create map images. To get a better idea of what we hope to accomplish, take the following image: We’re going to request a map image that contains a polygon. We’ll be able to specify the sizing information for this image as well. Understanding the HERE Map Image API Before we jump into the Go code, we should probably understand a little more about the HERE Map Image API. Since this is a REST API, there will be different endpoints for accomplishing different things. A list of those possible endpoints can be found here . For this example, we’ll be focusing on the region endpoint. Try executing the following command with cURL after swapping out the app id and app code with your own: curl https://image.maps.api.here.com/mia/1.6/region?a0=37.739700%2C-121.425200%2C37.797400%2C-121.216100%2C37.639100%2C-120.996900%2C37.739700%2C-121.425200&app_code=APP_CODE_HERE&app_id=APP_ID_HERE&h=720&ppi=320&w=1280&z=11 Generating an app id and app code is free and can be done in the HERE Developer Portal . After executing the command, you’ll notice that it created exactly what we saw in the prior image at the top of this tutorial. The request made use of a few parameters. The a0 parameter represents the area to draw the polygon. It represents each of the points in the shape. The w parameter represents the output image width, along with h being for height. The ppi represents the resolution and z represents the zoom on the map. The a0 is probably the most complicated part of this request. So now we should probably make something useful out of this API. Developing an Application with the Go Programming Language We won’t be doing anything fancy in our Golang application. We’ll just be constructing a request and sending it. Most of the setup will be around the data model for our polygon, to make things a little easier on the developer. Take the following data structures: type Point struct {\n    Latitude  float64\n    Longitude float64\n}\n\ntype Polygon struct {\n    Points []Point\n} Instead of forcing someone to create that ugly a0 string by hand, we’re going to create some cleaner looking data structures, as seen above. With the data structures in place, the following can be done in our main function: func main() {\n    polygon := Polygon{\n        Points: []Point{\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n            Point{Latitude: 37.7974, Longitude: -121.2161},\n            Point{Latitude: 37.6391, Longitude: -120.9969},\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n        },\n    }\n} Great, so we have the points for our polygon. The problem is that our a0 parameter still expects a string. We can create some classic toString functions to take care of this. func (point *Point) toString() string {\n    return fmt.Sprintf(\"%f,%f\", point.Latitude, point.Longitude)\n} The above function will take a point and turn it into a string where the axis is delimited by a comma. With the point being converted into a string, the entire slice of points needs to be converted. The following toString function can be created: func (polygon *Polygon) toString() string {\n    var result string\n    var points []string\n    for _, point := range polygon.Points {\n        points = append(points, point.toString())\n    }\n    result = strings.Join(points, \",\")\n    return result\n} In the above function we are looping through each of our points, converting them into strings, and then joining the slice of strings into one string delimited by comma. If we wanted to, we could do the following: func main() {\n    polygon := Polygon{\n        Points: []Point{\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n            Point{Latitude: 37.7974, Longitude: -121.2161},\n            Point{Latitude: 37.6391, Longitude: -120.9969},\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n        },\n    }\n    fmt.Println(polygon.toString())\n} Now that the data is properly formatted, it is time to create a request. It is best to create a separate function for this, maybe calling it a GetMapWithPolygon function like the following: func GetMapWithPolygon(output string, geometry string) {\n    endpoint, _ := url.Parse(\"https://image.maps.api.here.com/mia/1.6/region\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", \"APP-ID-HERE\")\n    queryParams.Set(\"app_code\", \"APP-CODE-HERE\")\n    queryParams.Set(\"ppi\", \"320\")\n    queryParams.Set(\"w\", \"1280\")\n    queryParams.Set(\"h\", \"720\")\n    queryParams.Set(\"z\", \"11\")\n    queryParams.Set(\"a0\", geometry)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        fmt.Printf(\"The HTTP request failed with error %s\\n\", err)\n    } else {\n        f, _ := os.Create(output)\n        data, _ := ioutil.ReadAll(response.Body)\n        f.Write(data)\n        defer f.Close()\n    }\n} While long, the above function is just creating a url string with query parameters. Each of the query parameters is what we’ve already seen in the raw request. For more information on consuming data from web services with Go, check out a tutorial I wrote titled, Consume RESTful API Endpoints within a Golang Application . After executing the request, if it didn’t fail, an output file is created and the response body is saved directly to the file. The response body should be image data. func main() {\n    polygon := Polygon{\n        Points: []Point{\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n            Point{Latitude: 37.7974, Longitude: -121.2161},\n            Point{Latitude: 37.6391, Longitude: -120.9969},\n            Point{Latitude: 37.7397, Longitude: -121.4252},\n        },\n    }\n    GetMapWithPolygon(\"map.jpg\", polygon.toString())\n} The above main function makes use of the new GetMapWithPolygon polygon function. Conclusion You just saw how to use the HERE Map Image API with the Go programming language. This example was probably a bit overkill because it is only a single request to a REST API, but it is a common question that I receive at events. Knowing how to generate map images as needed can be a useful ability.", "date": "2019-03-12"},
{"website": "Here", "title": "March Release Highlights Including Finding Wineries and Avoiding Sharp Turns", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/march-release-highlights-including-finding-wineries-and-avoiding-sharp-turns-on-the-way", "abstract": "All services receive map content updates frequently but we will call out a few noteworthy highlights in March 2019 related to the following services: Routing API and Mobile SDKs . There were other minor updates and fixes across many other services as well which were related to regular maintenance releases. View the API Version History for specific monthly updates including change log and release notes for all of the APIs. Also be sure to check out the Top Feature Enhancements Driven by HERE XYZ Beta Participants . Routing API Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Learn more… Version 7.2.102 We have improved routing behavior when parameter “avoidTurns=difficult” is used to also avoid difficult sharp turns (in addition to earlier released avoidance of complex U-turns on multi-digitized roads) Here's an example scenario for a path to avoid a sharp turn by taking the traffic circle, rotary, rotunda, or island. Mobile SDKS Full-featured, native apps with our mapping platform. Learn more… Map Updates Added support for more detailed information of the long truck available turns. This feature will give possibility to take into account long truck specific turns and restrictions information while creating a Long truck specific route. Improved definition for Inconvenient maneuver that includes angle between the roads. Improved definition for Inconvenient maneuvers with time restrictions. Inclusion of basic Scouter routing attributes for routing use cases. Fixed issue when some Bahrain “Blocks” cities shown on the map on high scale (20KM) Added support of POIs of “Winery” category Fixed issue with EV charging station POIs duplication Updated EarthCore Buildings and Landmarks Here's an example of creating a category filter for a winery. NSArray* categories = [[NMAPlaces sharedPlaces] topLevelCategories]; \n\nfor (id category in categories) \n{\n  if (category.uniqueId == \"winery\" ) \n  { \n    NMACategory* restCategory = category;\n    NMAGeoCoordinates* murphys = [[NMAGeoCoordinates alloc]\n    \tinitWithLatitude:38.08603\n        longitude:-120.48867]; \n        \n    NMACategoryFilter *categoryFilter = [NMACategoryFilter new];\n    [categoryFilter addCategoryFilterFromUniqueId:restCategory.uniqueId];\n    \n    NMADiscoveryRequest* request = [ [NMAPlaces sharedPlaces]\n    \tcreateHereRequestWithLocation:murphys filters:categoryFilter]; \n    //... \n  }\n} This category was already available through our Places REST API , but now it's also available on mobile including while navigating offline. HERE iOS SDK Full-featured, native apps on iOS with our mapping platform. Learn more… Premium Edition Version 3.10.1 Introduced the “fast” speed profile for trucks Enabled Turn by Turn guidance for bike routes Implemented possibility to set/get course for all waypoints on the route Added error reporting when re-routing fails Added possibility to customize stopover reached callback Added feature to retrieve distance on route Added feature to specify wait time for each waypoint Added possibility to retrieve TTA for specific subleg AutoSuggests feature supports offline mode Added API to retieve remaining distance during guidance Added possibility to customize upcoming part of the route Added ability to configure cache size (256MB - 2GB) Implemented maneuver restrictions on motorcycle turn cost tables Fixed positioning latency issue Improved MapLoader stability Added support for new iPads Pro Added possibility to retieve route element by duration Enhanced difficult turns avoidance for trucks by excluding sharp turns from a route Enhanced routing options to exclude specified routing zones (such as environmental zones) from the calculated route as a Beta feature. Implemented avoidance of odd/even and time dependent environmental zones HERE Android SDK Full-featured, native apps on Android with our mapping platform. Learn more… Premium Edition Version 3.10.1 Introduced the “fast” speed profile for trucks Enabled Turn by Turn guidance for bike routes Implemented possibility to set/get course for all waypoints on the route Added error reporting when re-routing fails Added possibility to customize stopover reached callback Added feature to retrieve distance on route Added feature to specify wait time for each waypoint Added possibility to retrieve TTA for specific subleg Autosuggest is now supported for offline mode Added feature to retrieve remaining distance during guidance Added possibility to customize upcoming part of the route Added ability to configure cache size (256MB – 2GB) Implemented maneuver restrictions on motorcycle turn cost tables Fixed positioning latency issue According to changes in Android API 28 with deprecation of android.app.Fragment corresponding Mobile SDK API is marked as deprecated com.here.android.mpa.mapping.MapFragment and new API introduced com.here.android.mpa.mapping.SupportMapFragment instead. For more information see official Android documentation. Improved map representation in Mercator Projection Simplified creation of MapMarker objects Enhanced difficult turns avoidance for trucks by excluding sharp turns from a route Implemented avoidance of odd/even and time dependent environmental zones", "date": "2019-03-29"},
{"website": "Here", "title": "Top Feature Enhancements Driven by HERE XYZ Beta Participants", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/top-feature-enhancements-here-xyz-beta", "abstract": "Your product feedback matters Almost six months ago, on October 1st, HERE XYZ was shared with the world in a Public Beta . A number of you took us up on our offer, used the product to make maps and provided us invaluable feedback. As you may have noticed, HERE XYZ has exited its Public Beta phase and is now Generally Available. Your engagement with us resulted in more than 3000 projects, more than 700 maps, more than 90GB of map data uploaded, and almost 900GB of data transferred. We look forward to continuing the journey and getting others to join us in using HERE XYZ to manage geospatial data, at scale, to make great web maps and location-aware apps. More importantly, we wanted to share with you how your feedback during Beta led directly to the addition of features. While the full list is quite exhaustive, we’ve decided to pick out three examples each for XYZ Studio and for the HERE CLI – all of which demonstrate the value of developer feedback – so, please keep it coming – we’re using it all! XYZ Studio HERE XYZ Studio is an interactive, visual, web-based application for accessing XYZ Hub data and creating maps within minutes - without any code. Since Beta we’ve made many changes including conditional formatting, smart data tables, and legends for published maps. Style Rules This will likely be one of the biggest productivity boosters to your workflow. When styling layers it is cumbersome to separate out and style individual points. With conditional formatting you can style the entire layer the same or define rules for styling groups of data that meets certain characteristics. For example, in the Mapping Seismic Activity tutorial we demonstrate how to import seismic activity into XYZ Studio. With the conditional formatting feature, a few clicks and you can create a unique style group for earthquakes with a magnitude greater than 5.0 to be styled separately. Just select the property, comparison operator, and any values that make sense for your use case. Data Tables We like maps of course, but sometimes we also want to see or edit the underlying properties of a feature. The data table has been available since the beginning but for very large data sets was sometimes unmanageable. To solve this we’ve strengthened the connection between what you see in the map viewport and the data displayed in the data table. The features visible on the map will be treated like a bounding box to populate the table of data. This not only helps improve usability by narrowing down the data, it will greatly improve the performance for large amounts of data. For spaces with a smaller number of features – you will still be able to search, add columns, edit cells, or delete rows. Larger data sets will be paginated to help with managing the data being displayed efficiently. Legends Maps are better when shared – but it may not always be clear to anybody other than the map maker that designed the map what the data means. Symbols are a fundamental feature when publishing a project, so you have full control over the naming of layers and styles that can optionally be displayed in a legend. With credit to NPH, we hope you find these changes to XYZ Studio legend… wait for it, ary. XYZ CLI We think developers deserve an easy to use, convenient and streamlined experience to work with XYZ Hub APIs. That’s why we’ve built the HERE CLI. HERE CLI is a Node.js command line interface which provides more detailed upload options and can be helpful for automating some simple workflows and bash scripts. With the HERE CLI, additional data formats like Shapefiles and GeoJSONL can be easily streamed in to XYZ spaces on upload. Streaming Upload Uploading files with a web browser is pretty common for single files. Some geospatial data formats like Shapefiles may spread out geometry and properties data over multiple files which makes a simple drag-n-drop interface tricky. The CLI can help manage multiple-file formats like that. What about big data sets? Depending on your operating system and configuration, node may not efficiently handle memory loads if reading a file into memory all at once. The new -s flag will read the file in a data stream and update your XYZ Hub space. here xyz upload YOUR_SPACE_ID -f big_data.csv -s This can be used for uploading any supported format (GeoJSON, Shapefiles, etc.) as well. You can find out more from the CLI command docs: Upload and stream large CSV and GeoJSON files . GeoJSONL You may not already be familiar with GeoJSONL but it has usage in some systems such as the Interline GeoJSONL OSM Extracts . The problem this variation of GeoJSON tries to solve is what to do about very large geographic datasets. The world is a big place afterall, so the problem is solved by replacing a single root object with an array of objects separated by newlines. This violates the JSON specification but works well with many streaming parsers. The data file might look something like this: {\"type\":\"Feature\",\"id\":1,\"geometry\":{\"type\":\"Point\",\"coordinates\":[-157.8556764,21.304547]},\"properties\":{\"@type\":\"node\",\"@id\":21442033,\"@timestamp\":1520001878,\"ele\":\"6\",\"name\":\"Honolulu\",\"is_in\":\"USA, Hawaii\",\"place\":\"city\",\"source\":\"Landsat\",\"capital\":\"4\",\"name:de\":\"Honolulu\",\"name:en\":\"Honolulu\",\"name:ja\":\"ホノルル\",\"name:lt\":\"Honolulu\",\"name:pl\":\"Honolulu\",\"name:ru\":\"Гонолулу\",\"name:uk\":\"Гонолулу\",\"name:zh\":\"檀香山市\",\"is_state\":\"Hawaii\",\"name:haw\":\"Honolulu\",\"wikidata\":\"Q18094\",\"wikipedia\":\"en:Honolulu\",\"population\":\"390738\",\"is_in:ocean\":\"Pacific\",\"is_in:country\":\"USA\",\"state_capital\":\"yes\",\"population:date\":\"2010\",\"is_in:iso_3166_2\":\"US-HI\",\"is_in:country_code\":\"US\"}}\n{\"type\":\"Feature\",\"id\":2,\"geometry\":{\"type\":\"Point\",\"coordinates\":[-158.0310257,21.6859095]},\"properties\":{\"@type\":\"node\",\"@id\":88542613,\"@timestamp\":1195080018,\"created_by\":\"JOSM\"}} In addition to the -s streaming option mentioned above for large files, the HERE CLI will now recognize this .geojsonl file extension and process this structured file. You can learn more about the format from the blog post: Even more geospatial tools supporting the “GeoJSONL” format . QGIS Plugin One of the core philosophies of the HERE XYZ is to be open to the tools developers and map-makers are comfortable using already. For many GIS professionals and students, QGIS is the free and open-source cross-platform desktop application used every day. To make it easier to view, edit, and analyze data from the HERE XYZ Hub API we’ve released the xyz-qgis-plugin on GitHub. This plugin works with QGIS 3.0+ so that HERE XYZ supports you and your task rather than requiring you to change your workflow to use it. What's Next? Now that HERE XYZ is available as a product from HERE Technologies, please visit our developer site to learn more about how HERE XYZ enhances existing developer plans . If you are at FOSS4G North America in San Diego April 15-18, come by our booth, meet the product team and learn everything you want to know about HERE XYZ. We have a breakout session and interactive workshop planned to give you some hands-on experiences. See you in San Diego – until then, stay in touch on Twitter .", "date": "2019-03-28"},
{"website": "Here", "title": "Introduction to the SAPUI5 Geocoder Workshop", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/sapui5-geocode-workshop", "abstract": "Today we are happy to announce the next addition to our workshop series, the SAPUI5 Geocoder Workshop . Geocoding services are fundamental to integrating location details into your applications. With geocoding, developers can determine the geolocation coordinates of a place or an address by name and vice-versa. Developers can find all our services at the SAP API Hub , which include routing, search, maps, and much more. Scope and Requirements The following are prerequisites for getting started: Some HTML experience (need help ?) Some JavaScript experience (need help ?) SAP Developer account ( http://api.sap.com ) HERE Developer account ( https://developer.here.com ) IMPORTANT! It is a requirement to complete the SAPUI5 Maps Intro Workshop prior to starting any of the workshops in the SAPUI5 series. Overview of Tasks The following topics are covered in the Geocoding Workshop: Discovery. How to locate and test the HERE Geocoding API to use from the SAP API Hub . Configuration. Configure an SAPUI5 project to use HERE Geocode APIs via Destination. Development. Databind XML View to JSON data as resulting from HERE Geocode API call. The simple output of the SAPUI5 Geocoder Workshop results in obtaining geolocation data based on city name as shown here: Ready to get started? Remember, you must complete the SAPUI5 Maps Intro Workshop prior to starting this new one. Each workshop is a tutorial separated into sections to easily progress from each major milestone - doing so one step at a time. The advantage of preserving the workshop at GitHub is maintaining it with updates and bug fixes (if any). Please try it out! Summary SAP developers can integrate the HERE Geocoding API into their SAPUI5 projects. For more information about HERE, please visit our developer portal at http://developer.here.com .", "date": "2019-03-19"},
{"website": "Here", "title": "Real-Time Interaction Between Maps with Socket.io and JavaScript", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/real-time-interaction-between-maps-with-socket.io-and-javascript", "abstract": "I was doing some thinking recently. I was thinking how I could make maps more useful than just displaying visual content on the screen when requested. While displaying map information on a screen is useful in many circumstances, it doesn’t make for the most exciting of examples. This lead me to thinking about things from a more interactive level. Take the example of first responders such as law enforcement, fire, and medical. It might not make the most sense for them to be looking and refreshing a map to find incidents. Instead, what if the map automatically refreshed and was synchronized between the first responders? What I mean by this is what if incidents automatically appeared on everyone’s map at the same time without interaction? In this tutorial we’re going to explore sockets to broadcast map related information in real-time using Socket.io and simple JavaScript. To get a sense of what we’re going to accomplish, take a look at the following animated image. While not exactly a first responders type scenario, you can see that as the map is clicked in one instance, markers start to show up on all of the maps that are connected to the server via sockets. This is done without having to constantly refresh each of the windows. Creating the Socket.io Server for Keeping Track of Marker Data To make use of this example, we will need to create a server-side application for managing all of the client sockets and incoming data. As data is sent from one of the clients to the server, the server tracks it and sends it to all of the other connected clients. The clients never communicate directly with other clients. Create a new project on your computer and initialize a new Node.js project by executing the following commands: npm init -y\nnpm install express socket.io --save\ntouch app.js The above commands will create a package.json file, install our dependencies, and create a new app.js file for all of our server-side logic. If you don’t have the touch command, go ahead and create the app.js file however makes the most sense. Open the app.js file and include the following boilerplate code: const Express = require ( \"express\" )() ; const Http = require ( \"http\" ). Server (Express) ; const Socketio = require ( \"socket.io\" )(Http) ; Http . listen ( 3000 , () => { console . log ( \"Listening at :3000...\" ) ; } ) ; The above code will create our server which will listen for incoming socket connections on port 3000. However, the server will currently do nothing with those connections. Instead, add the following to the app.js file: const markers = [] ; Socketio . on ( \"connection\" , socket => { for ( let i = 0 ; i < markers . length ; i ++ ) { socket . emit ( \"marker\" , markers[i]) ; } socket . on ( \"marker\" , data => { markers . push (data) ; Socketio . emit ( \"marker\" , data) ; } ) ; } ) ; The markers variable will be used instead of a database in this example. Essentially, when marker information is sent to the server, it is stored in the markers array. Every time a user connects to the server, each item in the markers array is broadcasted to the client that had just connected to get them up to speed with everything that should exist on the map. If you really wanted to be efficient, you might just send the entire array rather than looping through it. When any of the connected clients sends a message labeled as marker , that message data is added to the markers array and broadcasted to all connected clients, not just the one that sent it. In this scenario the marker label is just a name and holds no real relevance to the markers array. At this point in time the server-side code is complete. We’re not doing anything too aggressive for this example, just storing marker data and sending it to users. Developing the Client Front-End for Displaying the Map and Markers Now we need to develop the client facing application code. The role of this code will be to display a map with markers, and send marker data to the server every time the map has been clicked. Create an index.html file on your computer and include the following boilerplate code: <!DOCTYPE html>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh;\"></div>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js\"></script>\n        <script>\n            const platform = new H.service.Platform({\n                \"app_id\": \"APP_ID_HERE\",\n                \"app_code\": \"APP_CODE_HERE\"\n            });\n            const map = new H.Map(\n                document.getElementById(\"map\"),\n                platform.createDefaultLayers().normal.map,\n                {\n                    zoom: 10,\n                    center: { lat: 37.7397, lng: -121.4252 }\n                }\n            );\n            const mapEvent = new H.mapevents.MapEvents(map);\n            const behavior = new H.mapevents.Behavior(mapEvent);\n        </script>\n    </body>\n</html> I’ve written quite a few examples around the code above. All we’re doing is initializing the HERE platform and displaying a map. Do note that we are including the Socket.io client library. You must also swap out the app id and app code tokens to match your actual tokens that are obtained through the HERE Developer Portal . The next step is to establish a connection to the socket server: const socket = io ( \"http://localhost:3000\" ) ; With the connection established, we probably want to update the map with whatever data is currently stored on the server. We can do this by creating a listener for events by a particular label: socket . on ( \"marker\" , data => { const marker = new H . map . Marker (data) ; map . addObject (marker) ; } ) ; Take note of the marker label. It doesn’t have to match the label that we have on the server, but do note that the server is trying to emit messages to that particular label. Just make sure you keep all your labels and emit labels in sync. In the listener, as new data comes in, a marker is created and added to the map. This applies to the data the server is currently storing and any future data. To create new markers and send them to the other clients, we can configure an event listener on the map for gesture type events: map . addEventListener ( \"tap\" , event => { const position = map . screenToGeo ( event . currentPointer . viewportX , event . currentPointer . viewportY ) ; const marker = new H . map . Marker (position) ; map . addObject (marker) ; socket . emit ( \"marker\" , position) ; } ) ; In the above code, after a tap event occurs, the pixel coordinates are converted to geo coordinates and the position of those coordinates are sent to the server to be broadcasted to all the other clients. If you run the server and launch a few instances of the client facing web application, you’ll get an idea of what’s happening. Conclusion You just saw how to use Socket.io with JavaScript to send map data in real-time to multiple clients. Like I mentioned earlier, I could imagine this would be useful in a lot of scenarios where it is critical that information is provided in real-time and in a synchronized fashion to all clients.", "date": "2019-04-08"},
{"website": "Here", "title": "Create Location-Aware Ads in Android with the HERE Geofencing API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/create-location-aware-advertisements-in-android-with-here-and-geofencing", "abstract": "A few months ago you probably heard the story about Burger King giving out coupons for $0.01 burgers every time someone entered a McDonald's with the Burger King mobile application installed. Whether or not you like either fast food chain, this was a ingenious marketing strategy and use of location in a mobile application. So how does something like this work, from a technical point of view? Since I don’t work for Burger King, I can’t give you the definitive story behind their technical adventures, but I can make some assumptions. Long story short, the fast food chain created a virtual geofence around each of their competitors stores. Using positioning within their mobile application, they likely determined whether or not that device entered a geofence and if it did, send them a notification with a coupon. You might remember the tutorial \" Geofencing Regions with JavaScript and HERE \" and while it focused on geofencing, it wasn’t for a mobile audience. This time around we’re going to see an Android example in the spirit of what Burger King was doing in their mobile app. Take a look at the following image of what we aim to accomplish: Yes, the example does not look polished, but that would be designers' job anyway. However, the functionality is there. The goal is to create two geofences. Where I live there is a Domino’s Pizza directly next to a Pizza Hut. Why two pizza restaurants are directly next to each other is beyond me, but it leaves an opportunity for this example. If we enter the geofence for Domino’s, we’ll get a message to go eat at Pizza Hut and if we enter the geofence for Pizza Hut we’ll get a message to go eat at Domino’s. It’s simple, but can be expanded to be more powerful. Uploading Geofence Data to HERE with HTTP To save the client from having to do a lot of number crunching, geofence position detection is handled server side from the HERE servers. Essentially we upload fence data and then we send our position every time we want to check the proximity to a fence. Remember, we could have potentially thousands of fences, so doing this client side would not be a good idea. HERE expects the geofence data to be in well-known text (WKT) format, so take the following example: POLYGON ((-121.4367556774805 37.73954861759737,-121.43642310582709 37.73954227917106,-121.43643380257618 37.73925593087524,-121.43674763281797 37.73924735532325,-121.4367556774805 37.73954861759737)) The above POLYGON has numerous points that define it. It is, for example, a Pizza Hut restaurant in Tracy, CA. Another fence might look like the following: POLYGON ((-121.43717674042182 37.739442604238896,-121.43687095484256 37.739442604238896,-121.43688173999453 37.73916470683655,-121.43720352649598 37.739149792814075,-121.43717674042182 37.739442604238896)) The above POLYGON data represends our Domino’s restaurant. While the data is correctly formatted, it isn’t quite ready to be sent to the HERE servers. Instead, it has to be added to a tab delimited file like the following: NAME    WKT\nPIZZA_HUT   POLYGON ((-121.4367556774805 37.73954861759737,-121.43642310582709 37.73954227917106,-121.43643380257618 37.73925593087524,-121.43674763281797 37.73924735532325,-121.4367556774805 37.73954861759737))\nDOMINOS POLYGON ((-121.43717674042182 37.739442604238896,-121.43687095484256 37.739442604238896,-121.43688173999453 37.73916470683655,-121.43720352649598 37.739149792814075,-121.43717674042182 37.739442604238896)) It is very important that the file is tab delimited and those are actual tabs, not spaces representing tabs. The NAME column represents the name of the particular fence. For example it could be a store id value or whatever else you can think up. The WKT column represents the actual geofence. Give the file a name with a .wkt extension and add it to a ZIP archive. The file must exist at the root of the ZIP archive. Per the HERE Geofencing API documentation , the fence data can be uploaded with the following cURL command: curl\n    --request\n    -i\n    -X POST\n    -H \"Content-Type: multipart/form-data\"\n    -F \"zipfile=@/path/to/zip/file.zip\"\n    \"https://gfe.api.here.com/2/layers/upload.json?layer_id=4711&app_id={YOUR_APP_ID}&app_code={YOUR_APP_CODE}\" Take note of the layer_id and make sure you provide your own app id and app code values, found in the HERE Developer Portal . You can have numerous layers, representing different groups of geofencing data, so it is important to reference the correct layer_id in the Android project. Displaying a HERE Map in Android with Polygon Objects Drawn While neither a map or visual polygon objects are truly necessary for this example, it gives us something a little more interesting to talk about. Remember, positioning and geofencing doesn’t require a visual component at all as most of our logic is through HTTP requests. If you’ve never used a HERE map before in your Android project, I recommend you take a look at a tutorial I wrote titled, Getting Started with HERE Maps in an Android Application . We won’t be going through the configuration steps for this particular tutorial. Instead, add the following to your MainActivity.java file: package com.example.raboy;\n\nimport android.graphics.Color;\nimport android.graphics.PointF;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.util.Log;\n\nimport com.here.android.mpa.common.GeoCoordinate;\nimport com.here.android.mpa.common.GeoPolygon;\nimport com.here.android.mpa.common.GeoPosition;\nimport com.here.android.mpa.common.OnEngineInitListener;\nimport com.here.android.mpa.mapping.Map;\nimport com.here.android.mpa.mapping.MapFragment;\nimport com.here.android.mpa.mapping.MapPolygon;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\nimport java.lang.ref.WeakReference;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private Map map = null;\n    private MapFragment mapFragment = null;\n    private GeoCoordinate currentPosition = new GeoCoordinate(37.7397, -121.4252);\n    private GeoCoordinate oldPosition = new GeoCoordinate(37.7397, -121.4252);\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mapFragment = (MapFragment) getFragmentManager().findFragmentById(R.id.mapfragment);\n        mapFragment.init(new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n                if (error == OnEngineInitListener.Error.NONE) {\n\n                    map = mapFragment.getMap();\n                    map.setCenter(new GeoCoordinate(37.7394, -121.4366, 0.0), Map.Animation.NONE);\n                    map.setZoomLevel(18);\n \n                    List<GeoCoordinate> pizzahutShape = new ArrayList<GeoCoordinate>();\n                    pizzahutShape.add(new GeoCoordinate(37.73954861759737, -121.4367556774805, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73954227917106, -121.43642310582709, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73925593087524, -121.43643380257618, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73924735532325, -121.43674763281797, 0.0));\n\n                    List<GeoCoordinate> dominosShape = new ArrayList<GeoCoordinate>();\n                    dominosShape.add(new GeoCoordinate(37.739442604238896, -121.43717674042182, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.739442604238896, -121.43687095484256, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.73916470683655, -121.43688173999453, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.739149792814075, -121.43720352649598, 0.0));\n\n                    GeoPolygon polygon = new GeoPolygon(pizzahutShape);\n                    MapPolygon mapPolygon = new MapPolygon(polygon);\n                    mapPolygon.setFillColor(Color.argb(70, 0, 255, 0));\n                    GeoPolygon geoDominosPolygon = new GeoPolygon(dominosShape);\n                    MapPolygon mapDominosPolygon = new MapPolygon(geoDominosPolygon);\n                    mapDominosPolygon.setFillColor(Color.argb(70, 0, 0, 255));\n                    map.addMapObject(mapPolygon);\n                    map.addMapObject(mapDominosPolygon);\n                }\n            }\n        });\n    }\n\n} In the above code we are initializing our map component, centering it on some coordinates, and drawing two polygons on the map. If you look at the coordinates used in each of the List<GeoCoordinate> variables, they should look very familiar to what we had put in our WKT file before uploading it to the HERE servers. Essentially we’re just drawing each of the two geofences to the map. Remember, to use a geofence, it is not a requirement to draw one, it only helps us out for visual reasons. Detecting Changes in Device Location with the HERE Positioning API You might remember that I wrote a previous tutorial titled, Gathering the Android Device Position with the HERE Positioning API , where we listened for changes in the position. We’re going to carry those concepts into this tutorial so we can check for how close our changed location is to a geofence. Take a look at the following modifications: public class MainActivity extends AppCompatActivity {\n\n    private Map map = null;\n    private MapFragment mapFragment = null;\n    private PositioningManager positioningManager = null;\n    private PositioningManager.OnPositionChangedListener positionListener;\n    private GeoCoordinate currentPosition = new GeoCoordinate(37.7397, -121.4252);\n    private GeoCoordinate oldPosition = new GeoCoordinate(37.7397, -121.4252);\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mapFragment = (MapFragment) getFragmentManager().findFragmentById(R.id.mapfragment);\n        mapFragment.init(new OnEngineInitListener() {\n            @Override\n            public void onEngineInitializationCompleted(OnEngineInitListener.Error error) {\n                if (error == OnEngineInitListener.Error.NONE) {\n                    map = mapFragment.getMap();\n                    map.setCenter(new GeoCoordinate(37.7394, -121.4366, 0.0), Map.Animation.NONE);\n                    map.setZoomLevel(18);\n                    positioningManager = PositioningManager.getInstance();\n                    positionListener = new PositioningManager.OnPositionChangedListener() {\n                        @Override\n                        public void onPositionUpdated(PositioningManager.LocationMethod method, GeoPosition position, boolean isMapMatched) {\n                            currentPosition = position.getCoordinate();\n                            if(!currentPosition.equals(oldPosition)) {\n                                map.setCenter(position.getCoordinate(), Map.Animation.NONE);\n                                oldPosition = currentPosition;\n                            }\n                        }\n                        @Override\n                        public void onPositionFixChanged(PositioningManager.LocationMethod method, PositioningManager.LocationStatus status) { }\n                    };\n                    try {\n                        positioningManager.addListener(new WeakReference<>(positionListener));\n                        if(!positioningManager.start(PositioningManager.LocationMethod.GPS_NETWORK)) {\n                            Log.e(\"HERE\", \"PositioningManager.start: Failed to start...\");\n                        }\n                    } catch (Exception e) {\n                        Log.e(\"HERE\", \"Caught: \" + e.getMessage());\n                    }\n                    map.getPositionIndicator().setVisible(true);\n\n                    List<GeoCoordinate> pizzahutShape = new ArrayList<GeoCoordinate>();\n                    pizzahutShape.add(new GeoCoordinate(37.73954861759737, -121.4367556774805, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73954227917106, -121.43642310582709, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73925593087524, -121.43643380257618, 0.0));\n                    pizzahutShape.add(new GeoCoordinate(37.73924735532325, -121.43674763281797, 0.0));\n\n                    List<GeoCoordinate> dominosShape = new ArrayList<GeoCoordinate>();\n                    dominosShape.add(new GeoCoordinate(37.739442604238896, -121.43717674042182, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.739442604238896, -121.43687095484256, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.73916470683655, -121.43688173999453, 0.0));\n                    dominosShape.add(new GeoCoordinate(37.739149792814075, -121.43720352649598, 0.0));\n\n                    GeoPolygon polygon = new GeoPolygon(pizzahutShape);\n                    MapPolygon mapPolygon = new MapPolygon(polygon);\n                    mapPolygon.setFillColor(Color.argb(70, 0, 255, 0));\n                    GeoPolygon geoDominosPolygon = new GeoPolygon(dominosShape);\n                    MapPolygon mapDominosPolygon = new MapPolygon(geoDominosPolygon);\n                    mapDominosPolygon.setFillColor(Color.argb(70, 0, 0, 255));\n                    map.addMapObject(mapPolygon);\n                    map.addMapObject(mapDominosPolygon);\n                }\n            }\n        });\n    }\n\n} The changes to the above code will configure a listener so we know when the location changes. If you’re curious to know what exactly changed, take a look at the following chunk of code: positioningManager = PositioningManager.getInstance();\npositionListener = new PositioningManager.OnPositionChangedListener() {\n    @Override\n    public void onPositionUpdated(PositioningManager.LocationMethod method, GeoPosition position, boolean isMapMatched) {\n        currentPosition = position.getCoordinate();\n        if(!currentPosition.equals(oldPosition)) {\n            map.setCenter(position.getCoordinate(), Map.Animation.NONE);\n            oldPosition = currentPosition;\n        }\n    }\n    @Override\n    public void onPositionFixChanged(PositioningManager.LocationMethod method, PositioningManager.LocationStatus status) { }\n};\ntry {\n    positioningManager.addListener(new WeakReference<>(positionListener));\n    if(!positioningManager.start(PositioningManager.LocationMethod.GPS_NETWORK)) {\n        Log.e(\"HERE\", \"PositioningManager.start: Failed to start...\");\n    }\n} catch (Exception e) {\n    Log.e(\"HERE\", \"Caught: \" + e.getMessage());\n}\nmap.getPositionIndicator().setVisible(true); The most meaningful part of code for us resides in the onPositionUpdated method. This is where we’ll take the updated position and send it to the HERE server to see our proximity to a geofence. A few things to note though. The user will have to accept GPS permissions at runtime for the application, otherwise the location can not be determined. The AndroidManifest.xml file needs to have updated permissions for location. You can learn about both of these in my previous tutorial on positioning with Android. Checking the Proximity of a Geofence with HTTP in Android As of now we’ve created and uploaded our geofence and configured our Android application to listen for changes in position. The real magic is checking to see if our position is within a geofence that we’ve uploaded. To do this, we’ll need to make use of HTTP requests within Android. When the position changes, we’ll need to send that position to the HERE server along with the layer_id for our possible geofences. If there is a match, we’ll see such in the result and be able to do a push notification or similar to the user. There are numerous ways to do HTTP requests in Android, but the easiest is with Volley . You will need to install Volley with Gradle before you can use it, but if you need help, you can learn more about it in a previous tutorial I wrote titled, Using Volley to Make Android HTTP Requests . Within the project, add the following method to the MainActivity class: public void makeRequest(GeoCoordinate coords) {\n    RequestQueue queue = Volley.newRequestQueue(this);\n    JsonObjectRequest request = new JsonObjectRequest(Request.Method.GET,\"https://gfe.api.here.com/2/search/proximity.json?layer_ids=4711&app_id=APP_ID_HERE&app_code=APP_CODE_HERE&proximity=\" + coords.getLatitude() + \",\" + coords.getLongitude() + \"&key_attribute=NAME\", null, new com.android.volley.Response.Listener<JSONObject>() {\n        @Override\n        public void onResponse(JSONObject response) {\n            try {\n                JSONArray geometries = response.getJSONArray(\"geometries\");\n                if(geometries.length() > 0) {\n                    if(geometries.getJSONObject(0).getJSONObject(\"attributes\").getString(\"NAME\").equals(\"PIZZA_HUT\")) {\n                        Log.d(\"HERE\", \"Don't eat at Pizza Hut, eat at Dominos.\");\n                    } else {\n                        Log.d(\"HERE\", \"Don't eat at Dominos, eat at Pizza Hut.\");\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }, new com.android.volley.Response.ErrorListener() {\n        @Override\n        public void onErrorResponse(VolleyError error) {\n            Log.d(\"HERE\", error.getMessage());\n        }\n    });\n    queue.add(request);\n} Alright so what is happening in this makeRequest method? We’re going to be making a GET request and expect a response in JSON format. The HTTP request is defined in the HERE Geofencing API documentation , but we’re taking our layer_id and current coordinates to check our proximity. We’re also asking for a NAME attribute because we uploaded name information in our WKT file. If we get a successful response, we’ll parse the data and see if any geometries were returned. If a geometry was returned it means we are likely within a geofence. If we’re in a geofence we should respond as such. In this example we are only printing to the logs, but a push notification or alert dialog could work too. With the method in place, we can update our onPositionUpdated function to look like the following: @Override\npublic void onPositionUpdated(PositioningManager.LocationMethod method, GeoPosition position, boolean isMapMatched) {\n    currentPosition = position.getCoordinate();\n    if(!currentPosition.equals(oldPosition)) {\n        makeRequest(new GeoCoordinate(position.getCoordinate().getLatitude(), position.getCoordinate().getLongitude()));\n        map.setCenter(position.getCoordinate(), Map.Animation.NONE);\n        oldPosition = currentPosition;\n    }\n} Notice that we are calling the makeRequest method every time the position changes. In a production scenario, you may want to make sure the position changes based on a particular threshold so you’re not making non-stop requests and draining the battery. Conclusion You just saw how to do geofencing with HERE and Android. This example was modeled after the McDonalds and Burger King shennanigans that happened a few months ago, but you can easily take this much further. For example you could expand until this demo and have the location and geofence checking happen in the background. Location intelligence is becoming more of a thing with brands trying to leverage everything in terms of location data to drive sales. For example, check out McDonalds latest acquisition of Dynamic Yield .", "date": "2019-04-02"},
{"website": "Here", "title": "From Map Lovers For Map Makers: HERE XYZ Is Now Also Freemium", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/from-map-lovers-for-map-makers-here-xyz-is-now-also-freemium", "abstract": "At HERE, we are always putting developers' needs and feedback first. Today, we are launching HERE XYZ as part of our Freemium plan and we welcome all mapmakers and explorers to join the best open location platform on the market. As I shared earlier on LinkedIn , we have just put map making on its head with the release of XYZ, our cloud-based service that provides software developers, as well as novice and professional mapmakers, the tools needed for web map publication and effortless data management. Data journalists, cartographers and geospatial data providers will find the real-time nature of HERE XYZ’s dynamic tiling capability to be indispensable for publishing maps that require live updates. For example, Interline Technologies , the San Francisco-based mobility consulting start-up that helps organizations understand and improve their transportation routes, is already using the HERE XYZ API as the ready-made “connector” for various live datasets across cloud services. HERE XYZ is part of the enhanced HERE Freemium plan which allows everyone to build apps (and now also maps) for free. The plan provides users with a large amount of storage space and data transfer. Developers can benefit from seamless integration with HERE Location Services APIs such as Geocoding, Routing, Places and more, allowing them to build full-featured, location-aware applications. Developers and non-developers alike can use XYZ Studio’s intuitive web application to upload their data to the XYZ cloud, create a map, customize and style it, and then easily share it. Built-in features such as conditional formatting, automatic legend creation and layer visibility make it easier to tell interesting stories from any kind of geospatial data. As Jayson wrote in his post, we highly value your feedback – and will continue reiterating HERE XYZ and implementing features and functionalities you request. I can't wait to see what web maps you create or what you build with HERE XYZ in combination with the rest of our over 20 location APIs. Share your new maps with us on Twitter @heredev or in case you are in San Diego next week, visit us at the FOSS4G North America (April 15-18), where brilliant developers and mapmakers flock together to discuss the latest developments in GIS technology. Come say hi to our XYZ team at the ice-breaker reception event, attend our tech talks and XYZ live demos and participate in our XYZ workshop.", "date": "2019-04-12"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.4 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.4-release", "abstract": "Highlights TLS 1.0 and 1.1 Deprecation We are planning to discontinue support for the severely outdated Transport Layer Security (TLS) versions 1.0 and 1.1 in OLP Services on 30 April 2019 . From May 2019 onward, only TLSv1.2 and higher versions will be supported by OLP in accordance with industry-wide best practice. Scope This change affects connections from outside OLP to the OLP Portal and all OLP APIs, including: Browser access to the OLP portal website Access to OLP services using the OLP Data Client Library (part of the OLP SDK) Access to OLP services using the OLP Data Visualization Library (part of the OLP SDK) Access to OLP services using the OLP Command Line Interface Access to OLP services (REST APIs) using any 3rd-party components Impact This change may be an impact in the following cases: 3rd-party components: If you are accessing OLP APIs using components not supplied by HERE (such as open-source HTTP/REST libraries) Unsupported browsers: If you are accessing the OLP Portal or client-based web applications embedding the OLP Data Visualization library using an unsupported browser If you are using OLP with HERE components on supported platforms without explicitly disabling TLS v1.2, this change should not have any impact on you. For example: OLP Portal and OLP Data Visualization library running within a browser: All supported browsers will continue to work and have been defaulting to TLSv1.2 connections with the supported cipher suite since the release of OLP. OLP Data Client and Command Line Interface: All versions of OLP data client and CLI deployed on a supported Java runtime environment (Java 8) will continue to work and have been defaulting to TLSv1.2 connections with the supported cipher suite since the initial release of OLP. Actions you need to take Ensure the following: You are using HERE components on supported platforms without any explicit downgrades on security features (such as disabling newer TLS versions or supported cipher suites). You are not using network components (such as middleboxes and proxies) that prevent the setup of TLSv1.2 connections. If you are using 3rd-party components, you must ensure that they support TLSv1.2 and the supported cipher suites. While we continue to honor our commitment to API stability, we strongly recommend timely upgrades to the latest supported versions of all components used to connect to OLP. This ensures the best compatibility and security. Further Information The RFC for deprecating TLSv1.0 and TLSv1.1 explains the rationale behind the industry-wide move to disable TLSv1 and TLSv1.1 The following is a list of the TLS Cipher Suites that OLP services will support: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 TLS_RSA_WITH_AES_256_GCM_SHA384 TLS_RSA_WITH_AES_128_CBC_SHA256 TLS_RSA_WITH_AES_128_GCM_SHA256 Coverage maps and size heatmaps for layers in the web portal We added a new feature that allows you to better understand the coverage of your partitions on both high and low zoom levels. The new coverage overlay helps you learn the geographical availability of your data. The new heatmap overlay reflects the geographical distribution of your layer data through partition size-driven color gradients. You can analyze your data coverage directly in the OLP Portal’s Data Inspector. Or, you can use the corresponding Visualization Library components to enrich your own applications with these data visualizations. Stream Layer Read API A new Stream Read API is now available. This removes the limitation of only being able to consume data from stream layers via the Data Client Library. The same realm can have subscriptions to Marketplace Provider, Consumer, and Workspace As an Org admin, you can sign up for subscriptions to Marketplace Provider, Consumer, and Workspace for the same realm. If your realm has both Marketplace Provider and Consumer subscriptions, you can grant specific user permissions by adding them to the Provider or Consumer management groups. As a user, if you have permissions to both Marketplace Provider and Consumer management groups, then you can use the toggle switch in your Marketplace user interface to switch between the Provider and Consumer views. This capability enables organizations to use all available OLP capabilities within one realm. Organizations can assign specific user permissions for specific needs. NOTE: To learn how to assign users to Provider and Consumer management groups in your realm, read Marketplace Provider User Guide and Marketplace Consumer User Guide . Change a Batch Pipeline Version's execution mode between on-demand or scheduled Pipeline users can now change the mode of execution of a Batch Pipeline Version from On-demand to Scheduled and vice versa during activation. This improvement helps save time because the users no longer need to create a copy of the Batch Pipeline Version to change the mode of execution. The Batch Pipeline Version can now be run on-demand to test the logic, and the same Batch Pipeline Version can then be scheduled to run based on data changes. Similarly, if a scheduled Batch Pipeline Version experiences any issues, then it can be deactivated and run on-demand for troubleshooting. Monitor custom metrics via Flink Accumulators in Stream Pipelines Stream Pipelines can now be debugged using custom metrics created using Flink Accumulators. Stream Pipelines support the following type of accumulators: Long and Double. Once created, these accumulators become available as metrics in Grafana to query and create dashboards. The metrics are prefixed with the phrase flink_accumulators_ to help you in identifying the available metrics. NOTE: Histogram Accumulator or a user-created Custom Flink Accumulators are not supported in Stream Pipelines. ​ Pipelines Added Added the option for Pipeline users to change the mode of execution of a Batch Pipeline Version from On-demand to Scheduled and vice versa during activation. This improvement helps save time because the users no longer need to create a copy of the Batch Pipeline Version to change the mode of execution. The Batch Pipeline Version can now be run on-demand to test the logic, and the same Batch Pipeline Version can then be scheduled to run based on data changes. Similarly, if a scheduled Batch Pipeline Version experiences any issues, then it can be deactivated and run on-demand for troubleshooting. Added the ability to debug Stream Pipelines using custom metrics created using Flink Accumulators. Stream Pipelines support the following type of accumulators: Long and Double. Once created, these accumulators become available as metrics in Grafana to query and create dashboards. The metrics are prefixed with the phrase 'flink_accumulator' to help you in identifying the available metrics. NOTE: Histogram Accumulator or any user-created Custom Flink Accumulators are not supported in Stream Pipelines. Changed To run a Batch Pipeline on-demand that uses an Index Layer in the input or output Catalogs, a dummy version of that Catalog and processing type is no longer required. Fixed Fixed an issue where a scheduled Batch Pipeline Version could not be forced to run instantly. See the Added release note entry for Pipelines to learn more about the new improvements. Fixed an issue where a Batch Pipeline Version, created and run instantly, could not be scheduled. See the Added release note entry for Pipelines to learn more about the new improvements. Known Issues Issue Only a finite number of permissions is allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and long names of actions defined. Workaround Delete Pipelines/Users to recover space. Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases. Also, the dashboard will not be available for user edits in a future release. Workaround Duplicate the dashboard or create a new dashboard. Issue If multiple pipelines consuming data from a single stream layer all belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is due to the fact that the pipelines share the same Application ID. Workaround Using the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector type, you can specify a Kafka Consumer Group ID per pipeline/application. If the Kafka consumer group IDs are unique, the pipelines/applications will consume all messages from the stream. If your pipelines use the http connector type, we recommend you create a new Group for each pipeline/application, each with its own Application ID. Issue A Pipeline Version can be activated even after an input catalog that it uses is deleted. Workaround The pipeline will fail when it starts running and will show the error message about missing catalog. Re-check the missing catalog or use a different catalog. ​ Data Added Added Stream Layer metrics updates to the \"Data, Catalog, and Layer Metrics\" Grafana dashboard. New tables and graphs for \"Write Byte Rate Per Layer (MB/s)\" and \"Read Byte Rate Per Layer (MB/s)\" enable you to see byte rates in and out per stream layer over time, as well as an average and a current summary. The \"Throughput Per Stream Layer\" metrics have been broken down to show \"In\" and \"Out\" numbers separately. Previously this metric was showing the combined value. Added a new Stream Read API. This removes the limitation of only being able to consume data from stream layers via the Data Client Library. Changed Improved error message experience when a user tries to delete a schema that is associated with a catalog marked \"Marketplace Ready\". Improved error message experience when a user tries to delete or update a catalog that is associated with a catalog marked \"Marketplace Ready\". Removed Data API: Per the six month deprecation notice delivered with the OLP 2.0 release, we are removing the publish v1 API this month (April 2019). Known Issues Issue Catalogs not associated with a realm are not visible in OLP. Issue Visualization of Index Layer data is not yet supported. Issue When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Issue Some older catalogs cannot be shared temporarily because the catalog owners don't have permissions assigned to them yet. This issue only applies to older catalogs. Contact us to report each occurrence as a bug. ​ Notebooks Known Issues Issue OLP Notebooks cannot be shared with OLP user groups. Workaround Notebooks can be shared with one or more individual users by entering each account separately. Issue Notebooks do not support analysis of Stream Layers and Index Layers. ​ Account & Permissions Known Issues Issue A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Delete pipelines/pipeline templates to recover space. Issue All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue When updating permissions, it can take up to an hour for changes to take effect. ​ Marketplace Added Added a Provider and Consumer toggle button in the Marketplace user interface. If you have both Marketplace Provider and Consumer access, then you can see a toggle button in the right upper corner of your Marketplace user interface. This allows you to switch between Provider and Consumer view. Known Issues Issue If you are a Workspace user and have pipelines that use the Kafka Direct connector to connect to stream data, no messages-in and bytes-in metrics can be collected. Workaround You can instrument your pipelines with custom messages-in and bytes-in metrics. Contact technical support if you need assistance. Issue When the Splunk server is busy, the server can lose usage metrics. Workaround If you suspect you are losing usage metrics, contact HERE technical support. We may be able to help rerun queries and validate data. Issue Added a Provider and Consumer toggle button in the Marketplace user interface. If you have both Marketplace Provider and Consumer access, then you can see a toggle button in the right upper corner of your Marketplace user interface. This allows you to switch between Provider and Consumer view. ​ Web & Portal Changed Moved the option to choose the execution mode of a Batch Pipeline Version from the Pipeline Version Configuration process to the Pipeline Version Activation process, where the execution mode for a Batch Pipeline Version can now be changed between Scheduled and On-demand (Run Now). This saves you time because you no longer need to create a copy of the pipeline version, just to make a change in its mode of execution. Fixed Fixed an issue where a Batch Pipeline Version using an Index Layer in the input or output Catalogs don't run on-demand from the Portal and gets stuck in the Scheduled state. Known Issues Issue The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name, and 255 characters for the value. Workaround For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue Pipeline Templates can't be deleted from the Portal UI. Workaround Use the CLI or API to delete Pipeline Templates. Issue In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list. Issue The Pipelines list page might be slow to load all the elements.", "date": "2019-04-08"},
{"website": "Here", "title": "Real-Time Interaction with HERE Maps Between Android and JavaScript with Socket.io", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/real-time-interaction-with-here-maps-between-android-and-javascript-with-socket.io", "abstract": "If you’ve been keeping up with my content, you might remember that about a week ago I had written a tutorial around real-time interaction using Socket.io and a HERE map. This tutorial titled, Real-Time Interaction Between Maps with Socket.io and JavaScript , demonstrated how Socket.io could be used to send client interactions with a map to a server and then broadcasted in real-time to all other connected clients, showing the results on the screen. We’re going to take things a step further in this tutorial. Instead of web browser to web browser communication, we’re going to introduce Android communication so that way as a user interacts with a map, whether it be in a web browser or on an Android device, those interactions get broadcasted to all similar platforms. To get an idea of what we hope to accomplish, take a look at the following animated image: Clicking an area on the Android map will add a marker to the Android map as well as all connected web browser and Android clients. Likewise, clicking an area on the web browser map will do the same. The code for the Socket.io server and JavaScript client that we saw in the other tutorial have not changed for this tutorial. For this reason, we won’t be exploring these again even though they’ll be heavily referenced. Definitely consult my previous tutorial if you haven’t already. Configuring an Android Application to use Socket.io Using Socket.io in Android with Java isn’t too different than using it with JavaScript. For the most part the APIs are the same. However, being that this is Android, there are some project level configurations that must happen first. If you’ve never used HERE with Android, I suggest you check out my previous tutorial titled, Getting Started with HERE Maps in an Android Application . We won’t be walking through the steps to configure HERE in this tutorial, only how to use it with Socket.io. Open your project’s build.gradle file because we need to have Gradle import our Socket.io dependency. Within this file, include the following: dependencies {\n    // ...\n    implementation ('io.socket:socket.io-client:1.0.0') {\n        exclude group: 'org.json', module: 'json'\n    }\n} You’ll want to include the library in your dependencies block without removing the other dependencies that are already in there. Once we have Socket.io as part of our project through Gradle, we need to make some changes to the project manifest file. Open the project’s AndroidManifest.xml file and make the following changes: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.raboy\">\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/>\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"\n        android:hardwareAccelerated=\"true\"\n        android:usesCleartextTraffic=\"true\">\n        <meta-data android:name=\"com.here.android.maps.appid\" android:value=\"APP_ID_HERE\"/>\n        <meta-data android:name=\"com.here.android.maps.apptoken\" android:value=\"APP_CODE_HERE\"/>\n        <activity android:name=\".MainActivity\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n</manifest> Much of the AndroidManifest.xml file is based on configurations that you’ve probably made for the HERE Android SDK. What we’re looking for in particular when it comes to Socket.io is the following line: android:usesCleartextTraffic=\"true\" It took me quite a while to figure out that the above line was needed. In older versions of Android it’s not necessary to explicitly allow cleartext traffic, but in more modern versions, like the Android Pie simulator that I’m using, it is a requirement, otherwise our socket connections will never establish. At this point in time we’re actually ready to start using Socket.io with HERE in our Android application. Sending Data and Responding to Events Visually with a HERE Map Before we start throwing in code, let’s understand how our application is going to work. Essentially we have two parts when it come to Socket.io. When we click on the map, a gesture event will trigger which will allow us to convert the pixel information into coordinate information. Using those coordinates we will send them to our Socket.io server. That is the first part. The second part will be around receiving coordinate information. The server will be sending all connected clients, both JavaScript and Android, broadcasts as they are received. In Android we need to listen for them and take the position data in them and turn them into markers. So let’s get up to speed when it comes to our Android code. In the MainActivity.java file you probably have something like this: public class MainActivity extends AppCompatActivity { private Map map = null ; private SupportMapFragment mapFragment = null ; @Override protected void onCreate (Bundle savedInstanceState) { super . onCreate (savedInstanceState); setContentView (R. layout . activity_main ); mapFragment = (SupportMapFragment) getSupportFragmentManager (). findFragmentById (R. id . mapfragment ); mapFragment. init ( new OnEngineInitListener () { @Override public void onEngineInitializationCompleted (OnEngineInitListener. Error error) { if (error == OnEngineInitListener. Error . NONE ) { map = mapFragment. getMap (); map. setCenter ( new GeoCoordinate ( 37. 7394 , - 121. 4366 , 0. 0 ), Map . Animation . NONE ); map. setZoomLevel ( 12 ); } } }); } } As part of our first step, we are going to establish a connection to the Socket.io server that we built with Node.js in the previous tutorial. First create a private variable like the following: private Socket socket; It is up to you where we actually try to establish a connection, but wherever we decide, we’ll need to catch any possible exceptions. Let’s modify our code to look like the following: public class MainActivity extends AppCompatActivity { private Map map = null ; private SupportMapFragment mapFragment = null ; private Socket socket; @Override protected void onCreate (Bundle savedInstanceState) { super . onCreate (savedInstanceState); setContentView (R. layout . activity_main ); try { socket = IO. socket ( \"http://10.0.2.2:3000\" ); socket. connect (); mapFragment = (SupportMapFragment) getSupportFragmentManager (). findFragmentById (R. id . mapfragment ); mapFragment. init ( new OnEngineInitListener () { @Override public void onEngineInitializationCompleted (OnEngineInitListener. Error error) { if (error == OnEngineInitListener. Error . NONE ) { map = mapFragment. getMap (); map. setCenter ( new GeoCoordinate ( 37. 7394 , - 121. 4366 , 0. 0 ), Map . Animation . NONE ); map. setZoomLevel ( 12 ); } } }); } catch ( URISyntaxException e) { Log. e ( \"HERE\" , e. getMessage ()); } } } Notice that we’ve added two particular lines in the above code. In my circumstance, my Socket.io server is running on my local computer and I’m using my Android simulator. For this reason, I cannot connect my simulator to localhost, so I have to use 10.0.2.2 instead. After defining the server information, then we can try to connect. Since we’ve already got a functional JavaScript application that is sending marker information, let’s listen for that information as part of our next step. Within the onEngineInitializationCompleted method, add the following: socket. on ( \"marker\" , new Emitter. Listener () { @Override public void call ( Object ... args) { try { JSONObject position = (JSONObject) args[ 0 ]; MapMarker defaultMarker = new MapMarker (); defaultMarker. setCoordinate ( new GeoCoordinate (position. getDouble ( \"lat\" ), position. getDouble ( \"lng\" ), 0. 0 )); map. addMapObject (defaultMarker); } catch (JSONException e) { Log. e ( \"HERE\" , e. getMessage ()); } } }); In the above code, we are listening for marker events or labels, which is what the server is configured to send. When we receive one of those events, we can convert it into JSON and extract the lat and lng values to be used in a MapMarker . Once we have our MapMarker we can add it to the map. If the server is storing a bunch of markers, when you launch your Android application, they should all start to populate. We want Android to be able to send marker data as well, not just JavaScript. After our marker event, add the following: mapFragment. getMapGesture (). addOnGestureListener ( new MapGesture. OnGestureListener . OnGestureListenerAdapter () { @Override public boolean onTapEvent (PointF p) { GeoCoordinate position = map. pixelToGeo (p); try { JSONObject pos = new JSONObject (); pos. put ( \"lat\" , position. getLatitude ()); pos. put ( \"lng\" , position. getLongitude ()); socket. emit ( \"marker\" , pos); } catch (JSONException e) { Log. e ( \"HERE\" , e. getMessage ()); } return false ; } }); What we’re saying in the above code is that when a tap event occurs, calculate the coordinates based on the pixels and add them to a JSON object. We then send that JSON object to the Socket.io server to be broadcasted. Conclusion You just saw how to use Socket.io with Android to send tap information to other connected Android and JavaScript devices to be converted into markers on a map. By doing this, a real-time interactive experience is created HERE that is carried between platforms. If you need help with the JavaScript side of things, I encourage you to check out my previous tutorial which focuses on the Socket.io server and JavaScript web application.", "date": "2019-04-16"},
{"website": "Here", "title": "How clean is the air you breathe? Custom Air Quality Maps with Arduino and HERE XYZ", "author": ["Harishjitu Saseendran, Mayuresh Sarang and Aamer Khan"], "link": "https://developer.here.com/blog/air-quality-mapping-and-visualization-using-xyz-arduino-uno", "abstract": "Many air quality devices are statically mounted. We wondered, what if the tools and information needed to understand the severity of air pollution was available on the go? What if we have a system which gives live updates or live readings of the pollution level in a given area? Thus, came the idea to provide a hardware-based solution using HERE XYZ to provide a visual demographic interpretation of the pollution level. Overview In this tutorial we will show you how to setup an Arduino Uno to become a GPS-enabled, Air Pollution Monitor . Then we will walk you through augmenting the generated data to include the street address nearest to the GPS positions using the HERE Reverse Geocoding API, then we will show you how to visualize the results in HERE XYZ Studio to publish an interactive map like this. View this map with HERE XYZ Studio . Our Hackathon Problem Many air quality devices are statically mounted. These devices typically cannot travel. We wondered, what if we made the tools and information needed to understand the severity of air pollution available on the go? How could we create a system that could give live updates or live readings of the pollution level in a given area? Thus, came the idea to prototype a hardware-based solution to collect the data and then use the HERE XYZ platform to provide a visual representation and interpretation of the pollution levels. In this tutorial we will show you how to: Setup and configure an Arduino Uno with an Air Quality Sensor and GPS Calibrate the Air Quality Sensor Collect the data Augment the data with HERE's Reverse Geocoding API Visualize the results using HERE XYZ Studio Hardware Many of these components can be found readily available through many outlets. We are not affiliated with any of the links below. Arduino UNO (micro controller) - http://arduino.cc GPS Module (NMEA) with Active GPS Antenna 3-5V 28dB 5-meter SMA Gas Sensor (MQ-135) Battery Adapter and 9v Battery Software Arduino Studio - http://arduino.cc TinyGPS++ - http://arduiniana.org/libraries/tinygpsplus/ MQ135 Calibration - https://github.com/GeorgK/MQ135 Eclipse - http://eclipse.org Calibrating the gas sensor By default, the gas sensor gives out raw analog / digital values, however, to get PPM values we need to calibrate the gas sensor. To calibrate the sensor, we need to use a library (MQ135.h) which can be downloaded from the following link. https://github.com/GeorgK/MQ135 Next, we connected the gas sensor to the Arduino board as shown below and then ran the following code using Arduino Studio.  We monitored the results and let it run for a minute using the Serial Console.  We copied the last result (in our case 494.63 into the MQ135.h library file.  This value is then used to help the library produce PPM values that we will use for the visualization part of this tutorial. #include \"MQ135.h\"\n\nvoid setup (){\n\t//Baud rate might differ for your GPS module \n\tSerial.begin (9600);\n}\nvoid loop() {\n\tMQ135 gasSensor = MQ135(A0);   // Attach sensor to pin A0\n\tfloat rzero = gasSensor.getRZero();\n\tSerial.println (rzero);\n\t//Setting 1 sec delay\n\tdelay(1000);\n} Once you get a value, insert it into the MQ135 Library header file (MQ135.h). This will a provide a calibrated reading for Parts Per Million (PPM). #define RZERO 494.63 Once we have the gas sensor calibrated, we connected the hardware and we used the following code and deploy it on the Arduino board using Arduino IDE (please see the hardware wiring diagram above). Arduino Code: // This code is based on the TinyGPS++ Library example named \"DeviceExample\"\n\n#include <tinygps++.h>\n#include <SoftwareSerial.h>\n#include \"MQ135.h\"\n\nTinyGPSPlus gps;\nSoftwareSerial ss(4,3); // Assigning pins 3 & 4 of arduino as TX & RX\nvoid setup() {\n  Serial.begin(9600); //setting baud rates\n  ss.begin(9600);\n  Serial.println(\"Latitude, Longitude, Date, PPM\");\n}\n\nvoid loop() {\n\n  while(ss.available() > 0) {\n    \n    // This section will print out the GPS Coordinates\n    if(gps.encode(ss.read())) {\n      Serial.print(gps.location.lat(), 6);\n      Serial.print(F(\",\"));\n      Serial.print(gps.location.lng(), 6);\n      Serial.print(F(\",\"));\n      \n      if (gps.date.isValid()) {\n        Serial.print(gps.date.year());\n        Serial.print(F(\"/\"));\n        Serial.print(gps.date.month());\n        Serial.print(F(\"/\"));\n        Serial.print(gps.date.day());\n        Serial.print(\" \");\n        Serial.print(gps.time.hour());\n        Serial.print(\":\");\n        Serial.print(gps.time.minute());\n        Serial.print(\":\");\n        Serial.print(gps.time.second());\n        Serial.print(\",\");\n      }\n      else {\n        Serial.print(F(\"INVALID\"));\n      }\n\n      //This section will print out the PPM Values from the MQ135\n      MQ135 gasSensor = MQ135(A0); // Read values from A0 pin of arduino\n      float air_quality = gasSensor.getPPM(); // Using MQ135.h library to get PPM values\n      Serial.print(air_quality);\n      Serial.println();\n    }\n  }\n} Working with captured readings and Preparing them for HERE XYZ Studio This completes the hardware setup then began a little leg work. To begin collecting data, we use CoolTerm to output the values from the Arduino Uno to a CSV file.  You can configure CoolTerm to do this by Next, we connected to the Arduino and started recording our journey. We travelled around for about 30 mins to get the live readings of the pollution level along with latitude & longitude. Once complete we disconnected from the Arduino and the file was saved to our Desktop. GPS Locations are useful, but we wanted to see the relative address of each data point. To get the addresses we need to do a \" Reverse Geocode Lookup \" so we created a REST client (Java code below). This program calls a HERE's Reverse GeoCoding API to conduct a reverse lookup and give us address information. To use these API's, you need to obtain a HERE AppID & App_Code. You will need to create a HERE Developer Account. Sign up here . Reverse Geocoding JAVA Program Using your HERE Developer Account, insert your App ID & App Code below and then run this file from Eclipse. For a HERE Developer Account go to https://developer.here.com . You will also need to hardcode the location of the file you outputted while traveling around collecting data. package geocoder;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\nimport org.json.JSONArray;\nimport org.json.JSONObject;\n\n/*\n * About Geocoder\n * \n * This is an application that reads in a CSV file where the column format is as follows\n * [Latitude],[Longitude],[Date],[PPM]\n * \n * This application reads the file in and then for each line creates a request to HERE's \n * reverse Geocoder API and then waits for a request.\n * \n * REQUIREMENTS to Run this code:\n * - You will need to hard code the location of the input file \"csvFile\" variable below.\n * - You will also need to hard code the location of the output file \"outfile\" variable below.\n * - Will also need to insert your HERE Developer AppID and AppCode in the \"url\" variable below.\n * \n * Potential Extensions:\n * - Turn the REST calls into an Asynchronous process\n * - Try using HERE's Batch Reverse Geocoder API - https://developer.here.com/documentation/batch-geocoder/topics/quick-start-batch-geocode.html\n * - Open up a serial connection to the Arduino board and process the incoming data in real time while asynchronously emitting the data to XYZ.\n */\n\npublic class Geocoder {\n\tprivate static final  String USER_AGENT = \"Mozilla/5.0\";\n\t\n\t//Your csv file with captured data\n    static String csvFile = \"[INSERT PATH TO INPUT CSV]\";\n\n    public static void main(String[] args) {\n    \t\n    \t\n        String line = \"\";\n        String cvsSplitBy = \",\";\n        String[] capturedData = null ;\n        \n\t\twriteToCsv(\"Latitude\",\"Longitude\",\"Date & Time\",\"PPM Values\",\"Address\");\n\n        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n        \t\n        \t// will skip first line\n        \tString hearderLine = br.readLine();\n\n           \twhile ((line=br.readLine()) != null) {\n                // use comma as separator\n           \t\tcapturedData = line.split(cvsSplitBy);\n\n           \t\t//URL that we are calling\n        \t\tString url = \"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json?prox=\"+capturedData[0]+\",\"+capturedData[1]+\"&mode=retrieveAddresses\"+\"&app_id=[APP ID]\"+\"&app_code=[APP CODE]\";\n        \t\t\n        \t\tString latitude = capturedData[0];\n        \t\tString longitude = capturedData[1];\n        \t\tString datetime  = capturedData[2];\n        \t\tString ppmValues = capturedData[3];\n        \t\t\n        \t\t//Creating an object of URL Class\n        \t\tURL obj = new URL(url);\n        \t\tHttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\n        \t\t// optional default is GET\n        \t\tcon.setRequestMethod(\"GET\");\n\n        \t\t//add request header\n        \t\tcon.setRequestProperty(\"User-Agent\", USER_AGENT);\n\n        \t\t//Print this response code if you are facing any issues\n        \t\tint responseCode = con.getResponseCode();\n        \t\tBufferedReader in = new BufferedReader(\n        \t\t        new InputStreamReader(con.getInputStream()));\n        \t\tString inputLine;\n        \t\tStringBuffer response = new StringBuffer();\n        \t\t\n        \t\twhile ((inputLine = in.readLine()) != null) {\n        \t\t\tresponse.append(inputLine);\n        \t\t}\n        \t\t\n        \t\t//Getting the response in String\n        \t\tString jsonobj = response.toString();\n\n        \t\t//Reading JSON output using json.org library\n        \t\t//Its recommended to study the JSON response from server prior to extracting the required output\n        \t\t//Refer link https://developer.here.com/api-explorer/rest/geocoder/reverse-geocode\n        \t\tJSONObject json = new JSONObject(jsonobj);\n        \t\tJSONObject response1 = json.getJSONObject(\"Response\");\n        \t\tJSONArray View = response1.getJSONArray(\"View\");\n        \t\tJSONObject obj1 = View.getJSONObject(0);\n        \t\tJSONArray result = obj1.getJSONArray(\"Result\");\n        \t\tJSONObject obj2 = result.getJSONObject(0);\n        \t\tJSONObject location = obj2.getJSONObject(\"Location\");\n        \t\tJSONObject address = location.getJSONObject(\"Address\");\n        \t\t\n        \t\tString label = address.getString(\"Label\");\n        \t\t\n        \t\t\tin.close();\n        \t\t\n        \t\t//print result\n        \t\tSystem.out.println(label);\n        \t\t\n        \t\t//write to output file\n        \t\twriteToCsv(latitude,longitude,datetime,ppmValues,label);\n                \n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n\tprivate static void writeToCsv(String latitude, String longitude, String datetime, String ppmValues, String label) {\n\t\ttry {\n\t\t\t\n\t\t\t// Your output file path\n    \t    File outfile =new File(\"[INSERT PATH TO OUTPUT CSV]\");\n\n\t\t\tFileWriter fw = new FileWriter(outfile,true);\n\t\t\tBufferedWriter bw = new BufferedWriter(fw);\n\t\t\tPrintWriter pw = new PrintWriter(bw);\n\t\t\t\n\t\t\tpw.println(latitude+\",\"+longitude+\",\"+datetime+\",\"+ppmValues+\",\"+\"\\\"\"+label+\"\\\"\");\n\t\t\tpw.flush();\n\t\t\tpw.close();\n\t\t\tfw.close();\n\t\t\tbw.close();\n\t\t}catch(Exception E) {\n\t\t\tSystem.out.println(E);\n\t\t}\n\t}\n} Once the program completes, your data file will have been updated to include the Addresses nearest to the GPS coordinates captured while traveling.  Next, we will show you how to upload the data into HERE XYZ Studio and configure the visualization so that it is more easily interpreted. About the Data Recorded The MQ135 sensor is recording Benzene, Alcohol & NH3 to produce a single reading.  We don't know how much of each gas was detected, but we can still visualize the results with a few calculations. The sensor needs to be calibrated so that a PPM value can be used (this was in the Calibration step above).  For our visualization we determined the minimum, maximum and average PPM values from the recorded data to produce a color scheme that you see in the map below.  We used Excel to find these values. In our case the low was 250, the high was 2270 and the average was 500.  With this information we can complete our map. Visualizing with XYZ Studio After we obtained, assembled and augmented the data, the next step was to feed it into the HERE XYZ Studio for visualization. HERE XYZ supports CSV and other formats, so all we had to do was create a new map and upload our dataset. Go ahead and log into HERE XYZ Studio (if you don't have an account signup , it is free) and click \"Create new project\" and give personalize the project's Name and Description. Next click \"Add\" Next, we want to upload our data set.  Click \"Upload Files\" navigate to your dataset and once complete click \"Done\" to return to your map. Your map will look something like ours does in the image below.  What you are seeing is a bunch of dots all bunched together without any color coding. Our next step is to add color to represent different colors for the Low and High readings.  Then we will add some rules to represent the range of data between our High, Average and Low readings. On the next screen tap \"Points\" to reveal the point configuration menu. Next click \"Add new point style\". This will reveal the style configuration menu where we will define our \"Maximum\" value like this. Once you click \"Confirm\" your map will look like this.  What you are seeing here is a raw data representation where none of the data point have been styled. Next, we will change the colors on the Maximum value to purple so that we can easily see the data.  (If you don't see a color choose like below, click on \"Data1\" to reveal the Point Configuration menu. Next click Points and then \"Maximum\" to reveal the color chooser below.). Click on the colors and choose purple. You will want to do this for the minimum value of your dataset as well.  Next, we created more complex rules for color coding to represent ranges of data (below average, average and above average).  The average configuration look like this.  For Below and above average you would repeat this step with different values. Soon your map will start coming together and look like this. (Depending on the order of the Color Configuration rules you may need to resort your rules to look like this so that the Minimum and Maximum rules are executed first.) You can also inspect each point by selecting it to see the Address, GPS position and PPM values, but first you'll need to select the \"Cards\" pulldown and then drag the \"Address\" field into the area with \"PPM and Date\". Now your map is complete! Let's show you how to publish and share it with your friends. Click on the \"Publish\" button in the bottom right of the main map screen, tap the button to the right of Publish. Next make any configurations you like; we tend to turn on Description and Legend. Once complete scroll to the bottom and tap the \"Copy\" link next to the URL.  This will copy to your clipboard and you are now complete. Conclusion The goal of our project was to showcase the possibilities we can achieve by combining a simple mobile hardware setup with HERE APIs and HERE XYZ studio to develop a solution that could be helpful to a lot of sector and individuals. About the Authors Harishjitu Saseendran , based out of HERE’s Mumbai office, holds engineering degrees in Electronics and Telecommunication. He also has experience in Java, php, MySQL, Python, Android and Arduino Programming. Most of his spare time is spent creating Android-based applications and IOT projects. He likes to get his hands on different tech, leading him to create and evolve innovative solutions like this Air Pollution Monitoring System. Mayuresh Sarang , is an engineer in Computer Science. He spends most of his time developing Web Applications for HERE Technologies based out of Mumbai. His experience excels in Java EE, JSP Servlets, Spring Boot and Hibernate. He has sound knowledge of building Restful Web Services and Rest Clients and he likes creating smart IOT based solutions which gave him an idea of monitoring air pollution using Arduino. Aamer Khan , based out of HERE’s Mumbai office has a bachelor's in computer science and is a strong believer in how modern technologies can better the world. He has experience in Visual Basic and excels in creating advanced Excel macros for automation. He enjoys writing and sharing experiences with his readers. He assisted in documenting this project and providing input to the team. Editor's Note: This is a guest post from a HERE team based out of Mumbai, India. This project came from an internal Hackathon presentation and we would like to share it with you. If you would like to contribute to the HERE Developer Blog, please reach out to us via DM @HEREDev on Twitter.", "date": "2019-04-24"},
{"website": "Here", "title": "Find Out Which Side of the Road to Drive on Using the HERE Geocoder API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/find-out-which-side-of-the-road-to-drive-on-using-the-here-geocoder-api", "abstract": "I’ve been working with the HERE Location APIs for a long time now, but I still keep finding neat new features. For example, you probably knew that you can ask the Geocoder API for the street address of a given location. For example: https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\n?app_id={{app_id}}\n&app_code={{app_code}}\n&prox=51.50345,-0.12768\n&mode=retrieveAddresses\n&maxresults=1 One API call and a quick look at the (truncated) response tells us the latlong 51.50345,-0.12768 is at 10 Downing Street in London. (If you want to try this yourself, make sure to sign up for your free set of credentials and replace the app_id and app_code in the request.) {\n    ...\n    \"Address\": {\n        \"Label\": \"10 Downing Street, London, SW1A 2AA, United Kingdom\",\n        \"Country\": \"GBR\",\n        \"State\": \"England\",\n        \"County\": \"London\",\n        \"City\": \"London\",\n        \"District\": \"Westminster\",\n        \"Street\": \"Downing Street\",\n        \"HouseNumber\": \"10\",\n        \"PostalCode\": \"SW1A 2AA\",\n        \n        ...\n\n    },\n    ...\n} But did you also know that you can ask the Geocoder API which side of the road people are driving on in any given location? Well, you can! To do this, we first need to know that using special parameters we can customize the response of the Geocoder API. This customization allows us to omit information we're not interested in or request additional information that isn’t part of the default response. You can check Customizing the Response in the Geocoder API documentation for full details on these parameters and on which elements you can add and/or omit. In our case, we are looking for additional information, which is available as part of the AdminInfo attribute in the Location objects of the response. To ensure that this object is added to the response, we need to request it using the parameter locationattributes . This parameter allows us to customize the data of the Location objects in the response. The value AdminInfo indicates that we want this set of information included. (You can omit information by adding a - in front of the value. Try -address for example, to completely omit any address information.) We already know that people in the UK drive on the wrong left side of the road, so let's try another country. How about Kenya, with a latlong of -1.27397, 36.81459? https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\n?app_id={{app_id}}\n&app_code={{app_code}}\n&prox=-1.27397,36.81459\n&mode=retrieveAddresses\n&maxresults=1\n&locationattributes=adminInfo As we can see the response now includes an AdminInfo object with a DrivingSide value of right . {\n   ...\n   \"AdminInfo\": {\n        \"TimeZoneOffset\": \"UTC+03:00\",\n        \"LocalTime\": \"2019-05-03T13:49:06+0300\",\n        \"Currency\": \"KES\",\n        \"DrivingSide\": \"left\",\n        \"SystemOfMeasure\": \"metric\"\n    }\n    ...\n} This tells us that people in Kenya also drive on the left side. (A bad habit presumably picked up from the British.) There’s also some other interesting information, such as the local time, currency and whether metric or imperial measurements are preferred in this location. Let’s fire up the JavaScript API and build a little tool that allows us to explore the world and find out where people are driving on the right side of the road. We want to be able to click on any place on the map and see a little info box about the country we clicked on. The end result should look something like this. To build this, we will combine elements from a selection of our JavaScript API examples. First, we’ll need to set up a basic interactive map . Next, we need to be able to calculate a geographic location from a mouse click . We also need to be able to display the information on the map, for which I’ve chosen SVG Graphics Markers . The most interesting aspect for us is how to use the Geocoder API from within the JavaScript API, so we will look at this in some more detail below. You can check out the complete example in GitHub to see how all these elements work together. The JavaScript API provides convenient wrappers for the various HERE REST APIs, which means we can simply create a GeocodingService object, pass it the parameters from our REST call above and then initiate a reverse geocode. We also need to provide OnSuccess and OnError callback functions to handle the response. First let's look at how to initiate the geocoding request. function reverseGeocode(platform) {\n\n    var geocoder = platform.getGeocodingService();  \n    var prox = coord.lat + ',' + coord.lng;\n    \n    var reverseGeocodingParameters = {\n        prox: prox,\n        mode: 'retrieveAddresses',\n        maxresults: '1',\n        locationattributes: 'adminInfo'      \n    };\n\n    geocoder.reverseGeocode(\n        reverseGeocodingParameters,\n        onSuccess,\n        onError\n    );\n} Finally, we can parse the results in the OnSuccess function and format some strings to display in our marker. That's it. function onSuccess(result) {\n    locations = result.Response.View[0].Result;\n    country = locations[0].Location.Address.AdditionalData[0].value;  \n    adminInfo = locations[0].Location.AdminInfo;    \n    localTime = adminInfo.LocalTime.substring(11,16);\n    currency = adminInfo.Currency;  \n    drivingSide = ((adminInfo.DrivingSide == 'right') ? 'right' : 'left');  \n    systemOfMeasure = ((adminInfo.SystemOfMeasure == 'metric') ? 'ml' : 'fl oz');\n    \n    addAdminInfoMarker(map);\n} Happy Geocoding and safe driving!", "date": "2019-05-06"},
{"website": "Here", "title": "Powering New Serverless Location-Based Functions for Microsoft Azure Developers", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-powers-new-serverless-location-based-functions-for-microsoft-azure-developers", "abstract": "At HERE we believe in enabling developers to build great things using the power of location. I am personally very excited to announce the availability of our core Location Platform Services via one of the strongest and brightest developer ecosystems, Microsoft Azure. By opening up our core location platform services including the largest POI database on the Microsoft Azure Marketplace as serverless functions, we want the Azure developer community to have new capabilities and fully tap into the power of location intelligence. HERE Maps & Location Services allows developers to fast-track the development of location-centric applications, by leveraging HERE’s global map data and curated location content in combination with the readily available location services including rendering, search, routing, transit and positioning. The set of location-based APIs and services is available on Azure, available across more than 193 countries, and includes: Geocoding – High-precision mapping of geo-coordinates and addresses Positioning – Device tracking and positioning for indoors and outdoors, online or offline Fleet Telematics – Advanced algorithms for optimal truck routing and planning with a deep set of data including truck attributes (maximum height and weight clearance), toll costs, and environmental zones Routing – Precise instructions to a destination using various transport modes (car, truck, public transit, bicycle) and leveraging matrix and isoline algorithms Places – Extensive set of Points of Interest with rich attribution for 400+ categories providing real world context and relevance for a variety of use cases Map Tiles – Pre-rendered map tiles with different display types, such as regular map, satellite imagery and terrain Map Image – Pre-rendered map images already optimized for both desktop & mobile devices With HERE Maps & Location Services, Azure developers have access to a deeper set of location-based data and algorithms as well as the flexibility to incorporate data that is unique to their organizations. This gives developers a unique opportunity to build highly contextual and engaging experiences in the areas of IoT device management, field workforce management, transportation and mobility, emergency services, infrastructure management, urban planning, fleet management, (real-time) tracking of assets, location search, and many more. Jeff Sandquist, General Manager, Cloud + AI Developer Relations at Microsoft said, “We look forward to seeing how our developer community leverages the power of location intelligence to enrich their enterprise and IoT apps with these robust HERE Location Service APIs.” These serverless functions are available on the Microsoft Azure Marketplace and functions library in three Azure Resource Manager (ARM) solution templates: HERE Maps & Location Services serverless functions - This ARM template deploys HERE serverless functions to be invoked as part of Azure applications HERE Maps & Location Services for WebApp backends - This template deploys the HERE serverless functions and Azure Services like Service Bus and Cosmos DB necessary to utilize the functions in a Web Application backend HERE Maps & Location Services for Data Streams - This template deploys the HERE serverless functions and Azure services like Event Hub and Cosmos DB necessary to utilize the functions in a real time streaming application Today, Azure developers can get started for free with 250,000 location transactions with complete details in the links above. We can't wait to see what you build!", "date": "2019-05-07"},
{"website": "Here", "title": "Hands-On With The HERE Mapping And Location APIs as Azure Functions", "author": ["Ashutosh Badwe"], "link": "https://developer.here.com/blog/hands-on-with-the-here-mapping-and-location-apis-as-azure-functions", "abstract": "Today we are excited to share with all of you the launch of HERE’s location services solution templates on the Azure Marketplace . These Azure Resource Manager (ARM) templates make easy for Azure IT professionals and developers to invoke our enterprise class, SLA backed REST services like Map Image, Map Tiles, Geocoder, Positioning, Routing, Places and Fleet Telematics as Azure functions in their Azure applications and solutions . These services solve a range of problems like map visualization, navigation & routing, geocoding, time zone lookups, geofencing, custom locations & routing, route matching GPS traces, geospatial, sequencing multiple waypoints, truck routing and lat / lon positioning based on Wi-Fi and Cell coverage . The re are three HERE location services ARM templates that are now available on the Azure Marketplace: HERE Maps & Location Services serverless functions - This ARM template deploys HERE serverless functions that can be invoked directly within Azure applications and solution s. HERE Maps & Location Services for WebApp backends - This template deploys the HERE serverless functions and Azure Services like Service Bus and Cosmos DB necessary to utilize the functions in a Web Application backend HERE Maps & Location Services for Data Streams - This template deploys the HERE serverless functions and Azure services like Event Hub and Cosmos DB necessary to utilize the functions in a real time streaming application Why did we do this? T ime and again we have heard from Azure developers that they would like to get self-service access to our location services in the development environment of their choice with minimal friction between trying, buying and using our services. Not only that, we have been receiving feedback asking us how we could seamlessly integrate our APIs with other Azure services, so that developers spend more time building applications and solution rather than integrating APIs . How do our three solution templates enable that? HERE Maps & Location Services serverless functions template deploy s our s erverless location functions directly from the Azure marketplace . These functions can be invoked as http end points that can be invoked from Azure applications and solution that need location intelligence. HERE Maps & Location Services for WebApp backends template is meant to get web app lication developers setup with everything they need to utilize our APIs in their backends. This could be any web application that requires Maps to be displayed or implements features like directions, address lookup etc. In addition to the serverless functions, t his template deploys Service Bus and Cosmos DB in the developer account configured and ready to go. Just send your web application requests to the service bus and invoke our functions. The functions also store API responses in Cosmos DB for logging or further processing. The diagram below shows this in more detail. HERE Maps & Location Services for Data Streams template is ideal for real time streaming applications like an IoT application with a fleet of devices that are streaming data to the cloud . In such data stream application, you will most likely need to add location context in real time , for ex: if you have lat / lon coordinates of the delivery truck you most likely need Geocoding functionality to get the address or vice-versa . In addition to the serverless functions, this template also deploys the Azure EventHub and Cosmos DB all configured and ready to go. As your data stream is ingested into the Event Hub, HERE location functions can be invoked in real time and the output can be store for logging or further processing. The diagram below shows this in more detail . We would like to show you how simple it is to get started with our services from the Azure Marketplace with the HERE Maps and Location Services for Web Application backends ARM template as an example . It is quite easy and involves the following steps: Get Started for FREE at developer.here.com and save your HERE A PP ID and APPCODE . This is the same Freemium plan that gives you 250K transactions for FREE per month. View the template on the Azure Marketplace by clicking this link Click the “GET IT NOW” button and select Continue. Specify the APPID and APPCODE from step 1 in the HERE Configuration screen Select defaults and Click “Create” on the last screen. Once the template is deployed in your Azure account, you are ready to invoke our serverless functions and bring location intelligence to your Web A pplications . You can always get more details about the APIs from our developer portal and as always t echnical support from HERE’s location experts and fellow developers like you is available on s tack o verflow . There are many great benefits of using our APIs as serverless functions including Better security by storing the API credentials in a secure centralized cloud location instead of client applications Ability to customize the functions with business logic to create custom location microservices Seamless integration with Azure services like EventHub, Service Bus, CosmosDB and many others. You can also work with these functions in conv e niently in your development environment . All this means lower development time and faster time to market from start to deploy. In summary, we have now brought our popular Freemium developer offering many steps closer to your Azure environment with many added benefits . More deployment and technical details and all documentation links for the templates are available in the “Learn more” section s on the Azure marketplace listing pages for the three templates. To really bring home the power of this offerings, m y colleagues in the HERE developer evangelism team will shortly be posting a blog and sample code which will show you how to get started with a real time fleet telematics application in 15 minutes using the HERE Maps & Location Services for Data Streams template. So , keep your eye out for this and other great information at our developer blog . Many of you have already noticed that when you sign up for Freemium on our developer portal you get access to all of our APIs, mobile SDKs as well as our XYZ product. Many of these APIs are not yet available as Azure serverless functions in this release. But we have noted your feedback and will be adding more services to our Azure marketplace offerings. In the meantime, your APPID and APPCODE will work for your Azure templates in addition to all the other services available to you as part of Freemium. As of writing this blog, the REST APIs available as Azure functions are as follows : Map Tile: Shows fresh day-time map tiles in multiple styles with rendered live-traffic tiles. Map Image : Access pre-rendered map images optimized for desktop and mobile devices. Routing : Get precise instructions to a destination using various transport modes, leveraging different algorithms. Geocoder : Convert street addresses to coordinates and vice-versa with batch, auto-correction processing. Places : Allow your users to search, discover and interact with Points of Interest. Positioning : Provide positioning estimates based on global Wi-Fi and cell coverage. Fleet Telematics : Access advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs , c ustom Locations & Routes", "date": "2019-05-09"},
{"website": "Here", "title": "Distance Calculations Between Points with the HERE JavaScript SDK", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/distance-calculations-between-points-with-the-here-javascript-sdk", "abstract": "When I’m interacting with developers using HERE APIs and services, one common question I get is around distance calculations. The HERE SDK and APIs make it easy to calculate paths or routes, but it isn’t the most obvious if you want to pull the total distance from those calculations. In fact, there are multiple different distances that can be obtained. As a developer, you could be searching for the distance between two points regardless of roadways. Take, for example, air travel or similar for that type of distance. You could also be searching for the distance between two points along a route that can be navigated. Think your GPS when you’re driving or similar for that type of distance. We’re going to take a look at calculating these two distances using the HERE JavaScript SDK . Calculating the Absolute Distance Between Two Points The first example we’ll look at is around the absolute distance between two points, ignoring any kind of roads or similar. Let’s take a look at the following example code: const tracyMarker = new H.map.Marker({ lat: 37.7397, lng: -121.4252 });\nconst stocktonMarker = new H.map.Marker({ lat: 37.9577, lng: -121.2908 });\nconst straightLineString = new H.geo.LineString();\nstraightLineString.pushPoint(tracyMarker.getPosition());\nstraightLineString.pushPoint(stocktonMarker.getPosition());\nconst straightPolyline = new H.map.Polyline(straightLineString);\nmap.addObject(straightPolyline); Of course if you really wanted to try the above code, you’d need to properly configure your application and add a map, but hopefully you can get the idea. We have two markers and we’re drawing a straight line between those two markers. If we wanted to calculate the distance, we would typically make use of the haversine algorithm, because remember, the earth is not flat. To make our lives easier, the HERE JavaScript SDK takes care of this algorithm for us. Let’s take a look at the following modification to our code: const distance = tracyMarker.getPosition().distance(stocktonMarker.getPosition());\nconsole.log(distance); The above lines would print out the distance in meters. The distance function is part of the H.geo.Point class which is returned from markers when calling the getPosition function. Calculating the Distance Along a Route With the basic distance calculation out of the way, we can take a look at finding the route distance. After all, I probably want to know how far I’m driving when I enter information into my GPS. Let’s take a look at the following code for our example: const params = {\n    mode: \"fastest;car;traffic:enabled\",\n    waypoint0: \"37.7397,-121.4252\",\n    waypoint1: \"37.9577,-121.2908\",\n    representation: \"display\"\n};\nroutingService.calculateRoute(params, success => {\n    const routeLineString = new H.geo.LineString();\n    success.response.route[0].shape.forEach(point => {\n        const [lat, lng] = point.split(\",\");\n        routeLineString.pushPoint({\n            lat: lat,\n            lng: lng\n        });\n    });\n    const routePolyline = new H.map.Polyline(\n        routeLineString,\n        {\n            style: {\n                lineWidth: 5\n            }\n        }\n    );\n    map.addObject(routePolyline);\n}, error => {\n    console.log(error);\n}); You’ve probably seen some form of the above code in the documentation. Like with the previous example, you’ll need to do some preparation work in your code if you actually want to run it. I’m just sharing the part that is important to us. As it stands, we cannot easily get the distance from the above code. We need to make a modification. In the params , we need to add the following: routeAttributes: \"summary\" The summary will return information like distance, or estimated travel time. With the summary information being returned, we can access it in the success callback of the calculateRoute function: console.log(success.response.route[0].summary.distance); Like with our other distance calculation, this distance is also in meters. Conclusion You just saw how to do some basic distance calculations with your location data using the HERE JavaScript SDK . There are plenty of other scenarios, but these are the two most common that I receive when I’m at developer events.", "date": "2019-04-23"},
{"website": "Here", "title": "Introducing the SAPUI5 Points of Interest Workshop", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/introducing-the-sapui5-points-of-interest-workshop", "abstract": "Today we are happy to announce the next addition to our workshop series, the SAPUI5 Points of Interest Workshop . Displaying a map is great, but without highlighting specific places, what is the point? With the HERE Places API, developers can discover or explore points of interest (POI) near a specific geolocation. All of the APIs HERE provides for SAP developers can be found at the SAP API Hub , which include routing, geocoding, maps, and much more. Scope and Requirements The following are prerequisites for getting started: Some HTML experience (need help ?) Some JavaScript experience (need help ?) SAP Developer account ( http://api.sap.com ) HERE Developer account ( https://developer.here.com ) IMPORTANT! It is a requirement to complete the following workshops first: SAPUI5 Maps Intro Workshop SAPUI5 Geocoder Workshop Overview of Tasks The following topics are covered in the Points of Interest (POI) Workshop: Discovery. How to locate and obtain endpoint for HERE Places API to use from the SAP API Hub . Configuration. Configure an SAPUI5 project to use HERE Places APIs via Destination. Development. Databind XML View to JSON data as resulting from HERE Places API call. The simple output of the SAPUI5 Points of Interest Workshop results in displaying markers on a map based on static input and result from call to HERE Places API: Ready to get started? Remember, you must complete prior workshops before starting this one. Each workshop is a tutorial separated into sections to easily progress from each major milestone - doing so one step at a time. The advantage of preserving the workshop at GitHub is maintaining it with updates and bug fixes (if any). Please try it out! Summary SAP developers can integrate the HERE Places API into their SAPUI5 projects. For more information about HERE, please visit our developer portal at http://developer.here.com .", "date": "2019-05-09"},
{"website": "Here", "title": "Enriching SageMaker Preprocessing With Location Data", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/enriching-sagemaker-preprocessing-with-location-data", "abstract": "Today we are happy to announce our latest tutorial - Fetching Location Data With SageMaker . SageMaker is Amazon's fully managed machine learning service. Data scientists and developers can use it to build and train machine learning models and integrate into applications. The following diagram is a typical machine learning workflow process: The first step in generating example data is labeled \"Fetch\", where initial gathering of data occurs. Whether the data is in-house or publicly available, it is typically merged into a single repository before moving on to \"Clean\" and/or \"Prepare\" step(s). In our new tutorial, we guide you through the process of getting started with SageMaker and factoring location data in the generated example data. NOTE: The tutorial is not an entire walk-through of the machine learning workflow - only the work done in \"Fetch\" is considered. Scope and Requirements The following are prerequisites for getting started: Machine learning concepts (need help ?) AWS account ( https://aws.amazon.com ) HERE Developer account ( https://developer.here.com ) Overview of Tasks The following topics are covered or referenced in the tutorial: Setup. Creating a SageMaker Notebook Instance Architecture. Understanding architecture and review of initial \"incidents\" dataset Development. Enrich \"incidents\" dataset to include nearby points of interest using HERE Places API The simple output of the tutorial is a unified dataset ready for the next step in the machine learning data pipeline. The following screen capture demonstrates the output within the Jupyter environment: Summary If you need to factor location data into your machine learning example data, we invite you to explore the Fetching Location Data With SageMaker tutorial. For more information about HERE, please visit our developer portal at http://developer.here.com . If you want to see HERE & SageMaker work together in real time, join us on May 15th for our AWS Connections Livestream on Twitch.", "date": "2019-05-10"},
{"website": "Here", "title": "April Release Highlights Feat. Fleet Telematics Custom Locations with Free Truck Parking", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/april-2019-release-highlights", "abstract": "All services receive map content updates frequently but we will call out a few noteworthy highlights in April 2019 related to the following services: Routing API , Fleet Telematics API and Mobile SDKs . There were other minor updates and fixes across many other services as well which were related to regular maintenance releases. View the API Version History for specific monthly updates including change log and release notes for all of the APIs. Routing API Provide precise instructions to a destination using various transport modes (e.g., car, truck, public transit, bicycle) and leveraging different algorithms (e.g., matrix, isoline routing). Learn more… Version 7.2.103 Fixed the issue of relaxing truck restriction penalty on routes starting or ending at a junction.  Now the route computation with relaxed truck restriction penalty does not fail if any link connected to the matched start or end junction permits at least car traffic. Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs, etc. Learn more... Version 2.5.15 Routing can avoid Environmental Zones (parameter &excludeZoneType=environmental) depending on vehicle type, emission class, fuel type, weight and time of day/weekday. Routing considers signposted \"Preferred Truck Routes\" for general trucks and for Australian B-Double road trains (&vehicleCat=bdouble). Real time truck parking availability can be searched and retrieved, aggregated from 3rd party live content (limited coverage to some US states only, requires additional licensing) Here's an example search along I-70 in Indiana to identify a Fleet Telematics Custom Location Extension exit to use for free truck parking. #!/bin/bash\n\nif [ $# -eq 0 ]\nthen\n    SEARCH='39.442,-87.5052'\nelse\n    SEARCH=$@\nfi\n\ncurl \\\n  -X GET \\\n  -H 'Content-Type: *' \\\n  --get \"$FLEET_CLE_URI_HERE/1/search/proximity.json\" \\\n    --data-urlencode \"app_id=$APP_ID_HERE\" \\\n    --data-urlencode \"app_code=$APP_CODE_HERE\" \\\n    --data-urlencode \"layer_ids=TRUCK_PARKING_POI\" \\\n    --data-urlencode \"key_attributes=SOURCE_ID\" \\\n    --data-urlencode \"proximity=$SEARCH\" \\\n| jq '.' Mobile SDKS Full-featured, native apps with our mapping platform. Learn more… Map Updates Average speed cameras have been added to the map. Now our clients can use this information to provide visual/audio notifications or to render them on the map. 3793 cameras were added for the whole map. The penalty of exiting the highway has been equalized with exiting one to avoid following inconvenient routes (Previously, exiting the highway had bigger cost than entering one, which in some occasions would force the user to go for a long detour instead of taking the first exit to the destination point). Algorithm responsible for building a route geometry has been improved to avoid visual gaps in the middle of the route. Removed redundancy in the data representation of time restrictions in routing zones. Building and landmarks coverage expansion and improvements in multiple countries: Philippine, Singapore, Switzerland, Romania, Belgium, Germany and United Arab Emirates Updated 2D Generalized Signs to 2019Q1 data HERE iOS SDK Full-featured, native apps on iOS with our mapping platform. Learn more… Premium Edition Version 3.11 Decreased map data usage when Traffic is on Implemented avoidance of odd/even and time-dependent environmental zones Implemented Turn-by-Turn guidance for truck routes in online and offline modes Enhanced difficult turns avoidance for trucks by excluding sharp turns from a route Added possibility to specify padding around the edges of the map. The map will continue to fill the entire container, but object positioning, map transformation, and camera movements will behave as if it has been placed in a smaller space Introduced fuzzy matching logic that allows the creation of an optimal route that passes over a waypoint within the specified radius. This might be useful when a waypoint is only known approximately (e.g. Drag-and-drop, estimated coordinates) Introduced junction snapping logic that allows moving a waypoint onto the junction within the specified radius. It allows eliminating short maneuvers, e.g. \"Turn left and follow for 3m\" Introduced selective matching logic that allows moving a waypoint to a segment that is visible on the lowest zoom level within the specified radius. Selective matching behavior is useful for Drag-and-drop and snapping to more important streets Added new API that allows customizing text color for maneuver enumeration HERE Android SDK Full-featured, native apps on Android with our mapping platform. Learn more… Premium Edition Version 3.11 Decreased map data usage when Traffic is on Implemented avoidance of odd/even and time-dependent environmental zones Implemented Turn-by-Turn guidance for truck routes in online and offline modes Enhanced difficult turns avoidance for trucks by excluding sharp turns from a route Added possibility to enable/disable map matching in Positioning Manager Added possibility to specify padding around the edges of the map. The map will continue to fill the entire container, but object positioning, map transformation, and camera movements will behave as if it has been placed in a smaller space Introduced fuzzy matching logic that allows the creation of an optimal route that passes over a waypoint within the specified radius. This might be useful when a waypoint is only known approximately (e.g. Drag-and-drop, estimated coordinates) Introduced junction snapping logic that allows moving a waypoint onto the junction within the specified radius. It allows eliminating short maneuvers, e.g. \"Turn left and follow for 3m\" Introduced selective matching logic that allows moving a waypoint to a segment that is visible on the lowest zoom level within the specified radius. Selective matching behavior is useful for Drag-and-drop and snapping to more important streets Added new API that allows customizing text color for maneuver enumeration", "date": "2019-04-30"},
{"website": "Here", "title": "Display Weather Information in a NativeScript with Angular Android and iOS Mobile App", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/display-weather-information-in-a-nativescript-with-angular-android-and-ios-mobile-application", "abstract": "I am a huge fan of NativeScript and have been for a long time. While HERE doesn’t currently offer an official NativeScript SDK for building Android and iOS applications, it shouldn’t stop you from using HERE with NativeScript because most APIs can be accessed over HTTP. A few months ago I had written a tutorial around using the HERE Weather API with Angular which many of you found very useful. To make this tutorial mobile friendly, I thought NativeScript would be a great candidate. In this tutorial we’re going to expand what we saw in the web version and take it to Android and iOS with NativeScript. To get an idea of what we hope to accomplish, take a look at the following image: Nothing too fancy is happening in the above picture. We are collecting the 7 day forecast and displaying it in a list with the appropriate weather icons. All of this data, including the icon, is returned as part of the API response. To proceed with this tutorial, you will need to have NativeScript and Angular CLI installed and properly configured, along with a HERE Developer Portal account. Create a New NativeScript with Angular Project Assuming you’ve got NativeScript ready to go, we can create a new Angular templated project for use with this project. From the command line, execute the following command: tns create here-weather-project --template tns-template-blank-ng Since we’ll be using HTTP to communicate with REST APIs, we won’t need to install any special plugins. As we reach a certain point in the tutorial we will install a JavaScript library for time conversions, but it isn’t necessary for our project and can wait. Request Weather Forecast Information from the HERE Weather API To be successful with the HERE Weather API , we’ll need to make use of the the Angular HttpClient module. To do this, we need to make some changes to the project’s src/app/app.module.ts file: import { NgModule, NO_ERRORS_SCHEMA } from \"@angular/core\";\nimport { NativeScriptModule } from \"nativescript-angular/nativescript.module\";\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppRoutingModule } from \"./app-routing.module\";\nimport { AppComponent } from \"./app.component\";\n\n@NgModule({\n    bootstrap: [\n        AppComponent\n    ],\n    imports: [\n        NativeScriptModule,\n        AppRoutingModule,\n        HttpClientModule\n    ],\n    declarations: [\n        AppComponent\n    ],\n    schemas: [\n        NO_ERRORS_SCHEMA\n    ]\n})\nexport class AppModule { } In the above code, notice that the HttpClientModule was imported and then added to the imports array of the @NgModule block. With it added, we can start using it in our components and services. To keep this example simple, we will not be creating any new services or components. We’re going to leverage the HomeComponent that should already exist as part of the NativeScript template. Open the project’s src/app/home/home.component.ts file and include the following: import { Component, OnInit } from \"@angular/core\";\nimport { HttpClient, HttpParams } from '@angular/common/http';\nimport { map } from 'rxjs/operators';\n\n@Component({\n    moduleId: module.id,\n    selector: \"home\",\n    templateUrl: \"./home.component.html\"\n})\nexport class HomeComponent implements OnInit {\n\n    private appId: string;\n    private appCode: string;\n\n    public weather: any;\n\n    public constructor(private http: HttpClient) { }\n    public ngOnInit() { }\n    public getWeather(coordinates: any) { }\n\n} Because we know we’ll be using the HttpClient class, we need to import it along with the HttpParams class. We then need to start configuring each of our methods. In the constructor method we inject the HttpClient , but we also need to define our HERE application tokens: public constructor(private http: HttpClient) {\n    this.appId = \"HERE-APP-ID\";\n    this.appCode = \"HERE-APP-CODE\";\n} Make sure to replace the actual tokens with those found in your HERE Developer Portal account. With the tokens defined, let’s start creating the HTTP request to the HERE Weather API. Within the file, make the getWeather method look like the following: public getWeather(coordinates: any) {\n    let params = new HttpParams({\n        fromObject: {\n            \"product\": \"forecast_7days_simple\",\n            \"latitude\": coordinates.latitude,\n            \"longitude\": coordinates.longitude,\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        }\n    });\n    this.http.get(\"https://weather.cit.api.here.com/weather/1.0/report.json\", { params: params })\n        .pipe(map(result => (<any>result).dailyForecasts.forecastLocation))\n        .subscribe(result => {\n            this.weather = result.forecast;\n        }, error => {\n            console.error(error);\n        });\n} The above code is where the magic happens. After being provided a set of latitude and longitude coordinates, we can construct the request with the parameters found in the documentation. These parameters also include our application tokens. With the parameters properly formatted, we can make the request and store the response in the weather variable. In our scenario, we only care about the forecastLocation information. There are plenty of other parameters and response data to look at as part of the HERE Weather API. To execute this function when the component initializes, we can make use of the ngOnInit method: public ngOnInit() {\n    this.getWeather({ latitude: 37.7397, longitude: -121.4252 });\n} In the above example we are requesting weather information for Tracy, CA. As of now we aren’t displaying the information, only obtaining it. To display it, we can visit the project’s src/app/home/home.component.html file: <ActionBar class=\"action-bar\">\n    <Label class=\"action-bar-title\" text=\"TRACY, CA\"></Label>\n</ActionBar>\n\n<GridLayout class=\"page\">\n    <ListView [items]=\"weather\" class=\"list-group\">\n        <ng-template let-forecast=\"item\">\n            <GridLayout class=\"list-group-item\" rows=\"auto, auto\" columns=\"50, *\">\n                <Image [src]=\"forecast.iconLink\" rowSpan=\"2\" row=\"0\" col=\"0\"></Image>\n                <Label text=\"{{ forecast.highTemperature }}C\" row=\"0\" col=\"1\" class=\"p-x-5\"></Label>\n                <Label text=\"{{ forecast.utcTime }}\" row=\"1\" col=\"1\" class=\"p-x-5\"></Label>\n            </GridLayout>\n        </ng-template>\n    </ListView>\n</GridLayout> The above XML will create a nicely formatted list of data. The data will include the image, the temperature in Celsius, and the time. However, the time won’t be formatted and the we may be more interested in Fahrenheit format for the temperature. This is where we can start formatting our data. Change the Response Format with Angular Pipes There are plenty of ways to format our data, but in Angular, it might be best to create a pipe for our needs. We can actually create two pipes, one for the Fahrenheit conversion and one for the time formatting. To do this, execute the following commands from within your project: ng g pipe fahrenheit\nng g pipe moment The above commands will create two pipes. As you might have noticed, we’ll be using Moment.js for our time conversions. This means we need to install it like mentioned earlier in the tutorial. To do this, execute the following from the command line: npm install moment --save We’re going to start with our Celsius to Fahrenheit conversion. Open the project’s src/app/fahrenheit.pipe.ts file and include the following: import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n    name: 'fahrenheit'\n})\nexport class FahrenheitPipe implements PipeTransform {\n\n    public transform(value: any, args?: any): any {\n        return ((value * (9 / 5)) + 32).toFixed(2);\n    }\n\n} We’re using a standard formula during our transformation to make this possible. Before we try to use this pipe, let’s finish the MomentPipe as well. Open the project’s src/app/moment.pipe.ts and include the following: import { Pipe, PipeTransform } from '@angular/core';\nimport * as moment from \"moment\";\n\n@Pipe({\nname: 'moment'\n})\nexport class MomentPipe implements PipeTransform {\n\n    public transform(value: any, args?: any): any {\n        return moment(value).format(\"MMMM DD, YYYY\");\n    }\n\n} There is one more step that must be taken before we can actually use the FahrenheitPipe and MomentPipe pipes. We need to include them as part of our module. However, we aren’t going to include them to our project’s src/app/app.module.ts file. If any reference to these pipes exist there, go ahead and remove them. Instead, we’re going to add them to the project’s src/app/home/home.module.ts file like so: import { NgModule, NO_ERRORS_SCHEMA } from \"@angular/core\";\nimport { NativeScriptCommonModule } from \"nativescript-angular/common\";\n\nimport { HomeRoutingModule } from \"./home-routing.module\";\nimport { HomeComponent } from \"./home.component\";\nimport { FahrenheitPipe } from '../fahrenheit.pipe';\nimport { MomentPipe } from '../moment.pipe';\n\n@NgModule({\n    imports: [\n        NativeScriptCommonModule,\n        HomeRoutingModule\n    ],\n    declarations: [\n        HomeComponent,\n        FahrenheitPipe,\n        MomentPipe\n    ],\n    schemas: [\n        NO_ERRORS_SCHEMA\n    ]\n})\nexport class HomeModule { } At this point in time we can actually use the two pipes in our application. Go back into the project’s src/app/home/home.component.html file so we can make a small adjustment. Take note of the following: <GridLayout class=\"list-group-item\" rows=\"auto, auto\" columns=\"50, *\">\n    <Image [src]=\"forecast.iconLink\" rowSpan=\"2\" row=\"0\" col=\"0\"></Image>\n    <Label text=\"{{ forecast.highTemperature }}C / {{ forecast.highTemperature | fahrenheit }}F\" row=\"0\" col=\"1\" class=\"p-x-5\"></Label>\n    <Label text=\"{{ forecast.utcTime | moment }}\" row=\"1\" col=\"1\" class=\"p-x-5\"></Label>\n</GridLayout> In our GridLayout we are now piping the data returned from the API into the FahrenheitPipe and MomentPipe pipes. Again, not entirely necessary, but helpful long term for larger projects. Conclusion You just saw how to use the HERE Weather API in your NativeScript with Angular project. The HERE Weather API is much more involved than just a 7 day forecast, but for the simplicity of the example, that is the only data we decided to work with. This tutorial was a followup to the weather with Angular tutorial I had written prior which was strictly for the web.", "date": "2019-05-02"},
{"website": "Here", "title": "HERE Technologies Joins The Urban Computing Foundation", "author": ["Oliver Fink"], "link": "https://developer.here.com/blog/why-we-joined-the-urban-computing-foundation", "abstract": "The Linux Foundation, the nonprofit organization enabling mass innovation through open source, announced last week the formation of the Urban Computing Foundation to accelerate open source software that improves mobility, safety, road infrastructure, traffic congestion and energy consumption in connected cities. I am excited to share that HERE Technologies is part of that foundation and will focus on finding and collaborating on open solutions that make it easier for all to unlock the potential of urban data. Initial contributors include developers from Uber, Facebook, Google, HERE Technologies, IBM, Interline Technologies, Senseable City Labs, StreetCred Labs and University of California San Diego (UCSD). The Urban Computing Foundation aims to provide open access to tools and platforms for developers in both public and private organizations who are building connected solutions for mobility, reducing congestion and pollution and increasing access; safety, new technologies to create a world where it’s safe and easy for everyone to get around; and insights, anonymized data from citizens that can help urban planning around the world. The Linux Foundation, the nonprofit organization enabling mass innovation through open source, today announced the formation of the Urban Computing Foundation to accelerate open source software that improves mobility, safety, road infrastructure, traffic congestion and energy consumption in connected cities. Initial contributors include developers from Uber, Facebook, Google, HERE Technologies, IBM, Interline Technologies, Senseable City Labs, StreetCred Labs and University of California San Diego (UCSD). As cities and transportation networks evolve into ever-more complicated systems, urban computing is emerging as an important field to bridge the divide between engineering, visualization and traditional transportation systems analysis. However, these advancements are dependent on compatibility among many technologies across different public and private organizations. Urban Computing Foundation will provide a neutral forum for this critical work, including adaption of geospatial and temporal machine learning techniques and urban environments and simulation methodologies for modeling and predicting city-wide phenomena. To contribute to this work, please visit the Urban Computing Foundation website. “During moments of both technology disruption and opportunity, open development is critical for enabling interoperability and speeding adoption,” said Jim Zemlin, executive director of the Linux Foundation. “The Urban Computing Foundation is poised to provide the compatibility tools and resources for developers to create software that can map out and operate technology services in any given urban area, ensuring safety and equitable access to transportation.” The first project hosted at the Foundation is https://kepler.gl/ , an open source geospatial analysis tool created by Uber for building large-scale data sets. Kepler was released in 2018 to help make it easier to create meaningful visualizations of location data without the need for coding. Kepler.gl is used by developers, data scientists, visualization specialists and engineers around the world to explore and analyze a variety of scenarios that include transportation patterns and safety trends. Some of the companies using Kepler.gl include Airbnb, Atkins Global, Cityswifter, HERE Technologies, Limebike, Mapbox, Sidewalk Labs, Uber and UBILabs, among others. “As a founding participant with the Urban Computing Foundation, Uber is honored to contribute Kepler.gl as the initiative’s first official project,” said Travis Gorkin, Uber Data Visualization Lead and Urban Computing Foundation TAC contributor. “Technologies like Kepler.gl have the capacity to advance urban planning by helping policymakers and local governments gain critical insights and better understand data about their cities.” The Foundation will use an open governance model being developed by the Technical Advisory Council (TAC), which includes a variety of technical and IP stakeholders in the urban computing space. Project inclusion will be determined by a review and curation process managed by the TAC. I'm personally excited to be working in the TAC together with these peers: Drew Dara-Abrams, principal, Interline Technologies Travis Gorkin, engineering manager of data visualization, Uber Shan He, project leader of Kepler.gl, Uber Randy Meech, CEO, StreetCred Labs Michal Migurski, engineering manager of spatial computing, Facebook Drishtie Patel, product manager of maps, Facebook Paolo Santi, senior researcher, MIT Max Sills, attorney, Google", "date": "2019-05-13"},
{"website": "Here", "title": "Format Data into GeoJSON with JavaScript to be used with HERE XYZ", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/format-data-into-geojson-with-javascript-to-be-used-with-here-xyz", "abstract": "If you’re new to HERE XYZ or to the mapping space in general, you might not be familiar with GeoJSON. While GeoJSON is still JSON, it is formatted as part of a specification for geographic features. We’re going to see how to take ordinary location data and parse it into GeoJSON using JavaScript. To get an idea of what we want to accomplish, take a look at the following image: We’re going to accept input and spit out GeoJSON data. Now, most of what we’re going to do is completely overkill because we don’t need a visual component and pretty much everything can be done in just a few lines of code. We’re just going to make it interesting. Somewhere on your computer, create a new index.html file and include the following boilerplate code: <html>\n    <body style=\"background-color: #DDD\">\n        <table style=\"width: 800px\">\n            <tr>\n                <td>Input</td>\n                <td>Output</td>\n            </tr>\n            <tr>\n                <td valign=\"top\" style=\"width: 50%; height: 400px\">\n                    <p>\n                        <label>Latitude:</label>\n                        <input type=\"text\" id=\"latitude\" value=\"37.7397\" />\n                    </p>\n                    <p>\n                        <label>Longitude:</label>\n                        <input type=\"text\" id=\"longitude\" value=\"-121.4252\" />\n                    </p>\n                    <p>\n                        <input type=\"text\" id=\"propertyname1\" value=\"date\" />\n                        <input type=\"text\" id=\"propertyvalue1\" value=\"20190509\" />\n                    </p>\n                    <p>\n                        <input type=\"text\" id=\"propertyname2\" value=\"foo\" />\n                        <input type=\"text\" id=\"propertyvalue2\" value=\"bar\" />\n                    </p>\n                    <p>\n                        <button type=\"button\" onclick=\"createGeoJSON()\">Create GeoJSON</button>\n                    </p>\n                </td>\n                <td valign=\"top\" style=\"width: 50%; height: 400px\">\n                    <textarea id=\"output\" style=\"width: 100%; height: 400px\"></textarea>\n                </td>\n            </tr>\n        </table>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/geojson/0.5.0/geojson.min.js\"></script>\n        <script>\n            // Logic here...\n        </script>\n    </body>\n</html> In the above code we are adding some very basic form elements and importing GeoJSON.js . You don’t need to be using browser-based HTML to make use of GeoJSON.js. In the HTML form, we have two rows of input fields which we’re going to use to represent dynamic user input for both the name and the value. We’re doing this so we can add custom data to the GeoJSON. Now let’s start working with the data. In the index.html file, add the following to the <script> tags: <script>\n    const createGeoJSON = () => {\n        const data = [\n            {\n                lat: document.getElementById(\"latitude\").value,\n                lng: document.getElementById(\"longitude\").value\n            }\n        ];\n        data[0][document.getElementById(\"propertyname1\").value] = document.getElementById(\"propertyvalue1\").value;\n        data[0][document.getElementById(\"propertyname2\").value] = document.getElementById(\"propertyvalue2\").value;\n        const dataGeoJSON = GeoJSON.parse(data, { Point: [\"lat\", \"lng\"] });\n        document.getElementById(\"output\").value = JSON.stringify(dataGeoJSON, null, 4);\n    }\n    createGeoJSON();\n</script> The createGeoJSON method will create an array of objects to be parsed. At a minimum, each object should contain a latitude and longitude. Next, we are taking our dynamic fields and adding them as properties to sit next to the latitude and longitude values. In theory, our data array would look like the following: [\n    {\n        lat: 37,\n        lng: -121,\n        foo: \"bar\",\n        date: \"20190509\"\n    }\n] After we parse the data, we are choosing to update the <textarea> with the final result, which would look something like the following: {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -121.4252,\n                    37.7397\n                ]\n            },\n            \"properties\": {\n                \"date\": \"20190509\",\n                \"foo\": \"bar\"\n            }\n        }\n    ]\n} When it comes to HERE XYZ, the above GeoJSON data would work. However, there are other features that we can take advantage of that are specific to XYZ. For example, we can introduce tagging of our data. Tags are searchable components within our data, so if I created a tag based on a date, then I could search for all data that has that particular tag. To do this, we can make our code look like the following: const data = [\n    {\n        lat: document.getElementById(\"latitude\").value,\n        lng: document.getElementById(\"longitude\").value,\n        \"@ns:com:here:xyz\": {\n            tags: [document.getElementById(\"propertyvalue1\").value, document.getElementById(\"propertyvalue2\").value]\n        }\n    }\n]; Notice that we’ve introduced an @ns:com:here:xyz property which is an object with various tags. It is up to you what you want to add here, or anything at all. Conclusion You just saw how to work with GeoJSON data in JavaScript which can later be used with HERE XYZ . Like I mentioned at the beginning, pretty much everything in this tutorial was overkill, but it does paint an easy picture on how to get your data ready.", "date": "2019-05-21"},
{"website": "Here", "title": "How to Render a Map of San Diego's Smart City Streetlights with HERE XYZ, Python and Tangram", "author": ["Jayson DeLancey"], "link": "https://developer.here.com/blog/how-to-render-a-map-of-san-diegos-smart-city-initiative-with-here-xyz-and-tangram", "abstract": "It can be hard to get your head around how immense an IoT network deployment is without a map, especially for Smart Cities.  Using HERE XYZ to visualize infrastructure at a city level makes a world of difference.  Let's look at how to do that, first fetching and scrubbing data with Python and then using HERE XYZ with Tangram and a bit of JavaScript to render a web map like the one shown. This sample project and others like it can be completed entirely using the freemium account if you sign-up and start experimenting for yourself. CityIQ IoT Platform The City of San Diego deployed the world’s largest smart city platform where thousands of streetlights around the city have been equipped with IoT sensors. These sensors collect metadata that can be fetched from a set of public access web services providing traffic, pedestrian flow, parking, and environmental data. An asset is a physical thing and in the context of CityIQ refers to street lights. Each asset has sensor nodes including a camera to capture video and audio along with environmental sensors to capture things like temperature, humidity, and pressure. To maintain privacy, the assets also include an edge device with compute capabilities to process these node feeds with computer vision and upload metadata about what was captured to the cloud. It is this metadata that the city provides free public access. You can learn more from the San Diego Sustainability website. There are two initial steps to accessing the valuable asset data like this: Get an OAuth token Get the Asset metadata This is a good lesson in that some data sources are not ready for geospatial analysis so using tools like Python are helpful to clean the data. Get an OAuth token Here’s an example method in Python for authenticating and retrieving the token. import json\nimport base64\nimport requests\n\ndef get_client_token(client, secret):\n    uri = 'https://auth.aa.cityiq.io/oauth/token'\n    credentials = base64.b64encode(client + ':' + secret)\n    headers = {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache',\n        'Authorization': 'Basic ' + credentials\n    }\n    params = {\n        'grant_type': 'client_credentials'\n    }\n\n    response = requests.post(uri, headers=headers, params=params)\n    return json.loads(response.text)['access_token']\n\ndef main():\n    token = get_client_token('PublicAccess', 'uVeeMuiue4k=')\n    print(token)\n\nmain() Get the Asset metadata So what do you do with the token? You use it in subsequent requests such as fetching the locations of assets. Here’s a bit more Python to demonstrate the second step. def get_assets(token):\n    uri = 'https://sandiego.cityiq.io/api/v2/metadata/assets/search'\n    headers = {\n       'Content-Type': 'application/x-www-form-urlencoded',\n       'Predix-Zone-Id': 'SD-IE-TRAFFIC',\n       'Authorization': 'Bearer ' + token\n       }\n\n    # Bounding Box for San Diego Camera locations because these are the\n    # nodes that have traffic, parking and pedestrian data\n    params = {\n            'bbox': '33.077762:-117.663817,32.559574:-116.584410',\n            'page': 0,\n            'size': 200,\n            'q': 'assetType:CAMERA'\n            }\n    response = requests.get(uri, headers=headers, params=params)\n\n\ndef main():\n  token = get_client_token('PublicAccess', 'uVeeMuiue4k=')\n  assets = get_assets(token)\n  print(json.dumps(assets))\n\nmain() The first thing to note is that the response only includes 200 assets out of more than 11 thousand. You’ll need to make multiple calls to fetch the entire list of assets or reduce the bounding box of the search area. The second thing is the content itself which is an array of dictionaries that look like this: {\n            \"assetType\": \"CAMERA\",\n            \"mediaType\": \"IMAGE\",\n            \"coordinates\": \"32.71573892:-117.133679\",\n            \"parentAssetUid\": \"0b0e643f-473d-482b-927e-b1e7e7a6ec2c\",\n            \"eventTypes\": [\n                \"PKOUT\",\n                \"PKIN\"\n            ],\n            \"assetUid\": \"049e6af3-6865-4c80-a0a3-46218c859fde\"\n        }, The event types indicate the types of data available from this particular node which includes PKOUT and PKIN for parking out and in respectively for a particular location. There are also traffic (TFEVT) and pedestrian (PEDEVT) events that can be interesting. Now that we have access to the assets we can do a bit more cleanup. GeoJSON and Reverse Geocoding One of the reasons for choosing Python in this exercise so far is the ease of editing and transforming data. To display this data on a map, it’s easier to transform it into something like GeoJSON which is a standardized specification for representing geospatial objects in JSON. It would look something like this: {\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n            -117.2642206,\n            32.81047216,\n            0\n        ]\n    },\n    \"type\": \"Feature\",\n    \"properties\": {\n        \"assetType\": \"CityIQ Camera Node\",\n        \"street\": \"La Jolla Hermosa Ave\",\n        \"coords\": \"32.81047216:-117.2642206\",\n        \"assetUid\": \"000b2365-5309-422a-9be6-1b7127ca18db\",\n    }\n}, As you can see from this example an object in GeoJSON has geometry associated with it, in this case a point (longitude comes first). It also has a set of properties which is just a dictionary of key-value pairs. This was a small exercise to take the JSON response from the CityIQ services above, split the location into its corresponding latitude and longitude parts.  I also did one additional bit of data enrichment with an operation called reverse geocoding. Taking the latitude and longitude, I used the HERE Reverse Geocoder to identify the name of the street. The intention is to be able to create a tag in HERE XYZ so that streetlights can be filtered by the street name when queried with the XYZ Hub API (ie. show only streetlights on La Jolla Hermosa Ave). Here’s an example: import geojson\n\ndef reverse_geocode(lat, lon, app_id_here, app_code_here):\n    uri = 'https://reverse.geocoder.api.here.com/6.2/reversegeocode.json'\n    headers = {}\n    params = {\n            'app_id': app_id_here,\n            'app_code': app_code_here,\n            'prox': str.join(',', [lat,lon]),\n            'mode': 'retrieveAddresses',\n            'maxresults': 10,\n    }\n\n    response = requests.get(uri, headers=headers, params=params)\n    return json.loads(response.text)\n\ndef get_street_name(lat, lon):\n    results = reverse_geocode(lat, lon)\n    street = None\n    for a in results['Response']['View'][0]['Result']:\n        if 'Street' in a['Location']['Address']:\n            street = a['Location']['Address']['Street']\n            return street\n\n    print(\"No address found for %s,%s\" % (lat,lon))\n    return street\n\ndef enrich_feature(lat, lon):\n    point = geojson.Point(coordinates=(lon, lat))\n\n    props = {}\n    props['coords'] = lat + ':' + lon\n    props['street'] = get_street_name(lat,lon)\n    props['assetUid'] = feature['properties']['description']\n    props['assetType'] = 'CityIQ Camera Node'\n\n    return geojson.Feature(geometry=point, properties=props)\n\n# exercise left for the reader # loop over data to make a list of enriched features\n# for each asset then write it to disk\n\nwith open('assets.geojson', 'w') as output:\n  geojson.dump(features, output) An additional step of aggregating all those features and geojson.dump() to a file gives me my data set as a geojson file. HERE XYZ As datasets get large enough it can be challenging to find a way to render it with client-side JavaScript. There are two tools I used for this project, Tangram and HERE XYZ . CLI The HERE CLI is easy to install and get started.  There’s a tutorial on Using the HERE XYZ CLI which explains how that works so I won’t go into more detail here. The summary for this project is to create a space for the streetlight data and then upload it while tagging the name of the street. That looks something like this: here xyz create -t 'san-diego-streetlights'\nhere xyz upload xyz-space-id -f assets.geojson -t street That's it, the geospatial data is now safely stored in the cloud and accessible in Studio, from the CLI, or using the underlying APIs which we'll do in the next section. Tangram Tangram is a Real-Time WebGL Map tool for Vector Data. Instead of splitting geospatial data up into raster images (like PNGs) for each region, a vector tile gives far more flexibility to customize the style and presentation. In combination with Leaflet you can create an interactive experience many expect from web maps today. How do you get vector tile data? That’s where HERE XYZ is valuable. With the free tier you can upload GeoJSON data and fetch vector tile data with the API from what is called a space. To get started quickly with Tangram, our friend Dylan Babbs wrote a helpful node.js package runner.  Try running: npx tangram-make mymap xyz-space-id xyz-token This bootstraps you with a skeleton tangram web map.  You should see the following files in a project directory. mymap\n├── index.css\n├── index.html\n├── index.js\n└── scene.yaml If you used a valid space id and token simply firing up a web server should let you view a web map.  A simple way to do this is with python -m SimpleHTTPServer if you have Python installed or use the node.js http-server .  This initial map is centered on Seattle but you can customize that in the index.js . const map = L.map('map', {\n   center: [32.714, -117.170],   // Try San Diego\n   zoom: 7.5,\n   layers: [tangram],\n   zoomControl: false\n}); What's next? If you open in a browser a tool called Tangram Play you can read the scene.yaml from this folder.  This is a useful resource because you can get some immediate feedback as you learn how to customize the Tangram rendering by making changes to the scene.yaml and view the resulting map. With some color changes and editing you can end up with a map that looks like this: Take some time playing with this project and if you want to recreate the source code is available on github in the HERE XYZ Showcase .", "date": "2019-05-14"},
{"website": "Here", "title": "Show the Weather Forecast in a NativeScript with Vue.js iOS and Android Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/show-the-weather-forecast-in-a-nativescript-with-vue.js-ios-and-android-application", "abstract": "About a week ago I had written a tutorial around using the HERE Weather API in a NativeScript with Angular application . This was an extension to my popular tutorial which focused on strictly Angular with the HERE Weather API . However, if you’re a NativeScript developer, you probably know that Angular isn’t the only way to do business. In this tutorial we’re going to explore using the HERE Weather API in NativeScript, but this time using Vue.js and simple JavaScript. To get an idea of what we want to accomplish, take a look at the following image: In the above image you’ll notice a nicely formatted list view with the 7 day local forecast. This is an application that works on both Android and iOS because of NativeScript , however it was made possible with Vue.js and the HERE Weather API. Create a New NativeScript with Vue.js Project The first step towards being successful with this project is to create the project and install any of the dependencies. Assuming that you’ve got the Vue CLI installed as well as the NativeScript CLI, execute the following: vue init nativescript-vue/vue-cli-template ns-vue-project The above command will create a new project. When asked, go ahead and choose the defaults. After creating the project, we technically don’t need anything else. However, in an effort to make our application as slick as possible, we’re going to download a dependency to format our date and time information. Navigate into your project directory and execute the following command: npm install moment --save The above Moment.js library is pretty much the standard when it comes to working with dates and times in JavaScript. Again, it isn’t absolutely necessary, but it will help us in the future. Now we can start adding our code to interact with the HERE Weather API. Communicate with the HERE Weather API using HTTP Because of how Vue.js works, we’re able to have all of our component code in the same file. Rather than introducing new complexity, we’re going to leverage a component that already exists rather than create a new one. Open the project’s app/components/App.vue file and add the following boilerplate code: <template>\n    <Page>\n        <ActionBar title=\"TRACY, CA\"/>\n        <GridLayout columns=\"*\" rows=\"*\">\n        </GridLayout>\n    </Page>\n</template>\n\n<script >\n    import * as http from \"http\";\n    import * as moment from \"moment\";\n    export default {\n        data() {\n            return {\n                weather: []\n            }\n        },\n        mounted() { },\n        methods: { },\n        filters: { }\n    }\n</script>\n\n<style scoped>\n    ActionBar {\n        background-color: #53ba82;\n        color: #ffffff;\n    }\n\n    .message {\n        vertical-align: center;\n        text-align: center;\n        font-size: 20;\n        color: #333333;\n    }\n</style> In the above code you can see that we’ve imported the NativeScript HTTP module which we’ll be using for consuming data from the REST API. We’re also importing Moment.js which we’ll use later. The goal here is to get weather information and store it in a weather array to be used in the <template> area. To do this, let’s focus on creating some methods with Vue.js. Since the HERE Weather API requires quite a few query parameters, instead of just concatenating them directly, we’re going to create a helper function for the job: encodeQueryParameters(params) {\n    const encodedParameters = [];\n    for(const key in params) {\n        if(params.hasOwnProperty(key)) {\n            encodedParameters.push(key + \"=\" + encodeURIComponent(params[key]));\n        }\n    }\n    return \"?\" + encodedParameters.join(\"&\");\n} If you’ve used JavaScript for a while, you’ve probably seen some variation of the above function a thousand times. We’re just accepting an object and encoding it to be compatible query parameters. We can create a getWeather method that makes use of it: getWeather(appId, appCode, position) {\n    const params = {\n        product: \"forecast_7days_simple\",\n        latitude: position.latitude,\n        longitude: position.longitude,\n        app_id: appId,\n        app_code: appCode\n    }\n    http.getJSON(\"https://weather.api.here.com/weather/1.0/report.json\" + this.encodeQueryParameters(params)).then(result => {\n        this.weather = result.dailyForecasts.forecastLocation.forecast;\n    }, error => {\n        console.error(error);\n    });\n}, We’re constructing our parameters object based on the HERE Weather API documentation. When we have our object, we are encoding it to query parameters and using it in a getJSON request. A lot of information comes back, but we’re only storing the forecast information. To get an idea of what our methods look like completed, they might look like this: methods: {\n    getWeather(appId, appCode, position) {\n        const params = {\n            product: \"forecast_7days_simple\",\n            latitude: position.latitude,\n            longitude: position.longitude,\n            app_id: appId,\n            app_code: appCode\n        }\n        http.getJSON(\"https://weather.api.here.com/weather/1.0/report.json\" + this.encodeQueryParameters(params)).then(result => {\n            this.weather = result.dailyForecasts.forecastLocation.forecast;\n        }, error => {\n            console.error(error);\n        });\n    },\n    encodeQueryParameters(params) {\n        const encodedParameters = [];\n        for(const key in params) {\n            if(params.hasOwnProperty(key)) {\n                encodedParameters.push(key + \"=\" + encodeURIComponent(params[key]));\n            }\n        }\n        return \"?\" + encodedParameters.join(\"&\");\n    }\n}, We probably want to load the weather information when our application loads. To do this, we can make use of the mounted lifecycle event in Vue.js. To make use of this event, include the following: mounted() {\n    this.getWeather(\"APP-ID-HERE\", \"APP-CODE-HERE\", { latitude: 37.7397, longitude: -121.4252 });\n}, Notice in the mounted event we are only calling the getWeather function that we had previously created. Make sure to swap the app id and app code values with those found in your HERE Developer Portal . In theory, we now have weather information to work with. It is time we actually render it on the screen. We’ll want to create a ListView in our <template> block like this: <template>\n    <Page>\n        <ActionBar title=\"TRACY, CA\"/>\n        <GridLayout columns=\"*\" rows=\"*\">\n            <ListView for=\"item in weather\" class=\"list-group\">\n                <v-template>\n                    <GridLayout class=\"list-group-item\" rows=\"auto, auto\" columns=\"50, *\">\n                        <Image :src=\"item.iconLink\" rowSpan=\"2\" row=\"0\" col=\"0\" />\n                        <Label row=\"0\" col=\"1\">{{ item.highTemperature }}C</Label>\n                        <Label :text=\"item.utcTime\" row=\"1\" col=\"1\" />\n                    </GridLayout>\n                </v-template>\n            </ListView>\n        </GridLayout>\n    </Page>\n</template> There are a few things to notice in the above XML. First you’ll notice that we are only including three pieces of data from our response. We’re displaying the weather icon, the highest temperature of the day and the timestamp. Second you’ll notice that we are adding formatting to our list rows with a GridLayout component. If we were to run the application, it would work, but the timestamp wouldn’t look too attractive. Also, if you’re in the United States like I am, you’re probably more familiar with Fahrenheit as the measurement. We can fix this. Transform API Responses with Vue.js Filters The best way to do transformations in the XML is to make use of Vue.js filters which act as pipes in other technologies. Essentially, we provide a value to the filter and it is transformed into another value. Let’s take a look at the following two filters : filters: {\n    fahrenheit(value) {\n        return ((value * (9 / 5)) + 32).toFixed(2);\n    },\n    pretty(value) {\n        return moment(value).format(\"MMMM DD, YYYY\");\n    }\n} In the above code we have a fahrenheit filter and a pretty filter. The fahrenheit filter will apply a formula to convert the temperature to fahrenheit and the pretty filter will use Moment.js to format our date into something more human readable. To use our filters, we can make some adjustments to the XML: <GridLayout class=\"list-group-item\" rows=\"auto, auto\" columns=\"50, *\">\n    <Image :src=\"item.iconLink\" rowSpan=\"2\" row=\"0\" col=\"0\" />\n    <Label row=\"0\" col=\"1\">{{ item.highTemperature }}C / {{ item.highTemperature | fahrenheit }}F</Label>\n    <Label :text=\"item.utcTime | pretty\" row=\"1\" col=\"1\" />\n</GridLayout> In the above code, notice that we are using a pipe character and the filter name. When we do this, we are taking the original value, piping it into our filter, then displaying the result of the transformation. Conclusion You just saw how to use the HERE Weather API in a NativeScript project that used Vue.js as the core framework. The HERE Weather API does a lot more than just 7 day forecast information, even though it was the focus of this example. As long as your computer is properly configured, you’ll be able to build your project for both Android and iOS with NativeScript. If you’re more familiar with Angular, you can check out my NativeScript with Angular version here .", "date": "2019-05-20"},
{"website": "Here", "title": "April 2019 Release Notes", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/april-2019-release-notes", "abstract": "These are release notes that describe the improvements to the services in the new release. This release includes updates of: Geocoder API, Geocoder Autocomplete API, Routing API, Places API, Places API (China), Fleet Telematics API, Map Data, Mobile SDK User Interface (UI) kit. This release is mainly a maintenance release. You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Routing API Version 7.2.103 Fixed the issue of relaxing truck turn restrictions at junctions where a road divider does not span on the junction. Added response attributes for zone access regulations based on a scheme of vehicle’s license plate number. Places API Version 2.73.0 PDS category 600-6300-0246: Doughnut Shop is mapped to “food-drink” Places category (cs=places) in the Browse endpoint. “Int’l” added as a synonym for “International”. Fleet Telematics API Version 2.5.15 When uploading layers in WKT format, it is now possible to specify numeric columns (like it is possible when uploading Shapefiles). Map Data for Mobile SDK Version 8.30.95.153 (April 2019) New traffic signs layer has been added. This layer will allow our customers to use information about traffic signs all over the world. Based on this information providing a visual and audial warning about incoming obstacle will become possible. The official language for Cambodia and Myanmar has been changed to English to avoid translation gaps in the region. Updated EarthCore Buildings and Landmarks HERE Mobile SDK User Interface (UI) kit Version 2.1.1 Integrated the HERE SDK 3.11 release Update to Xcode 10.2 and Swift 5.0 Update to CocoaPods 1.6.1 Fixed minor issues The open source repositories can be found here: https://github.com/heremaps/msdkui-android https://github.com/heremaps/msdkui-ios The detailed release notes can be found here: https://github.com/heremaps/msdkui-android/releases https://github.com/heremaps/msdkui-ios/releases The following services had new releases with minor changes: Geocoder API (Version 6.2.179) Geocoder Autocomplete API (Version 6.2.179) Places API China (Version 2.69.0)", "date": "2019-05-13"},
{"website": "Here", "title": "Learning from HERE developers", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/video-tutorials-for-here-developers", "abstract": "I am one of those developers who learn better and faster from video tutorials. The voice cue gives me a one-to-one learning experience. If you are like me, you are in for a treat. With the accelerated advances in technology, it is necessary to keep up with different frameworks, environments, libraries preferred by developers. Video tutorials give you just the pace and level of detail required to switch between different technologies. If you fall in that category, check out the HERE Technologies YouTube channel for video tutorials. Watch the Learn from HERE Developer series for tutorials from experienced developers where they navigate between JavaScript, VueJs, Golang, Tangram, Android and iOS integrated with HERE Maps APIs. Also watch the Webinar series Developer Waypoints in the Developer Livestreams playlist . If learning by watching is not enough for you, you should catch our live coding series on Twitch where you can get your questions answered during the coding sessions with my fellow developer evangelist Nic Raboy. If you have questions while following these tutorials, post your comments on the video tutorials or on stack-overflow with the tag here-api . Happy coding!", "date": "2019-05-28"},
{"website": "Here", "title": "Reverse Geocoding NEO 6M GPS Positions with Golang and a Serial UART Connection", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/reverse-geocoding-neo-6m-gps-positions-with-golang-and-a-serial-uart-connection", "abstract": "A while back you might have come across a tutorial I wrote titled, Reverse Geocoding Coordinates to Addresses with the Go Programming Language . This tutorial was useful, but we used static data to represent our latitude and longitude positions. In a realistic scenario we probably want to get coordinate information from a GPS module or similar and then use that real-time data to make reverse geocoding requests. I had a u-blox NEO 6M GPS module laying around that I was using with my Arduino and figured it would make a cool example if I connected it to my computer with a serial to USB cable for gathering position information. In this tutorial we’re going to use the Go programming language to interact with our serial port, decode GPS data, and reverse geocode it for address estimates. The Requirements Because there is a hardware emphasis on this tutorial, there are a few requirements to be successful. You should consider purchasing the following: Serial to USB Debug Cable NEO 6M GPS Module Active GPS Antenna Antenna Adapter I’m not saying other hardware won’t work in this tutorial, but the above is what I used. You don’t absolutely need the antenna, but without it, you could sit around for a day or so waiting for a GPS fix with the satellites. Also, be prepared to solder if your GPS module doesn’t have any pins attached for the debug cable. Beyond the hardware requirements, you will need Golang installed and configured on your computer and you will need a HERE Developer Portal account for using the reverse geocoding service. Interacting with the Serial Port using Golang We’re going to be working with a three step process, the first of which is getting GPS data from the serial port. The data will not be clean, but we’ll fix it up as we progress. To interact with the serial port, there are quite a few packages available. I had the most luck with the go-serial package. It can be installed by executing the following: go get github.com/jacobsa/go-serial/serial Within your $GOPATH create a new project with a main.go file in it. As part of our boilerplate code, add the following: package main\n\nimport (\n    \"bufio\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/jacobsa/go-serial/serial\"\n)\n\nfunc main() {\n    fmt.Println(\"Starting the application...\")\n} To interact with the serial port, it must be opened and then the stream of bytes that come from the open serial port must be processed. Let’s look at how that’d happen with Go. Inside the main function, include the following: func main() {\n    fmt.Println(\"Starting the application...\")\n    options := serial.OpenOptions{\n        PortName:        \"/dev/cu.SLAB_USBtoUART\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n} Notice that I’ve defined my actual serial port in the above code. Make sure you choose the correct port that represents your GPS module. After you open the port, you must read the byte data. This is where it could potentially get complicated. The byte data doesn’t consistently come in, but yet there is a true format that must be followed. This format says that each piece of data is separated by a new line. You could create your own buffers to process the bytes and look out for new line characters or you can use a Scanner where each line in it can be accessed with the Text function. Depending on your GPS module, you’ll get different formatted data. My NEO 6M GPS spits out data that looks like the following: $GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47 The above is a NMEA sentence and it must be parsed to make sense of it. Note that if your GPS hasn’t gotten a satellite fix, your NMEA sentences will be incomplete. Parsing the NMEA GPS Data into Something Useable Parsing the NMEA sentences is not difficult, but some setup must happen first. I recommend creating another file within your project to separate your code. Within your project, create a nmea.go file with the following: package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype NMEA struct {\n    fixTimestamp       string\n    latitude           string\n    latitudeDirection  string\n    longitude          string\n    longitudeDirection string\n    fixQuality         string\n    satellites         string\n    horizontalDilution string\n    antennaAltitude    string\n    antennaHeight      string\n    updateAge          string\n}\n\nfunc ParseNMEALine(line string) (NMEA, error) { }\nfunc ParseDegrees(value string, direction string) (string, error) { }\nfunc (nmea NMEA) GetLatitude() (string, error) { }\nfunc (nmea NMEA) GetLongitude() (string, error) { } The NMEA sentence is essentially a comma delimited list, so we just need to load it into a Go data structure and format the data. To load it, take a look at the ParseNMEALine function: func ParseNMEALine(line string) (NMEA, error) {\n    tokens := strings.Split(line, \",\")\n    if tokens[0] == \"$GPGGA\" {\n        return NMEA{\n            fixTimestamp:       tokens[1],\n            latitude:           tokens[2],\n            latitudeDirection:  tokens[3],\n            longitude:          tokens[4],\n            longitudeDirection: tokens[5],\n            fixQuality:         tokens[6],\n            satellites:         tokens[7],\n        }, nil\n    }\n    return NMEA{}, errors.New(\"unsupported nmea string\")\n} In my example we are only parsing $GPGGA formatted sentences. There are quite a few other options. You’ll know which one you have because the sentence will start with the format. The line that is passed to this function comes from the Scanner from the previous step. After we have our data in a Go data structure we can parse the latitude and longitude. Right now it will be in some kind of degrees, minutes, seconds (DMS) format, but we want a pure decimal version of it. Take a look at the following ParseDegrees function: func ParseDegrees(value string, direction string) (string, error) {\n    if value == \"\" || direction == \"\" {\n        return \"\", errors.New(\"the location and / or direction value does not exist\")\n    }\n    lat, _ := strconv.ParseFloat(value, 64)\n    degrees := math.Floor(lat / 100)\n    minutes := ((lat / 100) - math.Floor(lat/100)) * 100 / 60\n    decimal := degrees + minutes\n    if direction == \"W\" || direction == \"S\" {\n        decimal *= -1\n    }\n    return fmt.Sprintf(\"%.6f\", decimal), nil\n} What we’re doing is separating the degrees from the minutes and applying some math. Let’s say we have 4322.0678 as the value that comes from our GPS. We are trying to do the following: result = 43 + (22.0678 / 60) In the above example, 43 is the degrees and 22.0678 is our minutes. Depending on the direction or quadrant that is returned, North, South, West, East, we can decide whether our number should be negative or positive. To make use of this ParseDegrees function we can do the following: func (nmea NMEA) GetLatitude() (string, error) {\n    return ParseDegrees(nmea.latitude, nmea.latitudeDirection)\n}\n\nfunc (nmea NMEA) GetLongitude() (string, error) {\n    return ParseDegrees(nmea.longitude, nmea.longitudeDirection)\n} So as of right now we are reading data from our serial port and we have some parsing mechanisms in place, but we are not actually parsing our data yet. We need to connect the two steps now. Go back into the main.go file and add the following: func main() {\n    fmt.Println(\"Starting the application...\")\n    options := serial.OpenOptions{\n        PortName:        \"/dev/cu.SLAB_USBtoUART\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    for scanner.Scan() {\n        gps, err := ParseNMEALine(scanner.Text())\n        if err == nil {\n            if gps.fixQuality == \"1\" || gps.fixQuality == \"2\" {\n                latitude, _ := gps.GetLatitude()\n                longitude, _ := gps.GetLongitude()\n                fmt.Println(latitude + \",\" + longitude)\n            } else {\n                fmt.Println(\"no gps fix available\")\n            }\n            time.Sleep(2 * time.Second)\n        }\n    }\n} So instead of just printing out our scanned line, we are now parsing it. If we don’t get any errors, we can check for the fix quality. The fix quality basically tells us whether or not our GPS has gotten a fix with the satellites. No fix will result in no valuable data. If we have a fix, we can get our parsed latitude and longitude and print it out. Since data comes in quite fast, we can add a sleep delay to slow things down. Getting an Address Estimate from the Latitude and Longitude GPS Coordinates So by now we should have our parsed latitude and longitude data. This data, at least when I tried, was down to just a few meters in accuracy which is quite awesome. Since latitude and longitude data isn’t exactly human readable, we should probably reverse geocode it to get an estimated address. Like I previously mentioned, I had written a tutorial strictly on reverse geocoding location data with Golang . We’re pretty much going to copy and paste from it. Within your project, create a heredev.go file with the following code: package main\n\nimport (\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n)\n\ntype GeocoderResponse struct {\n    Response struct {\n        MetaInfo struct {\n            TimeStamp string `json:\"TimeStamp\"`\n        } `json:\"MetaInfo\"`\n        View []struct {\n            Result []struct {\n                MatchLevel string `json:\"MatchLevel\"`\n                Location   struct {\n                    Address struct {\n                        Label       string `json:\"Label\"`\n                        Country     string `json:\"Country\"`\n                        State       string `json:\"State\"`\n                        County      string `json:\"County\"`\n                        City        string `json:\"City\"`\n                        District    string `json:\"District\"`\n                        Street      string `json:\"Street\"`\n                        HouseNumber string `json:\"HouseNumber\"`\n                        PostalCode  string `json:\"PostalCode\"`\n                    } `json:\"Address\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n}\n\ntype Position struct {\n    Latitude  string `json:\"latitude\"`\n    Longitude string `json:\"longitude\"`\n}\n\ntype Geocoder struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\nfunc (geocoder *Geocoder) reverse(position Position) (GeocoderResponse, error) {\n    endpoint, _ := url.Parse(\"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"mode\", \"retrieveAddresses\")\n    queryParams.Set(\"prox\", position.Latitude+\",\"+position.Longitude)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeocoderResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geocoderResponse GeocoderResponse\n        json.Unmarshal(data, &geocoderResponse)\n        return geocoderResponse, nil\n    }\n} Most of the above code is just data structure definitions modeled around the response data that comes back from the API. We also have a reverse function which will make the HTTP request to the API. If you want more information on the little bit that is happening above, I suggest you read the previous tutorial. Now let’s head back into the main.go file and make use of it: geocoder := Geocoder{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\nfor scanner.Scan() {\n    gps, err := ParseNMEALine(scanner.Text())\n    if err == nil {\n        if gps.fixQuality == \"1\" || gps.fixQuality == \"2\" {\n            latitude, _ := gps.GetLatitude()\n            longitude, _ := gps.GetLongitude()\n            fmt.Println(latitude + \",\" + longitude)\n            result, _ := geocoder.reverse(Position{Latitude: latitude, Longitude: longitude})\n            if len(result.Response.View) > 0 && len(result.Response.View[0].Result) > 0 {\n                fmt.Println(result.Response.View[0].Result[0].Location.Address.Label)\n            } else {\n                fmt.Println(\"no address estimates found for the position\")\n            }\n        } else {\n            fmt.Println(\"no gps fix available\")\n        }\n        time.Sleep(2 * time.Second)\n    }\n} In the above code we’ve now added our HERE Developer Portal credentials and made a request using the latitude and longitude data that comes back from the GPS. If results come back from the reverse geocode attempt, we can look at the first result and print out the address. Essentially what’s happening is we get a NMEA sentence from the GPS, we parse it, we print the latitude and longitude, we reverse geocode the latitude and longitude, and we print out the address. We do this for every sentence that comes back in our stream. Conclusion You just saw how to process GPS data with Golang using a serial port connection and the HERE Reverse Geocoding API. Like previously mentioned, while a diverse set of hardware might work with this example, I can only validate the hardware that I listed. I also strongly recommend you have an antenna for your GPS module otherwise you might be left scratching your head as to whether your GPS module is working or your code.", "date": "2019-05-16"},
{"website": "Here", "title": "How to Get the Shape of an Area Using the HERE Geocoder API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/how-to-get-the-shape-of-an-area-using-the-here-geocoder-api", "abstract": "We recently walked you through the HERE Geocoder API and how it can be used to discover interesting details about any given place, for example the local time or which side of the road people drive on. However, there are even more neat features hidden in the API. Today we will be looking at the IncludeShapeLevel feature, which returns the shape of an area such as a district, city or even a whole country! This can be very useful for a variety of use cases, such as visualizing postal codes or generating geofences. First, let’s fire up the Geocoder API! As we learned last time, we can customize the response of the API using special parameters. This allows us to request additional information about a place. Last time we asked for data like the local time and currency, this time are going to ask for the shape of the areas around our location. Once again, we are using the parameter additionaldata to request, well, additional data. https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\n?app_id={{app_id}}\n&app_code={{app_code}}\n&prox=52.52087,13.40891\n&mode=retrieveAddresses\n&additionaldata=IncludeShapeLevel,district\n&maxresults=1 As you can see we are providing a value pair of IncludeShapeLevel,<level> for this parameter. Valid choices for <level> are country, state, county, city, district, postalCode and default. In the example above, we’ve reverse geocoded a latitude and longitude (the location of the TV tower in Berlin) and requested the shape of the city district around it (called “Mitte”). Similarly, we could forward geocode a postal code. https://geocoder.api.here.com/6.2/geocode.json\n?app_id={{app_id}}\n&app_code={{app_code}}\n&searchtext=10115+DE\n&additionaldata=IncludeShapeLevel,postalCode Note that we’ve used default as the shape level. When using default, the returned shape will correspond to the match level of the geocoder response. Since we’ve only provided a postal and country information, the best match the Geocoder will be able to provide is at the postal code level. This means that the returned shape will be that of the postal code area. Note that you can only request one shape per Geocoder request. In both cases, our response will include a Shape element, which contains the requested outline in WKT ( well-known text ) format. Depending on whether the requested area is contiguous or not, this will either be a POLYGON or MULTIPOLYGON geometry. \"Shape\": {\n   \"_type\": \"WKTShapeType\",\n   \"Value\": \"POLYGON ((13.36566 52.53586, 13.36575 52.53579, 13.36582 52.53574, 13.36599 52.53564, ..., 13.36566 52.53586))\"\n} Like last time, let’s use the HERE JavaScript API to visualize this information. We want to build a simple web map which highlights the shape of a country when you click on it. Below we will look at the most relevant elements of the code, but you can always explore the complete project in GitHub . The end result should look something like this. We can grab most of the elements for this app from the examples section of our JavaScript documentation. First, we’ll need to set up a basic interactive map . Next, we need to be able to calculate a geographic location from a mouse click . We also need to display a polygon on the map . The Geocoder call is where it gets interesting. The JavaScript API provides convenient wrappers for the various HERE REST APIs, which means we can simply create a GeocodingService object, pass it the parameters from our REST call above and then initiate a reverse geocode. We also need to provide OnSuccess and OnError callback functions to handle the response. First, let's look at how to initiate the geocoding request. function reverseGeocode(platform) {\n    // set up Geocoder API    \n    var geocoder = platform.getGeocodingService();  \n    var prox = coord.lat + ',' + coord.lng;\n    \n    var reverseGeocodingParameters = {\n        prox: prox,\n        mode: 'retrieveAddresses',\n        maxresults: '1',            \n        additionaldata: 'IncludeShapeLevel,country'      \n    };\n\n    geocoder.reverseGeocode(\n        reverseGeocodingParameters,\n        onSuccess,\n        onError\n    );\n} We can then parse the results in the OnSuccess function. Since the JavaScript API uses its own internal format for Geometries , we need to convert our WKT data in this format. Fortunately, there’s a convenient helper function in H.util.wkt available to do this. As mentioned above, the shape returned might either be a single polygon (in case of a contiguous area) or multiple polygons. While postal codes will usually be contiguous areas, most countries will not. Even a single island or exclave will result in a MULTIPOLYGON response. I mean, just check out Finland. After using H.util.wkt.toGeometry() we can check for the type of Geometry returned and handle it appropriately. In either case we will create at least one H.map.Polygon object, style it, and add it to the map. Voila! function onSuccess(result) {\n    // parse results from Geocoder API and retrieve shape information\n    locations = result.Response.View[0].Result;\n    shape = locations[0].Location.Shape.Value;                 \n    addCountryOutline(map);\n}\n\nfunction onError(error) {\n    alert('Ooops!');\n}\n\nfunction addCountryOutline(map) {\n\n    // clear map\n    markerGroup.removeAll();\n\n    // set up polygon style\n    var customStyle = {\n        strokeColor: 'black', \n        fillColor: 'rgba(0,175,170,0.5)', \n        lineWidth: 2,            \n        lineJoin: 'bevel'\n    };\n    \n    // the shape is returned as WKT and we need to convert it a Geometry\n    var geometry = H.util.wkt.toGeometry(shape); \n\n    // geometry is either a single or multi-polygon     \n    if (geometry instanceof H.geo.MultiGeometry) {\n        var geometryArray = geometry.getGeometries(); \n        for (var i = 0; i < geometryArray.length; i++) {\n            markerGroup.addObject(new H.map.Polygon(geometryArray[i].getExterior(), \n            \t{ style: customStyle }));            \n        }\n    } else { // instanceof H.geo.Polygon            \n        markerGroup.addObject(new H.map.Polygon(geometry.getExterior(), \n        \t{ style: customStyle }));            \n    }        \n} Stay tuned for more Geocoder secrets in the near future!", "date": "2019-05-17"},
{"website": "Here", "title": "Interacting with a NEO 6M GPS Module using Golang and a Raspberry Pi Zero W", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/interacting-with-a-neo-6m-gps-module-using-golang-and-a-raspberry-pi-zero-w", "abstract": "About a week ago I had written a tutorial around my NEO 6M GPS module and the Go programming language . In this tutorial I demonstrated how to use Golang to interact with the serial port on my computer, consume the GPS stream, parse the NMEA formatted sentences, and then exchange the latitude and longitude positions for actual addresses with the HERE Reverse Geocoding service. I originally got the GPS module for my Arduino and figured, why couldn’t I do something similar with my Raspberry Pi Zero W? A while back I had done an experiment with a Raspberry Pi and WLAN AP positioning , where I could calculate an estimate of my position from nothing more than WiFi SSID and BSSID information. That experiment worked, but only gave me estimates. Now that I have a GPS module, I can get my location down to just a few meters of accuracy. In this tutorial we’re going to take what we learned in the previous tutorial and apply it to our trusted Internet of Things (IoT) device, the Raspberry Pi Zero W. The Hardware and Software Requirements Because we’re working with IoT and GPS modules, there are a few hardware requirements on top of our software development requirements. In terms of hardware, I’m using the following: Raspberry Pi Zero W NEO 6M GPS Module Active Antenna Active Antenna Adapter Female GPIO Header Male to Female Jumper Wires If you’re using other hardware or similar hardware, this tutorial may still work. Just note that I was using the material above. I also had to solder my GPIO header. There are snap on headers, but it is up to you and your skill level. A picture of my setup can be seen below: In terms of software, my Raspberry Pi Zero W is running Raspbian Lite which is a flavor of Debian. There aren’t any further dependencies for the Raspberry Pi in terms of software. On my host computer I have Golang installed. Since Go is a compiled language, it doesn’t need to be installed on the Raspberry Pi. Configuring the Raspberry Pi Zero W for Serial Interaction The assumption is that you’ve already installed Raspbian on your Raspberry Pi Zero W and have been able to connect to it with SSH. If you aren’t sure how to do this, I recommend you check out a previous tutorial I wrote titled, Use Your Raspberry Pi as a Headless System without a Monitor . However, once your Raspberry Pi is ready, you’ll need to configure it to use a serial connection. After establishing an SSH connection, execute the following: sudo raspi-config The above command will start the configuration manager where you can change various settings. To get an idea of the things you can accomplish, take a look at the following image: We’re going to be interested in the Interfacing Options . Select it and proceed to choosing P6 Serial from the list. When choosing P6 Serial you’ll be presented with two new prompts. The first prompt will ask if you want to enable logins over the serial connection: Make sure you choose No when prompted. We’re going to continue to allow logins over SSH only. The next screen will ask you if you want the serial port hardware to be enabled: At this step it is important that you choose the Yes option. This will allow us to access the GPS module via the Raspberry Pi’s serial port. This does not reference a serial port connection between the host computer and the Raspberry Pi. At this point we can connect our GPS module. Connecting the GPS Module to the Raspberry Pi GPIO Header Before you attempt to connect the GPS module, it is important that your Raspberry Pi is disconnected from power. You’ll also want to make sure you actually have a GPIO header on your Raspberry Pi and your NEO 6M has the appropriate pins attached as well. Rather than rigging up something fancy, we’re going to connect the two devices with a cheap set of jumper wires. Here is a picture of my hardware configuration: I have a nice Adafruit pin template which I cannot recommend enough since the pins are not labeled on the Raspberry Pi. My wire configuration is as follows: GPS VCC to Raspberry Pi 5V (Red) GPS GND to Raspberry Pi GND (Black) GPS RXD to Raspberry Pi TXD (White) GPS TXD to Raspberry Pi RXD (Green) I am not using the PPS pin on my GPS module for this setup. You can power on your Raspberry Pi and even read the stream that your serial port is receiving. In my case, the serial port I’m using on the Raspberry Pi Zero W is at /dev/ttyS0 , but yours might differ. You might not notice any useful data coming in. If this is the case, your GPS might not have gotten a satellite fix yet. When I tried without an active antenna it took about 23 hours to get a fix, but when I hooked up an antenna it took just a few minutes. Collecting GPS Data, Parsing the Data, and Reverse Geocoding it with HERE With the Raspberry Pi ready to go, pretty much all of what we need to do involves copy and paste from my previous tutorial . We won’t go too deep into the code for this tutorial, but I’m going to include it to save you some time. Within your $GOPATH create a new project with the following files: main.go\nnmea.go\nheredev.go Most of our driving logic will go in the main.go file while all of our HERE related logic will go in the heredev.go file and all of our GPS parsing will go in the nmea.go file. Open the project’s heredev.go file and include the following: package main\n\nimport (\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n)\n\ntype GeocoderResponse struct {\n    Response struct {\n        MetaInfo struct {\n            TimeStamp string `json:\"TimeStamp\"`\n        } `json:\"MetaInfo\"`\n        View []struct {\n            Result []struct {\n                MatchLevel string `json:\"MatchLevel\"`\n                Location   struct {\n                    Address struct {\n                        Label       string `json:\"Label\"`\n                        Country     string `json:\"Country\"`\n                        State       string `json:\"State\"`\n                        County      string `json:\"County\"`\n                        City        string `json:\"City\"`\n                        District    string `json:\"District\"`\n                        Street      string `json:\"Street\"`\n                        HouseNumber string `json:\"HouseNumber\"`\n                        PostalCode  string `json:\"PostalCode\"`\n                    } `json:\"Address\"`\n                } `json:\"Location\"`\n            } `json:\"Result\"`\n        } `json:\"View\"`\n    } `json:\"Response\"`\n}\n\ntype Position struct {\n    Latitude  string `json:\"latitude\"`\n    Longitude string `json:\"longitude\"`\n}\n\ntype Geocoder struct {\n    AppId   string `json:\"app_id\"`\n    AppCode string `json:\"app_code\"`\n}\n\nfunc (geocoder *Geocoder) reverse(position Position) (GeocoderResponse, error) {\n    endpoint, _ := url.Parse(\"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\")\n    queryParams := endpoint.Query()\n    queryParams.Set(\"app_id\", geocoder.AppId)\n    queryParams.Set(\"app_code\", geocoder.AppCode)\n    queryParams.Set(\"mode\", \"retrieveAddresses\")\n    queryParams.Set(\"prox\", position.Latitude+\",\"+position.Longitude)\n    endpoint.RawQuery = queryParams.Encode()\n    response, err := http.Get(endpoint.String())\n    if err != nil {\n        return GeocoderResponse{}, err\n    } else {\n        data, _ := ioutil.ReadAll(response.Body)\n        var geocoderResponse GeocoderResponse\n        json.Unmarshal(data, &geocoderResponse)\n        return geocoderResponse, nil\n    }\n} Rather than going in-depth like I did in the previous tutorial, the above code will model our API responses and make an HTTP request to the HERE Reverse Geocoding API. We’re using HERE because we’re going to take the latitude and longitude positions retrieved from the GPS and get address estimates from them. Now open the project’s nmea.go file and include the following: package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"math\"\n    \"strconv\"\n    \"strings\"\n)\n\ntype NMEA struct {\n    fixTimestamp       string\n    latitude           string\n    latitudeDirection  string\n    longitude          string\n    longitudeDirection string\n    fixQuality         string\n    satellites         string\n    horizontalDilution string\n    antennaAltitude    string\n    antennaHeight      string\n    updateAge          string\n}\n\nfunc ParseNMEALine(line string) (NMEA, error) {\n    tokens := strings.Split(line, \",\")\n    if tokens[0] == \"$GPGGA\" {\n        return NMEA{\n            fixTimestamp:       tokens[1],\n            latitude:           tokens[2],\n            latitudeDirection:  tokens[3],\n            longitude:          tokens[4],\n            longitudeDirection: tokens[5],\n            fixQuality:         tokens[6],\n            satellites:         tokens[7],\n        }, nil\n    }\n    return NMEA{}, errors.New(\"unsupported nmea string\")\n}\n\nfunc ParseDegrees(value string, direction string) (string, error) {\n    if value == \"\" || direction == \"\" {\n        return \"\", errors.New(\"the location and / or direction value does not exist\")\n    }\n    lat, _ := strconv.ParseFloat(value, 64)\n    degrees := math.Floor(lat / 100)\n    minutes := ((lat / 100) - math.Floor(lat/100)) * 100 / 60\n    decimal := degrees + minutes\n    if direction == \"W\" || direction == \"S\" {\n        decimal *= -1\n    }\n    return fmt.Sprintf(\"%.6f\", decimal), nil\n}\n\nfunc (nmea NMEA) GetLatitude() (string, error) {\n    return ParseDegrees(nmea.latitude, nmea.latitudeDirection)\n}\n\nfunc (nmea NMEA) GetLongitude() (string, error) {\n    return ParseDegrees(nmea.longitude, nmea.longitudeDirection)\n} The NEO 6M, like most GPS units, return data in a specific format. My unit for example returns $GPGGA lines which are a form of NMEA sentence. There are a variety of line types, so your final code may differ from mine. Essentially we have a CSV line that we need to load and parse. The point of the nmea.go file is to load the CSV data into a data structure and then parse the latitude and longitude into a format that is more human readable. The final step is to read our serial data and make use of our nmea.go and heredev.go files. To read from our serial port we need to install a package. There are quite a few available, but I had the most success with the go-serial package. It can be installed by executing the following from the command line: go get github.com/jacobsa/go-serial/serial With our package installed, open the main.go file and include the following to finish off our project: package main\n\nimport (\n    \"bufio\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/jacobsa/go-serial/serial\"\n)\n\nfunc main() {\n    options := serial.OpenOptions{\n        PortName:        \"/dev/ttyS0\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    geocoder := Geocoder{AppId: \"APP-ID-HERE\", AppCode: \"APP-CODE-HERE\"}\n    for scanner.Scan() {\n        gps, err := ParseNMEALine(scanner.Text())\n        if err == nil {\n            if gps.fixQuality == \"1\" || gps.fixQuality == \"2\" {\n                latitude, _ := gps.GetLatitude()\n                longitude, _ := gps.GetLongitude()\n                fmt.Println(latitude + \",\" + longitude)\n                result, _ := geocoder.reverse(Position{Latitude: latitude, Longitude: longitude})\n                if len(result.Response.View) > 0 && len(result.Response.View[0].Result) > 0 {\n                    fmt.Println(result.Response.View[0].Result[0].Location.Address.Label)\n                } else {\n                    fmt.Println(\"no address estimates found for the position\")\n                }\n            } else {\n                fmt.Println(\"no gps fix available\")\n            }\n            time.Sleep(2 * time.Second)\n        }\n    }\n} To access the GPS data we need to specify the serial port. If yours is different than mine, make sure you update it in the configuration. You’ll also need to add your app id and app code for reverse geocoding. The serial port will provide a stream of bytes. Each NMEA compliant sentence is separated by a new line, but our stream doesn’t come in a line at a time. Rather than trying to do our own line parsing, we can use a Scanner in Go to process it for us. When we get a line, we are going to load it with the ParseNMEALine function. Then if no errors happened we are going to check to see if we have a GPS fix. If we have a fix, we can get the latitude and longitude, print it out, then use it as part of the reverse geocoding HTTP request. Again, I’ve just kind of glossed over the Go content in this tutorial. If you want more information on what’s actually happening, check out my previous tutorial . So we’ve got our code, now we need to get it on the Raspberry Pi Zero W. Rather than trying to compile on the device, which could take a long time, we can cross compile. Execute the following from the command line: GOOS=linux GOARCH=arm GOARM=5 go build The above command will create a binary for Linux and the appropriate Raspberry Pi architecture. For more information on cross-compiling, please check out a tutorial I wrote titled, Cross Compiling Golang Applications for Use on a Raspberry Pi . Send the binary file to your Raspberry Pi Zero W and try to run it. If everything went smooth, you should be getting position information as well as address information. Conclusion You just saw how to build a Golang application that interacts with a GPS module on a Raspberry Pi Zero W and reverse geocodes the received positions into address estimates. While this isn’t a fancy example, the concepts used can be applied to much more complicated projects. If you’re looking for more Golang with GPS or Raspberry Pi content, check out my tutorial titled, Tracking a Raspberry Pi with WLAN and Golang, then Displaying the Results with HERE XYZ or Reverse Geocoding NEO 6M GPS Positions with Golang and a Serial UART Connection .", "date": "2019-05-22"},
{"website": "Here", "title": "Developing Location-Aware Alexa Skills", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/developing-location-aware-alexa-skills", "abstract": "Every developer understands there are multiple interfaces for end-users to interact with technology – keyboard, mouse, touch-pad, touch-screen, pointing device, VR, AR, mixed reality, and voice. With the popularity of devices like Amazon Echo, voice-interactive experiences have enhanced how many engage technology within the home or office. In recent months, the Amazon Alexa team announced a new feature that provides access to the geolocation of participating Alexa-enabled devices . What does this mean? It provides an opportunity for end-users to interact with Alexa when away from home and allow custom experiences based on location. From a developer's perspective, this could raise multiple questions: What must be done to create a location-aware Alexa skill? Which Alexa devices are supported, and can that be determined in code? What about consumer privacy? What location services are provided? This post aims to answer all these questions. How to Create a Location-Aware Skill To enable location services, the developer needs to modify the permissions of the skill. On the skill page in the developer console,  select Build > Permissions and enable the Location Services button. In the screen capture above, the highlighted area needs toggled on. Also note near the top of the options that it is possible to request the address or general area of the device. This option is used for devices that are typically stationary, such as the Echo, Echo Dot, and Echo Show. Device Support The current supported Amazon devices for location services include the Echo Auto and devices running the Alexa App. There is a way to determine in code if the device is even capable of supporting location services. When an end-user makes a request to an Alexa skill, the developer can check the context of the incoming request as follows: var isGeolocationSupported = \n  context.System.device.supportedInterfaces.Geolocation; If the code returns true, the device is capable of providing it's own geolocation. Managing Permissions If the device is capable, but the end=user has not granted permission, this should be handled in code. var geo = context.Geolocation;\nif (!geo || !geo.coordinate) {\n  var permissions = context.System.user.permissions;\n  var isGeoPermitted = \n    permissions.scopes['alexa::devices:all:geolocation:read']\n    .status === \"GRANTED\";\n    if ( !isGeoPermitted) {\n    return responseBuilder\n      .speak('YOUR SKILL NAME would like to use your location. ' +\n      'To turn on location sharing, please go to your Alexa app, ' + \n      'and follow the instructions.')\n      .withAskForPermissionsConsentCard(\n        ['alexa::devices:all:geolocation:read']\n      ).getResponse();\n} The above code checks first for the presence of the Geolocation object, and then for the sub=object of coordinate . If either are missing, the code prompts the user to grant permission to access location services. Available Location Services Once all checks have been cleared, the developer can access latitude and longitude. var lat = geo.coordinate.latitudeInDegrees;\nvar lng = geo.coordinate.longitudeInDegrees; With this geolocation data available, what now? What if the developer needs access to nearby places, weather, or a route to another location? This is possible by accessing our HERE APIs. Please explore the possibilities by viewing our available REST APIs ! If you'd like to learn more, watch the following webinar hosted by the Alexa team featuring yours truly.", "date": "2019-05-31"},
{"website": "Here", "title": "Providing The Platform For Road Safety", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/providing-the-platform-for-road-safety", "abstract": "Safety First! That’s the message from a group of carmakers, technology providers and road operators, which today announced they are joining forces in a European data-sharing initiative aimed at reducing road traffic deaths. Modern vehicles scan the physical world, classifying everything they see. Their cameras detect traffic, lane closures and accidents. Radar helps suspension systems pre-empt potholes. And tire traction readings give feedback about the road surface. For a chunk of metal moving at speed these enhanced sensory abilities are a godsend, helping cars adjust their driving strategy on the fly and aiding the driver when needed. The utility of all that data doesn’t end there though: it can also be passed on, via the cloud, to other drivers, alerting them to potentially dangerous situations on the road. Sharing data like this is nothing new. Almost all carmakers have been doing this in some form within their own fleets for years. More recently, the HERE Open Location Platform has begun powering services built with data pooled from different car brands. The safety benefits are obvious – with a greater density of data, drivers benefit from more precise and reliable information. Well, today brings the news of a new European initiative that also embraces this approach. It’s called ‘Data for Road Safety’ and it sees car manufacturers, road operators and technology providers, including HERE, join forces to share safety-related data gathered from vehicles and road infrastructure. Data for Road Safety was outlined on Monday afternoon at a high-level roundtable of the EU Data Task Force in Eindhoven. Coming on the eve of this year’s ITS European Congress, the project launch is designed to send a strong message about the importance of sharing data to improve road safety. HERE is one of the 11 founding partners of the project, working alongside the likes of Ford, Volvo, BMW and Daimler. We’ll begin participating in the initiative in the role of data aggregator, but also explore how we can get involved as a service provider too. Our deep experience building services from vehicle sensor data will come in handy. “We have shown that the technology is both commercially ready and globally available,” said our CFO Peter Meier who represented HERE at today’s Eindhoven roundtable. “Now the focus is on more industry players coming together in the spirit of collaboration to create truly scaled data services where, eventually, drivers of any brand of car can benefit from the experiences of others on the road.” He continued: “We welcome the ‘Data for Road Safety’ initiative as a catalyst for further collaboration and look forward to contributing to its success.” OLP Marketplace: supporting OEMs and transport agencies in new road safety push HERE is well placed to help automakers and transport agencies in a data-driven safety push. The HERE OLP is a collaborative location platform and home to global-scale location data, tools and services. It also integrates the world’s first global location data exchange, HERE OLP Marketplace , enabling data providers to unlock value from their data by making it available to others. To help promote an open data ecosystem to improve road safety, HERE today announced that it is committing to make European safety-related data distributed under a Creative Commons license (CC) accessible to Marketplace data consumers at no cost to them. Such data could come from road infrastructure and vehicles. BMW cars, for example. Today, BMW Group revealed that it will be the first carmaker to make a set of live safety-related data from its European fleet available through the Marketplace. The data, planned to be available from July 1, will include anonymized information collected by BMW and MINI cars, such as that related to slippery roads, poor visibility or broken-down cars. For our CEO Edzard Overbeek, today’s news underscores the opportunity for HERE to play a key role in bringing the industry together. “Through the OLP, HERE is creating a vibrant ecosystem where data can be exchanged to create applications and solutions that benefit people and society at large,” he said. “Traffic safety is a fundamental societal need and requires industry-wide collaboration that we are pleased to facilitate. We commend BMW Group in taking the initiative, and invite others to join this effort.”", "date": "2019-06-03"},
{"website": "Here", "title": "Read GPS Data with a Raspberry Pi Zero W and Node.js", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/read-gps-data-with-a-raspberry-pi-zero-w-and-node.js", "abstract": "The Raspberry Pi is an awesome piece of Internet of Things (IoT) hardware and when equipped with the correct modules, it can do powerful things with minimal effort. Take GPS for example. You can pick up a NEO 6M GPS module or similar for roughly the same price of a Raspberry Pi, read position information, and reverse geocode that information to address estimates. In this tutorial we’re going to see how to hook up a GPS module to a Raspberry Pi Zero W, read the data over the serial port connection, and send it to HERE in exchange for human readable addresses. We’re going to do all this with just a few lines of Node.js and JavaScript. The Software and Hardware Requirements Before we get too invested in the project, let me outline the hardware and software requirements. In terms of hardware, I’m using the following: U-blox NEO 6M GPS Module Raspberry Pi Zero W There is fine print to the above hardware. My GPS module already had pins attached and I had soldered a GPIO header to my Raspberry Pi Zero W myself. I also have an antenna for my GPS module to boost my signal. How you get to that point is up to you, but in terms of specific hardware, that is the IoT device and GPS module I’m using. To get an idea of what my setup looks like, take a look at the following image: When it comes to software, having Node.js installed on your Raspberry Pi Zero W is a requirement. If you need help installing it, take a look at my tutorial titled, Install Node.js on a Raspberry Pi Zero W without NodeSource . Configuring the Wires and Enabling Serial Port Communication on the Raspberry Pi Before we attach the GPS module, we need to enable serial port communication on the Raspberry Pi. This isn’t for host computer to Raspberry Pi communication, but Raspberry Pi to GPS module communication. Assuming you are using Raspbian, which is one of the most common Rasbperry Pi Linux distributions, execute the following after establishing an SSH connection: sudo raspi-config After executing the above command, you’ll be shown a configuration prompt with options far beyond what we’re trying to accomplish. Inside the configuration tool, you’re going to want to choose Interfacing Options from the list. This is where we are given an opportunity to choose how to interface with the Raspberry Pi. For this particular tutorial we’re interested in using the serial port on the Raspberry Pi Zero W through the GPIO header. From the list, select P6 Serial to be brought to the next screen. To finalize the configuration, the first of two screens will ask about enabling serial based logins. We’re already using SSH so being able to login through the serial connection is not relevant to us. Go ahead and choose No to proceed to the next step. The next screen will ask about the port hardware being enabled. We must enable this so that way our Raspberry Pi can read the GPS data coming in from the pin connection. Once you’ve completed this step, you should restart your Raspberry Pi. Instead of doing a restart, you can do a complete shutdown because we plan to connect our GPS module. The Raspberry Pi Zero W should not be powered when we start connecting our pins. You can get an idea of my pin setup in the following picture: You probably noticed my Adafruit GPIO template. If you don’t have one, I strongly recommend buying one since the pins are not marked on the Raspberry Pi. This will save you from having to do lookups on the internet for the layout. My pin connections are as follows: GPS VCC to Raspberry Pi 5V (Red) GPS GND to Raspberry Pi GND (Black) GPS RXD to Raspberry Pi TXD (White) GPS TXD to Raspberry Pi RXD (Green) Once connected, you should be able to view the incoming stream of data. On my Raspberry Pi, the serial port is /dev/ttyS0 , but yours may be different. At this point we can focus on the code. Reading from the Serial Port, Parsing the Data, and Reverse Geocoding it with HERE You should already have Node.js configured on your Raspberry Pi Zero W by now. If you haven’t, please consult this tutorial . On your Raspberry Pi, create a new directory and execute the following commands: npm init -y\nnpm install serialport --save\nnpm install gps --save\nnpm install request --save\nnpm install request-promise --save The above commands will create a new package.json file and install our dependencies. We’ll be using serialport to read from our serial port, gps to parse our NMEA sentences which are returned from the GPS module, and request as well as request-promise for making HTTP requests to the HERE Reverse Geocoding API. Create an app.js file within your project and include the following lines: const SerialPort = require(\"serialport\");\nconst SerialPortParser = require(\"@serialport/parser-readline\");\nconst GPS = require(\"gps\");\nconst Request = require(\"request-promise\");\n\nconst port = new SerialPort(\"/dev/ttyS0\", { baudRate: 9600 });\nconst gps = new GPS();\n\nconst APP_ID = \"HERE_APP_ID\";\nconst APP_CODE = \"HERE_APP_CODE\";\n\nconst parser = port.pipe(new SerialPortParser());\n\nfunction getAddressInformation(latitude, longitude) {}\n\ngps.on(\"data\", async data => {});\nparser.on(\"data\", data => {}); The above code will essentially initialize our dependencies. We are configuring the correct serial port and baud rate, defining our HERE API tokens, and drawing the blueprint for our event listeners. If you don’t already have a HERE Developer Portal account, you’ll need one to get your tokens. It is free, so don’t worry. Before we start reading and parsing our GPS data, let’s create our function for swapping latitude and longitude coordinates with addresses. Add the following to the getAddressInformation function: function getAddressInformation(latitude, longitude) {\n    let address = {};\n    return Request({\n        uri: \"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\",\n        qs: {\n            \"app_id\": APP_ID,\n            \"app_code\": APP_CODE,\n            \"mode\": \"retrieveAddress\",\n            \"prox\": latitude + \",\" + longitude\n        },\n        json: true\n    }).then(result => {\n        if (result.Response.View.length > 0 && result.Response.View[0].Result.length > 0) {\n            address = result.Response.View[0].Result[0].Location.Address;\n        }\n        return address;\n    });\n} Using a simple HTTP request and some parameters as defined in the HERE Reverse Geocoding API , we can get an estimate of the address for that position. Now let’s look at the event listener for when data comes through the serial port: parser.on(\"data\", data => {\n    try {\n        gps.update(data);\n    } catch (e) {\n        throw e;\n    }\n}); When data comes through the serial port, the goal is to pass it to the GPS NMEA parser. We could parse it ourselves, but using an already existing parser does help. The NMEA parser would look like this: gps.on(\"data\", async data => {\n    if(data.type == \"GGA\") {\n        if(data.quality != null) {\n            let address = await getAddressInformation(data.lat, data.lon);\n            console.log(address.Label + \" [\" + data.lat + \", \" + data.lon + \"]\");\n        } else {\n            console.log(\"no gps fix available\");\n        }\n    }\n}); GPS modules return NMEA sentences of different formats. My NEO 6M module returns $GPGGA formatted sentences. You can figure out what yours returns by just reviewing the raw data that comes back in the serial port event listener. When the data is parsed, we check for a data quality. If the data quality is null or zero, it means we probably don’t have a GPS fix. Without a GPS fix we won’t have latitude and longitude positions. When we do have a fix, we can use those positions in our getAddressInformation function. If you’re not using an antenna on your GPS, it could take a day to get data. As soon as I attached mine, it took just a few minutes to get a fix. Conclusion You just saw how to read, parse, and reverse geocode GPS data on a Raspberry Pi Zero W with JavaScript and Node.js. While this example was quite simple, it can open the door to complicated ideas. If you’re a fan of Golang, I also wrote a tutorial just like this Node.js tutorial. It is titled, Interacting with a NEO 6M GPS Module using Golang and a Raspberry Pi Zero W .", "date": "2019-05-30"},
{"website": "Here", "title": "Enabling Faster Innovation With The MuleSoft Technology Partner Program", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/enabling-faster-innovation-with-the-mulesoft-technology-partner-program", "abstract": "Being a developer-first company means that we want to be exactly where developers build great products. T oday, I am happy to announce that we have joined the MuleSoft Technology Partner Program and have contributed to the MuleSoft partner ecosystem by releasing our Geocoder API specifications. This collaboration will empower MuleSoft developers to create more engaging and contextual user experiences with the most comprehensive and accurate location technology. These APIs are now available in MuleSoft’s Anypoint Exchange, the marketplace for saving, sharing and discovering reusable IT assets, such as APIs, connectors and templates. Organizations can quickly and easily integrate HERE Location Services from Anypoint Exchange into applications, data and solutions. The HERE Geocoder APIs enable: high-precision conversion of real-world addresses into latitude/longitude coordinates (and vice versa) for mapping and spatial analysis; processing of up to one million lines of address information for forward (address to latitude/longitude) or reverse (latitude/longitude to address) geocoding in a batch process; and automatic completion and correction of misspellings to get better suggestions for an address search. These APIs provide fresh and accurate enterprise-grade location information in 196 countries and counting. They are the most comprehensive choice for any global solution requiring location services. “This partnership and HERE Technologies’ release of MuleSoft Certified connector will enable our mutual customers to easily combine MuleSoft APIs and integrations with location based technology to gain competitive advantage by launching new applications faster and reducing deployment times,” said Brian Miller, Senior Vice President of Business Development at MuleSoft. MuleSoft customers can achieve greater competitive advantage across a range of industries and applications, including tracking and logistics, ecommerce and location-based marketing, among many others. As the partnership continues to evolve, we will bring the full power of location intelligence to the MuleSoft ecosystem with HERE’s enterprise-grade, SLA-backed location services, such as maps, routing, POIs, positioning, traffic and weather. The MuleSoft Technology Partner Program is comprised of leading software organizations across both functional applications like CRM, marketing automation, HCM and financials systems as well as across industries including financial services, healthcare, retail and government sectors. Technology partners are leveraging MuleSoft’s Anypoint Platform ™ to reduce deployment time, improve customer experiences and drive innovation . Anypoint Platform unlocks the power of API-led connectivity, enabling organizations to connect apps, data and devices more rapidly and efficiently, both on-premises and in the cloud. Getting started couldn’t be easier. If you are already a developer on the MuleSoft Anypoint Platform, secure your HERE credentials by signing up for a Freemium plan on developer.here.com and bring your App Id and App Code over to the HERE Geocoder listing on the MuleSoft Anypoint Platform. I can't wait to see what you build with HERE!", "date": "2019-05-29"},
{"website": "Here", "title": "May 2019 Release Notes", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/may-2019-release-notes", "abstract": "These are D105 (May 2019) release notes that describe the improvements to the services in the new release. This release includes updates of: Geocoder API, Geocoder Autocomplete API, Routing API, Places API and Fleet Telematics API. This release is mainly a maintenance release. The Highlights: Isoline Routing range is increased to 800km and 9 hours. You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Geocoder API Version 6.2.181 The ‘LinkInfo’ section contains a new item “Traffic” with sub elements “Speed”, “Unit” and “TMCCodes”. Routing API Version 7.2.105 We have improved the quality of our ETA predictions by removing capping of traffic speeds to base speeds. Isoline range was increased to 800km and 32400 seconds (9 hours). Optimized isoline calculation in Australia by considering also second and third most important roads after highway to address regional specifics of the road network density. Places API Version 2.74.0 New category “Vaping Store” (pds category: 600-6900-0108) mapped to “shop” in Find Places category. New category Cigar and Tobacco Shop (pds category: 600-6900-0107) mapped to Find Places category “Shop”. Fleet Telematics API Version 2.5.17 Toll cost and environmental zone access can be fuel type dependent, so calculateroute.json got a parameter &fuelType=petrol/diesel/lng/lpg/cng/ethanol/propane/hydrogen/electric Basic support for bicycle routing (mode=bicycle instead of car or pedestrian). calculateroute response contains travel time and length per route leg. Routing can return maneuver instructions either in text or html format (parameter &instructionFormat=text/html). Routing can return additional maneuver information (parameter &maneuverAttributes=direction,action) The following services had new releases with minor changes: Geocoder Autocomplete API (Version 6.2.181)", "date": "2019-06-11"},
{"website": "Here", "title": "How to Work with GeoJSON Data in Golang for HERE XYZ", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/how-to-work-with-geojson-data-in-golang-for-here-xyz", "abstract": "Since I’m personally becoming more familiar with HERE XYZ , I’ve been learning about all the bits and pieces that go with it, and that includes data formats such as GeoJSON . In a previous tutorial titled, Format Data into GeoJSON with JavaScript to be used with HERE XYZ , I demonstrated how to work with GeoJSON data in JavaScript. However, I’m a huge fan of the Go programming language so I figured it would be awesome to try to replicate what I did with Golang. We’re not going to work directly with HERE XYZ in this example. We’re just going to get our data ready to be sent to HERE XYZ or received from it. I have other tutorials where we make HTTP requests to the HERE XYZ APIs using Golang. Before we create a project, execute the following from the command line: go get github.com/paulmach/go.geojson The above command will get the community supported go.geojson package for use in our project. Within your $GOPATH , create a new project with a main.go file. In that main.go file, include the following boilerplate code: package main\n\nimport (\n    \"fmt\"\n\n    geojson \"github.com/paulmach/go.geojson\"\n)\n\ntype Position struct {}\ntype XYZData struct {}\n\nfunc NewGeoJSON(position Position, tags []string) ([]byte, error) {}\nfunc main() {} You’ll notice that we have two data structures and two functions, one of which is our main function. Under normal circumstances, using the pure GeoJSON package would be sufficient, but we’re going to create our own helper function to work with HERE XYZ. Essentially HERE XYZ allows tagging which is useful when issuing search queries. You could, for example, create a tag for a date and then return results that only match that tag. This doesn’t break the GeoJSON specification, but it does mean we need to include certain things. Let’s first create our Position data structure: type Position struct {\n    Latitude  float64 `json:\"lat\"`\n    Longitude float64 `json:\"lng\"`\n} As you guessed, we have a latitude and longitude property to work with instead of a plain floating point slice. The XYZData data structure will look like the following: type XYZData struct {\n    Tags []string `json:\"tags\"`\n} With those two data structures in place, we can start constructing our GeoJSON feature collection. We’re going to create our full feature collection in the NewGeoJSON function and return a slice of bytes which could later be sent to HERE XYZ. func NewGeoJSON(position Position, tags []string) ([]byte, error) {\n    featureCollection := geojson.NewFeatureCollection()\n    feature := geojson.NewPointFeature([]float64{position.Longitude, position.Latitude})\n    feature.SetProperty(\"@ns:com:here:xyz\", XYZData{Tags: tags})\n    featureCollection.AddFeature(feature)\n    return featureCollection.MarshalJSON()\n} In the above function we are accepting a position of latitude and longitude coordinates as well as any number of tags to be stored. After creating a new feature for the collection we are adding a property to that feature. The property has a specific key and it is an object. We want our final output to look something like this: {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        { \n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [-121,37]\n            },\n            \"properties\": {\n                \"@ns:com:here:xyz\": {\n                    \"tags\": [\"foo\",\"bar\"]\n                }\n            }\n        }\n    ]\n} We can make use of this NewGeoJSON function in the main function. Take the following for example to reproduce the above output: func main() {\n    g, _ := NewGeoJSON(Position{37, -121}, []string{\"foo\", \"bar\"})\n    fmt.Println(string(g))\n} Not so bad right? GeoJSON can be a lot more complex, but this is just a basic example, something that was valuable for one of my own projects. In my example I was collecting latitude and longitude positions and needed to send it to HERE XYZ. So I took the data I had and converted it to GeoJSON format. Conclusion You just saw how to work with GeoJSON data in Golang. While the go.geojson package for Golang makes it easy in general, we wanted to make some changes that better accommodate working with HERE XYZ. To learn more about working with location data in Golang, check out my previous tutorial titled, Reverse Geocoding NEO 6M GPS Positions with Golang and a Serial UART Connection .", "date": "2019-06-04"},
{"website": "Here", "title": "Custom Locations with the HERE Fleet Telematics APIs- Part I", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/custom-locations-with-the-here-fleet-telematics-apis-part-i", "abstract": "Businesses often rent warehouses for temporary use. They may also have private offices and locations which they want to see only on their map. In this post we are going to find out how to do exactly that. After discussing Truck routing in the previous blog, let us explore the Custom Location API , one of the HERE Fleet Telematics APIs. What are custom locations? Any locations that you want visible only on your private edition of the map, can be a custom location. These locations can be in the form of points- exact location of a place, polyline- a private road or polygons- shape of an area like a parking lot. In this example, I am considering exact locations of warehouses (Points) that your trucks will be delivering goods to. How do these locations get added to the map? These locations are added to the map in the form of a layer on top of the basic map. You can then retrieve this layer by making it visible on your map and by making HTTP REST requests to search for locations within this layer with respect to your location. Let's begin the fun part! Adding custom locations Custom locations can be added to your map in 2 ways: Upload CSV files through a web portal: If you have a list of places with incomplete or full addresses, this list can be geocoded using the web portal . Log in to the portal using the app_id and app_code you will be using for building the application. Remember that a custom layer is bound to the credentials using for logging in unless linked to more credentials. If you don't have an app_id and app_code yet, get them for free by signing up at the Developer Portal . Now, after you have logged in to the portal using your credentials, you will be able to see all the added layers on your layer manager. You can upload a layer here by clicking on Geocode layer Upload a csv where you have saved the list of addresses. Enter the names of columns that match those given on the page and click on Geocode . Provide a name to this layer. Note that this will be the layer_id used to identify the layer. You can also directly add the 'Latitude' and 'Longitude' columns if you have that data instead. Upload WKT files using REST call WKT or Well-Known Text is a markup format used to represent vector geometry objects on a map. To add custom locations using the RESTful API, you will have to convert your data in a WKT file. A WKT file has the extension 'wkt' and has a column named WKT in it which contains the location geometry. You can either add 'POINT' geometry, 'POLYGON' or 'POLYLINE' geometries. Note that one file can contain only one geometry type. Below is an example of a WKT file. NAME\tSTREET\tDISTRICT\tPOSTALCODE\tCITY\tCOUNTRY\tMATCH_LEVEL\tGEOMETRY_ID\tWKT\n    Lemke\tLuisenplatz 1\tCharlottenburg\t10585\tBerlin\tGermany\thouseNumber\t32\tPOINT(13.2998139 52.520075)\n    Adonis\tTorstraße 132\tMitte\t10119\tBerlin\tGermany\thouseNumber\t31\tPOINT(13.40015 52.5294) To upload this layer, use the following REST call with the post body as the wkt file. var url = \"https://cle.api.here.com/2/layers/upload.json\";\nurl= addURLParam(url, \"app_id\", my_app_id);\nurl= addURLParam(url, \"app_code\", my_app_code);\nurl= addURLParam(url, \"layer_id\", \"WAREHOUSES_DIST_3\");\n\nfunction init(){\n  document.getElementById('upload').addEventListener('click', upload);\n}\n\nfunction upload(event){\n  event.preventDefault();    //stop the form submitting\n\n  //header for accepted response\n  let h = new Headers();\n  h.append('Accept', 'application/json');\n  let fileupload = new FormData();\n  let myFile = document.getElementById('fileUpload').files[0];\n  // The key in this case can be anything. I have named it layer\n  fileupload.append('layer', myFile, \"layer.wkt\");\n \n  let uploadRequest = new Request(url, {\n      method: 'POST',\n      headers: h,\n      mode: 'no-cors',\n      body: fileupload\n  });\n\n  fetch(uploadRequest)\n  .then(response => {\n    document.getElementById('map').innerHTML = \"File uploaded\";\n})\n  .catch(error => console.error('Error:', error));\n}\n\nfunction addURLParam(url, name, value){\n  url += (url.indexOf(\"?\") == -1 ? \"?\" : \"&\");\n  url += encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n  return url; \n} Displaying the custom location layer Now that you have added the layer, you can display it as a separate layer on top of your map. // set up containers for the map  + panel\n    var mapContainer = document.getElementById('map');\n        // routeInstructionsContainer = document.getElementById('panel');\n    \n    //Step 1: initialize communication with the platform\n    let M = {\n        'Init': { // developer.here.com for app_id and app_code\n            \"app_id\":   my_app_id,\n            \"app_code\": my_app_code,\n            \"useHTTPS\": true\n        }\n    };\n    \n    var platform = new H.service.Platform(M.Init);\n    \n    var defaultLayers = platform.createDefaultLayers();\n    // Set center of the map\n    var mapcenter= {lat:52.51607, lng:13.37698};\n    \n    //Step 2: initialize a map - this map is centered over Berlin\n    var map = new H.Map(mapContainer,\n        defaultLayers.normal.map,{\n        center: mapcenter,\n        zoom: 13\n    });\n    //Step 3: make the map interactive\n    // MapEvents enables the event system\n    // Behavior implements default interactions for pan/zoom (also on mobile touch environments)\n    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n    \n    // Create the default UI components\n    var ui = H.ui.UI.createDefault(map, defaultLayers);\n    \n    var getCustomLocationService = platform.getCustomLocationService();\n    //Display layer as a Tile \n    // create tile provider and layer that displays CLE layer\n    var layer_provider = new mapsjs.service.extension.customLocation.TileProvider(getCustomLocationService, \n        {\n        layerId: 'WAREHOUSES_DIST_3'\n        }, \n        {\n        resultType: mapsjs.service.extension.TileProvider.ResultType.MARKER \n        });\n    var rest_LAYER = new mapsjs.map.layer.MarkerTileLayer(layer_provider);\n        map.addLayer(rest_LAYER); Note that the app_id and app_code used are the same as the ones associated with the uploaded layer. The layer name also has to be the same one as the uploaded layer name. Modifying the custom location layer If you need to add more geometries to this layer, you can do so with the call below. https://cle.api.here.com/2/layers/modify.json?app_id={{app_id}}&app_code={{app_code}}&action=update&layer_id=WAREHOUSES_DIST_3 Similar to the POST request for uploading a layer, this request also requires the layer id and credentials as the previously uploaded layer. The post body is of the type form-data and the uploaded file is of the same format as the .wkt file used while uploading a layer. To change an entry in an existing layer partially, you need to know the geometry id of the entry you wish to change. You can get this id by logging on to the portal mentioned above or by listing the layer info. Once you have this information, you can make the following request to change details in the layer. https://cle.api.here.com/2/layers/modify.json?app_id={{app_id}}&app_code={{app_code}}&action=update&layer_id=WAREHOUSES_DIST_3&geometry_id=35 The body will be same as above and the .wkt file will contain all the fields of the entry in the layer including the content to be changed. For deleting an entry in a layer, you will need the geometry id and running the following command with the body as the .wkt file containing all the fields in that entry will do the work. https://cle.api.here.com/2/layers/modify.json?app_id={{app_id}}&app_code={{app_code}}&action=delete&layer_id=WAREHOUSES_DIST_3&geometry_id=38 What next? In the next blog post, we will discuss how to use these layers to find places in your custom layer inside a given radius, in a bounding box and along a route. Meanwhile, happy coding!", "date": "2019-06-19"},
{"website": "Here", "title": "Publish Location Data from a Raspberry Pi to HERE XYZ and View it on a Map", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/publish-location-data-from-a-raspberry-pi-to-here-xyz-and-view-it-on-a-map", "abstract": "In a previous tutorial , you’ll probably remember that I demonstrated how to collect GPS data on a Raspberry Pi Zero W with a NEO 6M GPS module and Node.js. In this example we simply collected the latitude and longitude position data, reverse geocoded it to addresses, and printed it out. A more useful scenario might involve visualizing the data that was collected and sharing it with others. This can easily be accomplished by including HERE XYZ into the mix. HERE XYZ can act as a data storage layer for our location data and we can query that data using various API endpoints that are included with the service. In this tutorial we’re going to collect position data on a Raspberry Pi, upload it to HERE XYZ as it comes in, and then later view it on a map. Take a look at the following image which is a result of my experiment: I removed street names and house numbers for privacy reasons, but it clearly shows a walk I did around my neighborhood. I had my Raspberry Pi Zero W hooked up to a portable battery with the GPS module attached. Since I don’t have an LTE adapter for my Raspberry Pi, I tethered it to my mobile phone for internet. As I walked around my neighborhood, the data was sent to HERE XYZ without any further backend or database required. If you’re a long time follower of my content, you’ll probably remember a tutorial I wrote titled, Tracking a Raspberry Pi with WLAN and Golang, then Displaying the Results with HERE XYZ . This was a near identical experiment, but in the previous I used WLAN instead of GPS to track the position. I also didn’t make use of the HERE XYZ APIs, but instead manually uploaded my data. The above picture, from the previous tutorial also shows a less defined route. Only so much can be concluded from WLAN data versus GPS data. This tutorial which you’re currently reading should be a step up, unless of course you’re interested in WLAN AP tracking instead of GPS. In case you’re curious, my Raspberry Pi setup looks like the following: I’m just using a simple USB battery pack, a Raspberry Pi Zero W and a NEO 6M GPS module. Interacting with HERE XYZ from a Raspberry Pi Zero W If you haven’t already, I strongly recommend you check out my tutorial titled, Read GPS Data with a Raspberry Pi Zero W and Node.js . It has the hardware and software requirements as well as more thorough details on the collecting of GPS data. We’re going to modify the code from the previous tutorial to include HERE XYZ and exclude the HERE Reverse Geocoding API. Create a new directory on your computer and execute the following commands: npm init -y\nnpm install axios geojson serialport gps moment --save\ntouch app.js If you don’t have the touch command, create the app.js file manually. We’ll be using axios to make HTTP requests to the HERE XYZ API, geojson to parse our data into something HERE XYZ understands, serialport for interacting with the GPS module, gps for parsing our GPS data, and moment for making timestamp data easy to work with in JavaScript. Inside the app.js file, include the following: const SerialPort = require(\"serialport\");\nconst SerialPortParser = require(\"@serialport/parser-readline\");\nconst GPS = require(\"gps\");\nconst Axios = require(\"axios\");\nconst GeoJSON = require(\"geojson\");\nconst OS = require(\"os\");\nconst Moment = require(\"moment\");\n\nvar SERIAL_PORT = \"/dev/cu.SLAB_USBtoUART\";\n\nif(OS.platform() == \"linux\") {\n    SERIAL_PORT = \"/dev/ttyS0\";\n}\n\nconst port = new SerialPort(SERIAL_PORT, { baudRate: 9600 });\nconst gps = new GPS();\n\nconst parser = port.pipe(new SerialPortParser());\n\ngps.on(\"data\", data => {\n    if(data.type == \"GGA\" || data.type == \"RMC\") {\n        if(data.quality != null || data.status == \"active\") {\n            console.log(data.lat + \",\" + data.lon);\n        } else {\n            console.log(\"no gps fix available\");\n        }\n    }\n});\n\nparser.on(\"data\", data => {\n    try {\n        gps.update(data);\n    } catch (e) {\n        throw e;\n    }\n}); The above code is more or less what we saw in the previous tutorial, with the exception of a few upgrades to make it more resistant to failure, not more features. If you want the details on what everything in the above tutorial does, please view the previous tutorial since it isn’t the focus for this one. Now that we have GPS data coming in, we need to have it flow into HERE XYZ. However, before we can do that, we need to make sure we have the appropriate pieces configured. My suggestion would be to use the XYZ CLI going forward. As a developer you might find it easier than clicking around in a portal. You will need a free account in order to proceed. To install the XYZ CLI, execute the following: npm install -g @here/cli After you install the XYZ CLI, you’ll need to configure it to use your account. This should be done on your computer, not the Raspberry Pi. We’re only doing XYZ configurations, not using the CLI for interactions. Execute the following: here configure account Use the username and password that you used when creating a HERE Developer Portal account. You’ll only need to do this one time. After configuring the CLI to use your account, you’ll want to create a new space to store your data. This can be done with the following: here xyz create --title \"raspberry-pi-project\" --message \"data from the raspberry pi\" Take note of the space id that is returned after executing the above command. We’ll need to use it in our Node.js code. In addition to a space id, you’ll also want to create a token with the correct permissions. You can do that with the CLI, or by visiting the token dashboard found here . After the token is generated, make note of it because it, along with the space id, will be used in the Node.js application. Before we get into the code, you should be aware of how to see your data outside of the CLI. This can be done in the Data Hub of XYZ Studio. Head over to HERE XYZ Studio , and choose the Data Hub tab. You can view your spaces and data in the Data Hub if you prefer over the CLI. Right now you’ll have no data for the space that we plan to use. With that out of the way, let’s go back into our app.js file. We need to add the following near the top: const XYZ_TOKEN = \"TOKEN_HERE\";\nconst XYZ_SPACE = \"SPACE_ID_HERE\"; The REST API will require both the token and space id. For code cleanliness, it is a good idea to just create a constant for this information. Now let’s make use of axios and the geojson libraries to make our request: function uploadToXYZ(position) {\n    const now = (new Date()).getTime();\n    const date = Moment(now).format(\"YYYYMMDD\");\n    const data = [\n        {\n            lat: position.lat,\n            lng: position.lng,\n            timestamp: now.toString(),\n            date: date,\n            \"@ns:com:here:xyz\": {\n                tags: [now.toString(), date]\n            }\n        }\n    ];\n    const dataGeoJSON = GeoJSON.parse(data, { Point: [\"lat\", \"lng\"] });\n    return Axios({\n        method: \"PUT\",\n        url: \"https://xyz.api.here.com/hub/spaces/\" + XYZ_SPACE + \"/features\",\n        headers: {\n            \"Authorization\": \"Bearer \" + XYZ_TOKEN,\n            \"Content-Type\": \"application/geo+json\"\n        },\n        data: JSON.stringify(dataGeoJSON)\n    });\n} The first step is to create GeoJSON data to how HERE XYZ expects. This means defining the latitude and longitude as well as any properties or tag information. The properties, which are timestamp and date in this example, will be visible in the Data Hub . The tags will be searchable when making requests to read data. This would be useful for something like displaying all data for a given date, or similar. Once we create our GeoJSON data, we can make an HTTP request to the API. We can make use of the uploadToXYZ function within the GPS parser like so: gps.on(\"data\", data => {\n    if(data.type == \"GGA\" || data.type == \"RMC\") {\n        if(data.quality != null || data.status == \"active\") {\n            console.log(data.lat + \",\" + data.lon);\n            uploadToXYZ({ lat: data.lat, lng: data.lon }).then(result => { }, error => console.log(error));\n        } else {\n            console.log(\"no gps fix available\");\n        }\n    }\n}); A potential problem with this is with the volume of requests. GPS data will be picked up quite frequently. To avoid burning through your API limits, it might be a good idea to throttle your requests. This can easily be accomplished by keeping track of the elapsed time between requests. Near the top of your app.js file, include the following: const THROTTLE_TIME = 2000;\nvar trackedTime = (new Date()).getTime(); In my example, I want to only make requests every 2000 milliseconds. Feel free to adjust that number or remove it completely. With those variables in place, we can update the GPS parser to the following: gps.on(\"data\", data => {\n    if(data.type == \"GGA\" || data.type == \"RMC\") {\n        if(data.quality != null || data.status == \"active\") {\n            const now = (new Date()).getTime();\n            if(now - trackedTime >= THROTTLE_TIME) {\n                console.log(data.lat + \",\" + data.lon);\n                uploadToXYZ({ lat: data.lat, lng: data.lon }).then(result => { }, error => console.log(error));\n                trackedTime = now;\n            }\n        } else {\n            console.log(\"no gps fix available\");\n        }\n    }\n}); At this point, if we were to run the application on the Raspberry Pi, it should push our GPS data to HERE XYZ. There are a few things to note: The assumption is that the Raspberry Pi was configured for GPS collection via the previous tutorial. The GPS module has a fix on the signal and is getting position data. The HERE XYZ space id and token information is correct. The Raspberry Pi has an internet connection. Just to reiterate, definitely check out my previous tutorial for getting everything configured on the Raspberry Pi. Displaying HERE XYZ Data on a Map with Leaflet.js Now that we have data in XYZ, we probably want to visualize it so it makes sense or others can make sense of it. To do this, we can use just about anything when it comes to a renderer. We can use the HERE JavaScript SDK with interactive maps, Leaflet.js, Tangram, etc. At the end of the day, we just want to show a map with polylines and markers. For this example, I’m choosing to use Leaflet.js to render our data. We need to create a new project. This time it will represent a web application, completely independent from the Raspberry Pi project that we had created. You’ll want to create a new index.html file with the following code: <html>\n    <head>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" />\n    </head>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh\"></div>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/geojson/0.5.0/geojson.min.js\"></script>\n        <script src=\"heredev.js\"></script>\n        <script>\n            const start = async () => {\n                const tiles = \"https://1.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/512/png8?app_id={appId}&app_code={appCode}\";\n                const map = new L.Map(\"map\", {\n                    center: [37, -121],\n                    zoom: 11,\n                    layers: [L.tileLayer(tiles, { appId: \"HERE_APP_ID\", appCode: \"HERE_APP_CODE\" })]\n                });\n            }\n            start();\n        </script>\n    </body>\n</html> The above code, assuming you’ve added your app id and app code, will display a map with Leaflet.js and use the HERE Map Tile API. What we need to do is request our data from the HERE XYZ API, similar to how we added it on the Raspberry Pi. To do this, we can use axios to do the following: const response = await axios({\n    method: \"GET\",\n    url: \"https://xyz.api.here.com/hub/spaces/\" + \"HERE_SPACE_ID\" + \"/search\",\n    params: {\n        access_token: \"HERE_TOKEN\"\n    }\n}); You’ll want to use the same space id and token that you used on the Raspberry Pi. In production, you may want to create another token that has less permissions, for example a read-only token. To bring it all together, we can upgrade our client facing project to the following: <html>\n    <head>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" />\n    </head>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh\"></div>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/geojson/0.5.0/geojson.min.js\"></script>\n        <script src=\"heredev.js\"></script>\n        <script>\n            const start = async () => {\n                const tiles = \"https://1.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/512/png8?app_id={appId}&app_code={appCode}\";\n                const map = new L.Map(\"map\", {\n                    center: [37, -121],\n                    zoom: 11,\n                    layers: [L.tileLayer(tiles, { appId: \"HERE_APP_ID\", appCode: \"HERE_APP_CODE\" })]\n                });\n                const response = await axios({\n                    method: \"GET\",\n                    url: \"https://xyz.api.here.com/hub/spaces/\" + \"HERE_SPACE_ID\" + \"/search\",\n                    params: {\n                        access_token: \"HERE_TOKEN\"\n                    }\n                });\n                const polylineData = [];\n                response.data.features.forEach(feature => {\n                    let position = feature.geometry.coordinates;\n                    polylineData.push({ lat: position[1], lng: position[0] });\n                });\n                const polyline = new L.Polyline(polylineData, { weight: 5 });\n                polyline.addTo(map);\n                const sourceMarker = new L.Marker(polylineData[0]);\n                const destinationMarker = new L.Marker(polylineData[polylineData.length - 1]);\n                sourceMarker.addTo(map);\n                destinationMarker.addTo(map);\n                const bounds = new L.LatLngBounds(polylineData);\n                map.fitBounds(bounds);\n            }\n            start();\n        </script>\n    </body>\n</html> In the above code, we make our request for the data in HERE XYZ, obtain all of the geometry information to construct a polyline, and add the polyline to the map. At the start of our data and the end we drop a marker. Conclusion You just saw how to use the HERE XYZ APIs to send GPS position data from a Raspberry Pi and display it on a map without having to manually process the data. This was all accomplished using simple JavaScript and Node.js. To be fair, this tutorial was part of a series. We didn’t really talk about how to interact with a GPS module on a Raspberry Pi with Node.js because the focus for this was XYZ. If you want to properly configure your Raspberry Pi and interact with the GPS module, view my previous tutorial .", "date": "2019-06-06"},
{"website": "Here", "title": "Introducing harp.gl – 3D Vector Maps for the Web", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/introducing-harp.gl-3d-vector-maps-for-the-web", "abstract": "When we build products at HERE, we don't want to just provide you with advanced tools, but also let you make them your own. Today we’re excited to launch the beta release of harp.gl , a new open source 3D web map renderer. harp.gl is a full-fledged vector map renderer built on the latest web technologies. Combining harp.gl's immersive visuals with industry-grade HERE map data will give you the best location visualization experience on the web. Why harp.gl? At HERE, we work with a wide variety of data sources and types, many of which include 3D elements. Building products like high-definition maps with lane-level detail and venue maps with multiple levels requires advanced visualization tools to help accelerate the development process. In addition, we wanted to build a tool on a technology that many of our internal teams could adopt. For this reason, we chose the web as our platform. Key principles harp.gl was developed with three key principles in mind: web first open source flexibility Web first Building harp.gl from the ground, we wanted to take advantage of the latest and greatest capabilities of modern browsers. harp.gl was written with web technologies such as WebGL , three.js , and TypeScript . WebGL enables us to draw geometries with blazing fast speed on the GPU, delivering an efficient and smooth rendering experience. We decided to use three.js as a base and added mapping specific capabilities on top of it. harp.gl supports any standard three.js APIs. TypeScript gives us the extra support needed around strong typing and additional compilation checks. Open Source It goes without saying that the best software gets developed when the engineering team has a direct connection to the customer. Being open source, harp.gl is developed with transparency to the community. Become part of the conversation and interact with the developers by opening an issue or creating a pull request on GitHub. Flexibility One of the design goals of harp.gl was a flexible architecture to support a wide variety of use cases. Although we offer best in class location content , harp.gl does not limit you to using only HERE data sources. harp.gl works with several data providers such as Mapbox, Nextzen, or any other vector tile service. However, the flexibility isn't just with data providers. In addition to vector tiles, harp.gl can work with multiple data types. Enhance your map with static GeoJSON, raster tiles, three.js objects, or any custom source by writing a few lines of code. Features 3D Don't limit yourself to 2.5D and extruded polygons. harp.gl can render true 3d objects, including advanced textures and geometries. three.js user? You can interact with the harp.gl API the same way as you would with three.js. Just assign the object a position with coordinates to add it to the map. Below, an animating three.js object imported from a fbx file. Camera Options Start with the standard top-down view or customize the map's tilt and angle to create realistic POV views. harp.gl's camera angle can be set between 0 and 90 degrees. With harp.gl's camera animations, fly between cities or perform slow rotating pans to create a cinematic experience. Map Projections When it comes to map projections, choose between the standard mercator projection or the realistic spherical earth. The spherical earth bypasses the distortion and scaling problems arising from projecting the earth onto a plane and displays a 3D globe. Custom styles As a vector renderer, harp.gl gives you the options to customize any and all map features with a styling language. Apply your brand's look and feel to the map or simply have fun creating some ludicrous themes. Getting started with harp.gl You can add harp.gl to your app in two different ways: a set of TypeScript node modules, allowing you to pick and choose the exact components you need for you application a simple JavaScript bundle api that can be imported into your html page with a script tag Here’s how to get started with the simple api: <html>\n   <head>\n      <style>\n         body, html { border: 0; margin: 0; padding: 0 }\n         #map { height: 100vh; width: 100vw; }\n      </style>\n      <script src=\"https://unpkg.com/three/build/three.min.js\"></script>\n      <script src=\"https://unpkg.com/@here/harp.gl/dist/harp.js\"></script>\n   </head>\n   <body>\n      <canvas id=\"map\"></canvas>\n      <script src=\"index.js\"></script>\n   </body>\n</html> You can get set up your XYZ token here or if you already have xyz cli installed you can generate your token using here xyz token and then inside your JavaScript file, you initialize the map and then add the base map: const map = new harp.MapView({\n   canvas: document.getElementById('map'),\n   theme: \"https://unpkg.com/@here/harp-map-theme@latest/resources/berlin_tilezen_night_reduced.json\",\n});\nmap.setCameraGeolocationAndZoom(new harp.GeoCoordinates(1.278676, 103.850216),16);\nconst mapControls = new harp.MapControls(map);\nconst omvDataSource = new harp.OmvDataSource({\n   baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n   apiFormat: harp.APIFormat.XYZOMV,\n   styleSetName: \"tilezen\",\n   authenticationCode: 'YOUR-XYZ-TOKEN',\n});\nmap.addDataSource(omvDataSource); What's coming next? Expect plenty of new features and releases from harp.gl in the upcoming months. Some of the new features we're particularly excited about: 3D city models & landmarks : easily import HERE's advanced city models as a data source 3D terrain : Visualize the real earth surface instead of the sea-level surface to better understand where your data is located Advanced post-processing : take harp.gl cinematic effects to a whole new level with-post processing effects such as depth of field and screen space ambient occlusion Additional resources examples : curated list of harp.gl examples documentation tutorial : learn the basics of harp.gl Github : get started and view the source code We encourage you to give harp.gl a try. Make something cool with harp.gl? Share your maps with us on Twitter by tagging @heredev .", "date": "2019-06-21"},
{"website": "Here", "title": "Updating a Map with JavaScript on an Interval to Reflect Server-Side Changes", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/updating-a-map-with-javascript-on-an-interval-to-reflect-server-side-changes", "abstract": "About a week ago I had written a tutorial around showing a map with data that I had collected within HERE XYZ. The tutorial was on the basis that I was collecting GPS data of my current route and then later showing it on the map. However, what if I wanted others to view my current route as it happens? We’re going to see how to use simple JavaScript to continuously request data from HERE XYZ to update on a map. Requesting HERE XYZ Data on an Interval When it comes to JavaScript, there are several approaches to refresh the screen if you’re not able to use an event listener, websocket, or long-polling request. You could refresh the entire page using an HTML <meta> tag, you could reload the page with JavaScript, or you could perform tasks within the page on an interval. With maps, refreshing the entire page could be costly towards your API transactions. Instead it makes more sense to do things on an interval and only update what’s necessary. To do this we can make use of the JavaScript setInterval method. This method looks something like this: setInterval(() => {\n    // Repeating logic here...\n}, 1000) In the above example, we would repeat our function every 1000 milliseconds. To put things into perspective, if we’ve already rendered a map, we might make an HTTP request on an interval and draw new map objects on the map. Take the following example which makes use of Leaflet.js and HERE XYZ: <html>\n    <head>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" />\n    </head>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh\"></div>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/geojson/0.5.0/geojson.min.js\"></script>\n        <script>\n            const start = async () => {\n                const tiles = \"https://1.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/512/png8?app_id={appId}&app_code={appCode}\";\n                const map = new L.Map(\"map\", {\n                    center: [37, -121],\n                    zoom: 11,\n                    layers: [L.tileLayer(tiles, { appId: \"HERE_APP_ID\", appCode: \"HERE_APP_CODE\" })]\n                });\n                var polyline, sourceMarker, destinationMarker;\n                setInterval(async () => {\n                    const response = await axios({\n                        method: \"GET\",\n                        url: \"https://xyz.api.here.com/hub/spaces/\" + \"HERE_XYZ_SPACE_ID\" + \"/search\",\n                        params: {\n                            access_token: \"HERE_XYZ_TOKEN\"\n                        }\n                    });\n                    map.eachLayer(layer => {\n                        if(!layer._url) {\n                            layer.remove();\n                        }\n                    });\n                    const polylineData = [];\n                    response.data.features.forEach(feature => {\n                        let position = feature.geometry.coordinates;\n                        polylineData.push({ lat: position[1], lng: position[0] });\n                    });\n                    polyline = new L.Polyline(polylineData, { weight: 5 });\n                    sourceMarker = new L.Marker(polylineData[0]);\n                    destinationMarker = new L.Marker(polylineData[polylineData.length - 1]);\n                    polyline.addTo(map);\n                    sourceMarker.addTo(map);\n                    destinationMarker.addTo(map);\n                    const bounds = new L.LatLngBounds(polylineData);\n                    map.fitBounds(bounds);\n                }, 5000);\n            }\n            start();\n        </script>\n    </body>\n</html> If the above code looks familiar to you, it is because you probably saw it in my previous example . However, my previous example did not refresh to render new data on the map. In my example above, I am using setInterval to make an HTTP request with axios , clear the map of all objects except the HERE map tiles, and redraw the polylines and markers based on the new information. Conclusion You just saw how to use a simple setInterval JavaScript method to continuously request new data from HERE XYZ and display it on a map. If given the opportunity, websockets, event listeners, and long-polling would be the most ideal to prevent requests for data that might not have changed, but this is the next best thing.", "date": "2019-06-13"},
{"website": "Here", "title": "Explore Custom Locations With the HERE Fleet Telematics APIs — Part II", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/custom-locations-with-the-here-fleet-telematics-apis-part-ii", "abstract": "In Part I of our tutorial, we learnt how to add private warehouses to a map. No one else has access to them except you. But do you really have access to them? Let's explore how to get to these custom locations further. Last time we discussed how to add, append, delete and update custom locations to your map . In Part II we will explore searching and routing to these locations within a fixed radius, within a bounding box, and along an isoline. Within a radius Normally, to look for places within a radius, you would need your exact location in terms of latitude and longitude and the radius of search in meters. We have already done this while using the Places > Search API How is this different from custom locations? Not by much. The only difference here is that you would search within the custom layer you added, with the layer Id as the key. function getnearestCustomLocation(){\n    var url = \"https://cle.api.here.com/2/search/proximity.json\";\n    \n    url= addURLParam(url, \"app_id\", \"YOUR_APP_ID\");\n    url= addURLParam(url, \"app_code\", \"YOUR_APP_CODE\");\n    url= addURLParam(url, \"proximity\", \"52.51607,13.37698,4000\");\n    url= addURLParam(url, \"layer_ids\", \"WAREHOUSES_DIST_3\");\n    \n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function() \n    {\n        if (this.readyState == 4 && this.status == 200) \n        {\n        var myArr = JSON.parse(this.responseText);\n        console.log(this.responseText.length);\n        for (i=0; i < this.responseText.length; i++)\n        {\n            newpos= {lat: myArr.geometries[i].nearestLat, lng: myArr.geometries[i].nearestLon};\n            var wh_icon = new H.map.Icon(\"img/warehouse.png\");\n            wh_marker = new H.map.Marker(newpos,{icon:wh_icon});\n            map.addObject(wh_marker);\n        }    \n        }\n    };\n    xhttp.open(\"GET\", url, true);\n    xhttp.send();\n    } Here I have simply displayed the places in my custom layer 'WAREHOUSES_DIST_3' within 4km of my current location. You can also add them as your routing waypoints . This layer was added using methods discussed in Custom Locations Part-I . Within a bounding box Another way of searching for custom locations can be within a given region described by a bounding box . The box within which you would want to search for locations within your custom layer is defined by the latitude and longitude of the upper left, lower and right corners of the box. The result will be all the locations in the given layer Id within the defined box on the map. https://cle.api.here.com/2/search/bbox.json?app_id=YOUR_APP_ID&app_code=YOUR_APP_CODE&bbox=52.51828,13.33282;52.50535,13.39073&layer_id=WAREHOUSES_DIST_3 Isoline search Imagine that your truck is on its way for a delivery. There is an emergency and the driver needs to drop the cargo at your nearest warehouse. How would you find this private warehouse en route the pre-fed destination. Isoline lets you find locations that can be reached within a specific distance or within a specific time. This distance or time can be specified in the query as seen in the Isoline Routing example . The way we can use isoline here is by searching for locations in the custom layer, that can be reached within a distance / time of detour along your original destination. How is it different than a normal proximity search with a radius? Well this looks for destinations which will be a certain distance of detour away from your original route. This use-case plays in when you are already en route, while the proximity search is when you are starting out and don't have a specific destination in mind yet. Let's talk about the parameters in this request. https://cle.api.here.com/2/search/routeisoline.json?app_id=YOUR_APP_ID&app_code=YOUR_APP_CODE&waypoint0=52.52008,13.41441&waypoint1=52.51574,13.4182&layer_ids=WAREHOUSES_DIST_3&max_detour_distance=1000 With waypoint0 and waypoint1, we define the start and endpoint of the current route. With the max_detour_distance parameter, we define the detour that we wish to take, in meters from the current route. The result will look something like this: {\n        \"response\": {\n            \"route\": [\n                {\n                    \"mode\": {\n                        \"type\": \"fastest\",\n                        \"transportModes\": [\n                            \"car\"\n                        ]\n                    },\n                    \"boatFerry\": false,\n                    \"railFerry\": false,\n                    \"waypoint\": [\n                        {\n                            \"linkId\": \"+53501246\",\n                            \"mappedPosition\": {\n                                \"latitude\": 52.52008,\n                                \"longitude\": 13.41441\n                            },\n                            \"originalPosition\": {\n                                \"latitude\": 52.52008,\n                                \"longitude\": 13.41441\n                            },\n                            \"spot\": 0.55626,\n                            \"seqNrOnRoute\": 0\n                        },\n                        {\n                            \"linkId\": \"+733292930\",\n                            \"mappedPosition\": {\n                                \"latitude\": 52.51574,\n                                \"longitude\": 13.41824\n                            },\n                            \"originalPosition\": {\n                                \"latitude\": 52.51574,\n                                \"longitude\": 13.4182\n                            },\n                            \"spot\": 0.25441,\n                            \"seqNrOnRoute\": 1\n                        }\n                    ],\n                    \"leg\": [\n                        {\n                            \"link\": [\n                                {\n                                    \"linkId\": \"53501246\",\n                                    \"length\": 26,\n                                    \"remainDistance\": 775,\n                                    \"remainTime\": 71,\n                                    \"shape\": [\n                                        52.51989,\n                                        13.41403,\n                                        52.52013,\n                                        13.41452,\n                                        52.52024,\n                                        13.4147\n                                    ],\n                                    \"functionalClass\": 4\n                                },\n                                {\n                                    \"linkId\": \"779490732\",\n                                    \"length\": 15,\n                                    \"remainDistance\": 748,\n                                    \"remainTime\": 71,\n                                    \"shape\": [\n                                        52.52024,\n                                        13.4147,\n                                        52.52035,\n                                        13.41483\n                                    ],\n                                    \"functionalClass\": 4\n                                },\n                                {\n                                    \"linkId\": \"779490733\",\n                                    \"length\": 46,\n                                    \"remainDistance\": 733,\n                                    \"remainTime\": 68,\n                                    \"shape\": [\n                                        52.52035,\n                                        13.41483,\n                                        52.52069,\n                                        13.41523\n                                    ],\n                                    \"functionalClass\": 4\n                                },\n                                {\n                                    \"linkId\": \"-77272542\",\n                                    \"length\": 26,\n                                    \"remainDistance\": 687,\n                                    \"remainTime\": 66,\n                                    \"shape\": [\n                                        52.52069,\n                                        13.41523,\n                                        52.5205,\n                                        13.41547\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-77272541\",\n                                    \"length\": 39,\n                                    \"remainDistance\": 660,\n                                    \"remainTime\": 61,\n                                    \"shape\": [\n                                        52.5205,\n                                        13.41547,\n                                        52.52022,\n                                        13.41583\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-53500310\",\n                                    \"length\": 34,\n                                    \"remainDistance\": 620,\n                                    \"remainTime\": 59,\n                                    \"shape\": [\n                                        52.52022,\n                                        13.41583,\n                                        52.52013,\n                                        13.41595,\n                                        52.51998,\n                                        13.41614\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-704317753\",\n                                    \"length\": 49,\n                                    \"remainDistance\": 586,\n                                    \"remainTime\": 55,\n                                    \"shape\": [\n                                        52.51998,\n                                        13.41614,\n                                        52.51981,\n                                        13.41635,\n                                        52.51962,\n                                        13.41657\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-704317756\",\n                                    \"length\": 29,\n                                    \"remainDistance\": 537,\n                                    \"remainTime\": 52,\n                                    \"shape\": [\n                                        52.51962,\n                                        13.41657,\n                                        52.51956,\n                                        13.41664,\n                                        52.51951,\n                                        13.41669,\n                                        52.51939,\n                                        13.41679\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-704317755\",\n                                    \"length\": 35,\n                                    \"remainDistance\": 507,\n                                    \"remainTime\": 48,\n                                    \"shape\": [\n                                        52.51939,\n                                        13.41679,\n                                        52.51911,\n                                        13.41703\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-704285110\",\n                                    \"length\": 81,\n                                    \"remainDistance\": 472,\n                                    \"remainTime\": 45,\n                                    \"shape\": [\n                                        52.51911,\n                                        13.41703,\n                                        52.51894,\n                                        13.41718,\n                                        52.51876,\n                                        13.41732,\n                                        52.51845,\n                                        13.41755\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-704285109\",\n                                    \"length\": 53,\n                                    \"remainDistance\": 390,\n                                    \"remainTime\": 42,\n                                    \"shape\": [\n                                        52.51845,\n                                        13.41755,\n                                        52.51822,\n                                        13.41769,\n                                        52.518,\n                                        13.41781\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-77272580\",\n                                    \"length\": 56,\n                                    \"remainDistance\": 337,\n                                    \"remainTime\": 35,\n                                    \"shape\": [\n                                        52.518,\n                                        13.41781,\n                                        52.51777,\n                                        13.4179,\n                                        52.5175,\n                                        13.41799\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-1198028424\",\n                                    \"length\": 34,\n                                    \"remainDistance\": 280,\n                                    \"remainTime\": 30,\n                                    \"shape\": [\n                                        52.5175,\n                                        13.41799,\n                                        52.51719,\n                                        13.41807\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-1198028423\",\n                                    \"length\": 49,\n                                    \"remainDistance\": 245,\n                                    \"remainTime\": 25,\n                                    \"shape\": [\n                                        52.51719,\n                                        13.41807,\n                                        52.51701,\n                                        13.41811,\n                                        52.51675,\n                                        13.41815\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-734724633\",\n                                    \"length\": 26,\n                                    \"remainDistance\": 196,\n                                    \"remainTime\": 22,\n                                    \"shape\": [\n                                        52.51675,\n                                        13.41815,\n                                        52.51651,\n                                        13.41815\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-810879789\",\n                                    \"length\": 24,\n                                    \"remainDistance\": 169,\n                                    \"remainTime\": 17,\n                                    \"shape\": [\n                                        52.51651,\n                                        13.41815,\n                                        52.51629,\n                                        13.41813\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-810879788\",\n                                    \"length\": 68,\n                                    \"remainDistance\": 145,\n                                    \"remainTime\": 15,\n                                    \"shape\": [\n                                        52.51629,\n                                        13.41813,\n                                        52.51602,\n                                        13.41812,\n                                        52.51585,\n                                        13.41811,\n                                        52.51568,\n                                        13.41806\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-53507141\",\n                                    \"length\": 25,\n                                    \"remainDistance\": 77,\n                                    \"remainTime\": 13,\n                                    \"shape\": [\n                                        52.51568,\n                                        13.41806,\n                                        52.5156,\n                                        13.41803,\n                                        52.51546,\n                                        13.41798\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"-53507143\",\n                                    \"length\": 14,\n                                    \"remainDistance\": 52,\n                                    \"remainTime\": 6,\n                                    \"shape\": [\n                                        52.51546,\n                                        13.41798,\n                                        52.51541,\n                                        13.41818\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"53507142\",\n                                    \"length\": 24,\n                                    \"remainDistance\": 37,\n                                    \"remainTime\": 4,\n                                    \"shape\": [\n                                        52.51541,\n                                        13.41818,\n                                        52.51563,\n                                        13.41823\n                                    ],\n                                    \"functionalClass\": 3\n                                },\n                                {\n                                    \"linkId\": \"733292930\",\n                                    \"length\": 12,\n                                    \"remainDistance\": 12,\n                                    \"remainTime\": 3,\n                                    \"shape\": [\n                                        52.51563,\n                                        13.41823,\n                                        52.51606,\n                                        13.41825\n                                    ],\n                                    \"functionalClass\": 3\n                                }\n                            ],\n                            \"length\": 775,\n                            \"travelTime\": 71\n                        }\n                    ],\n                    \"summary\": {\n                        \"travelTime\": 71,\n                        \"distance\": 775,\n                        \"baseTime\": 71,\n                        \"trafficTime\": 71,\n                        \"flags\": []\n                    },\n                    \"searchResult\": {\n                        \"geometries\": []\n                    }\n                }\n            ],\n            \"warnings\": []\n        },\n        \"response_code\": \"200 OK\"\n    } Here you see that you can get the link id's of the roads that can be taken to the various locations within the custom layer that can be reached with a detour of 1000 meters. ERRORS If you have uploaded the custom layer following the custom location part-I blog , and try to use the isoline search to search places within the layer with a detour, you might get an error which looks like this: error {\n    \"issues\": [\n        {\n            \"message\": \"Missing column 'LINK_ID' in layer 'WAREHOUSES_DIST_3'\"\n        }\n    ],\n    \"error_id\": \"52e5f3c3-b0fe-4313-9b5a-f60f6f4f610b\",\n    \"response_code\": \"400 Bad Request\"\n} The issue here is that isoline search can ONLY be used if the uploaded layer of custom locations has a column named LINK_ID. This column contains a parameter associated with the road that connects to the loation. To retreive this LINK_ID, run a batch geocoder with one of the parameters of outcols as 'mapReferenceId' and locationattributes as 'mapReference'. The request should look like this. https://batch.geocoder.api.here.com/6.2/jobs?app_id=YOUR_APP_ID&app_code=YOUR_APP_CODE&action=run&header=true&indelim=,&outdelim=,&outcols=latitude,longitude,locationLabel,mapReferenceId&mailto=YOUR_EMAIL_ID&locationattributes=mapReference&outputcombined=true The body of this post request should contain the locations which you need in your layer. recId,searchText,country\n        1,\"Proskauer Straße 30, Friedrichshain,10247,Berlin\",Germany\n        2,\"Gärtnerstraße 26, Friedrichshain,10245,Berlin\",Germany\n        3,\"Wühlischstraße 17, Friedrichshain,10245,Berlin\",Germany The response is columns 'latitude,longitude,locationLabel,mapReferenceId'. Here the coulumn mapReferenceId will serve as your LINK_ID. Conclusion We have created a layer on top of the map with private locations. We have added, updated and deleted locations. We have searched for these locations within a radius, within a box and along an isoline. As much as fleet telematics is a prominent a use-case here, fun applications like maintaining a list of restaurants to visit or museums to visit can also be created using the same set of APIs by getting your credentials at the developer portal . Let me know what you think of the tutorial, try it yourself and feel free to ask questions. Happy coding!", "date": "2019-07-08"},
{"website": "Here", "title": "Visualize Data from a XYZ Space in harp.gl", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/visualize-data-from-a-xyz-space-in-harp.gl", "abstract": "We recently announced the beta release of harp.gl , our new 3D vector web rendering engine, and couldn't be happier for the positive feedback! Now that you've seen what harp.gl can do, let's start using it with other powerful tools we have introduced earlier this year. Our geospatial data storage and management solution, XYZ , integrates well with harp.gl. I'll show you how you can visualize a tiled data source from an XYZ Space inside harp.gl. Find data The first thing we'll need to do is get a hold of some data. A great site for this is the US government's data portal . This data portal is an aggregated site for data set across many of the government's agencies. Let's take a look at the National Wild and Scenic River Segments data set, for example. To download the data set, click on the Download button in the GeoJSON row. This will download an approximately 30mb sized file. Upload the data to an XYZ Space using the CLI. If you don't already have a HERE Developer account and have used XYZ before, now would be a good time to sign up . It's free to get started with and doesn't require a credit card to sign up. We'll be using the XYZ CLI to upload the data set to our XYZ Space. The CLI is great for uploading larger data sets. If you don't already have the CLI installed, be sure to install it from npm and then log in. If you already have the CLI installed on your machine, please skip this step. npm install -g @here/cli here configure account The first thing we'll want to do is create a new XYZ Space. We can do this with the following command: here xyz create -t \"rivers data\" -d \"https://catalog.data.gov/dataset/national-wild-and-scenic-river-segments-feature-layer-0fc13\" I supplied the title of the XYZ Space with the -t parameter and a description with the -d parameter. I generally like to put the data set's original URL as a description so I can easily retrieve the source in the event I'd like to revisit the data set. Next, we'll want to upload the rivers data set to the XYZ Space we just created: here xyz upload YOUR_SPACE_ID -f PATH_TO_FILE You'll need to replace YOUR_SPACE_ID with the space ID that was outputted to you after you ran the here xyz create command in the previous step. Additionally, please replace PATH_TO_FILE with the path to the file downloaded from the data.gov site. Your data has now been uploaded to an XYZ Space! To verify the data has been uploaded, you can run the following command here xyz show YOUR_SPACE_ID Set up the harp.gl map There are two ways to consume the harp.gl api: link a simple bundle as a <script> tag in your html install a set of node modules from npm In this blog post, we'll be using the simple bundle for simplicity's sake. For larger, more complex projects, we generally recommend using the node modules. You'll want to create a new directory with two files in it, an index.html and an index.js . mkdir rivers-map\ncd rivers-map\ntouch index.js\ntouch index.html You'll also want to set up a local server, for example in Python 2.x: python -m SimpleHTTPServer 8888 and in Python 3.x: python -m http.server 8888 Once you've created the new directory and the files within, open up index.html and add this code: <html>\n   <head>\n      <style>\n         body, html { border: 0; margin: 0; padding: 0; }\n         #map { height: 100vh; width: 100vw; }\n      </style>\n      <script src=\"https://unpkg.com/three/build/three.min.js\"></script>\n      <script src=\"https://unpkg.com/@here/harp.gl/dist/harp.js\"></script>\n   </head>\n   <body>\n      <canvas id=\"map\"></canvas>\n      <script src=\"index.js\"></script>\n   </body>\n</html> And then add the following within index.js : const TOKEN = 'YOUR_XYZ_TOKEN';\nconst SPACE_ID = 'YOUR_SPACE_ID';\nconst map = new harp.MapView({\n   canvas: document.getElementById('map'),\n   theme: \"https://unpkg.com/@here/harp-map-theme@latest/resources/berlin_tilezen_day_reduced.json\",\n});\n\nwindow.onresize = () => map.resize(window.innerWidth, window.innerHeight);\n\nmap.setCameraGeolocationAndZoom(\n   new harp.GeoCoordinates(-10.617488, -70.065335),\n   5\n);\n\nconst controls = new harp.MapControls(map);\ncontrols.maxPitchAngle = 90;\ncontrols.setRotation(20, 50);\n\nconst omvDataSource = new harp.OmvDataSource({\n   baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n   apiFormat: harp.APIFormat.XYZOMV,\n   styleSetName: \"tilezen\",\n   authenticationCode: TOKEN,\n});\nmap.addDataSource(omvDataSource); The above code initializes our new harp.gl map with a default reduced day theme. We are also setting the map's default center and zoom, while also adding the HERE base map with the harp.OmvDataSource class. Be sure to replace 'YOUR_XYZ_TOKEN' with your own XYZ token. To find your XYZ token, please run the following in your command line: here xyz token This command will output a few XYZ tokens to use. Copy and paste that into your code. We recommend using a read only token. This way, no one can overwrite your data set! Add the rivers data set to the harp.gl map Now that we've got the harp.gl base map configured, let's add the rivers data set to the map. We'll be using the OmvDataSource class again. We generally always use this class whenever we are adding vector tiles from a server. const xyzSpaceDataSource = new harp.OmvDataSource({\n   baseUrl: `https://xyz.api.here.com/hub/spaces/${SPACE_ID}/tile/web`,\n   apiFormat: harp.APIFormat.XYZSpace,\n   authenticationCode: TOKEN,\n}); We've initialized the data source, and now we'll add it to the map: map.addDataSource(xyzSpaceDataSource).then(() => {\n   const colorConfig = [\n      { classification: 'Wild', color: '#E85A3C' },\n      { classification: 'Recreational', color: '#3C7EE8' },\n      { classification: 'Scenic', color: '#D04FFF' }\n   ];\n\n   const styles = colorConfig.map(x => {\n      return {\n         \"when\": `$geometryType ^= 'line' && properties.CLASSIFICATION == '${x.classification}'`,\n         \"renderOrder\": 1000,\n         \"technique\": \"solid-line\",\n         \"attr\": {\n            \"color\": x.color,\n            \"metricUnit\": \"Pixel\",\n            \"lineWidth\": 3\n         }\n      }\n   });\n   xyzSpaceDataSource.setStyleSet(styles);\n   map.update();\n}); map.addDataSource() returns a promise, so we'll wait until the data has been added to the map. Once it's been added to the map, we will style the data with the harp.gl styling specification. I've decided to color each river by the classification type. The data has the following classification types: wild, recreational, and scenic. I created the colorConfig object to help with the code's cleanliness. We'll be creating an array of three style objects (one for each classification type) and passing it to the method .setStyleSet , which will apply the styling rules to the data set. The result of your map will look like: Wrapping up In just a few easy steps, we've created a great looking map of the different wild and scenic rivers across the United States. A natural next step of this map might be to create a map legend so viewers of the map can understand what classifications the different colors correlate to. You can take a look at the project's source code or live demo . In this blog post you've learned how to: find and download public data sets from open data sites upload data to an XYZ Space with the command line interface initialize a basic harp.gl map add a tiled data set from an XYZ Space to a harp.gl map For more location technology and visualization content, follow @dbabbs or @heredev on Twitter.", "date": "2019-06-28"},
{"website": "Here", "title": "Building Location-Aware Chatbots with Amazon Lex and HERE Location Services", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/building-location-aware-chatbots-with-amazon-lex-and-here-location-services", "abstract": "You might remember that I was recently on a Twitch live-stream with Michael Palermo talking about AWS Lex and how you can use it with HERE. While we do have a workshop on the subject as well, I thought I could add my own spin on the subject in an effort to make the process even easier for new developers to the material. In this tutorial we’re going to see how to use Amazon Lex with HERE Location Services (HLS) to build a chatbot. This particular tutorial will depend on JavaScript knowledge since we’ll be using Node.js with AWS Lambda. Creating the AWS Lex Sample Utterances, Intents, and Slot Variables Before we start adding location logic or any logic for that matter, we need to configure our Lex chatbot. To do this we’ll need to design each of our intents, provide sample phrase data or sample utterance data and then provide any variables that we want the user to be able to use. Go to the Lex dashboard in AWS and create a new custom chatbot. After creating the chatbot, you’ll be given the opportunity to create intents. An intent behaves like a route to do logic. Think of each intent as a different request for functionality. We’re going to create two intents for our project, an AboutIntent and a PositionIntent . Starting with the AboutIntent , we need to add some sample utterance data. Sample utterances are possible phrases that can be used to access the intent. Think of everything your user might ask in an attempt to get information. I added the following: give me information about this bot\nwho made this bot I’ve added two, but you should probably add significantly more. The more the better, not because you’re guessing what the user might ask, but Lex actually gets smarter and can start making assumptions based on the data you’ve taught it. Now let’s look at our PositionIntent which will eventually be connected to HERE. This intent is a little different because we want the user to be able to provide data. These are known as slot variables and they aren’t difficult to configure. Let’s assume we want the user to provide latitude and longitude information with the expectation they will receive an address in return. The user might ask the following: what is the address at latitude 37 and longitude -121\nwhere is longitude -121 and latitude 37 Of course we’re going to have a lot more potential phrases, but you can get the idea. However, the user likely won’t ask for the same position that I’ve requested. We can replace that data with our slot variables like so: what is the address at latitude {Latitude} and longitude {Longitude}\nwhere is longitude {Longitude} and latitude {Latitude} We can then define those slots further down on the screen as AMAZON.NUMBER types. This tells Amazon to expect dynamic data that are numerics, so that way it can be processed correctly. Developing the Response Logic with Node.js and AWS Lambda When working with Lex, there are strict expectations on what the request objects and response objects look like. To be more clear, Lex will provide a request object to our backend and our backend must respond with an object. To get an idea of our request object, Lex might give us something that looks like the following: {\n    \"currentIntent\": {\n        \"name\": \"ProfileIntent\",\n        \"slots\": {\n            \"Address\": \"California\",\n            \"FullName\": \"Nic Raboy\"\n        },\n        \"confirmationStatus\": \"\"\n    },\n    \"bot\": {\n        \"name\": \"nraboys_bot\",\n        \"alias\": \"nics_bot\",\n        \"version\": \"1.0.0\"\n    },\n    \"userId\": \"nraboy\",\n    \"inputTranscript\": \"\",\n    \"invocationSource\": \"DialogCodeHook\",\n    \"outputDialogMode\": \"Text\",\n    \"messageVersion\": \"1.0\",\n    \"sessionAttributes\": {},\n    \"requestAttributes\": {}\n} The plan is to work with this object directly with JavaScript. Only the currentIntent information is particularly important to us in this example. Based on this object, you can see Lex has already done the heavy lifting for us by determining the intent to use and the slot variables to use with it. When it comes to a response, Lex expects the following format: {\n    sessionAttributes: {},\n    dialogAction: {\n        type: \"Close\",\n        fulfillmentState: \"Fulfilled\",\n        message: {\n            \"contentType\": \"PlainText\",\n            \"content\": \"Hello World!\"\n        }\n    }\n} Of course there are changes that can be made, but for this example the above response object is more than suitable. Knowing what we know now, we can build a simple Lambda function. On your computer, create a new directory and execute the following from inside: npm init -y\ntouch index.js If you don’t have access to the touch command, create the index.js file manually. With the project created, we can add our code. Open the project’s index.js file and include the following: const dispatcher = async (event) => {\n    let response = {\n        sessionAttributes: event.sessionAttributes,\n        dialogAction: {\n            type: \"Close\",\n            fulfillmentState: \"\",\n            message: {\n                \"contentType\": \"PlainText\",\n                \"content\": \"\"\n            }\n        }\n    };\n    switch(event.currentIntent.name) {\n        case \"AboutIntent\":\n            response.dialogAction.fulfillmentState = \"Fulfilled\";\n            response.dialogAction.message.content = \"Created by Nic Raboy at HERE\";\n            break;\n        default:\n            response.dialogAction.fulfillmentState = \"Failed\";\n            response.dialogAction.message.content = \"I don't know what you're asking...\";\n            break;\n    }\n    return response;\n}\n\nexports.handler = (event, context) => {\n    return dispatcher(event);\n} Notice in the above example that we have one intent which is accessible through our dispatcher function. If we are provided any other intent, we’ll visit our fallback statement. Remember, our goal is to process that Lex object in the request. Including Location Logic with HERE Location Services Now that we have our basic Lambda function created, we can start making requests to HERE. For this example, we’re assuming the user has provided latitude and longitude information in a chat. The user provides this information because they want address information which can be determined through the reverse geocoder. This is not a terribly exciting example, but it works well and can easily be changed to be more useful. Before we can start using the HERE, we need to install a package for making HTTP requests. From the command line, execute the following: npm install request --save\nnpm install request-promise --save If we go back into our index.js file, we can import the package that we just downloaded and then make use of it within our dispatcher method: const Request = require(\"request-promise\");\n\nconst dispatcher = async (event) => {\n    // ...\n    switch(event.currentIntent.name) {\n        // ...\n        case \"PositionIntent\":\n            let slots = event.currentIntent.slots;\n            let result = await Request(\n                \"https://reverse.geocoder.api.here.com/6.2/reversegeocode.json\",\n                {\n                    qs: {\n                        \"app_id\": \"APP_ID_HERE\",\n                        \"app_code\": \"APP_CODE_HERE\",\n                        \"mode\": \"retrieveAddresses\",\n                        \"prox\": slots.Latitude + \",\" + slots.Longitude\n                    },\n                    json: true\n                }\n            );\n            response.dialogAction.fulfillmentState = \"Fulfilled\";\n            response.dialogAction.message.content = result.Response.View[0].Result[0].Location.Address.Label;\n            break;\n        default:\n            // ...\n    }\n    return response;\n} In the above code, I commented out the things we had added prior. Instead, take focus of the PositionIntent that we’ve added to the dispatcher function. In this statement, we extract the Latitude and Longitude slot that we defined in Lex. Using this information, along with the HERE token information, we can make a request to the HERE Reverse Geocoder API . The HTTP request is an asynchronous operation, which we can use with an async / await in JavaScript. When complete, we can add the Label from the response and then return our object to Lex. Packaging the AWS Lambda Function for Deployment Because we’re using an external package and not just a single vanilla JavaScript file, we need to package our project before submitting to Lambda. To do this we can execute the following: zip -r handler.zip * The above command will recursively ZIP our entire working directory, including our source code and node_modules directory. If you don’t have a zip command line function, do it manually. If your project includes native dependencies designed specifically for macOS, Windows, or Linux, you’ll need to include more steps in your packaging process. You can learn more about this in my previous tutorial titled, Deploying Native Node.js Dependencies on AWS Lambda . This project does not currently use native dependencies, so we are fine. At this point in time the Lambda project can be added to AWS Lambda. Connecting Lex Intents to the AWS Lambda Function While we do have Lex configured and our Lambda function developed, the two are not yet communicating with each other. To do this you need to point each intent to Lambda from within the Lex dashboard. Within each of the intents, choose AWS Lambda function as the Fulfillment option. When you do this, you can save your intent and then rebuild your project. Instead of responding with information about the request, the response from Lambda will be used. Conclusion You just saw how to build a chatbot with Amazon Lex that has location functionality through HERE Location Services. If you haven’t already seen the episode of AWS Connections featuring Lex , I encourage you to watch it. For further learning, you could also check out another getting started tutorial I wrote on the subject.", "date": "2019-06-27"},
{"website": "Here", "title": "Real-Time Maps with a Raspberry Pi, Golang, and HERE XYZ", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/real-time-maps-with-a-raspberry-pi-golang-and-here-xyz", "abstract": "By now you’ve probably seen a few of my tutorials related to Raspberry Pi and location data. I’m a big fan of these small Internet of Things (IoT) devices and have written tutorials around WLAN positioning with Golang and GPS positioning with Node.js . I wanted to continue down the Golang route and do a tutorial around GPS positioning and storing that data in HERE XYZ to be viewed in real-time. In other words, have a Raspberry Pi collect GPS data with Golang, push it to HERE XYZ, and view it on some web client in real-time by querying the data in HERE XYZ. We’re going to see how to accomplish all of this and if everything goes smooth, we might end up with something like the following: The above image is a result of what I got when I drove around with the Raspberry Pi in my car. The Requirements There are a few requirements that must be met to be successful with this tutorial. Variations could probably be used, but I can only confirm what’s worked for me. In terms of hardware, I’m using the following: Raspberry Pi Zero W NEO 6M GPS Active External Antenna U.FL Adapter for External Antenna You could probably get away with using any of the Raspberry Pi models that have WiFi. If you have an LTE module for your Raspberry Pi, even better, because I was just tethering to my phone in the car for access to the internet. The GPS module is the same module that I referenced in my previous tutorial where it was directly connected to my computer. You’ll need an antenna for it otherwise it could take days to get a fix on the satellites. In terms of software and services, you’ll need the following: Golang installed on your host development computer A free HERE account You’ll need a HERE account to configure HERE XYZ for storing your location data. Since Golang compiles to native binaries, you just need it on your development computer. If you try to develop on your Raspberry Pi, the build process might be slow due to the weaker hardware specifications. Collecting GPS Data on the Raspberry Pi with Golang If you’ve read my previous tutorial titled, Reverse Geocoding NEO 6M GPS Positions with Golang and a Serial UART Connection , some of this will look familiar. It doesn’t hurt to have a refresher though. Before you create a new project, execute the following commands: go get github.com/paulmach/go.geojson\ngo get github.com/adrianmo/go-nmea\ngo get github.com/jacobsa/go-serial/serial The above commands will get our necessary packages to save us a lot of development time. The serial package will allow us to access the serial connection between Raspberry Pi and GPS module, the go-nmea package will allow us to parse the raw GPS data into something we can understand, and the go.geojson package will allow us to create GeoJSON formatted data to be sent to HERE XYZ. With the necessary packages available, create a main.go file somewhere within your $GOPATH and add the following boilerplate code: package main\n\nimport (\n    \"bufio\"\n    \"bytes\"\n    \"flag\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n    \"net/url\"\n    geojson \"github.com/paulmach/go.geojson\"\n    \"github.com/adrianmo/go-nmea\"\n    \"github.com/jacobsa/go-serial/serial\"\n)\n\ntype HereDev struct {\n    Token   string `json:\"token\"`\n    SpaceId string `json:\"space_id\"`\n}\n\nfunc NewGeoJSON(latitude float64, longitude float64) ([]byte, error) {}\nfunc (here *HereDev) PushToXYZ(data []byte) ([]byte, error) {}\nfunc main() {} Because we plan to access the HERE XYZ API and that API requires a space id and token, we’re creating a data structure to hold that information. We’ll be creating a NewGeoJSON function to create GeoJSON formatted data and a PushToXYZ function to push our GeoJSON data to HERE XYZ. However, we’ll worry about that in a bit. Let’s take a look at our main function: func main() {\n    options := serial.OpenOptions{\n        PortName:        \"/dev/ttyS0\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n} The above code is a good starting point. What we’re saying is to open the /dev/ttyS0 serial port on the Raspberry Pi and use a baud rate of 9600. For any data that comes in, we’re going to access it with a Scanner and print it out. We’re using a Scanner because we want complete lines of data, not bits and pieces. So what does the Raspberry Pi and NEO 6M wire configuration look like? Mine looks like the following: In case you’re new to Raspberry Pi and the GPIO pin configurations, or it is difficult to see in the image, my wire configuration is like the following: GPS VCC to RPI 5V (Red) GPS GND to RPI GND (Black) GPS TX to RPI RXD (Green) GPS RX to RPI TXD (White) If you don’t have a pin template from Adafruit or similar, get one because it is a worthy investment since the pins are not labeled on the hardware itself. Just having connected the GPS module and the Raspberry Pi isn’t good enough. The serial port still needs to be enabled through the software settings of the Raspberry Pi. You can use the raspi-config tool in Raspbian to do this. If you’re unfamiliar, please check out my previous tutorial titled, Interacting with a NEO 6M GPS Module using Golang and a Raspberry Pi Zero W , which includes images and thorough details. Now that we’re collecting data from the serial connection, we need to parse it. This can be easily accomplished with the NMEA library that we had installed. Let’s update the main function to look like the following: func main() {\n    options := serial.OpenOptions{\n        PortName:        \"/dev/ttyS0\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    for scanner.Scan() {\n        s, err := nmea.Parse(scanner.Text())\n        if err == nil {\n            if s.DataType() == nmea.TypeGGA {\n                data := s.(nmea.GGA)\n                if data.Latitude != 0 && data.Longitude != 0 {\n                    // Print out position data...\n                }\n            }\n        }\n    }\n} We’re taking the text from the Scanner and we’re parsing it. My GPS unit provides GPGGA formatted strings, but yours might differ. Figure out what yours returns and check for it before you try to print out latitude and longitude information. You’ll want to make sure you’re parsing it correctly. Sending GeoJSON Data to HERE XYZ with Golang We have latitude and longitude information, but we can’t really send that directly to HERE XYZ. Instead, we need to create a GeoJSON compliant object to be sent instead. Within your main.go file, create the following function: func NewGeoJSON(latitude float64, longitude float64) ([]byte, error) {\n    featureCollection := geojson.NewFeatureCollection()\n    feature := geojson.NewPointFeature([]float64{longitude, latitude})\n    featureCollection.AddFeature(feature)\n    return featureCollection.MarshalJSON()\n} The above function will take a latitude and longitude coordinate and create a new feature collection from it. If we wanted to get a little more extravagant, we could create tags for our data and other properties, but we won’t for this example. After we parse our data we can now make use of the NewGeoJSON function like so: for scanner.Scan() {\n    s, err := nmea.Parse(scanner.Text())\n    if err == nil {\n        if s.DataType() == nmea.TypeGGA {\n            data := s.(nmea.GGA)\n            if data.Latitude != 0 && data.Longitude != 0 {\n                gjson, err := NewGeoJSON(data.Latitude, data.Longitude)\n                if err != nil {\n                    log.Fatal(err)\n                }\n                fmt.Println(string(gjson))\n            }\n        }\n    }\n} I actually wrote a similar tutorial titled, How to Work with GeoJSON Data in Golang for HERE XYZ , if you want to get more information on working with GeoJSON data in Golang. This is where we start to get involved with HERE XYZ. Our data is ready to go, so we need to be able to send it from our Raspberry Pi as it is collected and store it on HERE XYZ. We’re going to use a mixture of the XYZ CLI and web portals for this. This should be done on your host computer, not the Raspberry Pi. Install the XYZ CLI by executing the following: npm install -g @here/cli After installing the CLI your HERE account needs to be registered to it. This can be done by executing the following: here configure account Make sure to provide your credentials when prompted. This information will be stored securely and locally on your computer. With the CLI configured, a new XYZ project needs to be created. To do this, execute the following: here xyz create --title \"raspberry-pi-project\" --message \"data from the raspberry pi\" The above command will create a new XYZ space that can be accessed from the CLI or from the web dashboards. Make note of the space id that is returned because it is necessary within the Golang code as well as our interactive map code. We’re also going to need an access token for our space. Open the token dashboard and choose to generate a new token for your space. Make sure you take note of the token because it too will be used with the space id in the Go code and the interactive map code. At any point if you wish to view the data you’ve uploaded, you can visit the Data Hub in XYZ Studio . Now that we have a space id and an access token, we can continue our project development. Add the following to the main.go file: func (here *HereDev) PushToXYZ(data []byte) ([]byte, error) {\n    endpoint, _ := url.Parse(\"https://xyz.api.here.com/hub/spaces/\" + here.SpaceId + \"/features\")\n    request, _ := http.NewRequest(\"PUT\", endpoint.String(), bytes.NewBuffer(data))\n    request.Header.Set(\"Content-Type\", \"application/geo+json\")\n    request.Header.Set(\"Authorization\", \"Bearer \"+here.Token)\n    client := &http.Client{}\n    response, err := client.Do(request)\n    if err != nil {\n        return nil, err\n    } else {\n        return ioutil.ReadAll(response.Body)\n    }\n} The above PushToXYZ function will take our GeoJSON data and do an HTTP request against the HERE XYZ API. The response isn’t too useful to us for this example, but we’ll return it anyways. For more information on making HTTP requests with Golang, check out my previous tutorial titled, Consume RESTful API Endpoints within a Golang Application . Go back into the main function and update it to the following: func main() {\n    options := serial.OpenOptions{\n        PortName:        \"/dev/ttyS0\",\n        BaudRate:        9600,\n        DataBits:        8,\n        StopBits:        1,\n        MinimumReadSize: 4,\n    }\n    serialPort, err := serial.Open(options)\n    if err != nil {\n        log.Fatalf(\"serial.Open: %v\", err)\n    }\n    defer serialPort.Close()\n    reader := bufio.NewReader(serialPort)\n    scanner := bufio.NewScanner(reader)\n    here := HereDev{Token: \"ACCESS_TOKEN_HERE\", SpaceId: \"ACCESS_TOKEN_HERE\"}\n    for scanner.Scan() {\n        s, err := nmea.Parse(scanner.Text())\n        if err == nil {\n            if s.DataType() == nmea.TypeGGA {\n                data := s.(nmea.GGA)\n                if data.Latitude != 0 && data.Longitude != 0 {\n                    gjson, err := NewGeoJSON(data.Latitude, data.Longitude)\n                    if err != nil {\n                        log.Fatal(err)\n                    }\n                    here.PushToXYZ(gjson)\n                }\n            }\n        }\n    }\n} In the above code we are initializing our here variable and we are making use of it after we’ve generated our GeoJSON data. This Golang example has one job and it is to push data to XYZ. To build our application for use on a Raspberry Pi, we can run the following: GOOS=linux GOARCH=arm GOARM=5 go build The above command will build a binary meant for ARM which is what the Raspberry Pi uses. For more on cross-compiling, check out a previous tutorial I wrote. Collect GPS Data at Boot Our application should work if we transfer it to a Raspberry Pi. However, we might want to make it so it auto-starts when we turn on the Raspberry Pi. To do this we need to create a service. Add the following to a tracking.service file in the /etc/systemd/system/ path of your Raspberry Pi: [Unit]\nDescription=GPS-Project\nDocumentation=\nWants=network-online.target\nAfter=network-online.target\nAssertFileIsExecutable=/usr/local/bin/gps-project\n\n[Service]\nWorkingDirectory=/usr/local/\n\nUser=root\nGroup=staff\n\nExecStart=/usr/local/bin/gps-project\n\nRestart=always\n\nLimitNOFILE=65536\n\nTimeoutStopSec=infinity\nSendSIGKILL=no\n\n[Install]\nWantedBy=multi-user.target The above service assumes a few things. It assumes that your binary is called gps-project and it exists in the /usr/local/bin path. It also assumes the owner is root and the group is staff . Finally, it has to have execute permissions. Feel free to adjust the above service as you feel necessary. With the binary and service in place, execute the following: systemctl enable tracking.service Now the binary should run in the background every time the Raspberry Pi starts. This means that if you’re like me, you can hop in your car, plug the Raspberry Pi into a USB port and have it start collecting data on its own without any host computer involved. Displaying Route Data from HERE XYZ on a Map in Real-Time At this point in time we should have a Raspberry Pi sending GPS data to HERE XYZ. Now we need a way to visualize that data on a map, preferably in near real-time. We need to create a separate project. Create an index.html file with the following boilerplate HTML markup: <html>\n    <head>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.css\" />\n    </head>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh\"></div>\n        <script src=\"https://unpkg.com/leaflet@1.4.0/dist/leaflet.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js\"></script>\n        <script src=\"https://cdnjs.cloudflare.com/ajax/libs/geojson/0.5.0/geojson.min.js\"></script>\n        <script>\n            const start = async () => {\n                const tiles = \"https://1.base.maps.api.here.com/maptile/2.1/basetile/newest/normal.day/{z}/{x}/{y}/512/png8?app_id={appId}&app_code={appCode}\";\n                const map = new L.Map(\"map\", {\n                    center: [37, -121],\n                    zoom: 11,\n                    layers: [L.tileLayer(tiles, { appId: \"HERE_APP_ID\", appCode: \"HERE_APP_CODE\" })]\n                });\n                var polyline, sourceMarker, destinationMarker;\n                setInterval(async () => {}, 5000);\n            }\n            start();\n        </script>\n    </body>\n</html> The above code will use Leaflet.js and the HERE Map Tile API. To protect my privacy, I chose to use basetiles which include no street label information. You can pick whatever works best for you. Make sure to replace the app id and app code values with those of your own. So far our code will just show a map on the screen. Now we want to draw our path of travel and center on it. We’re even going to update the map automatically to look for new changes. Let’s take a look at our setInterval usage: setInterval(async () => {\n    const response = await axios({\n        method: \"GET\",\n        url: \"https://xyz.api.here.com/hub/spaces/\" + \"XYZ_SPACE_ID\" + \"/search\",\n        params: {\n            access_token: \"XYZ_TOKEN\"\n        }\n    });\n    map.eachLayer(layer => {\n        if(!layer._url) {\n            layer.remove();\n        }\n    });\n    const polylineData = [];\n    response.data.features.forEach(feature => {\n        let position = feature.geometry.coordinates;\n        polylineData.push({ lat: position[1], lng: position[0] });\n    });\n    polyline = new L.Polyline(polylineData, { weight: 5 });\n    sourceMarker = new L.Marker(polylineData[0]);\n    destinationMarker = new L.Marker(polylineData[polylineData.length - 1]);\n    polyline.addTo(map);\n    sourceMarker.addTo(map);\n    destinationMarker.addTo(map);\n    const bounds = new L.LatLngBounds(polylineData);\n    map.fitBounds(bounds);\n}, 5000); The above code says that every 5000ms, we will make an HTTP request to the HERE XYZ API. Instead of adding data we are querying it. After doing our HTTP request, we clear the map. Remember we’re repeating this so we don’t want old lines and markers to appear every 5000ms. After clearing the map, we look at the GeoJSON that comes back, and draw new polylines and markers. We’re pretty much just connecting each of the points that are coming back in our XYZ query. Conclusion You just saw quite a few things in this tutorial. We saw how to collect GPS position data on a Raspberry Pi, parse it, and upload it to HERE XYZ. In my circumstance, I had my Raspberry Pi Zero W in my car and it was publishing my position data in real-time as I drove around. We then saw how to query HERE XYZ for our data and display it on a map. If we wanted to, someone could view the map and see us driving around in real-time. This tutorial was an upgrade to my previous tutorial titled, Tracking a Raspberry Pi with WLAN and Golang, then Displaying the Results with HERE XYZ , which used WLAN instead of GPS. We also made use of the HERE XYZ API instead of manually processing our data.", "date": "2019-06-20"},
{"website": "Here", "title": "Validate Street Addresses with Vue.js and the HERE Geocoder Autocomplete API", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/validate-street-addresses-with-vue.js-and-the-here-geocoder-autocomplete-api", "abstract": "When it comes to geocoding, being able to convert addresses to latitude and longitude coordinates so they can be displayed on a map is not the only use-case. A lot of times being able to geocode an address makes for great address validation to see if an address actually exists. Take for example a tutorial written by Jayson DeLancey titled, Street Address Form Validation with ReactJS and HERE Geocoder Autocomplete . In this tutorial he demonstrated how to accept user input, offer suggestions, and ultimately check to see if the addresses are valid using React and the APIs found in the HERE Developer Portal . We’re going to change it up a bit. Instead of using React, we’re going to try to validate addresses using Vue.js , another very popular framework for web development. To get a sense of what we’re going to accomplish, take a look at the following animated image: When we enter a query of any complexity, the HERE Autocomplete API starts to return suggestions which we use to populate the read-only form below the query box. These suggestions are valid addresses. However, we go a step further and use the HERE Geocoder API to see if what we’ve actually typed as a query is valid. We don’t have to use one of the suggestions. We need to make note of something before continuing. While the HERE Geocoder API does a good job at validating street addresses, it is probably not suitable for validating shipping addresses. For example, it might not be able to determine a specific unit in an apartment complex or business. That unit information is kind of important when it comes to shipping. What we’re validating is street addresses. Creating a New Project with the Vue CLI Assuming you have the Vue CLI installed and configured, we can start by creating a new project with the following command: vue create address-validation When prompted, choose the defaults. We’re not doing anything too complex so we won’t need Vuex, or routing, or anything fancy like that. We’re also not going to be using any external JavaScript dependencies because we’ll be using HTTP requests against a RESTful API. Before we start adding core logic, we need to configure our component and get a basic form showing on the screen. When creating a project, we’re given a src/components/HelloWorld.vue file, but we’re going to rename it to src/components/HereAddressLookup.vue instead. This file should include the following to start: <template>\n    <div class=\"information\">\n        <div>\n            <label for=\"street\">Street</label><br />\n            <input type=\"text\" v-model=\"street\" disabled />\n        </div>\n        <div>\n            <label for=\"city\">City</label><br />\n            <input type=\"text\" v-model=\"city\" disabled />\n        </div>\n        <div>\n            <label for=\"state\">State</label><br />\n            <input type=\"text\" v-model=\"state\" disabled />\n        </div>\n        <div>\n            <label for=\"postcode\">Postal Code</label><br />\n            <input type=\"text\" v-model=\"postcode\" disabled />\n        </div>\n        <div>\n            <label for=\"country\">Country</label><br />\n            <input type=\"text\" v-model=\"country\" disabled />\n        </div>\n    </div>\n</template>\n\n<script>\n    export default {\n        name: \"HereAddressLookup\",\n        data() {\n            return {\n                street: \"\",\n                city: \"\",\n                state: \"\",\n                postcode: \"\",\n                country: \"\"\n            };\n        },\n        props: {\n            query: String\n        },\n        watch: { },\n        methods: { }\n    }\n</script>\n\n<style scoped>\n    .information {\n        width: 50%;\n        margin: 15px 0px;\n    }\n    .information input {\n        width: 100%;\n        padding: 5px;\n        margin: 5px 0px;\n    }\n</style> You’ll notice the above code is a little more than the basic code that you get when creating a project. We’ve created a simple form in the <template> block, styled that form int he <style> block, and assigned variables to each form element through the v-model properties. These variables are found in the data method of the class. Also take note that this particular component will have one user defined HTML property, which is for search query information. To make this component active, we need to make some modifications to the src/App.vue file: <template>\n    <div id=\"app\">\n        <div>\n            <label for=\"query\">Query</label><br />\n            <input type=\"text\" v-model=\"query\" />\n        </div>\n        <HereAddressLookup :query=\"query\"/>\n        <button type=\"button\">Validate</button>\n    </div>\n</template>\n\n<script>\n    import HereAddressLookup from './components/HereAddressLookup.vue'\n\n    export default {\n        name: 'app',\n        components: {\n            HereAddressLookup\n        },\n        data() {\n            return {\n                query: \"\"\n            };\n        },\n        methods: { }\n    }\n</script>\n\n<style>\n    input[type=\"text\"] {\n        width: 50%;\n        padding: 5px;\n        margin: 5px 0px;\n    }\n</style> Just like with the previous file, this file has a little more than the basics. We are adding the HereAddressLookup component tag to the <template> block along with other form information. Our actual component doesn’t accept queries through a form, so we’re going to be doing that in the App component. The text field is bound to a query variable and that query variable is being used in the HereAddressLookup tag on the query property that we defined. It is coincidence that we named the variable and the property the same, it is not a requirement. We have the foundation of our application in place, so now we can start to accomplish what we set out to do. Watching for Changes to a Search Query The first thing that we want to accomplish is address suggestions. When a user enters address information into the box, we want suggestions to appear in our component to help the user. This will be accomplished by watching the box for changes and using the HERE Autocomplete API. Open the project’s src/components/HereAddressLookup.vue file and include the following watch object to the class: watch: {\n    query: function(value) {\n        fetch(`https://autocomplete.geocoder.api.here.com/6.2/suggest.json?app_id=APP_ID_HERE&app_code=APP_CODE_HERE&maxresults=1&query=${value}`)\n            .then(result => result.json())\n            .then(result => {\n                if(result.suggestions && result.suggestions.length > 0) {\n                    if(result.suggestions[0].address.houseNumber && result.suggestions[0].address.street) {\n                        this.street = result.suggestions[0].address.houseNumber + \" \" + result.suggestions[0].address.street;\n                    } else {\n                        this.street = \"\";\n                    }\n                    this.city = result.suggestions[0].address.city ? result.suggestions[0].address.city : \"\";\n                    this.state = result.suggestions[0].address.state ? result.suggestions[0].address.state : \"\";\n                    this.postcode = result.suggestions[0].address.postalCode ? result.suggestions[0].address.postalCode : \"\";\n                    this.country = result.suggestions[0].address.country ? result.suggestions[0].address.country : \"\";\n                } else {\n                    this.street = \"\";\n                    this.city = \"\";\n                    this.state = \"\";\n                    this.postalCode = \"\";\n                    this.country = \"\";\n                }\n            }, error => {\n                console.error(error);\n            });\n    }\n} The watch object is where you define functions that trigger when certain variables change. For example, we have a query function which based on its name is mapped to the query variable. In this application the query variable is declared through the props object. So every time that query property changes, this function will trigger. Let’s dig a little deeper into this query function. When executed we make use of an HTTP request through the fetch function in JavaScript. In the above code, make sure you swap the app id and app code with your own tokens found in the HERE Developer Portal . When we get our results, we do some checks to see if certain fields were left undefined. For example, if we have Cupertino, CA as our query, the street information will most certainly not be available in the suggestion. If the fields are available, we set the bound variables so they appear in our form. Because the component property is already bound in the App component, we could run this and we’d receive suggestions based on the keyboard input. To throttle the requests, you could enforce at least X amount of characters are present before making a suggestion. Validating an Address and Analyzing the Match Quality Suggestions are not really validations because at the end of the day, we want to validate the query that the user provides. To do this, we need to make some additions to our HereAddressLookup component. Take the following function in the methods object: methods: {\n    validate: function(query) {\n        return fetch(`https://geocoder.api.here.com/6.2/geocode.json?app_id=APP_ID_HERE&app_code=APP_CODE_HERE&searchtext=${query}`)\n            .then(result => result.json())\n            .then(result => {\n                if(result.Response.View.length > 0 && result.Response.View[0].Result.length > 0) {\n                    let data = result.Response.View[0].Result[0];\n                    return data;\n                }\n            }, error => {\n                console.error(error);\n            });\n    }\n} We’re following a similar strategy with our validate function as we saw in the query function. We are doing a fetch , but this time to the HERE Geocoder API. Make sure you swap the app id and app code tokens with your own, which are found in the HERE Developer Portal . The data we get back from our request will be similar to the Autocomplete API. However, along with address information, and latitude and longitude information, we’re also getting match quality information. In most circumstances, if you provide a query to the Geocode API you’ll get an address and coordinates back, but that doesn’t necessarily mean your query is accurate because it will search on a threshold. Take a look at the following information in the response: { \n    \"State\": 1, \n    \"City\": 1, \n    \"Street\": [ 1 ],\n    \"Country\": 1\n} A value of 1 means there was an exact match. Any number less than 1 means it wasn’t an exact match. If fields are missing, it means that information wasn’t provided, which we can also translate to a non-match. Let’s add some more logic to our application. Open the project’s src/App.vue file and include the following in the data function: data() {\n    return {\n        query: \"\",\n        position: null,\n        quality: null,\n    };\n}, We’re adding two more variables which we’ll use to display data after a validation request is made. We can add them to the <template> block like so: <div v-if=\"position && quality\">\n    <p>{{ position }}</p>\n    <p>{{ quality }}</p>\n</div> The last thing we need to do is execute the validation request. We can do this by creating another method in our App component and slightly changing what we’re doing in the <template> block. Our final <template> should look like the following: <template>\n    <div id=\"app\">\n        <div>\n            <label for=\"query\">Query</label><br />\n            <input type=\"text\" v-model=\"query\" />\n        </div>\n        <HereAddressLookup ref=\"validator\" :query=\"query\"/>\n        <div v-if=\"position && quality\">\n            <p>{{ position }}</p>\n            <p>{{ quality }}</p>\n        </div>\n        <button type=\"button\" @click=\"validate()\">Validate</button>\n    </div>\n</template> Notice that we’ve now added a ref property to the <HereAddressLookup> tag. We need to gain reference to our component so we can call functions within it. We’ve also added a validate function to our button based on a click event. Our validate function would exist in our App component and it would look like this: methods: {\n    validate: function() {\n        this.$refs.validator.validate(this.query).then(result => {\n            this.quality = result.MatchQuality;\n            this.position = result.Location.DisplayPosition;\n        }, error => {\n            console.error(error);\n        });\n    }\n} We can gain access to the component reference and take the data in our query variable to run validation. In our example, we’re not actually doing anything with the match quality data. In your example, you may want to perform logic based on that information. Conclusion You just saw how to validate street addresses using Vue.js, the HERE Autocomplete API, and the HERE Geocoder API. This tutorial was inspired by Jayson DeLancey’s tutorial which focused on React instead of Vue.js. Like I mentioned earlier, while this is great for street address validation, it should be used with caution for shipping validation. Remember, you have to account for businesses sharing a building or apartment units.", "date": "2019-07-02"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.5 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.5-release", "abstract": "Highlights Rate Changes for HERE Credits HERE credit rate changes went into effect on June 1. The new rates will be applied to your account starting on the anniversary billing date of your organization. To make it easy to track which rates applied to which usage, the HERE credit usage report has been enhanced (at https://platform.here.com/profile/credit-usage ). Now there are alerts displayed when a rate change has occurred over the period which was queried. We've also added a table to show historical HERE credit rates: https://platform.here.com/profile/credit-usage/history . For more about the upcoming rate changes, see the announcement . New Layers in HERE Map Content The HERE Map Content catalog has new layers: Administrative Index: a standard layer which provides HERE Tile IDs for various locations published by the Administrative Places layer Sign Text: a HERE Premium layer that publishes textual and graphic information posted on signs along roads Environmental Zones: a HERE Premium layer that publishes area-restrictions & regulations based on environmental criteria Note HERE Premium layers may incur additional usage fees. For more information, see https://openlocation.here.com/plans . New Data Source for HERE Weather The HERE Live Weather North America and HERE Archive Weather North America catalogs now include a new high quality Multi-Radar/Multi-Sensor (MRMS) source from NOAA. This will result in expanded and more granular coverage for North America. Inspect Batch Pipelines with Spark UI You can now use the Spark UI to inspect your batch pipelines in the deployed OLP cloud environment. With this, you can view the execution and performance details of a currently-running Spark job, helping you to fine-tune and troubleshoot your pipeline configuration and logic. To access the Spark UI, go to the Jobs tab for a running pipeline version and select the link to open the Spark UI from the actively-running job. When the job terminates (success or failure), the Spark UI will no longer be available. Contact Email for Pipelines You can now provide one email address for each pipeline, so that we can provide better support and communication for situations that might affect your pipeline operations. Such situations include: Planned outages Security or patch updates that require us to restart your pipeline We request that you provide an email address for each of your pipelines, otherwise we cannot notify you of potential interruptions. We recommend specifying an email distribution list—instead of an individual email—so that all of your operations staff can be notified. This email address can be changed at any time, and as many times as needed. We will only use this email address for communication about your pipeline, and not for marketing or other purposes. Note: To be notified of unexpected or unplanned pipeline failures, you will still need to configure Alerts in the Pipeline Status Dashboard in Grafana. We will continue to improve the experience of pipeline notifications in future releases. Configure Pipeline Runtime Credentials You can now configure pipelines to run either under a specified service account (“app”) credential, or under your user credential. By running pipeline instances under separate apps, you can restrict data access between them. For example, you can restrict data access between Dev, Test and Prod instances. By default, the pipeline runs under your user credential, simplifying pipeline creation and configuration while developing and testing. You can change the app as many times as needed for each pipeline version. To configure a pipeline version to use an app credential, follow these steps: Create a new app. Add this new app to the group(s) to which your input and output catalogs belong. Deactivate the pipeline version. Activate the pipeline version, and, during activation, choose the new app for running the pipeline version. If you prefer to run your pipeline version with your user credential, follow these steps: Deactivate the pipeline version. Activate the pipeline version. The system will automatically pick your user account for running the pipeline version. Previously, pipelines ran using a system-generated app credential that was automatically added to the group selected when creating the pipeline. This had the effect of creating many app credentials (one per pipeline version), and caused confusion when determining how to grant pipelines access to data catalogs. With this release, we will deprecate the previously used system-generated apps. For more details, see the deprecation statement below. Schema Permissions Associated with Catalog Permissions Schema permissions are now associated with catalog permissions. You no longer need to share schemas separately from catalogs. Instead, the read permissions for a schema are granted at the same time you grant read permissions for the parent catalog. Data consumers will retain read access to a schema unless they lose read access to all catalogs associated with that schema. Support for SENSORIS Data OLP now supports the sensor data format SENSORIS. The following artifacts are available to help you work with SENSORIS data: The SENSORIS schema Catalogs with example data in both stream and versioned layers Visualization support in volatile and versioned layers An example data archiving pipeline for storing SENSORIS data in an index layer. (No example index layer is provided since index layers do not yet support data visualization.) An example Zeppelin Notebook Delete a Single Layer You can now delete a single layer using the Data API, the Portal, the Data Client Library and the Data CLI. This feature enables you to delete stream, volatile and index layer types directly without deleting the entire catalog containing them. You no longer have to lose the catalog configuration or the data in a catalog when you want to delete individual layers. This update does not enable you to delete a versioned layer because data dependencies can exist across versioned layers making the deletion of one potentially problematic to any workflows requiring others. Account & Permissions Known Issues Issue A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Delete pipelines/pipeline templates to recover space. Issue All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue When updating permissions, it can take up to an hour for changes to take effect. Data Added The Data Archiving Library now works behind a proxy, allowing you to write data to an index layer from behind a corporate firewall/proxy. With this release, it is now possible to disregard Protobuf validators when creating a schema using the schema Maven archetype tool in the OLP SDK. Schema consumers can see which validations were applied on the OLP Portal schema details page. The Data API Developer Guide has been updated to reflect the fact that the ingest API's /layers/ < layerID > /sdiimessagelist endpoint does not support compressed messages. Compressed messages are not supported by this endpoint because this endpoint breaks down SDII MessageList messages into individual SDII messages, which it cannot do if the messages are compressed. This endpoint doesn't include any decompression/compression logic. In order to send compressed SDII MessageList messages to OLP, use the ingest API's generic ingestion endpoint. Note that you will have to break down the SDII MessageList messages into individual SDII messages yourself. For more information see the Data API Developer Guide's ingest API reference . The Data, Catalog and Layer Metrics Grafana dashboard includes a new table for stream layer metrics: Messages Written Per Layer. These metrics show you the number of messages written to a given layer by any application in your realm, providing you with more information about usage of your stream layers to help you during integration and debugging. Deprecated The target end-of-life date for publish API v1 is July 31, 2019 (the six month deprecation period ended in April). If you use OLP SDK 2.3 or later, or Data Client Library 0.1.833 or later, you already have proper support for publish API v2. If you are using older versions of the OLP SDK or Data Client Library, you must update to the latest version before July 31, 2019 to avoid workflow interruptions. If you use the REST API directly, you do not need to take any action because API Lookup has already been updated to use publish API v2. NOTE: you must use API Lookup to get the proper base URL for any REST API request. Known Issues Issue Catalogs not associated with a realm are not visible in OLP. Issue Visualization of Index Layer data is not yet supported. Issue When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Marketplace Known Issues Issue Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue When the Splunk server is busy, the server can lose usage metrics. Workaround If you suspect you are losing usage metrics, contact HERE technical support. We may be able to help rerun queries and validate data. Notebooks Added A new sample notebook demonstrates the analysis of SENSORIS data. Refer to the updated Notebooks documentation (Upgrade and Install Libraries) for more information on the required artifacts and dependencies. Known Issues Issue Notebooks cannot be shared with OLP user groups. Workaround Notebooks can be shared with one or more individual users by entering each account separately. Issue The Notebook Spark connector does not support analysis of stream layers and index layers. Workaround Use the Data Client Library to analyze stream and index layers. Pipelines Fixed Fixed an issue where the Pipeline Status Dashboard in Grafana was displaying false failures and sending false email notifications when the pipeline didn't actually fail. Fixed an issue where a batch pipeline wasn't terminating properly due to an OutOfMemory error. Deprecated System-generated apps are now deprecated. These apps will be removed six months after this release. In these six months, existing pipeline versions that are running or scheduled using a system-generated app will continue to operate normally. At the end of the six-month period, all pipeline versions that are not using either the user account or the user-generated apps will fail. Known Issues Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases. Also, the dashboard will not be available for user edits in a future release. Workaround Duplicate the dashboard or create a new dashboard. Issue If multiple pipelines consuming data from a single stream layer all belong to the same group (pipeline permissions are managed via a group), then each of those pipelines will only receive a subset of the messages from the stream. This is due to the fact that the pipelines share the same Application ID. Workaround Using the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector type, you can specify a Kafka Consumer Group ID per pipeline/application. If the Kafka consumer group IDs are unique, the pipelines/applications will consume all messages from the stream. If your pipelines use the http connector type, we recommend you create a new Group for each pipeline/application, each with its own Application ID. Issue A pipeline version can be activated even after an input catalog that it uses is deleted. Workaround The pipeline will fail when it starts running and will show the error message about missing catalog. Re-check the missing catalog or use a different catalog. Web & Portal Known Issues Issue The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name, and 255 characters for the value. Workaround For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue Pipeline Templates can't be deleted from the Portal UI. Workaround Use the CLI or API to delete Pipeline Templates. Issue In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list.", "date": "2019-07-04"},
{"website": "Here", "title": "Highlight Regions of a Map with Angular and a Reverse Geocoder", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/highlight-regions-of-a-map-with-angular-and-a-reverse-geocoder", "abstract": "I recently read a tutorial by Richard Süselbeck titled, How to Get the Shape of an Area Using the HERE Geocoder API , which demonstrated using the reverse geocoder to highlight certain areas on a map. I found this particularly interesting because all I had ever thought of the HERE Reverse Geocoder API was a means to find addresses from latitude and longitude positions, not shapes or regions. While I know vanilla JavaScript is still widely appreciated when it comes to client facing web applications, I for one prefer a framework such as Angular, Vue.js, or React. In this tutorial we’re going to expand on what Richard did, but take it into the world of Angular and allow region highlighting through mouse events on the map. To get an idea of what we want to accomplish, take a look at the following animated image: While Richard’s tutorial focused on highlighting countries, we’re going to focus on highlighting states from the USA when clicked. Apparently you can also highlight regions based on postal codes and other information as well, which is neat. The Requirements To be successful with this project you’ll need the following: A HERE Developer Portal account. The Angular CLI . The Angular CLI is needed to work with Angular and the HERE account is required in order to get application tokens to use HERE services within your own applications. As of writing this tutorial, I’m using Angular 8.0.2. Older and newer versions will likely work with some minor modifications, but your results may vary. Configuring and Laying the Project Foundation To save us from having to explain using HERE with Angular in general, I want to direct you to an older tutorial that I wrote titled, Display HERE Maps within your Angular Web Application . This previous tutorial demonstrates how to create an Angular component to be used for all of our mapping needs. To quickly get you up to speed with little explanation, execute the following: ng new here-highlight-project Choose the defaults when running the above command. We don’t need a router and we don’t need any special packages or CSS extensions. Next execute the following command to create a new component: ng g component here-map Make sure you’re in the project directory when you run the above command. With the component created, paste the following markup into the project’s src/app/here-map/here-map.component.html file: <div #map style=\"width: 100vw; height: 100vh\"></div> The TypeScript that pairs with this particular HTML file goes in the project’s src/app/here-map/here-map.component.ts file and it looks like this: import { Component, OnInit, ViewChild, Input, ElementRef } from '@angular/core';\n\ndeclare var H: any;\n\n@Component({\n    selector: 'here-map',\n    templateUrl: './here-map.component.html',\n    styleUrls: ['./here-map.component.css']\n})\nexport class HereMapComponent implements OnInit {\n\n    @ViewChild(\"map\", { static: false })\n    private mapElement: ElementRef;\n\n    @Input(\"appid\")\n    private appId: string;\n\n    @Input(\"appcode\")\n    private appCode: string;\n\n    private platform: any;\n    private map: any;\n    private geocodingService: any;\n\n    public constructor() { }\n\n    public ngOnInit() {\n        this.platform = new H.service.Platform({\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        });\n        this.geocodingService = this.platform.getGeocodingService();\n    }\n\n    public ngAfterViewInit() {\n        this.map = new H.Map(\n            this.mapElement.nativeElement,\n            this.platform.createDefaultLayers().normal.map,\n            {\n                zoom: 5,\n                center: {\n                    lat: 39.8283,\n                    lng: -98.5795\n                }\n            }\n        );\n        let mapEvent = new H.mapevents.MapEvents(this.map);\n        let behavior = new H.mapevents.Behavior(mapEvent);\n    }\n\n} Alright we’re almost caught up. Remember, the goal here isn’t to get started with HERE and Angular, but to do some fancy highlighting. This is why I’m not giving much or any context behind what we’ve done so far. We’re just catching up from my previous tutorial . Open the project’s src/app/app.component.html file and include the following: <here-map \n    #map \n    appid=\"APP_ID_HERE\" \n    appcode=\"APP_CODE_HERE\">\n</here-map> The TypeScript to pair with the above HTML can be found in the project’s src/app/app.component.ts file and it looks like the following: import { Component, OnInit, ViewChild } from '@angular/core';\nimport { HereMapComponent } from \"./here-map/here-map.component\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n    @ViewChild(\"map\", { static: false })\n    private mapElement: HereMapComponent;\n    \n    public ngOnInit() { }\n\n    public ngAfterViewInit() { }\n\n} The final thing to do is to import the HERE JavaScript SDK, something we haven’t done yet in this particular tutorial. This will give us access to the interactive map as well as the services that we plan to use. Open the project’s src/index.html and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HEREMapProject</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body>\n        <app-root></app-root>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    </body>\n</html> Alright we’re caught up now. If we didn’t play catch up, what happens next might not make sense. Selecting Regions of a Map with the HERE Reverse Geocoder Just to reiterate, we’re going to be capturing mouse events, converting those events to latitude and longitude coordinates, using those coordinates in the reverse geocoder, and drawing the shape data that’s returned to represent region highlights. It sounds like we’re doing a lot, but it really isn’t. We’re going to be capturing our interactions in the AppComponent class and responding to those interactions in the HereMapComponent class. It is best we start with the responses before the captures. Open the project’s src/app/here-map/here-map.component.ts file and include the following functions: public getPositionAt(x: number, y: number) {}\npublic highlightRegion(position: any) {} We need to be able to convert pixel positions into geo coordinate positions and the getPositionAt function that we design should do this. The highlightRegion function should reverse geocode our position, get our shape, and draw it on the map as polygon objects. Take a look at the getPositionAt function: public getPositionAt(x: number, y: number) {\n    return this.map.screenToGeo(x, y);\n} The map variable is private which is why we’re doing the conversion in the HereMapComponent class rather than the AppComponent class. The x and y values are picked up from the click event that we’ll see soon. These are viewport positions, not map positions. Next we have the highlightRegion function which is a little more complex: public highlightRegion(position: any) {\n    let reverseGeocodingParameters = {\n        prox: position.lat + \",\" + position.lng,\n        mode: \"retrieveAddresses\",\n        maxresults: \"1\",\n        additionaldata: \"IncludeShapeLevel,state\"\n    };\n    this.geocodingService.reverseGeocode(\n        reverseGeocodingParameters,\n        success => {\n            let locations = success.Response.View[0].Result;\n            let shape = locations[0].Location.Shape.Value; \n            this.map.removeObjects(this.map.getObjects());\n            let customStyle = {\n                strokeColor: \"black\",\n                fillColor: \"rgba(0,175,170,0.5)\",\n                lineWidth: 2,\n                lineJoin: \"bevel\"\n            };\n            let geometry = H.util.wkt.toGeometry(shape);\n            if(geometry instanceof H.geo.MultiGeometry) {\n                let geometryArray = geometry.getGeometries();\n                for (let i = 0; i < geometryArray.length; i++) {\n                    this.map.addObject(\n                        new H.map.Polygon(\n                            geometryArray[i].getExterior(),\n                            { style: customStyle }\n                        )\n                    );\n                }\n            } else {            \n                this.map.addObject(\n                    new H.map.Polygon(\n                        geometry.getExterior(),\n                        { style: customStyle }\n                    )\n                );\n            } \n        },\n        error => {\n            console.error(error);\n        }\n    );\n} By default, the HERE reverse geocoding service will not return shape information. We can request that information by adding the following to the request options: additionaldata: \"IncludeShapeLevel,state\" The above option will give us Well-Known Text (WKT) format shape data with our response. Before we can use it, we need to convert it to a geometry. The goal is to draw this geometry as a polygon on the map, but we need to check to make sure it is a single geometry or multiple. Think Hawaii in the United States. There are several islands which would be several polygon shapes. To make use of these functions, let’s travel back into the project’s src/app/app.component.ts file: public onMapClick(event: any) {\n    let position = this.mapElement.getPositionAt(event.clientX, event.clientY);\n    this.mapElement.highlightRegion(position);\n} By itself, the onMapClick function will never trigger. However, when it does, we’ll get the latitude and longitude coordinates given the pixel values from the event. Then we’ll take those latitude and longitude values and highlight the regions on the map. To make use of the onMapClick function, we can alter the project’s src/app/app.component.html file: <here-map \n    #map \n    appid=\"APP_ID\" \n    appcode=\"APP_CODE\"\n    (click)=\"onMapClick($event)\">\n</here-map> When our component is clicked, the onMapClick function will be called. Now there are other ways to accomplish this. For example, we could add a listener directly to the map like so: this.map.addEventListener(\"tap\", event => {\n    // Do stuff here\n}); It is going to come down to your preference. I figured since we’re using Angular, we might want to do things the Angular way. Conclusion You just saw how to extend Richard Süselbeck’s previously written tutorial on reverse geocoded shapes to Angular. While we didn’t necessarily accomplish anything new between the two, we filled the framework gap that was left by the vanilla JavaScript example. If you haven’t already, I encourage you to check out my previous tutorial on Angular as well as the one written by Richard.", "date": "2019-07-11"},
{"website": "Here", "title": "June 2019 Release Notes", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/june-2019-release-notes", "abstract": "These are D106 (June 2019) release notes that describe the improvements to the services in the new release. This release includes updates of: Maps API for JavaScript, Routing API, Fleet Telematics API and Mobile SDK. The Highlights: Maps API for JavaScript 3.1 with new vector data-based map rendering engine Map customization tool for designing map styles Mobile SDK now available for China You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below. Maps API for JavaScript Version 3.1 New WebGL based rendering engine customization of the map’s look and feel runtime change of the map style rich interactions with the map retrieve feature’s meta information ▫ hide/show base map data layers at the runtime ▫ map tilting and rotation ▫ extruded buildings in 2.5D view fractional zoom levels ▫ interactive traffic flow information The appearance of the default UI elements was improved and updated The way to authenticate the API was changed from the “app_id” and “app_code” to API key. Important Note! The new rendering engine is using the Vector tiles API. When you decide to implement and use the Vector tiles API in your application/product, you accept the following payment relevant conditions: 5 requests to the Vector tiles API will be charged as 1 transaction. Map Customization Tool Interactive tool to create map styles that can be used in Map API for Java Script 3.1 https://enterprise.here.com/map-style-editor Routing API Version 7.2.106 Added support for BK (Bearing capacity class) regulations in Sweden Added support for weight per Single and Tandem Axle group restrictions. Fleet Telematics API Version 2.5.18 Truck parameters can now change per waypoint New routing parameter “avoidAreas” to avoid certain geographical areas Routing supports additional vehicle types: bus, taxi, carHOV, pedestrian, delivery emergencyVehicle, motorcycle, roadTrain, bdouble, bicycle Custom Routing can optionally match overlay geometry onto both directions of multiple digitized roads Mobile SDK for IOS 3.12 Now available for China since HERE finally received the needed government approvals! Exposed information about traffic signs on a route through HERE SDK Implemented route importer as a feature which provides an opportunity to create a custom route object from the route shape, particularly from a list of geo-coordinates (lat, lon) Truck navigation is aligned with routing truck restrictions, and current behavior takes into account truck restriction options PENALIZE_VIOLATIONS. The route is calculated properly, but the user gets a warning that he could be fined POI icons are now easily tappable Implemented possibility to set the map center before map engine initialization. Previously map was always launched in Berlin, and as a result additional unnecessary map data were requested Added support for new iPad Air 3 and iPad Mini 5 (released on March 18) Improved determination of waypoint position, now waypoints are defined by position and street name Implemented caching mechanism for bitmap-based render tiles on low zoom levels Navigation Manager was extended to get indoor position during navigation. Now NavigationManager gets updates from all sources that provide switchover between indoor and outdoor navigation Map Matcher mechanism has been significantly improved. Main improvements were focused on 4 aggregated cases – corner jumps, rounded corner jumps, parallel roads and tunnels. This feature will be available in HERE SDK as beta feature Now Map Data Prefetcher can be used without Map View initialization Mobile SDK for Android 3.12 Now available for China since HERE finally received the needed government approvals! Implemented possibility to set the map center before map engine initialization. Previously map was always launched in Berlin, and as a result additional unnecessary map data were requested Exposed information about traffic signs on a route through HERE SDK Implemented route importer as a feature which provides an opportunity to create a custom route object from the route shape, particularly from a list of geo-coordinates (lat, lon) Truck navigation is aligned with routing truck restrictions, and current behavior takes into account truck restriction options PENALIZE_VIOLATIONS. The route is calculated properly, but the user gets a warning that he could be fined POI icons are now easily tappable", "date": "2019-07-22"},
{"website": "Here", "title": "Integrate the Smartcar API in Your Next HERE Location Services Web Application", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/integrate-the-smartcar-api-in-your-next-here-location-services-web-application", "abstract": "In preparation for the HackMobility event coming up in San Francisco, I thought I’d take a moment to familiarize myself with some of the themes and organizations making an appearance at the event. This lead me to Smartcar , a service that lets you connect your applications to your vehicles with no additional hardware. Smartcar offers APIs that work with quite a large selection of major vehicle brands. These APIs can access make and model information, vehicle identification numbers (VIN), the latitude and longitude location of your vehicle, and other things. These happens through the software and hardware that’s already built into many vehicle models. With this in mind, I thought it would be interesting to find the location of a vehicle on a map alongside information about that particular vehicle. This is where HERE comes into play. We’re going to see how to use the Smartcar JavaScript SDK to get vehicle information and integrate it into a web application that uses the HERE JavaScript SDK to give us the visual component. To get an idea of what we’re going to accomplish, take a look at the following animated image: I’m not using my own vehicle because I don’t have a supported model, but the Smartcar API let’s you use simulated data like what’s being presented in the above image. After signing into the application and linking your vehicle, it takes you to a map where markers represent the vehicle location and when clicked it will show information about that vehicle. A frontend and backend are necessary to be successful with this project. Building the Backend with Node.js and the Smartcar JavaScript SDK The first step of this project is to create a backend. There is a Smartcar JavaScript SDK that works in Node.js projects and client facing applications. Because the Smartcar API has an OAuth login flow that works with a secret key and spits out a refresh token, it makes the most sense not to implement everything in the client facing browser-based application. You wouldn’t want the refresh token or secret key to end up out of your control. Assuming you have Node.js installed, execute the following to create a new project: mkdir backend\ncd backend\nnpm init -y\ntouch app.js The mkdir command will create a new directory and the cd command will navigate into it. A new package.json file will be created as well as an app.js file through the touch command. If mkdir , cd , or touch don’t exist on your operating system, go ahead and do this manually. The backend will have a few dependencies which can be installed through the following commands: npm install express --save\nnpm install cors --save\nnpm install smartcar --save Since we’re creating our own API, we’ll be using Express Framework and the cross-origin resource sharing (CORS) middleware. We need CORS because our client facing application won’t be on the same port which might cause errors. More information on CORS with Express can be found in a previous tutorial I wrote. Before we jump into the code, you will need a free Smartcar account. Within your account, you’ll need to obtain your client id and client secret, as well as define a callback URL for the OAuth process. The URL should be a route within your application, for example http://localhost:3000/exchange. Open the project’s app.js file and include the following boilerplate code: const Express = require(\"express\");\nconst Cors = require(\"cors\");\nconst Smartcar = require(\"smartcar\");\n\nvar app = Express();\n\napp.use(Cors());\n\nconst SMARTCAR_CLIENT_ID = \"\";\nconst SMARTCAR_CLIENT_SECRET = \"\";\nconst SMARTCAR_REDIRECT_URL = \"http://localhost:3000/exchange\";\n\nvar smartcar_access_token = \"\";\n\nconst client = new Smartcar.AuthClient({\n    clientId: SMARTCAR_CLIENT_ID,\n    clientSecret: SMARTCAR_CLIENT_SECRET,\n    redirectUri: SMARTCAR_REDIRECT_URL,\n    scope: [\"read_vehicle_info\", \"read_location\", \"read_vin\"],\n    testMode: true,\n});\n\nvar server = app.listen(\"3000\", () => {\n    console.log(`Listening at ${server.address().address}${server.address().port}...`);\n}); The above code configures the packages that we previously downloaded, and this includes the Smartcar package for OAuth. Make sure to drop your client id and client secret into each of the variables. Since this particular example won’t use a database, the application will save the users access token, after sign-in, into memory and it will be used until you stop the application or until the access token expires. Generally the client would store this, but we’re not going to add that complexity to this example. Because we’re using OAuth, we need to define the scope of what should be accessible by our application. In this example we want to be able to get the vehicle info which includes make and model, gather the last known location, and get the VIN. We’re not including things like unlocking and locking of vehicle doors. Before we start adding our own logic endpoints, let’s do create the /exchange and /login endpoints: app.get(\"/login\", (request, response) => {\n    const link = client.getAuthUrl();\n    response.redirect(link);\n});\n\napp.get(\"/exchange\", (request, response) => {\n    const code = request.query.code;\n    client.exchangeCode(code).then(access => {\n        smartcar_access_token = access.accessToken;\n        response.redirect(\"http://localhost:2015\");\n    });\n}); The /login endpoint is going to be the users first point of access. When triggered, the OAuth flow will start and end at the /exchange endpoint. Rather than returning the tokens to the user, the access token will be set in memory and the client will be redirected to their frontend application which we’re going to assume is running on port 2015. Let’s think of our first endpoint that contains useful logic. We might want information about the vehicle such as make, model, and VIN. This information doesn’t exist as part of a single SDK function, so we have to do some work. Take the following for example: app.get(\"/vehicles\", (request, response) => {\n    Smartcar.getVehicleIds(smartcar_access_token).then(data => {\n        return data.vehicles;\n    }).then(ids => {\n        return vehicles = ids.map(async id => {\n            let vehicle = new Smartcar.Vehicle(id, smartcar_access_token);\n            return vehicle.info().then(info => {\n                return vehicle.vin().then(vin => {\n                    info.vin = vin;\n                    return info;\n                });\n            });\n        });\n    }).then(vehicles => {\n        Promise.all(vehicles).then(result => {\n            response.send(result);\n        });        \n    });\n}); In the above /vehicles endpoint we get all of the vehicle id values based on our access token. This is a remote request, hence the use of our promise. When we have the vehicle id information, we can chain our promise to get the vehicle info which is also a remote request. Using further promise chaining, we can get the VIN information from each of the id values and construct our own custom object that contains VIN as well as make and model information. Finally, since we’ve exchanged id information with promises that contain full information, we need to execute all of our promises through the Promise.all in JavaScript. The information we return will look something like this: [\n    {\n        \"id\": \"1234\",\n        \"make\": \"Ford\",\n        \"model\": \"Ranger\",\n        \"year\": 1998,\n        \"vin\": \"1N3T000000\"\n    }\n] We’re going to consume this information in our frontend application that uses the HERE JavaScript SDK, but not quite yet. We have information about our vehicles, but not the location. We can create another endpoint for that: app.get(\"/vehicle/:id/location\", function (request, response) {\n    let vehicle = new Smartcar.Vehicle(request.params.id, smartcar_access_token);\n    vehicle.location().then(result => {\n        response.send(result);\n    });\n}); Assuming the above endpoint is accessed with an actual vehicle id, we can use it along with the stored access token to get the latitude and longitude information about that vehicle. This is all the information we need for the backend of our current example. We can now take it to a map with the HERE JavaScript SDK. Displaying Your Car Location and Information on a Map with the HERE JavaScript SDK We’re going to create a separate client facing application to accomplish the user interface component. Execute the following commands somewhere on your computer to get us started: mkdir frontend\ncd frontend\ntouch index.html We’re creating a new directory with an index.html file in it. Remember, you can do this manually if you don’t have the mkdir , cd , or touch commands on your operating system’s command line. Open the project’s index.html file and add the following boilerplate code to get us started: <!DOCTYPE html>\n<html>\n    <head>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"http://js.api.here.com/v3/3.0/mapsjs-ui.css\" />\n    </head>\n    <body style=\"margin: 0\">\n        <div id=\"map\" style=\"width: 100vw; height: 100vh;\"></div>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"http://js.api.here.com/v3/3.0/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script>\n            const platform = new H.service.Platform({\n                \"app_id\": \"HERE_APP_ID\",\n                \"app_code\": \"HERE_APP_CODE\"\n            });\n            const defaultLayers = platform.createDefaultLayers();\n            const map = new H.Map(\n                document.getElementById(\"map\"),\n                defaultLayers.normal.map,\n                {\n                    zoom: 6,\n                    center: { lat: 37.7397, lng: -121.4252 }\n                }\n            );\n            const ui = H.ui.UI.createDefault(map, defaultLayers);\n            const mapEvent = new H.mapevents.MapEvents(map);\n            const behavior = new H.mapevents.Behavior(mapEvent);\n        </script>\n    </body>\n</html> The above markup will load the HERE JavaScript SDK and display an interactive map on the screen, assuming that you’ve added your free HERE developer credentials found in the HERE Developer Portal . I’ve written about including interactive maps in a few tutorials, but to get a great idea about what everything’s doing, check out Developer Waypoints on YouTube where I demonstrate step-by-step on what’s happening. This is where things get interesting. We need to make an HTTP request to our backend endpoints for information. We might do something like the following: fetch(\"http://localhost:3000/vehicles\")\n    .then(response => response.json())\n    .then(vehicles => {\n        let vehiclePromises = vehicles.map(vehicle => {\n            return fetch(`http://localhost:3000/vehicle/${vehicle.id}/location`)\n                .then(response => response.json())\n                .then(location => {\n                    vehicle.location = location.data;\n                    return vehicle;\n                });\n        });\n        return Promise.all(vehiclePromises);\n    }).then(result => {\n        let markerGroup = new H.map.Group();\n        result.forEach(vehicle => {\n            let marker = new H.map.Marker({ lat: vehicle.location.latitude, lng: vehicle.location.longitude });\n            markerGroup.addObject(marker);\n        });\n        map.addObject(markerGroup);\n        map.setViewBounds(markerGroup.getBounds());\n    }); Again, we’re going to use promise chaining here. First we’re going to make a request for all of our vehicles which include vehicle information. When we get that information, we’re going to loop through each vehicle, and reconstruct our information by making a request for the location. In reality, we want something like this in the end: [\n    {\n        \"id\": \"1234\",\n        \"make\": \"Ford\",\n        \"model\": \"Ranger\"\n        \"year\": 1998,\n        \"vin\": \"1N2345000\"\n        \"location\": {\n            \"latitude\": 37,\n            \"longitude\": -121\n        }\n    }\n] When we have a promise for all of this information, we can do a Promise.all go get an array of that data. The result of that Promise.all is chained so that way we can render the data when it’s ready. let markerGroup = new H.map.Group();\nresult.forEach(vehicle => {\n    let marker = new H.map.Marker({ lat: vehicle.location.latitude, lng: vehicle.location.longitude });\n    markerGroup.addObject(marker);\n});\nmap.addObject(markerGroup);\nmap.setViewBounds(markerGroup.getBounds()); We can create a group of markers based on the latitude and longitude of each vehicle, add the group to the map, and zoom in on them so they’re all within view. In this scenario, we’re only drawing markers based on position. We’ve essentially lost the vehicle information. To put the vehicle information to use, we can create InfoBubble components on each of our markers. Take a look at the following revision to our code: let markerGroup = new H.map.Group();\nresult.forEach(vehicle => {\n    let marker = new H.map.Marker({ lat: vehicle.location.latitude, lng: vehicle.location.longitude });\n    marker.setData(`<p>${vehicle.year} ${vehicle.make} ${vehicle.model}<br /><span style=\"font-size: 10pt\">VIN: ${vehicle.vin}</span></p>`);\n    marker.addEventListener('tap', event => {\n        var bubble = new H.ui.InfoBubble(event.target.getPosition(), {\n            content: event.target.getData()\n        });\n        ui.addBubble(bubble);\n    }, false);\n    markerGroup.addObject(marker);\n});\nmap.addObject(markerGroup);\nmap.setViewBounds(markerGroup.getBounds()); When we create markers for our marker group, we are setting the data on the marker to be shown through an InfoBubble that is accessible through a tap listener. The data and tap listeners are created on a per marker basis so each marker will show different information. Conclusion You just saw how to use the Smartcar JavaScript SDK with the HERE JavaScript SDK. This example was a simple one because all we did was get simulated vehicle information and display it on a map. However, you could come up with much more extravagant use-cases, for example ride-sharing, fleet management, or even enhanced user experience for vehicle servicing. If you’ve got a use-case, I’d love to hear about it in the comments!", "date": "2019-07-17"},
{"website": "Here", "title": "Announcing the new JavaScript API 3.1", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/announcing-the-new-javascript-api-3.1", "abstract": "Today we are excited to announce the brand-new version 3.1 of our JavaScript API, which delivers a whole host of new features and capabilities. Let's have a closer look using the magic of the Graphics Interchange Format's Graphics Control Extension (aka \"animated GIFs\"). First, the maps displayed by our JavaScript API 3.1 are now powered by vector tiles. This means you can now tilt the map, rotate the map and there are no more fixed zoom levels. Look! In addition, you can now display the 3D extruded buildings you may already be familiar with from our Mobile SDKs. Whoa. Even more exciting is the ability to customize the look and feel of your maps. Apply any style you like to any feature of the map. You can even do this at runtime! Check this out! There's even more and we have several blog posts in the works to introduce you to all of the new features soon. In the meantime, have a look at the documentation and examples to get you started. A quick note on authentication before you get going. The JavaScript API 3.1 uses a new type of API Key, so be sure to go into your projects on the developer portal and create this new key. Your old App ID/App Code credentials will continue to work for the JavaScript API 3.0 and below. Naturally, the JavaScript API 3.1 and all of these exciting new features are all part of your Freemium plan. Now excuse me while go and tilt around all my maps for no reason whatsoever. Wheeeeee!", "date": "2019-07-12"},
{"website": "Here", "title": "From Hexbins to Tangram: Here's What's New in HERE XYZ", "author": ["Katie Kowalsky"], "link": "https://developer.here.com/blog/from-hexbins-to-tangram-map-renderer-heres-whats-new-in-here-xyz", "abstract": "Whether you’ve been using HERE XYZ since we launched our beta last fall or are eager to give it a test drive, we have some exciting new features to showcase. We want HERE  XYZ to fit into your data workflow, whether that’s trying out some of our new CLI features that allow you to add JSON schemas, search and filter by property, and generate hexbins for point features. We’re also working on making XYZ as interoperable as possible. In XYZ Studio , you can now choose the Tangram renderer as an option for your map on publish. Read through our latest release notes later in this post to see what else is improved. We’ve also written up a handy blog post to try out XYZ data alongside the Harp.gl renderer . Our team is continually iterating based on the community’s feedback and are excited to hear from you! Start playing with XYZ with one of our helpful tutorials today. Release Notes XYZ Hub & CLI Release Notes: Property Search ️Property Filter Virtual Spaces Schema Validation Space Configuration Hexbins XYZ Studio New Feature: try out a new map renderer! Tangram is now available for published XYZ Studio maps. TL;DR: Tangram map renderer. Re-ordering of geometries. ✨ NEW ✨ Along with the minimalist HERE map renderer, we have a new Tangram map renderer. Tangram viewer provides new details like admin and street labels, as well as textures to the basemap. You can now reorder your geometries. Added two new basemap styles. 🔨 IMPROVED 🔧 UX/UI improvements. Under the hood, performance improvements. 🐜 FIXED 🐜 Fixed an issue of district not being shown in cards and style groups for Microsoft building footprint data. Other minor bug fixes.", "date": "2019-07-25"},
{"website": "Here", "title": "Real-Time Fleet Tracking Workshop for Azure Developers", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/real-time-fleet-tracking-workshop-for-azure-developers", "abstract": "In May 2019 we released three Azure Resource Manager (ARM) templates to simplify the integration of our REST services as Azure functions within an Azure solution. The templates cover the following: Serverless Functions - Deploys HERE location services as Azure functions that can be invoked directly within any Azure applications and/or solutions. Web App Back-ends - Deploys HERE location services as Azure functions along with Azure Service Bus and Cosmos DB to optimize for web application back-end. Real-Time Data Streams - Deploys HERE location services as Azure functions along with Event Hub and Cosmos DB to optimize for real-time streaming applications. Today, we are happy to announce a resource to help developers quickly get up to speed with the last ARM template mentioned above. This resource is a \"workshop\" available at GitHub and utilizes real-time data streams to create a fleet management scenario for real-time vehicle tracking. This post covers what you need to get started and provides a glimpse of what the workshop produces as an output. Scope and Requirements The following are prerequisites for getting started: Some HTML experience ( help ) Some JavaScript experience ( help ) A Microsoft Azure account ( https://azure.microsoft.com ) HERE Developer account ( https://developer.here.com ) Overview of Tasks The following tasks are covered in the Fleet Management Workshop: Real-Time Data Stream Template Deployment - Initial deployment and configuration of ARM template configured to use HERE location services. Configure Sample Data Producer - Create a script to simulate IoT devices that capture latitude, longitude, engine temperature, RPM, load and coolant temperature. Configure WebApp - Create and deploy an Azure Web App to serve as a dashboard to monitor virtual fleet of trucks in real-time. Validation - Execute producer script to simulate vehicles tracked via IoT devices and monitor via dashboard. Here is a screen capture of the dashboard from the completed workshop: Summary With the availability of the Fleet Management Workshop , Microsoft Azure developers can quickly learn how to implement a complex scenario such as real-time fleet tracking in a short amount of time.", "date": "2019-07-18"},
{"website": "Here", "title": "Cabonline selects HERE as mapping and location services provider", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/cabonline-selects-here-as-mapping-and-location-services-provider", "abstract": "Cabonline, whose technology platform matches riders to drivers for more than 60,000 taxi trips every day, has switched to HERE Technologies as it targets greater fleet efficiencies and precision ETAs for customers and drivers Cabonline is the largest taxi company in the Nordics and its technology platform powers everything from booking to dispatch to payment for multiple owned and affiliated taxi brands across the region. These include Taxi Kurir, Norgetaxi, TOPCAB, Kovanen, Taxi Skåne, Taxi Väst, Umeå Taxi and Sverigetaxi. Cabonline is now integrating the HERE Location Services suite into its platform, giving it access to accurate mapping, traffic information and routing algorithms. Kristofer Signer, CTO, Cabonline, said: “With HERE Technologies as our location partner, we aim to further optimize the movement of each of our 5,700 cars as well as enhance customer experience. This is an important part of our work to shape an efficient and scalable technology platform that can support our continued growth.” Supported by HERE Location Services, Cabonline targets several benefits, including: More precise ETAs for customers and drivers, aided by HERE routing algorithms which draw on real-time, predictive and historical traffic data More precise ride cost estimations for customers Improved driver safety, aided by industry-leading map information that integrates data for taxi driving lanes, speed limits and electric vehicle charging points Improved post-trip analytics Welcome on board! If you are building excitings things with maps and location data, leave a comment or get in touch at @heredev on Twitter.", "date": "2019-08-05"},
{"website": "Here", "title": "Mapping your sport activity with HERE XYZ Studio", "author": ["Roberto Butti"], "link": "https://developer.here.com/blog/mapping-your-sport-activity-with-here-xyz-studio", "abstract": "Whenever I go for a run, a bike ride or a swim I like to track my performance. And with that, I go a step further to analyze my endurance and achievements by creating custom maps. In this post, I will show you how to create a map with your cycling (or running) activity and styling your route based on your heart rate. In green color you will see the segments where your heart rate was low (for example less than 120 bpm) and in red color where your heart rate was high ( for example greater than 150 bpm). This is just an example of one metric, but feel free to add other attributes like speed, cadence, altitude etc. In order to use HERE XYZ Studio, we need to convert files provided by third party tools used to track activities into a Geojson file. These third party tools like Strava, Zwift, Garmin Connect usually allow you to download activities in FIT format and/or GPX format. I'm going to show you how to export FIT file from Zwift, GPX file from Strava and GPX and FIT from Garmin Connect. Export FIT file from Zwift In Zwift you can export your activities in FIT file. From your dashboard https://my.zwift.com/ you have the list of your activities. For each activity you have a \"Download\" link that allows you to download the FIT File. A FIT file is a binary file that contains all information about your activity (power, speed, elevation, GPS coordinates, hearth rate etc) Export GPX file from Strava If you use Strava, at this URL: https://www.strava.com/athlete/training you can see all your activities, sorted by date (latest activity on top of the list). If you select an activity you can see the detail activity page. On the left, on the sidebar, you have some shortcuts to edit the activity, to see analysis and you can access to some \"advanced\" functionalities via the \"three dots\" button. In the context menu you can click \"Export GPX\" to download your activity in GPX format. Export FIT/GPX file from Garmin Connect If you a Garmin devices user, and you have a registered account on Garmin Connect, in this Web page https://connect.garmin.com/modern/activities you can see your activities. Once you selected your activity from list, you can see the activity detail page. On the top right corner you have a wheel icon. Open the menu tools by clicking the wheel icon. In the menu, click on \"Export to GPX\" if you want a GPX file or \"Export Original\" if you want a FIT file. Convert GPX or FIT file into Geojson For converting GPX/FIT file into Geojson you can use this opensource tool: https://fit2geojson.netlify.com/ Drag and drop your GPX or FIT file into that tool. Click on \"Download\" button. A Geojson file will be saved on your local computer. Why do you need Geojson file? Because a lot of online Map tools use the Geojson format. Also XYZ Studio manages Geojson files. Create your Map based on your activity With https://xyz.here.com/studio you can create your custom map based on Geojson file in easy way. On https://xyz.here.com/studio/ click on the button \"Create new project\" in top right of the screen. To do that you need to log in in XYZ Studio. If you don’t have any account you can create one for free. XYZ Studio has “Freemium plans” good for starting your work. A new empty project (map) is created, and a new empty map is shown. Add your data to a map Now you can add data (your Geojson file just created) clicking on \"+ Add\" on the left side bar of your new empty project. In the new popup window \"Add data\" you can upload your Geojson file clicking on \"Upload files\" button. Once the file upload process is competed, you will see your new dataset available in \"My XYZ Spaces\". To load your data into the map, you need to make sure that the dataset is selected, and click on \"Add 1 dataset\" button. Customize your project information Once you have uploaded your data, you will see your project map. In the left panel you can change the project’s title and description. Style your data In order to style your data you need to access to the layer information. On the left side panel click on the name of the layer. Click on the layer name to activate the layer, and style the data. Click on the arrow to expand Lines section In \"Lines\" section click \"Add new style line\" to open the \"Add new style group\" popup window. In this popup window, you can define: * Style group name: set \"Heart Rate LOW\"; * Property: select hr in the list (hr is the property for the heart rate); * Condition: select \"Less than\"; * Value: set a integer value (for example 120) With this simple step you just created a rule for your lower heart rate (less than 120). Click on \"Confirm\" button to save. Now you can define the style (color). In the side bar you can see your new rule named \"Heart Rate LOW\". You can click the color picker and select the color. For example for lower rates you can select green color. You will se in the map all segments where you ran with your heart rate less than 120 with green color. In the same way, you can define and style a new rule for your higher heart rate segments. On the left side bar click \"Add new line style\". In this popup window, you can define: * Style group name: set \"Heart Rate HIGH\"; * Property: select hr in the list (hr is the property for the heart rate); * Condition: select \"Greater than\"; * Value: set a integer value (for example 150) Now you can select a color for styling segments that match your new rule. If you created your 2 new style in the right way, you can see the left side bar with these styles for lines: * Heart Rate HIGH * Heart Rate LOW * Default line style You can rename \"Default line style\" clicking on the pencil close to the name. For example you can name it Heart Rate MEDIUM. Publish your new map In order to share your new styled map with your friends or in your blog, you need to publish it. On the bottom of the left side panel click on the \"Publish settings\" button. In the popup \"Publish Settings\" window, click on \"Publish map\", select \"Description\" and \"Legend\" options and then scroll down the window. Click on Open URL link. A new tab will be open with your published map. You can see your workout activity on map, with colored segments with your Heart Rate. Now you can create your map activity based on your pace or on elevation. For cycling you can also style your map based on cadence or speed. And now… it’s time to color your activities.", "date": "2019-08-12"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.6 release", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.6-release", "abstract": "Highlights Location Services API (beta) With the OLP 2.6 release, beta versions of location services APIs will be available in OLP Workspace. You'll notice the following related updates in OLP Portal: Service Tab : visible to OLP Workspace licensees in the main OLP menu on the same level as Data & Pipelines. Service Overview : includes a listing of all HERE Location Services available in closed beta. Service detail page : provides information on the service API as well as links to documentation and “how to” guides. The services represented on the Service tab described above are: Search - leveraging a unified API for search and geocoding, users can search for known places or addresses, bring their own data to be leveraged by the search service, as well as perform free-form searches of place names and addresses with Autosuggest. Users will have the ability to engage the Search functionality in the following ways: Search - One Search Box provides users the ability to find a known place or address (partial or complete), as well as discover an unknown place. Search - Forward Geocoder returns the geo-coordinates for a single requested address, along with additional address and location details. Multiple results can be returned if the address is ambiguous. The Geocoding services supports the submittal of place names as additional semantic address information. Search - Reverse Geocoder returns the nearest address to known geo-coordinates, along with additional address and location details. Search - Browse Your Data provides a structured search for places through filtering by name and category ID. It is designed specifically for customers who want to use their own data (BYOD) with Search. Search - Autosuggest improves the user's experience by allowing the submittal of free-form, incomplete or mispelled addresses or place names. The results returned are a mixture of places or addresses relevant to the incomplete query, and complete Search - One Search Box query suggestions. Search - Places ID Lookup finds one result based upon its unique location ID. This service is typically used in complement of the above Search services above. Rendering - allows users to request tiles containing vector data using OLP resident content via the Vector Tiles service Routing - enables vehicle and pedestrian routing, calculating routes for consumer and enterprise applications Users will have the ability to engage Routing functionality in the following ways; Routing - Pedestrian service calculates pedestrian routes between two or more locations and provides additional route-related information. The Routing API is customizable so that the route calculation and additional information can be adapted to both consumer and enterprise applications. Routing - Vehicle service calculates routes between two or more locations using various transport modes and provides additional route-related information. The Routing API is customizable so that the route calculation and additional information can be adapted to both consumer and enterprise applications. Transit - includes transit departures, routing, and station search, enabling users to explore departures and calculate public transit routes Users will have the ability to engage Routing functionality in the following ways; Transit - Nearby Departures service explores departures of public transit lines to expose the subsequent/next stops along the line(s). Transit - Routing service calculates routes between two geographical points using public transit (train, tram, bus, ferry, ...). Transit - Station Search service provides multiple options for searching transit stations. Transit - Intermodal Routing service calculates intermodal routes using street routing, public transit and external mobility services. This offers an innovative and smart routing experience in urban areas to navigate between a given pair of locations. We are limiting access to these APIs to customers participating in our closed beta program, so that we can gather feedback and refine our offering before launching it to all customers. If you are interested in getting a sneak preview, and giving us feedback, please follow the link on the Service detail page and submit the OLP Information Request form to request access to the closed beta program. In future releases, we will enable customers to bring their own data, integrate their own algorithms or customize existing ones, and eventually build their own location services on OLP. Our goal is to remove the complexity of managing cloud infrastructure, and enable customers to augment our turnkey services with their unique location data and business logic. Option to increase data durability with multi-region synchronization With this release, you can configure new catalogs as multi-region as an additional data durability feature. In the event that your business is very risk-adverse to data loss, you can now set new catalogs as multi-region for the following layer types and operations only: Read operations on versioned layers Read and write operations on volatile layers Additional charges apply as follows: Storage charges double when storing data in a second region. Data I/O charges increase 2.5 to 4 times, depending on the size of the objects you’re uploading: less for fewer large objects, more for many small objects. This is due to the validation HERE performs to ensure successful replication. Find out more about multi-region catalogs and associated costs. Improved Availability SLA for Data Operations The OLP standard availability SLA for the following data operations has increased from 98.5% to 99.5% at no additional charge: Read operations on Versioned layers Read and Write operations on Volatile layers For more information, see OLP’s updated Service Level Agreement . Develop Stream Pipelines with Apache Flink 1.7.1 A new Stream-2.0.0 run-time environment with Apache Flink 1.7.1 is now available for creating Stream Pipelines. The Stream-2.0.0 run-time environment includes the following libraries: Apache Flink 1.7.1 Java 8u191 Scala 2.11 The Stream-1.5.x (with Apache Flink 1.2.1 ) run-time environment is now deprecated. Existing Stream pipelines that use the Stream-1.5.x run-time environment will continue to operate normally until February 1, 2020. During this period, Stream-1.5.x run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-1.5.x environment, please use OLP SDK 2.5 or older. After February 1, 2020 we will remove the Stream-1.5.x run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Stream Pipelines to the new Stream-2.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Stream pipeline to the new Stream-2.0.0 run-time environment, see Migrate Pipeline to New Run-time Environment . We will continue to evaluate the quality and stability of future Apache Flink releases to determine the versions to enable for OLP Pipelines. If you need a specific feature from a version of Apache Flink that is not yet available in OLP, please contact our Support team. As we enable the newer versions of Flink, we will make best efforts to support the older versions for up to 6 months. For more details about our general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . With this release, we are also simplifying the dependency management of various libraries used in OLP SDK and the Pipeline Run-time Environment. From now on, only one environment file will be needed for developing Stream pipelines under Maven, sdk-stream-bom.pom . This file combines the run-time environment libraries and all SDK libraries needed for pipeline development and eliminates the need for workarounds, like shading. To learn more about the new sdk-stream-bom.pom file, see OLP SDK Dependency Management . Develop Batch Pipelines with Apache Spark 2.4.2 A new Batch-2.0.0 run-time environment with Apache Spark 2.4.2 is now available for creating Batch Pipelines. The Batch-2.0.0 run-time environment includes the following libraries: Apache Spark 2.4.2 Java 8u191 Scala 2.11 The Batch-1.5.x (with Apache Spark 2.1.1 ) run-time environment is now deprecated. Existing Batch pipelines that use the Batch-1.5.x run-time environment will continue to operate normally until February 1, 2020. During this period, Batch-1.5.x run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-1.5.x environment, please use OLP SDK 2.5 or older. After February 1, 2020 we will remove the Batch-1.5.x run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the new Batch-2.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Batch pipeline to the new Batch-2.0.0 run-time environment, see Migrate Pipeline to New Run-time Environment . We will continue to evaluate the quality and stability of future Apache Spark releases to determine the versions to enable for OLP Pipelines. If you need a specific feature from a version of Apache Spark that is not yet available in OLP, please contact our Support team. As we enable the newer versions of Spark, we will make best efforts to support the older versions for up to 6 months. For more details about our general support for Apache Spark, please see Batch Pipelines - Apache Spark Support FAQ . With this release, we are also simplifying the dependency management of various libraries used in OLP SDK and the Pipeline Run-time Environment. From now on, only one environment file will be needed for developing Batch pipelines under Maven, sdk-batch-bom.pom . This file combines the run-time environment libraries and all SDK libraries needed for pipeline development and eliminates the need for workarounds, like shading. To learn more about the new sdk-batch-bom.pom file, see OLP SDK Dependency Management . Notifications for Planned Outages and Auto-recovery of Stream Pipelines Previously, when your Stream Pipeline was affected due to a planned outage, we didn't provide you enough time to perform the requested action (for example, Pause and Resume a Pipeline Version) and as a result, the Pipeline was canceled by us, leading to interruptions in your data processing. From this release onward, we will notify you in advance about the planned outages with clear details about the incident and expected user actions. The email notification will be sent to the email address associated with the impacted Stream pipeline and it will contain the following details: Incident Summary Realm Pipeline ID Pipeline Name Pipeline Version ID Requested Action with supporting instructions Due Date and Time System Operation to be performed by OLP if the Requested Action is not performed If you are not able to perform the Requested Action by the due date and time, we will perform the System Operation as highlighted in the outage email. Once we have initiated the System Operation on your Stream Pipeline, a second email will be sent with the following details: Realm Pipeline ID Pipeline Name Pipeline Version ID Incident Summary System Operation Date and Time System Operation Being Performed In cases where we need the processing of your Stream pipeline to be interrupted (for example, via Pause and Resume), and if you can't complete this action in time, then we will do it for you quickly and reliably. During the System Operation, we will attempt to save the current state and create a new job from the saved state. If you are able to perform the Requested Action by the due date and time, we will not perform the System Operation. We will be able to recover the state of only those Stream Pipelines that utilize check-pointing. Otherwise, we will Cancel and then Activate your pipeline if you haven’t performed the requested action by the due date and time. Therefore, we recommend you to use check-pointing in your Stream Pipelines. If an affected Stream Pipeline does not have an email address associated with it, we will not be able to send a notification and will perform the System Operation during the planned outage. Japanese Text The text on the OLP Portal is now available in Japanese. Support Panel For convenience, the following links have been added to the support panel on platform.here.com , Status page, Knowledge base and Service level agreement. New Navigation Launcher We’ve tweaked our navigation to accommodate the growing list of things you can do on OLP. Use the launcher icon ( ⫶⫶⫶ ) in the top right navigation to get to the items that were previously located along the top of the site. Account & Permissions Added Organization Admins Organization (Org.) Admins are able to better manage users, apps and groups. Additionally, by enabling \"Manage all apps\", an individual Org Admin is able to delegate ownership of an app to other users. This is especially useful to ensure that a pipeline can continue to be activated even when the pipeline/app owner is no longer a user in OLP. Known Issues Issue A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround Create a new app or user if you reach the limitation. Issue Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue When updating permissions, it can take up to an hour for changes to take effect. Data Deprecated Following up on the deprecation notice released with OLP 2.2.1 at the end of January, 2019, OLP will no longer support functionality to get all volatile partitions that changed between version Vn and Vm. Starting the first week of September: The only option is to request a list of volatile tiles which have changed since a given time. Volatile layer metadata will no longer be versioned. There is only one version, which is the latest version. Metadata/Query APIs for volatile layers with versions will stop working. Added Data Archiving Library Error Handling Data Archiving Library error handling has been improved with this release. You are now able to control error handling that is encountered when archiving stream data to an index layer. You decide what should happen to messages when they cannot be deserialized or do not otherwise contain good data, which allows you to clean up those messages at a later time. Spark Connector An updated release of the Spark Connector provides read support for both index and versioned layers. Spark Connectors provide a tool to help facilitate your data analysis, consumption and processing via Spark. Spend less time writing code to deal with different data formats and more time on your business case workflows. Known Issues Issue Catalogs not associated with a realm are not visible in OLP. Issue Visualization of Index Layer data is not yet supported. Issue When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Marketplace Known Issues Issue Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue When the Splunk server is busy, the server can lose usage metrics. Workaround If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Notebooks Deprecated OLP Notebooks has been deprecated, please refer to the advantages and enhancements offered in the new OLP SDK for Python instead. Download your old notebooks and refer to the Zeppelin Notebooks Migration Guide for further instructions. Known Issues Issue Notebooks cannot be shared with OLP user groups. Workaround Notebooks can be shared with one or more individual users by entering each account separately. Issue The Notebook Spark connector does not support analysis of stream layers and index layers. Workaround The Data Client Library can be used to analyze stream and index layers. OLP SDK for Python Added HERE OLP SDK for Python - Beta Performing analytics on OLP just got easier. Use the new HERE OLP SDK for Python - Beta to analyze and visualize OLP data in your own environment using Jupyter, Python, and Spark. Features include: Flexibility: Ability to use Python and the Python ecosystem of data science tools. Use and install your own Python libraries Scalability: Ability to scale up your data analysis using larger Spark clusters (e.g., EMR in AWS) Visualization: ipyleaflet and the popular Leaflet framework for interactive data visualization on a HERE base map Data Access: Users can more easily work with their own local data as part of their analysis Refer to HERE OLP SDK for Python - Beta for documentation, sample notebooks and installation instructions. OLP Notebooks Deprecation OLP Notebooks has been deprecated, please refer to the advantages and enhancements offered in the new HERE OLP SDK for Python - Beta instead. Please download your old notebooks and refer to the Zeppelin Notebooks Migration Guide within the OLP SDK for Python Setup Guide for further instructions. For additional questions, please log a support ticket. Known Issues Issue Currently, only MacOS and Linux distributions are supported. Workaround If you are using Windows OS, we recommend that you use a virtual machine. Optimized Map for Analytics Added Optimized Map for Analytics The Optimized Map for Analytics (OMA) is an alternative representation of HERE Map Content to facilitate data analysis. OMA is a friendly SQL-like version of HERE Map Content that simplifies the work to tie attributes to their reference layers. For example, a simple SQL lookup using OMA is one line of SparkSQL code while the same lookup using HERE Map Content would take more complicated Scala code. OMA currently supports analysis of road attributes and includes content from the following HERE Map Content layers: Road Topology and Geometry Road Attributes Navigation Attributes (premium content) Please refer to OMA documentation for further information. Known Issues Issue Layer navigation_access_permission schema is not accessible; data cannot be decoded from this layer. Workaround This layer will be available shortly. Pipelines Fixed Fixed an issue where a few Stream pipelines were not able to register the CPU and Memory usage data for accounting and billing. Known Issues Issue A pipeline failure or exception can sometimes take several minutes to respond. Issue The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround Duplicate the dashboard or create a new dashboard. Issue If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application. If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue Pipelines can still be activated after a catalog is deleted. Workaround The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Web & Portal Known Issues Issue The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue Pipeline Templates can't be deleted from the Portal UI. Workaround Use the CLI or API to delete Pipeline Templates. Issue In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround Refresh the Jobs and Operations pages to see the latest job or operation in the list.", "date": "2019-08-15"},
{"website": "Here", "title": "July 2019 Release Notes", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/july-2019-release-notes", "abstract": "A new release (D107) of the HERE Location Suite is now available on the Production environment (PRD). These are the release notes that describe the improvements to the services in the new release. This release includes updates of: Maps API for JavaScript and Routing API. This release is mainly a maintenance release. You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Maps API for JavaScript Version 3.1.0.3 We introduced animations to the H.map.ViewModel#setLookAtData method. We added an option to turn on the extrusion on the H.map.Rect, H.map.Circle and H.map.Polygon map objects. It is now possible for the providers that inherit from H.map.provider.RemoteTileProvider to include additional elements in the EvantTarget chain. Routing API Version 7.2.107 Added note elements in the response for routes violating or potentially violating zone restrictions.", "date": "2019-08-13"},
{"website": "Here", "title": "An Introduction to GeoJSON", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/an-introduction-to-geojson", "abstract": "As a new developer evangelist at HERE, I’m trying to quickly come to speed with geographic and map related terms and technologies. One of them I discovered rather quickly is a fascinating (and simple!) specification called GeoJSON. As you guess, GeoJSON is JSON related, which is great because if I never see XML again I’ll die a happy developer. Before I dig into what GeoJSON does and what problems it solves, be sure to check out the website ( https://geojson.org ) and full specification ( https://tools.ietf.org/html/rfc7946 ). And by the way, definitely take a look at that specification. I spent most of my life thinking those specs were boring, mind numbing technical documents but they can actually be quite helpful. In this particular case there were a few questions I had that were answered in the spec so it was absolutely worth my time reading it! GeoJSON is Geographic Data At a high level, GeoJSON is a way of representing geographic data. Let’s say you have a collection of cats (a… catalog let’s say) and the location of each cat is something you want to work with. That could be displaying them on a map, or telling a user which cat is closer to them, it doesn’t really matter. The previous example was focused on “points”, i.e. exact locations of cats, but that’s not the only type of data that can be represented in GeoJSON. Imagine you kept track of a cat’s movement through the data. That movement could be represented as a path over different points and stored in GeoJSON. As yet another example, as we know cats are very territorial. You could represent a set of cats and their territories as a set of polygons. Anything inside that polygon represents the area that belongs to the cat. (And yes, it belongs to the cat, not you.) If you can imagine every different way you can use a map or a globe, GeoJSON supports representing that information. Even better, the specification supports any ad hoq data as well. If we go back to the imaginary list of cats and their locations, we can associate the cats name, breed, gender, and so forth along with the geographic data. GeoJSON Parts GeoJSON consists of the following different parts: Geometry object: This is either the point, line, or polygon described earlier. Basically the location information. Feature object: This is the geometry object and the associated random ad hoq data. Remember, GeoJSON doesn’t care what data you associate with the location information. FeatureCollection: Basically just a list of feature objects. So typically one GeoJSON file (or dataset) will consist of a FeatureCollection containing a list of your data. Let’s take a look at a simple example. {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -90.0715, 29.9510 ]\n      },\n      \"properties\": {\n        \"name\": \"Fred\",\n   \t\t\"gender\": \"Male\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -92.7298, 30.7373 ]\n      },\n      \"properties\": {\n        \"name\": \"Martha\",\n   \t\t\"gender\": \"Female\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -91.1473, 30.4711 ]\n      },\n      \"properties\": {\n        \"name\": \"Zelda\",\n\t    \"gender\": \"Female\"\n      }\n    }\n  ]\n} At the top level you can see that I’m defining a FeatureCollection , or list of data. I then define my features , which is an array of Feature objects. Each Feature has a geometry object and a properties object. The geometry object will either be a Point , LineString , Polygon , MultiPoint , MultiLineString , or MultiPolygon . Each type should be pretty self-explanatory but certainly leave a comment if any aren’t clear. Inside properties you can see I’ve specified both a name and gender value for my cats. I can specify any data here at all, but as you can imagine, putting some thought into it and being consistent will go a long way to making your data more useful. Working with GeoJSON So given that you want to work with this type of file, how can you work with and display your data? The good news is that it’s just JSON. If you’re using JavaScript, the “effort” involved is a grand total of one line of code: let myData = JSON.parse(dataILoadedViaAjaxOrSomeSuch); At that point you’ve got your structured data and can then iterate over the features and do… well whatever you want with them. Consider this example where I use Vue to load in the JSON above and render it as an unordered list. First the HTML: <div id=\"app\" v-cloak>\n  <ul>\n    <li v-for=\"cat in cats\">\n      Cat {{ cat.name }} is {{ cat.gender }}\n      and is located at {{ cat.pos.lat }}, {{ cat.pos.lon }}\n    </li>\n  </ul>\n</div> Then the JavaScript: Vue.config.productionTip = false;\nVue.config.devtools = false;\n\nconst DATA = 'https://api.jsonbin.io/b/5d6ed60b2d1fb96463c30e63';\n\nconst app = new Vue({\n  el:'#app',\n  data:{\n    cats:[]\n  },\n  async created() {\n    let response = await fetch(DATA);\n    let geodata = await response.json();\n    this.cats = geodata.features.map(c => {\n      return {\n        name:c.properties.name,\n        gender:c.properties.gender,\n        pos: {\n          lat:c.geometry.coordinates[0],\n          lon:c.geometry.coordinates[1],\n        }\n      }\n    });\n  }\n}) Note I do a bit of mapping on the GeoJSON to make it simpler to use in the HTML. There’s no reason the layout need know of the GeoJSON format. You can see the result below (and feel free to play with the code): See the Pen geojson1 by Raymond Camden ( @cfjedimaster ) on CodePen . How about rendering on a map? HERE’s Map Image API makes it easy to display points of interest on a map. I changed my HTML to render an image: <div id=\"app\" v-cloak>\n  <h2>My Cats</h2>\n  <img :src=\"src\" v-if=\"poiList\">\n</div> And my JavaScript now generates an image URL based on the Map Image API: Vue.config.productionTip = false;\nVue.config.devtools = false;\n\nconst DATA = 'https://api.jsonbin.io/b/5d6ed60b2d1fb96463c30e63';\nconst APP_ID = 'your app id here';\nconst APP_CODE = 'your app code here';\n\nconst app = new Vue({\n  el:'#app',\n  data:{\n    poiList:''\n  },\n  async created() {\n    let response = await fetch(DATA);\n    let geodata = await response.json();\n    this.poiList = geodata.features.reduce((acc, curr) => {\n      if(acc !== '') acc += ',';\n      return acc += curr.geometry.coordinates[1] + ',' + curr.geometry.coordinates[0]\n    },'');\n  },\n  computed:{\n    src() {\n      return `https://image.maps.api.here.com/mia/1.6/mapview?app_id=${APP_ID}&app_code=${APP_CODE}&poi=${this.poiList}&w=400&h=300&z=8`;\n    }\n  \n  \n  }\n}) Feel free to play around with this version here: See the Pen geojson2 by Raymond Camden ( @cfjedimaster ) on CodePen . Testing GeoJSON So hey, you absolutely love GeoJSON and want to give it a spin in your own applications? Of course you do! Here’s two tools to help make working with GeoJSON easier. First, if you’re a Visual Studio Code user (and let’s be honest, most of you are), you can find an excellent extension called VSCode Map Preview . As you can guess, this extension provides a map view of your GeoJSON data. Given the cat data I shared earlier, I can hit F1, run Map Preview , and get the following output: This is a handy little tool, but note that it doesn’t currently support updating when you edit your text. You’ll have to close and re-open the preview to see changes. (This is a known issue .) Another option is the GeoJSON Viewer created by the HERE XYZ team. It has a built in editor and viewer. What’s cool is that the editor provides validation on your data. As you can see here, I’m clearly not providing the right information and I’ve got real time feedback about my issues. The Viewer also lets you import GeoJSON data via URL or files. I took data from the National Park’s System GeoJSON file and imported it into the viewer: As you can see, it does a pretty impressive job of rendering a lot of data! What Else? Obviously as a simple, easily to parse spec, there’s quite a bit you can do with GeoJSON. Industry adoption will impact how successful this spec is, but if you are already offering your data via an API, there’s no reason not to support this format. Give it a try and if you’ve got an example of your own use of GeoJSON, leave me a comment below!", "date": "2019-09-04"},
{"website": "Here", "title": "Getting Started with Harp.gl and Angular to Map Your Data", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/getting-started-with-harp.gl-and-angular-to-map-your-data", "abstract": "As you may have heard, HERE Technologies released its new open source 3D map renderer, harp.gl, into beta . In case you missed it, harp.gl leverages WebGL, three.js, and TypeScript to visual data on a map while leveraging the power of the GPU. This opens the door to functionality like 3D maps, different camera options, and a lot more. In this tutorial, we’re going to see how to get started with harp.gl , but using the popular Angular framework on the web. To get an idea of what we’re going to accomplish, take a look at the following animated image: The above image features a map and a few points that some might to refer to as markers. While it doesn’t look like much, how the tiles are rendered and how the points are rendered are actually a big deal, more specifically when working with massive amounts of data like you might find in HERE XYZ . So let’s take a look at how to reproduce what was done in the image. Create a New Angular Project with the Angular CLI To be successful with this tutorial, you will need to have the Angular CLI available. With it installed, execute the following: ng new harp-project After the project is created, we need to import the harp.gl dependencies. There are two approaches to doing this: Using the Node Package Manager (NPM). Using browser libraries with <script> tags. For this particular tutorial we’re going to be using browser libraries. This is similar to what I demonstrated when working with the core HERE Location Services (HLS) map in my tutorial titled, Display HERE Maps within your Angular Web Application . The NPM approach is a little more complex, so we’ll explore it in another tutorial. Remember, harp.gl, as of writing this, is a beta product. It is expected that there are bugs here and there. Open the project’s src/index.html file and include the following: <!doctype html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <title>HarpProject</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n    </head>\n    <body style=\"margin: 0\">\n        <app-root></app-root>\n        <script src=\"https://unpkg.com/three/build/three.min.js\"></script>\n        <script src=\"https://unpkg.com/@here/harp.gl/dist/harp.js\"></script>\n    </body>\n</html> Notice that we’ve included harp.gl as well as three.js. We’re going to need one more dependency which is important for parsing GeoJSON data. To get this dependency, execute the following from your CLI: npm install geojson --save Since GeoJSON is still JSON, we don’t absolutely need the above dependency, but it will make our lives a lot easier. You can learn more about this package in a previous tutorial I wrote titled, Format Data into GeoJSON with JavaScript to be used with HERE XYZ . We don’t need any further development dependencies to be successful in our project. However, we do need a HERE Developer Account and an XYZ access token . Develop an Angular Component for the Harp.gl Map and Logic With harp.gl included in our project through browser libraries and us having a developer account, we can proceed towards using harp.gl in our project. When it comes to Angular, the best practice is to create a separate component for all of our harp.gl shenanigans. This will help us reduce duplicate code throughout our application. From the Angular CLI, execute the following: ng g component harp The above command will create a new component which consists of a CSS file, an HTML file, and a TypeScript file. Let’s start by adding a placeholder element to our HTML file. Open the project’s src/app/harp/harp.component.html file and include the following: <canvas #map style=\"width: 100vw; height: 100vh\"></canvas> We’re creating a <canvas> element that is set to take up the full viewport width and height of the browser. What’s most important to us is the #map reference variable. We cannot use commands like document.getElementById in Angular, so we have to use special reference variables if we wish to interact directly with DOM elements. Now open the project’s src/app/harp/harp.component.ts file and include the following: import { Component, OnInit, ViewChild, Input, ElementRef } from '@angular/core';\nimport * as GeoJSON from \"geojson\";\n\ndeclare var harp: any;\n\n@Component({\n    selector: 'harp',\n    templateUrl: './harp.component.html',\n    styleUrls: ['./harp.component.css']\n})\nexport class HarpComponent implements OnInit {\n\n    @ViewChild(\"map\", { static: false })\n    private mapElement: ElementRef;\n\n    @Input(\"token\")\n    private token: string;\n\n    @Input(\"lat\")\n    private lat: Number;\n\n    @Input(\"lng\")\n    private lng: Number;\n\n    private map: any;\n\n    public constructor() { }\n\n    public ngOnInit() { }\n\n    public ngAfterViewInit() { }\n\n    public dropPoints(name: string, positions: any[]) { }\n\n    public createPoints(positions: any[]): any { }\n\n} The above code is mostly boilerplate as there isn’t any real logic as of now. You’ll notice that we are importing the GeoJSON dependency that we had previously installed. Because we are using browser libraries for our project rather than NPM modules with TypeScript definitions, we need to configure the transpiler to ignore any warnings that the definitions don’t exist. This can be done through the following: declare var harp: any; Within the HarpComponent class, we have several annotations in the form of @ViewChild and @Input . The @ViewChild allows us access to the reference variable we had set in the HTML file, while the @Input allow us access to any tag attributes that we’ll see soon. For this example, we’ll be able to pass the access token and a center latitude and longitude point as tag attributes. When the view finishes rendering for the component, we make use of the ngAfterViewInit life-cycle event. In it we can configure the map, among other things. public ngAfterViewInit() {\n    this.map = new harp.MapView({\n        canvas: this.mapElement.nativeElement,\n        theme: \"https://unpkg.com/@here/harp-map-theme@0.3.3/resources/berlin_tilezen_base.json\",\n    });\n    const controls = new harp.MapControls(this.map);\n    const omvDataSource = new harp.OmvDataSource({\n        baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n        apiFormat: harp.APIFormat.XYZOMV,\n        styleSetName: \"tilezen\",\n        authenticationCode: this.token,\n    });\n    this.map.addDataSource(omvDataSource);\n    this.map.setCameraGeolocationAndZoom(new harp.GeoCoordinates(Number(this.lat), Number(this.lng)), 12);\n} Notice a few things that are happening in the above code. First we’re getting our <canvas> tag from the reference variable. After, we are defining our data source which is through HERE XYZ and an access token that we obtained at the beginning of this tutorial. It will eventually be passed in as a tag attribute. Finally, after the data source is added to the map and rendered, we can re-center the map on the coordinates that were passed. At this point we should have a basic map that we can interact with. Now let’s look at adding some points on the map. To create points on the map, we have a two step process. The first step is to create a GeoJSON object: public createPoints(positions: any[]): any {\n    return GeoJSON.parse(positions, { Point: [\"lat\", \"lng\"] });\n} Using this createPoints function, we can accept an array of latitude and longitude objects, use our GeoJSON dependency, and return properly formatted GeoJSON features. The next step is to take those features, and add them to the map as another data source. public dropPoints(name: string, positions: any[]) {\n    const geoJsonDataProvider = new harp.GeoJsonDataProvider(name, this.createPoints(positions));\n    const geoJsonDataSource = new harp.OmvDataSource({\n        dataProvider: geoJsonDataProvider,\n        name: name\n    });\n    this.map.addDataSource(geoJsonDataSource).then(() => {\n        const styles = [{\n            when: \"$geometryType == 'point'\",\n            technique: \"circles\",\n            renderOrder: 1,\n            attr: {\n                color: \"#7ED321\",\n                size: 15\n            }\n        }];\n        geoJsonDataSource.setStyleSet(styles);\n        this.map.update();\n    });\n} Notice that in the dropPoints method we are defining the style information for our points. The process behind showing points isn’t too different from showing the map tiles. However, we still need to render them on the map. To do this, we can update our ngAfterViewInit method like so: public ngAfterViewInit() {\n    this.map = new harp.MapView({\n        canvas: this.mapElement.nativeElement,\n        theme: \"https://unpkg.com/@here/harp-map-theme@0.3.3/resources/berlin_tilezen_base.json\",\n    });\n    const controls = new harp.MapControls(this.map);\n    const omvDataSource = new harp.OmvDataSource({\n        baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n        apiFormat: harp.APIFormat.XYZOMV,\n        styleSetName: \"tilezen\",\n        authenticationCode: this.token,\n    });\n    this.map.addDataSource(omvDataSource);\n    this.map.setCameraGeolocationAndZoom(new harp.GeoCoordinates(Number(this.lat), Number(this.lng)), 12);\n    this.dropPoints(\"example-points\", [{ lat: 37.7497, lng: -121.4252 }, { lat: 37.7597, lng: -121.4352 }]);\n} Not so bad right? We can bring this tutorial to a close by actually showing the map on the screen with our hard-coded point values. Open the project’s src/app/app.component.html file and include the following markup: <harp\n    token=\"XYZ_ACCESS_TOKEN_HERE\"\n    lat=\"37.7397\"\n    lng=\"-121.4252\">\n</harp> Remember, inside the project’s src/app/harp/harp.component.ts file we set the selector value to be harp , hence why the tag name is <harp> in the HTML file. When using this code, don’t forget to use your own access token for rendering. Conclusion You just saw how to use harp.gl in your Angular project for mapping and data visualization purposes. Remember, harp.gl leverages WebGL which puts more emphasis on the power of your GPU for intense visualization tasks.", "date": "2019-08-08"},
{"website": "Here", "title": "Add voice-powered AI to anything with Houndify and HERE", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/add-voice-powered-ai-to-anything-with-houndify-and-here", "abstract": "Developers working with AI now have more to look forward to – through our partnership with SoundHound Inc. ®, the leading innovator in voice-enabled AI and conversational intelligence technologies we will enable developers to apply real-world location data from HERE Technologies to their applications. The aim is clear: to improve the driver experience and enhance safety. Drivers will be able to activate navigation by simply speaking, as opposed to keying in the information or logging on to a secondary mobile app. Developers will be able to fast-track the development of location-centric applications by leveraging the global map data and curated location content in combination with readily available location services, including rendering, search, routing, transit, and positioning. The integration will provide precise, end-to-end tracking and accurate, real-time and historical locations. This is especially useful in cars, where a vehicle’s ability to understand its precise positioning, retain contextual awareness of the environment, and store local knowledge of road rules is crucial. HERE provides mapping data on more than 200 countries for the newest Houndify domain. Houndify is the independent AI platform that enables developers and business owners to deploy a custom voice assistant anywhere and retain control of their brands and users. It provides all the ingredients necessary for voice and AI integration:  fast speech recognition, sophisticated natural language understanding, custom wake words, easy to use developer tools, knowledge graphs, and a large and rapidly growing number of domains. We’re thrilled to partner with SoundHound Inc. to provide a safer, natural way for end-users to engage with mobile navigation applications. Those of you interested in exploring this new voice activation on the Houndify platform can visit Houndify.com to learn more and register. I'm looking forward to what exciting services you build with both platforms!", "date": "2019-08-20"},
{"website": "Here", "title": "Mapping Your Data with the GPU using Harp.gl and Vue", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/mapping-your-data-with-the-gpu-using-harp.gl-and-vue", "abstract": "I recently wrote about using harp.gl along with the Angular framework to visualize potentially large amounts location data on a map. In case you were unfamiliar, harp.gl is a new open source 3D map renderer that leverages the GPU through WebGL, three.js, and TypeScript. Per popular request, I decided to reproduce the tutorial that I had previously written, but this time with Vue.js, another popular framework. To get an idea of what we want to accomplish, take a look at the following animated image: The goal is to render our map tiles, and show points at certain locations. It may sound very familiar to you if you’ve ever worked with the standard HERE interactive map APIs, or Leaflet, or something similar, but behind the scenes harp.gl is using a much more powerful engine that can be incredibly useful in certain scenarios. Create a New Project with the Vue CLI To be successful with this project you’ll need the Vue CLI. It isn’t a requirement to use Vue, but it will add the boilerplate code necessary to be successful with this particular example. From the CLI, execute the following: vue create harp-vue-project The above command may ask several questions in regards to the project configuration. Since this is a simple example, the defaults work fine. With the project created, we need to import the harp.gl dependencies. For this example, we’ll use the browser libraries and explore other options in a future tutorial. Open the project’s public/index.html file and include the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>harp</title>\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but harp doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://unpkg.com/three/build/three.min.js\"></script>\n        <script src=\"https://unpkg.com/@here/harp.gl/dist/harp.js\"></script>\n    </body>\n</html> Notice that we’ve included two different <script> tags towards the bottom of our HTML markup. There is one more dependency that we’ll be using, and while it isn’t a requirement, it will make our lives a little bit easier. From the CLI, execute the following: npm install geojson --save When the time comes to visualize points on the map, we’ll need to be using GeoJSON formatted point data. This can be created manually since GeoJSON is just JSON that follows a certain specification, or we can use a library to do this for us. We’re choosing to use a library that will do this for us. Creating a Harp.gl Map Component for the Project When working with Vue, it is a good idea to create separate components for the functionality within the application. This keeps the code clean and allows for the components to be reused. We’re going to create a component for all of our map functionality. Create a src/components/HarpMap.vue file within the project and add the following boilerplate code: <template>\n    <div>\n        <canvas ref=\"map\" style=\"width: 100vw; height: 100vh\"></canvas>\n    </div>\n</template>\n\n<script>\n    import GeoJSON from \"geojson\";\n    export default {\n        name: \"HarpMap\",\n        props: {\n            token: String,\n            lat: String,\n            lng: String\n        },\n        mounted() { },\n        methods: {\n            createPoints(positions) { },\n            dropPoints(name, positions) { }\n        }\n    }\n</script>\n\n<style scoped></style> Let’s break down what’s happening in the above code before we continue. Inside the <template> block we have a <canvas> tag with style information that is set to take up the full space of the viewport. What’s most important to us is the ref attribute because it is how we can gain access to the component in Vue. Inside the <script> block, we define our class information. We import the GeoJSON package, define a few methods, and define our possible tag properties. The tag properties are the attributes that are allowed when using the <HarpMap> tag. We’ll allow the user to provide token information, and center point information. Now let’s take a look at displaying a map when this component is used. We can do that within the mounted method which is a Vue life-cycle event that triggers after the application has rendered. mounted() {\n    this.map = new harp.MapView({\n        canvas: this.$refs.map,\n        theme: \"https://unpkg.com/@here/harp-map-theme@latest/resources/berlin_tilezen_night_reduced.json\",\n    });\n    const controls = new harp.MapControls(this.map);\n    const omvDataSource = new harp.OmvDataSource({\n        baseUrl: \"https://xyz.api.here.com/tiles/herebase.02\",\n        apiFormat: harp.APIFormat.XYZOMV,\n        styleSetName: \"tilezen\",\n        authenticationCode: this.token,\n    });\n    this.map.addDataSource(omvDataSource);\n    this.map.setCameraGeolocationAndZoom(new harp.GeoCoordinates(Number(this.lat), Number(this.lng)), 12);\n}, In the mounted method, the reference to the <canvas> tag is obtained and used on a new map. A new data source is also defined, and it uses a HERE XYZ access token. This token can be obtained through the HERE XYZ CLI or through the HERE XYZ Token Manager . Finally, the data source is added to the map and the map is centered on the latitude and longitude coordinates that were passed by the user. During the map configuration, the theme of the map can be defined as well as the tiles source. Using the Harp.gl Vue Component At this point in time the Vue component is ready for use, even if we’re not quite done with it. Open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <HarpMap \n            token=\"XYZ_ACCESS_TOKEN\" \n            lat=\"37.7397\" \n            lng=\"-121.4252\" />\n    </div>\n</template>\n\n<script>\n    import HarpMap from './components/HarpMap.vue'\n\n    export default {\n        name: 'app',\n        components: {\n            HarpMap\n        }\n    }\n</script>\n\n<style>\n    body {\n        margin: 0;\n    }\n</style> In the above markup, the HarpMap component was imported and it was used as a tag in the <template> block. Running the application, assuming the access token is provided, should show an interactive harp.gl map. As of right now there are no map objects. Including Visual Points on the Harp.gl Map When it comes to harp.gl, markers are known as points. The process of adding a point is similar to adding the initial data source which is the map tiles. We’ll be providing the data source, which is point data, and then styling each element in that data. We’re going to break this down into two functions, starting with the createPoints function: createPoints(positions) {\n    return GeoJSON.parse(positions, { Point: [\"lat\", \"lng\"] });\n}, Remember that GeoJSON package? We’re using it to take an array of latitude and longitude positions and convert them into a GeoJSON feature set. The next step is to draw those points to the map. We can look at the dropPoints method for this: dropPoints(name, positions) {\n    const geoJsonDataProvider = new harp.GeoJsonDataProvider(name, this.createPoints(positions));\n    const geoJsonDataSource = new harp.OmvDataSource({\n        dataProvider: geoJsonDataProvider,\n        name: name\n    });\n    this.map.addDataSource(geoJsonDataSource).then(() => {\n        const styles = [{\n            when: \"$geometryType == 'point'\",\n            technique: \"circles\",\n            renderOrder: 1,\n            attr: {\n                color: \"#7ED321\",\n                size: 15\n            }\n        }];\n        geoJsonDataSource.setStyleSet(styles);\n        this.map.update();\n    });\n} A name and GeoJSON feature set is provided as the data source. This acts as a layer on the map. When adding the data source to the map, style information is defined which says that each item in the data source should be rendered as a green circle. This method can be used in the mounted method if we want to show points when the map loads: this.dropPoints(\"example-points\", [{ lat: 37.7497, lng: -121.4252 }, { lat: 37.7597, lng: -121.4352 }]); Of course we could be providing many points or we could be designing the application to show the data differently. However, what we did is a good starting point to becoming familiar with the harp.gl process. Conclusion You just saw how to use harp.gl in a Vue web application. Like previously mentioned, harp.gl can be a powerful tool if you need to visualize a lot of data or complex data because it leverages the GPU of the client. If you’re more of an Angular fan, check out my previous tutorial which uses Angular instead.", "date": "2019-08-20"},
{"website": "Here", "title": "HERE Fleet Telematics Route Matching API", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/here-fleet-telematics-route-matching-api", "abstract": "Often wonder why does the route trace show that your delivery truck drove right through an apartment building? You will find out why and ways to fix it, in the tutorial below As much as a map is useful during the drive to help you navigate, it is equally useful in giving you insights about your trip once done. Fleet management services use this trip report to not only show where the vehicle traveled, but also information like the time when it reached a certain location, the average speed, driving behaviour, etc. This information is paramount to increase the efficiency of the fleet. While the trace of the route is pretty straight-forward for open roads, the trace of a route where the road is flanked by tall buildings can look like this, Raw trace with skewed route This can happen due to many reasons, where multipath effect due to the surrounding tall buildings is a major contributer. The signals received by the GNSS receiver from the satellites is interrupted by the tall buildings. This signal reflects and follows an alternative path to the receiver. The receiver thus receives two signals , with the same content but at different times. This confuses the receiver and thus it can skew the positon, by a little. Multipath effect To adjust for this skew in position, a complex algorithm had to be written to snap the vehicle to the nearest possible point on the road. Today it is possible by simply using the HERE Fleet Telematics Route Match API This API is a REST call which reads the raw route and returns a 'cleaned up' version of the route. To use this API, you need an app_id and app_code . If you don't have credentials yet, you can get them by signing up for free at the HERE Developer Portal We begin by getting the route waypoints in a csv/ gpx format. Make sure that the csv contains columns named 'latitude' and 'longitude'. We then convert this file into a zipped and Base64-encoded format. This can be done using simple online tools like this We do this as the route match API accepts a zipped and Base64-encoded csv/ gpx file as a parameter while calculating the corrected route. The REST call then looks like this: GET https://rme.api.here.com/2/matchroute.json?app_id={{YOUR_APP_ID}}&app_code={{YOUR_APP_CODE}}&routemode=truck&file=bGF0aXR1ZGUsbG9uZ2l0dWRlLHRpbWVzdGFtcCxzcGVlZF9rbWgsdmVoaWNsZUlkCjQ4LjEyMTAy\nODkwMDEsLTEuNjg3NzExOTU0MSwyMDE5LTA2LTE2VDEyOjQzOjAzKzAyOjAwLDcuOTEsUm9tYW4n\ncyBDYXIgMQo0OC4xMjEwMjUwODU0LC0xLjY4Nzc2OTAzMTUsMjAxOS0wNi0xNlQxMjo0MzowNCsw\nMjowMCw4LjIsUm9tYW4ncyBDYXIgMQo0OC4xMjEwMjEyNzA3LC0xLjY4NzgyNjA2MTIsMjAxOS0w\nNi0xNlQxMjo0MzowNSswMjowMCw4Ljc4LFJvbWFuJ3MgQ2FyIDEKNDguMTIwOTk0NTY3OCwtMS42\nODc4NjA5NjU3LDIwMTktMDYtMTZUMTI6NDM6MDYrMDI6MDAsOC45OCxSb21hbidzIENhciAxCjQ4\nLjEyMDk2Nzg2NDksLTEuNjg3OTAxMDIsMjAxOS0wNi0xNlQxMjo0MzowNyswMjowMCw4LjgsUm9t\nYW4ncyBDYXIgMQo0OC4xMjA5NDg3OTE1LC0xLjY4Nzk1Mzk0ODksMjAxOS0wNi0xNlQxMjo0Mzow\nOCswMjowMCwxMC4wLFJvbWFuJ3MgQ2FyIDEKNDguMTIwOTQ0OTc2OCwtMS42ODgwMDIwMTQxLDIw\nMTktMDYtMTZUMTI6NDM6MDkrMDI6MDAsMTAuOTgsUm9tYW4ncyBDYXIgMQo0OC4xMjA5Mjk3MTgs\nLTEuNjg4MDU3OTk0OCwyMDE5LTA2LTE2VDEyOjQzOjEwKzAyOjAwLDEyLjI2LFJvbWFuJ3MgQ2Fy Here the parameter file is has the encoded file discussed above. The parameter routemode supports arguements \"car, bus, taxi, carHOV, pedestrian, truck, delivery, emergency, motorcycle, roadtrain, custom1, bdouble, bicycle, tractorTruck\". The response of this GET call incliudes a JSON object with the original waypoints and linkid. What we are interested in, is the object named TracePoints which contains the latMatched and lonMatched objects which are the matched points corresponding to the given input. You can find details about other parameters in the response here . We can now use the TracePoints.latMatched and TracePoints.lonMatched to draw a polyline within them to display the route. var xmlhttp = new XMLHttpRequest();\nvar points = [];\n\n\nxmlhttp.onreadystatechange = function() {\n  if (this.readyState == 4 && this.status == 200) {\n   \n    var myObj = JSON.parse(this.responseText);\n    var i;\n    for (i=0; i < myObj.TracePoints.length; i++){\n      points[i] = {\"lat\": myObj.TracePoints[i].latMatched, \"lng\": myObj.TracePoints[i].lonMatched};\n      \n    }\n    addPolylineToMap(map, points);\n  }\n    \n  };\n\n  xmlhttp.open(\"GET\", \"https://ks.github.io/hosted/route_match_response.json\", true);\n  xmlhttp.send();\n\n\n  function addPolylineToMap(map,points) {\n    var lineString = new H.geo.LineString();\n  \n    points.forEach(function(point) {\n        lineString.pushPoint(point);\n      });\n  \n      polyline = map.addObject(new H.map.Polyline(\n      lineString, { style: { lineWidth: 4 }}\n    ));\n      \n      map.setViewBounds(polyline.getBounds());\n  \n  } The url used in this GET request is where I have hosted the JSON response received from the routematch API. You can chose to handle it in any manner. The important part is the plotting of the polyline with the {\"lat\": myObj.TracePoints[i].latMatched, \"lng\": myObj.TracePoints[i].lonMatched} . You can plot both the routes side-by-side and see the difference for yourself. Comparison of original route with the matched route You can now get rid of illogical traces and get clean traces with a simple API. Happy coding!", "date": "2019-09-06"},
{"website": "Here", "title": "Planning Your Package Deliveries with the HERE Waypoint Sequence Extension API and Vue.js", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/planning-your-package-deliveries-with-the-here-waypoint-sequence-extension-api-and-vue.js", "abstract": "When it comes to routing, knowing how to get from point A to point B in the most efficient manner isn’t exactly the only use-case. When it comes to modern applications or use-cases, a lot more can be and should be accomplished. Let’s take the scenario of a package delivery service. When it comes to a delivery driver, they fill up their truck at the warehouse and have to navigate to every address that exists on a package in their truck before returning the truck to the warehouse. The driver can’t just pick random packages from the truck and deliver them randomly because that would be very inefficient. Instead, each delivery should be carefully planned to optimize how many packages can be delivered and the quickest. So given X number of random addresses, how do you plan your route so that efficiency is the priority? This is where the HERE Waypoint Sequence Extension API comes into play. Give it a series of positions and it will return the order that those positions should be navigated to. Then you can take that ordered sequence and calculate the actual route between them. We’re going to explore the Waypoint Sequence API in this tutorial using the Vue.js JavaScript framework. To get an idea of what we want to accomplish, take the following animated image: What you can’t see in the above image is that I provided a bunch of random positions. After receiving an ordered sequence from the Waypoint Sequence API, numbers are attached to each marker to represent the order of access. Then a route is calculated and drawn between the markers. This was all done using Leaflet.js with Vue.js and a fancy polyline animation library. Create a New Vue.js Project with the Vue CLI Because this will be a Vue.js example, a new project needs to be created with the Vue CLI. Assuming the CLI has been installed, execute the following: vue create wse-project We’re not in the clear yet. Because we’ll be making HTTP requests to the HERE APIs, we’ll need to install a particular package to get the job done. From the CLI, execute the following: npm install axios --save We’ll be using the axios library to make HTTP requests. There are plenty of other ways to do this, but axios makes it very clean. If you’d like to learn about other ways to make HTTP requests with JavaScript, check out my previous tutorial titled, Execute HTTP Requests in JavaScript Applications . No further NPM modules are necessary, but we will be needing a few browser dependencies. Open the project’s public/index.html file and include the following: <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n        <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n        <title>WSE Project</title>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.5.1/dist/leaflet.css\" />\n    </head>\n    <body>\n        <noscript>\n            <strong>We're sorry but the app doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>\n        </noscript>\n        <div id=\"app\"></div>\n        <!-- built files will be auto injected -->\n        <script src=\"https://unpkg.com/leaflet@1.5.1/dist/leaflet.js\"></script>\n        <script src=\"https://cdn.jsdelivr.net/npm/leaflet.polyline.snakeanim@0.2.0/L.Polyline.SnakeAnim.min.js\"></script>\n    </body>\n</html> You’ll notice a few things in the above HTML. We’re adding both the Leaflet.js CSS and JavaScript dependencies as well as the snake animation dependency to give us a nice polyline animation. At this point in time we can start developing our component. Design a Leaflet.js Component for Maps and Location Functionality To keep our code clean and reusable, we’re going to create a separate Vue component for everything related to maps and location. Within the project’s src/components directory create a LeafletMap.vue file with the following boilerplate code: <template>\n    <div>\n        <div ref=\"map\" style=\"width: 100vw; height: 100vh;\"></div>\n    </div>\n</template>\n\n<script>\n    import axios from \"axios\";\n    export default {\n        name: \"LeafletMap\",\n        data() {\n            return {\n                platform: {},\n                map: {},\n                sequenceMarkerGroup: {}\n            }\n        },\n        props: {\n            appId: String,\n            appCode: String,\n            latitude: String,\n            longitude: String\n        },\n        created() { },\n        async mounted() { },\n        methods: {\n            dropMarker(position, text) { },\n            async calculateRouteSequence(places) { },\n            drawRoute(sequence) { }\n        }\n    }\n</script>\n\n<style></style> You’ll notice in the above code that we have several properties, several methods, and a few life-cycle events that are a part of Vue. The Props will represent properties passed when the component is created, the mounted method will load the map when the application starts, and each of the methods will help us with our Waypoint Sequence and drawing. A lot of the above code was explored in other tutorials that I’ve written on the subject of Leaflet.js. Let’s first draw our map. Within the mounted method, include the following: async mounted() {\n    const tiles = \"https://1.base.maps.api.here.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/512/png8?app_id={appId}&app_code={appCode}\";\n    this.map = new L.Map(this.$refs.map, {\n        center: [this.latitude, this.longitude],\n        zoom: 10,\n        layers: [L.tileLayer(tiles, { appId: this.appId, appCode: this.appCode })]\n    });\n}, To use Leaflet, we need to supply it map tiles. Using the HERE Map Tile API and a valid app id and app code from the HERE Developer Portal , we can configure our map. Make note that the this.$refs.map parameter references the ref attribute found within the <template> block. To use this component, open the project’s src/App.vue file and include the following: <template>\n    <div id=\"app\">\n        <LeafletMap\n            ref=\"map\"\n            appId=\"APP_ID_HERE\"\n            appCode=\"APP_CODE_HERE\"\n            latitude=\"37.7297\"\n            longitude=\"-121.4252\"\n        />\n    </div>\n</template>\n\n<script>\n    import LeafletMap from './components/LeafletMap.vue'\n\n    export default {\n        name: 'app',\n        components: {\n            LeafletMap\n        },\n        async mounted() {\n            let map = this.$refs.map;\n        }\n    }\n</script>\n\n<style>\n    body {\n        margin: 0;\n    }\n</style> In the above code we are importing the LeafletMap class and including it with the necessary properties for rendering. We should be up to speed now when it comes to the Leaflet.js foundation. Calculate the Waypoint Sequence with HERE and HTTP Requests The focus of this tutorial is around the HERE Waypoint Sequence API and calculating the sequence of waypoints for a optimal route. Before we start playing around with the API, let’s define a bunch of positions to be used. Within the src/App.vue file, add the following to the mounted function: let mockPlaces = [\n    { latitude: 37.74682893940135, longitude: -121.4198684692383 },\n    { latitude: 37.73488314788311, longitude: -121.44561767578126 },\n    { latitude: 37.72076290898376, longitude: -121.41712188720705 },\n    { latitude: 37.74251196215947, longitude: -121.435 },\n    { latitude: 37.731793096495316, longitude: -121.41770044283479 },\n    { latitude: 37.74, longitude: -121.46 },\n    { latitude: 37.72, longitude: -121.455 }\n]; The above is just an array of positions in no particular order, and existing somewhere around the center point of my map. Now that we have some data, let’s make use of the API. In the calculateRouteSequence function of the project’s src/components/LeafletMap.vue file, include the following: async calculateRouteSequence(places) {\n    let waypoints = {};\n    for(let i = 0; i < places.length; i++) {\n        waypoints[\"destination\" + (i + 1)] = `${places[i].latitude},${places[i].longitude}`;\n    }\n    return axios({\n        \"method\": \"GET\",\n        \"url\": \"https://wse.api.here.com/2/findsequence.json\",\n        \"params\": {\n            \"start\": `${this.latitude},${this.longitude}`,\n            ...waypoints,\n            \"end\": `${this.latitude},${this.longitude}`,\n            \"mode\": \"fastest;car;traffic:enabled\",\n            \"departure\": \"now\",\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        }\n    }).then(response => {\n        return response.data.results[0].waypoints\n    });\n}, The places parameter represents the mockPlaces array that we had just created. We need to properly format that data in a way that the API expects, so we loop through the array and format it more like the following: waypoints: {\n    \"destination0\": \"...\",\n    \"destination1\": \"...\",\n    \"destination2\": \"...\",\n} Once we have all of our properly formatted waypoints in no particular order, we can make a request with the axios library. The start and end positions can represent the warehouse that we’re starting at and the warehouse that we need to return to after all of our packages are delivered. The response to our request will be our ordered sequence of waypoints. To use the calculateRouteSequence function, go to the project’s src/App.vue file and include the following in the mounted function: let sequence = await map.calculateRouteSequence(mockPlaces); Having the sequence as raw data isn’t particularly exciting. Instead we can draw markers at each point in the sequence and give them a number. This way we can see which marker represents which stop in our path. Within the project’s src/components/LeafletMap.vue file, add the following to the dropMarker method: dropMarker(position, text) {\n    let icon = L.divIcon({\n        html: `\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"50\">\n                <circle cx=\"25\" cy=\"25\" r=\"25\" fill=\"#000000\" />\n                <text x=\"50%\" y=\"50%\" text-anchor=\"middle\" fill=\"white\" font-size=\"25px\" dy=\".3em\">${text}</text>\n            </svg>\n        `.trim()\n    });\n    L.marker([position.lat, position.lng], { icon: icon }).addTo(this.sequenceMarkerGroup);\n    this.sequenceMarkerGroup.addTo(this.map);\n    this.map.fitBounds(this.sequenceMarkerGroup.getBounds());\n}, Leaflet doesn’t have a good way to add text to markers unless you’re using an SVG marker. For that reason, we can take a position and some text, whip up a dynamic SVG, then add it to the map. It is a good idea to use a marker group so the markers can be centered on. You can initialize your marker group in the created method: created() {\n    this.sequenceMarkerGroup = new L.featureGroup();\n}, To drop these markers, we need to revisit the project’s src/App.vue file: for(let i = 0; i < sequence.length - 1; i++) {\n    map.dropMarker(sequence[i], i.toString());\n} Because the starting point and the ending point are the same, we’re not looping until the very last point, otherwise our starting marker would be replaced with our ending marker. Not a huge problem, but it can be confusing to look at. Now that we have the best sequence discovered, we can work towards actually navigating between these waypoints. Calculating the Path between Waypoints with the HERE Routing API To calculate a route that can be navigated, the standard HERE Routing API can be used. In the project’s src/components/LeafletMap.vue file, add the following to the drawRoute function: drawRoute(sequence) {\n    let waypoints = {};\n    for(let i = 0; i < sequence.length; i++) {\n        waypoints[\"waypoint\" + i] = `${sequence[i].lat},${sequence[i].lng}`;\n    }\n    axios({\n        \"method\": \"GET\",\n        \"url\": \"https://route.api.here.com/routing/7.2/calculateroute.json\",\n        \"params\": {\n            \"mode\": \"fastest;car;traffic:enabled\",\n            \"representation\": \"display\",\n            ...waypoints,\n            \"app_id\": this.appId,\n            \"app_code\": this.appCode\n        }\n    }).then(result => {\n        let shape = result.data.response.route[0].shape;\n        let line = shape.map(point => {\n            let [lat, lng] = point.split(\",\");\n            return { lat: lat, lng: lng };\n        });\n        new L.Polyline(line, {snakingSpeed: 500}).addTo(this.map).snakeIn();\n    }, error => {\n        console.error(error);\n    });\n} What’s happening in the drawRoute function isn’t too much different than what’s happening in the calculateRouteSequence function. First the sequence data is formatted and it is added to the axios request to the API. The results of the route calculation will consist of points which can be added to a polyline and rendered on the map. We’re using the snake animation library here so that way a nice animation happens for our long route between start and finish. To make use of this drawRoute function, we can add it to the project’s src/App.vue file like so: map.drawRoute(sequence); Just like that we have a best calculated route for our driver or whoever might need an optimized route between waypoints. Conclusion The Waypoint Sequence Extension API that HERE offers is very powerful and is a great candidate for solving the “traveling salesman” problem that a lot of organizations face. While we didn’t need to use Leaflet, I felt the animation library for polylines gave a great visualization to what we were trying to solve.", "date": "2019-08-29"},
{"website": "Here", "title": "Make a map with HERE XYZ and submit it to win up to $10,000 US", "author": ["Phil Johnston"], "link": "https://developer.here.com/blog/here-xyz-mapathon", "abstract": "Do you want to have a real impact on your community? Maybe you are trying to raise funds for a great initiative? What about paying it forward for the next generation. Whatever your reasoning, $10,000 US in your pocket will definitely help you with your goal. Maps have long since been a big part of telling stories about the world. HERE, recently introduced the HERE XYZ Studio & Hub products enabling people to create compelling maps with large datasets. Whether they are complex or simple, maps tell stories. We want to see your story as a map. Tell your story by creating a map using HERE XYZ (Studio and/or Hub), then submit it to the HERE XYZ Mapathon to enter to win up to $10,000 US. Participants of the HERE XYZ Mapathon will compete for prizes totaling $20,000 US. You must enter before November 3 to compete, so don’t delay. Void where prohibited. See challenge rules (link below) for more information. Learn more 👉 https://t.her.is/heremapathon", "date": "2019-09-20"},
{"website": "Here", "title": "Using Map Image API in Azure", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/using-map-image-api-in-azure", "abstract": "Earlier this year, we announced the launch of HERE location services for the Microsoft Azure Marketplace. Specifically, we released three Azure Resource Manager (ARM) templates to simplify the integration of our REST services as Azure functions within an Azure solution. The templates cover the following: Serverless Functions - Deploys HERE location services as Azure functions that can be invoked directly within any Azure applications and/or solutions. Web App Backends - Deploys HERE location services as Azure functions along with Azure Service Bus and Cosmos DB to optimize for web application backend. Real-Time Data Streams - Deploys HERE location services as Azure functions along with Event Hub and Cosmos DB to optimize for real-time streaming applications. Scope and Requirements Although our APIs can be used in multiple client types, our focus will be how to consume Azure Functions from HTML. The following are prerequisites for getting started: HTML experience ( help ) JavaScript experience ( help ) Microsoft Azure account ( https://azure.microsoft.com ) HERE Developer account ( https://developer.here.com ) Deploying Serverless Functions At azure.microsoft.com , select Azure Marketplace . Search for \"HERE Maps\" and select HERE Maps & Location Services . At the landing page for HERE Maps & Location Services, choose GET IT NOW . Follow prompts until you are at the landing page for HERE Maps & Location Services template within the Azure Portal, then select Create . After choosing the basic configuration, you will be prompted to enter your HERE App ID and App Code . Once you have completed the process and deployed the template, navigate to App Services in the Azure Portal. Click on your recently created Function App, which will have its own unique identifier. Within the function app, select the mapImage under the Functions, and then click on the </> Get function URL . Copy the URL and save it to a text file. You will use it in your HTML client page. Consuming MapImage Function Create an HTML page with the following content: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n    <title>Azure - Map Image</title>\n</head>\n<body>\n    <h1>Map Images - Azure Functions</h1>\n    <img id=\"mapImageBase\" src=\"https:// your-azure-url-id .azurewebsites.net/api/map_image/mia/1.6/mapview?c=52.49422,13.37436&w=600&h=480&z=11&code= your-azure-function-code \" />\n    <img id=\"mapImageMarkers\" src=\"https:// your-azure-url-id .azurewebsites.net/api/map_image/mia/1.6/mapview?poi=52.5%2C13.4%2C41.9%2C12.5%2C51.5%2C-0.1%2C48.9%2C2.3%2C40.4%2C-3.7&w=600&h=480&code= your-azure-function-code \" />\n    <img id=\"mapImageProximity\" src=\"https:// your-azure-url-id .azurewebsites.net/api/map_image/mia/1.6/mapview?c=28.6071%2C77.2127&z=12&u=1500&w=600&h=480&code= your-azure-function-code \" />\n    <img id=\"mapImageAddress\" src=\"https:// your-azure-url-id .azurewebsites.net/api/map_image/mia/1.6/mapview?co=britain&z=17&i=1&ci=London&s=downing%20street&n=10&w=600&h=480&code= your-azure-function-code \" />\n</body>\n</html> In the HTML, replace the your-azure-url-id and your-azure-function-code values in each <img> tag's src with what is in your copied URL. View the HTML in browser. You should now see four images representing unique ways to use the map image API. For more commentary and additional uses, please watch our on-demand episode on this topic! Summary Developers can quickly utilize location services from HERE within Azure! To access the code files associated with this post, please visit our GitHub livestreams page for Azure Maps. For more information about HERE, please visit our developer portal at developer.here.com Recently, we launched \"Azure Connections\", a new series on our Twitch channel . The focus of this series is to guide developers how to quickly adopt our Azure Marketplace integrations into coding solutions. Each episode features a core API. The first episode tackles map images, and this post navigates the steps to do the implementation. Join us next on October 2nd, 2019 for the second episode on Geocoding.", "date": "2019-09-10"},
{"website": "Here", "title": "Customizing Map Markers with DOM and SVG Configurations", "author": ["Nic Raboy"], "link": "https://developer.here.com/blog/customizing-map-markers-with-dom-and-svg-configurations", "abstract": "I frequently lurk in Stack Overflow looking for ways to improve the experience developers have with the various HERE APIs. A common question that comes up is around customizing markers, whether that be changing the color of the marker, the shape of the marker, or adding text to the marker. In this tutorial, we’re going to look at a few examples that make this possible. Take a look at the following image: In the above example, we have two custom markers created two different ways. In one marker we are constructing it with DOM found in HTML and in the other marker we are using an SVG image. Creating a Marker with the HTML DOM We’re going to first explore creating markers using simple DOM elements. While my example isn’t too complicated, it could become such if you wanted it to be. Take a look at the following JavaScript code: const dom = document.createElement(\"div\");\ndom.style.width = \"50px\";\ndom.style.height = \"50px\";\ndom.style.borderRadius = \"25px\";\ndom.style.backgroundColor = \"#000000\";\ndom.style.color = \"#FFFFFF\";\ndom.style.display = \"flex\";\ndom.style.fontSize = \"20px\";\ndom.innerHTML = \"<p style='margin: auto'>DOM</p>\";\nconst domIcon = new H.map.DomIcon(dom);\nmap.addObject(new H.map.DomMarker({ lat: 37.2, lng: -121.2 }, { icon: domIcon })); What we’re doing is we’re creating an element, accessing it with JavaScript, and modifying the style information or whatever else is necessary. In this example we’re creating an element where the container is round and of a certain size and color. Then the text is added to the inner portion of the container. Instead of using new H.map.Marker , we make use of a DomMarker which is nearly the same in terms of setup. If you end up using a DomMarker , I’d advise adding the construction of the DOM to its own function so you don’t have to repeat yourself too often. Creating a Marker with SVG XML Another way, and my personal preferred way, is to create an SVG icon for the marker. At its core, an SVG is more or less XML markup to illustrate curves, colors, and other stuff. We can add this XML markup directly to our application and render it. Take the following for example: const svg = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"50\">\n        <circle cx=\"25\" cy=\"25\" r=\"25\" fill=\"#000000\" />\n        <text x=\"50%\" y=\"50%\" text-anchor=\"middle\" fill=\"white\" font-size=\"20px\" dy=\".3em\">SVG</text>\n    </svg>\n`.trim();\nconst svgIcon = new H.map.Icon(svg);\nmap.addObject(new H.map.Marker({ lat: 37, lng: -121 }, { icon: svgIcon })); The above code is an example of defining some XML for an SVG and adding it to a standard marker as an icon. You can come up with much more complex icons when using an SVG. In the above example, it is important to note the use of the trim function for JavaScript. Because I’m using a multiline string for the XML and there are tabs, we need to trim away the whitespace to prevent errors. Like with the DomMarker , I recommend bringing the XML markup for an SVG into its own function. Conclusion You just saw two different ways to create a custom map marker. A third way, and probably the least flexible of the bunch, is to use a static image as your map marker. This will give you a complex marker, but it won’t be very dynamic if you need to change minor features or text ad-hoc. Don’t forget, you don’t need to use SVG or DOM components for markers. If you don’t need to customize anything, a standard marker with the default icon will work just fine.", "date": "2019-09-19"},
{"website": "Here", "title": "HERE is the highest-ranked location platform. Again.", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-is-the-highest-ranked-location-platform.-again", "abstract": "“HERE is once again the highest ranked location platform” – let that sink in. And it is all thanks to you, our developer community. We thought beating Google and the rest in 2018 was a big deal. For a second consecutive year, we – and by that I mean HERE and our developer community – have been named highest ranking location platform in the world. To me, this recognition reaffirms our conviction that you, the developer, are the fundamental pillar that defines the success of any platform. According to Ovum’s most recent Location Platform Index , HERE has maintained its standing as the world’s number one location platform. Having overtaken Google Maps in last year’s Index , HERE has cemented its leadership position as a result of ongoing improvements to the HERE Open Location Platform (OLP), a continuous commitment to developers, investment in artificial intelligence (AI) and a robust privacy framework. Ovum assessed 13 major vendors in the location space, ranking them according to their mapping and technology offering, the size of their reach across developer and OEM ecosystems, and the completeness of their platform offering. Ovum particularly referenced the availability of the following services: HERE XYZ – the location data management tool previously released this year; the launch of HERE Navigation on Demand – the Amazon Alexa integrated Software-as-a-Service (SaaS) in-car navigation solution; HERE Cellular Signals , which provides up-to-date information on mobile network performance on roads in 196 countries, as examples of industry leading developments; and the continuing push into the advertising technology (AdTech) sector with the recent launch of HERE Advertising Data Services . Investing $25 million into a dedicated AI research institute in Austria , we are promoting participation in the data economy through a dedicated reward scheme and examining blockchain’s role in providing a transparent foundation for this. As Ovum analysts Eden Zoller and Charlotte Palfrey state in the report, the ultimate goal for HERE “is to drive the creation of an open, standardized framework for data privacy in the location domain that others could join”. Collaboration is at the center of everything HERE does, with an open platform as the key to innovating location solutions and ultimately enabling an autonomous world for everyone. The work for us doesn't stop with this recognition. Every day our worldwide team are focusing on improving our platform, our experience for developers and our data and content offering. I cannot wait to show you what we have been working on with you soon. Until then, share what you have built with HERE by tweeting @heredev.", "date": "2019-08-16"},
{"website": "Here", "title": "Introducing Our New Customer Support Portal", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/introducing-our-new-customer-support-portal", "abstract": "Developer experience is paramount for us at HERE. And when we say developer experience, we mean everything from the quality and ease of use of our products and services, our documentation, our developer content, our community involvement, billing and of course, you guessed it – support. And to that effect, I am pleased to announce a new and improved support experience for our developers. We are launching a new support portal to help all developers with a paid account on registered on developer.here.com. Now you’ll be able to: search an expanding knowledge base for quick access to answers use a simple ticket form to create support requests access a \"my tickets\" view to manage your support requests and those within your organization The portal is a simpler and more integrated way to receive support from our team. If you have a paid plan, you will be able to log in into the HERE Support Portal with your developer account. If you’re on our Freemium plan, you can always ask and find answers to your questions on Stack Overflow . You can access the Support Portal from your user menu. As always, we appreciate your feedback on the improvements we make to your experience on the HERE developer portal @heredev", "date": "2019-09-24"},
{"website": "Here", "title": "Make a choropleth with qualitative data in XYZ Studio", "author": ["Dylan Babbs"], "link": "https://developer.here.com/blog/make-a-choropleth-with-qualitative-data-in-xyz-studio", "abstract": "A few months ago, we worked with the HERE Social Media team to produce the map for the Marijuana delivery on-demand sparks controversy in legal states article in our company's blog. You can see the full version of the map at this link . In this blog post, we'll present the steps to create a qualitative choropleth map of the legal status of marijuana in the United States with XYZ Studio. Input data The map's original data came in CSV ( comma-separated format ) with just two columns: state name legal status of marijuana (fully legal, medical only, or illegal) Take a look at the dataset: state,status Alaska,Fully legal California,Fully legal Colorado,Fully legal Maine,Fully legal Massachusetts,Fully legal Michigan,Fully legal Nevada,Fully legal Oregon,Fully legal Vermont,Fully legal Washington,Fully legal District of Columbia,Fully legal Arizona,Medical only Arkansas,Medical only Connecticut,Medical only Delaware,Medical only Florida,Medical only Georgia,Medical only Hawaii,Medical only Illinois,Medical only Louisiana,Medical only Maryland,Medical only Minnesota,Medical only Missouri,Medical only Montana,Medical only New Hampshire,Medical only New Jersey,Medical only New Mexico,Medical only New York,Medical only North Dakota,Medical only Ohio,Medical only Oklahoma,Medical only Pennsylvania,Medical only Rhode Island,Medical only Utah,Medical only West Virginia,Medical only Alabama,Illegal Idaho,Illegal Indiana,Illegal Iowa,Illegal Kansas,Illegal Kentucky,Illegal Mississippi,Illegal Nebraska,Illegal North Carolina,Illegal South Carolina,Illegal South Dakota,Illegal Tennessee,Illegal Texas,Illegal Virginia,Illegal Wisconsin,Illegal Wyoming,Illegal The data set contains information for all 50 states plus the District of Columbia. Enriching the data with geometry Before uploading to XYZ Studio to make a map, a single data preparation step is required. XYZ Studio currently only allows data that includes geometry to be uploaded. What that means if that we can't upload data that just contains state or country names, we'll have to upload the actual polygon geometry data of these states. What we'll need to do: acquire open data of state polygon boundaries merge the polygon boundaries data set to our marijuana legality data set output a GeoJSON file Luckily for us, there are plenty of websites online that we can find data sets of state boundaries. For this exercise, let's use the US States 20m file from Eric Celeste's website . Go ahead and download this file. To join these the state boundaries file with the marijuana legal status file, we'll be using a simple node script. This script will import a CSV and export a GeoJSON file. To read in the CSV, we'll use the handy Papaparse library . Create a new project folder and run: npm i papaparse Then make a new file called merge.js that includes the following code: const Papa = require('papaparse');\nconst fs = require('fs')\n\nconst marijuana  = Papa.parse(fs.readFileSync('./data.csv', 'utf8'), {\n    header: true,\n   dynamicTyping: true\n}).data;\nconst states = require('./gz_2010_us_040_00_20m.json');\n\nstates.features.forEach((feature, index) => {\n   const { properties } = feature;\n\n   //Marijuana data set doesn't have information on Puerto Rico, so remove it.\n   if (properties.NAME === 'Puerto Rico') {\n      states.features.splice(index, 1);\n   } else {\n      properties.STATUS = marijuana.find(m => m.state === properties.NAME).status;\n      delete properties.GEO_ID;\n      delete properties.LSAD;\n      delete properties.CENSUSAREA;\n      delete properties.STATE;\n   }\n});\n\nfs.writeFileSync('./output.geojson', JSON.stringify(states)); The above script merges the CSV data with the states polygon boundary to create a unified GeoJSON object. To execute the script, run: node merge.js ...and you should see a new file in your directory called output.geojson . Upload to XYZ Studio Now that we have a GeoJSON file with the state's geometries, we can upload it to XYZ Studio to make the map! Navigate to HERE XYZ Studio and log in to your account. Click on Data Hub in the top-level navigation menu and then Create new XYZ Space so we can begin uploading the data. Drag and drop the file: Make the map Now that the data is uploaded to XYZ Studio, let's begin styling the data. Navigate to Projects in the top-level navigation menu and then click Create new project . Give the map a title and a description: Next, click on + Add to add the marijuana data as a layer to XYZ Studio. We can now start styling the polygons. Conditional styling We'll want to style the state polygons based off the marijuana legal status. To do so, we'll use the conditional styling feature in XYZ Studio, where we can style the data based off a data's property. Click on + Add new polygon style to create a new style group. We'll want to create 3 new style groups: Fully legal. When STATUS Equals Fully legal Medical only. When STATUS Equals Medical only Illegal. When STATUS Equals Illegal Once you've created those three style groups, you can play around with the styling to pick the colors that you prefer. My final map looks like: Conclusion You've learned how to take a data set without geometry values and create a choropleth in XYZ Studio. You can now publish and share your map easily by clicking the Publish Settings button.", "date": "2019-09-11"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.7 release", "author": ["Amanda Taylor"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.7-release", "abstract": "Highlights for this release A utomatic Recovery of Stream Pipelines from Failed Flink JobManager Stream Pipelines using the stream-2.0.x environment can now be run in the High-Availability mode to automatically recover from a failed Flink JobManager. High-Availability mode reduces the downtime during processing to near-zero and is beneficial for the time-sensitive Stream data processing. In this mode, two (2) Flink JobManagers are created for a Stream pipeline job so that when the primary JobManager fails, the secondary JobManager will continue to run the pipeline job. This feature is optional and introduces additional cost for the extra resources. See Stream Pipeline Best Practices for more details. Use Flink Dashboard to troubleshoot currently Running Stream Pipelines Flink Dashboard is now available to view execution and performance details of a Stream pipeline job when it is in the Running state. This functionality is available for Stream-1.5.0 and Stream-2.x.x run-time environments. Access to these details helps in optimizing and troubleshooting Stream pipelines. Each Stream pipeline job in the Running state will be associated with a link that will open the Flink Dashboard in a new browser window/tab. When the Stream pipeline job is canceled or fails, the Flink Dashboard will no longer be available for that job. Delete data from Index Layers With this release, you can delete index layer metadata and data directly by using RSQL queries. This functionality is supported by the following Data interfaces: API, Data Client Library , CLI . Simple switching to Japanese and Chinese languages in the portal The portal can now be viewed in English, Japanese, and Chinese. The language selector can be found in the footer of platform.here.com Changes, Additions and Known Issues SDK for Java and Scala To read about updates to the SDK for Java and Scala, please visit the SDK Release Notes . Web & Portal Added: Request root cause analysis reports through the support portal (not applicable for OLP China) Customers with a platinum level support plan may request a written root cause analysis report for any priority 1 or 2 incident. It is now possible to request these reports through the HERE Support Portal. Visit platform.here.com/contact-us and raise a technical support ticket. The option for a root cause analysis report request is there. Reports are provided within 10 business days of the request. Added : It's now possible to use 'service' as a query parameter when making calls to the HERE Status API. For details, see the API Access page on status.here.com . Added : HERE Location Services (HLS) have been added alongside Open Location Platform Services (OLP) on status.here.com . Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Account & Permissions Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Data Known Issues: Partition list information normally available within the Layer/Partitions tab of the Portal UI is not displaying correctly for newer Volatile layers created after September 10. This known issue is actively being worked on and should be resolved shortly. Temporary workaround: To get partition list information for new volatile layers created after September 10, please use the appropriate CLI command with one of the following parameters: --modified-since 2018 OR --modified-since <time-of-interest> Example: olp catalog layer partition list <your-catalog-HRN> <your-volatile-layer-ID> --modified-since 2018 Issue: Catalogs not associated with a realm are not visible in OLP. Issue: Visualization of Index Layer data is not yet supported. Issue: When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround: After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Pipelines Issue : Given a Stream pipeline version running with the High-Availability mode enabled, when the pipeline version is viewed in the Portal and is paused or canceled or a new pipeline version is created within the same pipeline, then the High-Availability mode remains enabled during Resume, re-Activation of the existing pipeline version or during the Activation of the new pipeline version. The correct behavior is that the high-availability mode is disabled by default. We are working on a fix. Workaround : Uncheck the box \"Run with high-availability\" during Activation and Resume when operating via Portal. Or, consider using the CLI or Pipeline API. Issue : A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue : If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue : The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround : Duplicate the dashboard or create a new dashboard. Issue : For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround : Restart the stream pipeline. Marketplace Changed: When a catalog is marked marketplace-ready, you can continue to add and/or remove layers from the catalog even after your catalog has active subscriptions. This enables you to be fully in control of your data offerings in the marketplace. Added : You can offer evaluation data (free of charge) for promotion or market research purposes in the marketplace. When publishing an evaluation data listing, the connection fees are waived. When a Marketplace user discovers your evaluation data listing, they can self-subscribe to the data with no subscription fees. For more details, see the Marketplace Provider User Guide or the Marketplace Consumer User Guide Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue: When the Splunk server is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Notebooks Deprecated: OLP Notebooks has been deprecated, please refer to the advantages and enhancements offered in the new OLP SDK for Python instead. Download your old notebooks and refer to the Zeppelin Notebooks Migration Guide for further instructions. OLP SDK for Python Issue: Currently, only MacOS and Linux distributions are supported. Workaround: If you are using Windows OS, we recommend that you use a virtual machine.", "date": "2019-09-25"},
{"website": "Here", "title": "How FreightHub Predicts Truck Delays", "author": ["Philip Braun"], "link": "https://developer.here.com/blog/how-freighthub-predicts-truck-delays", "abstract": "As a supply chain professional, one deals with a great amount of complexity and uncertainty on a daily basis. A lot can go awry when coordinating a multimodal transport between two continents with many stakeholders involved. When a shipment is delayed, it often entails a human and financial impact. Even when 95% of the transport has gone without any hiccups, the last mile can result in great delays, and it is often the least transparent part. FreightHub leverages technology to predict delays and drive on-time performance to above industry averages. FreightHub implemented delay prediction for trucks FreightHub works with many partners for trucking and has built integrations which provide data about sea terminals, multimodal terminals and carriers. These integrations bring real-time data about events e.g. a container leaving a terminal. Our delay prediction product leverages these integrations to detect any delay for routes covered by trucks where data is provided in real time. To be able to detect a potential delay, we needed a way to estimate the travel time from one point to another, taking into account live traffic data and incidents on the calculated route. Our own system is capable of getting us transport plan data with high enough quality to be able to do this calculation. However we still needed a service which could calculate a route and travel time with multiple waypoints, taking into account live traffic status and truck profile among other parameters. After evaluating multiple providers we found all we need within one provider, HERE Technologies. We used the Fleet Telematics API for calculating routes and the Traffic API for getting incidents on the route. For example , our delay prediction is triggered when we receive in real-time a timestamp from a partner. In this scenario, FreightHub requests HERE for the duration of the trip between the two waypoints and checks for a potential delay by comparing the new ETA provided by HERE with the provisional timestamp existing in the transport plan. In this case, HERE can sometimes provide a reason for the delay: traffic, construction, accidents, etc. FreightHub includes the reason in the slack message to the ops manager. With the data we collect, we can conduct a more detailed analysis of the performance of our delay prediction, and leverage this information to further improve our algorithms. HERE Technologies REST API usage implementation HERE Technologies REST API is used in the example stated above. The delay prediction logic is triggered by receiving different events from our transport plan and other services, such as a shipment reaching a particular milestone or updated GPS location of truck. When an actual event is received for some shipment, we first get the list of waypoints for calculating the route. After we have waypoints and waiting times, we then use HERE Technologies API to calculate the route to get a new ETA (Estimated Time of Arrival). HERE returns traffic incidents for a given route. The response from HERE serves travel time and maneuver for all route legs. The service defines a route leg as the portion of a route between one waypoint and the next. What we call maneuver is basically all geolocations on the route from start to finish. HERE API provides multiple alternative routes ordered by relevance, so in this moment we are presuming that route on position 0 is the route the truck will probably use. What’s next? The roadmap for delay prediction is full of exciting topics and the potential for accuracy improvements is vast. We are continuously working on increasing coverage and decreasing latency for our customers. We strongly believe technology combined with the know-how of our logistics experts helps us solve potential delays before they even occur – making FreightHub a proactive, innovative and reliable freight forwarder. FreightHub is a digital freight forwarder which offers instant quotes & booking, real-time track & trace and supply chain analytics for your global air and sea freight. For more info please check www.freighthub.com/en", "date": "2019-09-27"},
{"website": "Here", "title": "Have a Better Wild Ryde with AWS and HERE", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/have-a-better-wild-ryde-with-aws-and-here", "abstract": "Developers are constantly learning. There are many technologies, languages, and platforms, and there are many options for getting ramped up. Since developers are busy people, many seek ways to train on their own terms. Often the path is self-taught, and the developer relations team at HERE are in constant pursuit to make the journey even better. Because our APIs are integrated with so many technologies, it would be ideal to learn how to develop with our location services while also learning other platforms. For example, Amazon provides popular self-paced workshops known as Wild Rydes Serverless Workshops . These workshops allow developers to learn facets of AWS by developing solutions around a new (fictional) ride-share experience featuring unicorns. Because these scenarios are highly location-centric, we provided a couple extensions to these workshops to demonstrate how to implement desirable features such as improved user experience and enriching data analytics. You can find these extensions at Amazon's home page for Wild Rydes Serverless Workshops under the heading \"Third Party Workshops\" . You can also access the extensions directly at our github repository . The extensions require completing some of the Amazon provided workshops first. Before getting started, you will need to have the following accounts: AWS account ( https://aws.amazon.com ) HERE Developer account ( https://developer.here.com ) We encourage developers to try out these extensions at their own pace. If you would like to catch a glimpse of what is involved, please check out our episode showcasing the highlights of the workshops and extensions below!", "date": "2019-10-02"},
{"website": "Here", "title": "Create Your Own Map Image Microservice", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/create-your-own-map-image-microservice", "abstract": "Map images provide visualizations that are vital to many web sites and applications. AWS developers can take advantage of many core location services from HERE using the AWS Serverless Application Repository . This means developers can create their own microservice to provide location services to their own clients. This post will show how you can deploy HERE MapImage Serverless Application for use in your development projects. This will allow you to access custom map images from HERE via your own custom API. To accomplish this, you will need credentials at the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com Deploying the HERE MapImage Serverless App After account credentials are confirmed, to find the HERE MapImage application, browse to the AWS Serverless Application Repository . After clicking the \"Browse all applications\" button, you will be prompted to do your search. Type \"HERE MapImage\" as shown below, then select the MapImage title in the results shown. Once the landing page for the MapImage application is shown, enter your HERE credentials in the highlighted areas shown below, then deploy. It will take a little time for the deployment process to complete. You are prepared for the next step once you see the \" Application successfully deployed! \" message is shown. Accessing Your Map Image Microservice Consider the following script in an HTML client: let lat = 33.41808,\n    lng = -111.9343,\n    gatewayID = \"your-gateway-id\",\n    api = \"execute-api.us-east-1.amazonaws.com/Stage/mapimage?\",\n    width = 600,\n    height = 480,\n    zoom = 11,\n    url =`https://${gatewayID}.${api}c=${lat},${lng}&w=${width}&h=${height}&z=${zoom}`;\nfetch(url)\n    .then(response => response.json())\n    .then(response => {\n        document.getElementById(\"mapImage\").src = \n            `data:image/jpeg;base64,${response}`;\n    }, error => {\n        console.log(error);\n    }); The above script calls a constructed URL which points to the new microservice via Amazon API Gateway. You must replace the value of gatewayID with the value generated from your API Gateway when the MapImage app was deployed. After the fetch completes, it passes the data into an img element with the ID of mapImage and sets the source to the response - ensuring it is of type data:image/jpeg;base64. Sample files are provided at our GitHub. Also, please enjoy our recorded session on this topic here:", "date": "2019-10-17"},
{"website": "Here", "title": "Raxel combines telematics, HERE location data and services to improve drivers’ safety", "author": ["Ivan Shornikov, CEO Raxel Telematics"], "link": "https://developer.here.com/blog/raxel-combines-telematics-here-location-data-and-services-to-improve-drivers-safety", "abstract": "Raw data has little value nowadays. For example, no matter how many sensors your telematics data sources have, the data is not valuable if it is not put in context. This is why at Raxel we combined telematics data with HERE location services to study drivers’ behavior and eventually increase driver safety. I’d like to share with you how we did it. Introduction into telematics At Raxel, we use smartphone sensors to collect location data and movement data. Then this data is coming to the Raxel platform where we process, enhance and enrich the data and interpret it into driving behavior and lifestyle data. Simply put, we combine telematics data sets with a number of HERE location data sources like the mobile SDKs. More on that below. How we turn raw data into useful data Telematics has several components: (1) data source, which can be a smartphone, on-board diagnostics dongle, Blackbox, etc. in another words, it is a device with sensors that can provide users with information; (2) Telematics platform that receives data from data source and processes this data to use it as a product (for example Fleet management solutions, usage-based insurance, etc) Raw telematics data doesn’t have any particular value for insurance companies on its own. Insurers use the outcome of the analysis of those datasets. Smartphones nowadays have more than 10 different sensors. However, for insurance product we collect only GPS, Accelerometer, Gyroscope, Compass and Barometer sensor data. As a next step we interpret this data into trips data and driver behavior data. Given our background and experience with insurance companies and universities, we know how different patterns have impact on e.g. the probability of road accidents. Using these correlations, we differentiate drivers by different risk groups from bad (score 0) to good (score 100) drivers. Insurance companies then use these groups to define a different activities and discounts for each of the driver groups. How it works We use location data across all our product: (1) to show app users their trips on a map, (2) to enhance and enrich sensors data, (3) data analytics and risk assessment (4) reporting. Location data is key in telematics as it provides information such as driving speed, the types of roads commonly used, road surface condition data, route and the time of day the vehicle is most often in operation. These data is captured and analyzed to understand driving pattern and behaviors. In our product we use: HERE mobile SDKs HERE Location Services such as Mapping, Routing and Geocoder, but most importantly are: HERE Speed Limits Road Match Extension (Match the GPS traces to the HERE road network to get the most probable routes for your vehicles and detect illegal maneuvers.) The HERE location platform contains rich semantic information about the roadways beyond what can be grafted by tracking moving vehicles, including speed limits, rules of the road, and road surface condition data. This can be combined with driver data to create a more realistic picture of how cars move, and why drivers make decisions. Based on the driver behaviors, we are able to provide real time alerts and hazard warnings to improve safety and reduce claim volumes. For our product, driving behavior data doesn’t have value without location data, and vice versa. For example, you know that driver had a rapid acceleration.? If you don’t have location data - you will mark it as aggressive maneuver, but what if it happened on a highway? – probably the driver just reached a comfortable speed and continue his trip. So, this event can’t be recognized as a dangerous event. Another case – if it happened on intersection. – it might be a case when driver tried to pass the intersection on a yellow or red traffic light. The similar story with speeding. You can’t detect speeding without having a precise speed limits data on a particular part of the road. Practical examples from our customers Telematics enable insurance companies to run new products: for example “pay per km” product – when you pay for insurance small amount of money for driven km and don’t pay when the car is parked, “on-demand” product – to buy insurance when you really need it. To improve claims management – insurance company has detailed information about accident, to reduce acquisition cost – product “Try before you buy” when a user who is not an existing customer can download app, check driving behavior and get a special terms for insurance without having history with a particular insurance company.", "date": "2019-10-07"},
{"website": "Here", "title": "Create a map in five steps with HERE XYZ Studio", "author": ["Roberto Butti"], "link": "https://developer.here.com/blog/create-a-map-in-five-steps-with-here-xyz-studio", "abstract": "When you need to build a custom map, you need at least 3 things: a map (obvious), data (a lot of data) and a tool that allow you to manage the previous two things. XYZ Studio is a tool that allow you to create custom map, and manage data in multiple ways: uploading your dataset of data; creating points and shape from scratch on map; selecting some public dataset available on XYZ. The easiest and fastest way to use XYZ Studio is to create a new project (map), and then add new existing public dataset available. Access to XYZ Studio In order to use XYZ Studio you need to have an account on the HERE developer portal . Go to https://xyz.here.com/studio/ and if you already have an account, input your credentials and then click on Sign in to login. If you don't have a valid account, you can click on \"Register for a HERE account\" and start the registration process. Atg the next step, choose the freemium plan so you can start using HERE XYZ Studio for free with a generous allowance in terms of transactions (API calls) and volume (amount of data exchanged with APIs). Create a new project After the login process, you will be redirected to your dashboard with your project/map previously created. If you are a new user you will see an empty dashboard. To create a new map click on the button \"Create new project\" on top left of the screen. Once you have a new empty project, you need to add some data. The easiest way to add data to your map is to use the public dataset available on HERE XYZ Studio. These public datasets exist in XYZ Studio thanks to Microsoft US Building Footprints project. These datasets are computer generated building footprints for the United States. If you want to take a look to the project I suggest you to read: https://github.com/Microsoft/USBuildingFootprints. Once you clicked \"Create new project\" button in your dashboard page, you will be redirected to the Project page. On the left you have a sidebar where you can manage your Map (create layer, add data, edit name and description, publish project). Add data to your new empty map In order to add a public dataset in your map, click on \"+ Add\" call to action. In the \"Add data\" page, click on \"Choose XYZ Space\" button. In the page \"Public Data in XYZ Space\" you can start typing your state, country, city that you want to include in your map. For example I selected Raleigh. You can select more than one place. Once you selected your locations click on \"Add Layer\" button to add these data on your map. You will see buildings on your map and a new layer on the left sidebar, named \"Building Footprints\". Style your buildings XYZ Studio allow you to style your map based on your own rules. For example you can color with red all your buildings for a specific street. If you want to style buildings in a specific street, select a building on the map. On the sidebar you will see all details of the building you selected. On the street attribute, select the paintbrush icon to create new style rule. On the \"Add new style group\" page you will see all parameters set as your selection. For example you will see: Property: street Condition: Equals Value: the street name of the building you selected on the map Click on \"Confirm\" button to create a new style rule. Now you will have your new Polygon style on the left sidebar, and you can change the color, for example \"Red\". You will see that all buildings of the street you selected will be colored with red color. You can play with different style with different properties, so you can customize your map. Publish your map Once you added data on your map and you customized the style of your map, you are ready to publish your map, in order to share your map with your friends, colleagues or embed your map in your blog or website. On the left side bar, click on \"Publish Settings\" and in the Publish Settings popup window, click on the checkbox \"Publish Map\". If you scroll down \"Publish Settings\" window you can see the field \"URL\". You can copy and share that URL in order to allow other people to see your customized map with public US footprint buildings.", "date": "2019-10-14"},
{"website": "Here", "title": "August/September 2019 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/october-2019-release-notes-1", "abstract": "Welcome to the October 2019 release of the HERE Location Suite. This post covers updates from the last two major updates, D108 and D109, released over the past two months. Let's kick it off with D108. Release D108 This release includes updates of: Maps API for JavaScript, Routing API, Geocoder API, Geocoder Autocomplete API, Places API, Traffic TPEG API, Fleet Telematics API, Fleet Telematics Waypoints Sequence API and HERE Tracking. The release highlights are: New features in Maps API for JavaScript Fleet Telematics enhancements related to truck routing New HERE Platform Self-hosted release You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Maps API for JavaScript ( Version 3.1.3.0) We introduced gesture support for map tilting and rotation. The label collision for the tilted and rotated map was improved - it prevents label crowding on the horizon and label collisions when the map is rotated. The method getObjectsAt returns the collection of features that were stacked in the vector rendering engine. The way to change the scene background and the \"skybox\" color was added to the API. Added improvements to the rendering of the raster layer with the WebGL rendering engine for the pixel ratio 2. Routing API (Version 7 . 2 . 108) We added support for restrictions related to truck axle count. It is now possible to define the number of axles of the truck and to calculate a route that will avoid roads on which only trucks with limited number of axles are allowed. Traffic TPEG API (Version 6 . 0 . 114.1) We have switched to Flow Feeds version 3.2.2 with OLR coverage We have enabled session size limitation for some profiles We have made minor performance improvements Fleet Telematics API ( Version 3.0.22) Routing now considers changing vehicle weight/height/length/trailers... during a journey: Specify capacity deltas at each waypoint. Routing now considers preferred routes for trucks, for certain weight, dangerous goods or bicycles. Parameter \" ignorePreferredRoutes \" switches it off. Router now supports vehicleType \" tractorTruck \". Custom routing tells whether customized road geometry was considered during routing (metainfo - overlays: true) Routing response can contain baseTime and trafficTime per leg Routing with optional/unsorted waypoints: Can now handle waypoints that are just \"visit\" and not a pick-drop pairs. Fleet Telematics Waypoints Sequence API ( Version 3.0.22) Returned times are approximate values. Applications can invoke another Routing request to obtain more accurate driving times. For smaller geographic extents (bounding box diagonal < 30 km) now up to 70 waypoints are supported when using traffic enabled routing. HERE Tracking ( Version 1 . 3 . 0) We added Aliases and Metadata APIs, which enables associating external system ids, and metadata to trackers Aliases API - Enables a tracker to be associated with an external system ID in a way that is neither part of the reported state of the device or the desired state Metadata API - Enables to store descriptive information associated to a tracker or geofence Added new end-point in Registry API to get Tracking license information The following services had new releases with minor changes: Geocoder API (Version 6.2.189) Geocoder Autocomplete API (Version 6.2.189) Places API (Version 2.77) HERE Platform Self Hosted ( Version Q3/2019) Geocoder 6.2. 187 .1 (D107) Reverse Geocoder 6.2. 187 .1 (D107) Geocoder Autocomplete 6.2. 187 .1 (D107) Fleet Telematics Custom Locations API 2.5.19 (D108) Fleet Telematics Geofencing API 2.5.19 (D108) Release D109 This release includes updates of: Maps API for JavaScript, Routing API, Fleet Telematics API, HERE Tracking API, Mobile SDKs for Android and iOS and HERE Mobile SDK User Interface (UI) kit. This release is mainly a maintenance release. The release highlights are: Support of the HERE XYZ spaces and other new features in Maps API for JavaScript Avoid sharp and U-turns in Fleet Telematics API Routing Isoline support, ability to filter search results by country and other enhancements in new HERE Mobile SDK release New HERE Mobile SDK User Interface (UI) kit. You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Maps API for JavaScript ( Version 3.1.5.0) We introduced the support of the HERE XYZ spaces. H.map.layer.CanvasLayer class in the WebGL mode now allows a real 3D rendering such as a model tilt and rotation. It is possible now to add an elevation to the map polygons. Fleet Telematics API ( Version 3.0.23) Route Match now also accepts trace files in GeoJSON format Routing can avoid sharp turns and/or u-turns. &avoidTurns=right:80;60 for > 80 degree turns 60 second penalty &avoidTurns=uTurnAtWaypoint HERE Android SDK Starter Edition version 3.13: The SDK has been updated to work with Android 10.0 Added support of AndroidX libraries Minimum supported Android API level was updated to 17 Premium Edition version 3.13: The SDK has been updated to work with Android 10.0 Added support of AndroidX libraries Minimum supported Android API level was updated to 17 Shared Map Service feature is deprecated Support of x86 emulators is deprecated Feature Street Level Imagery was removed Added support of a Routing Isoline. The Routing Isoline describes potential routes user can take and provides a polygon indicating the maximum reach in all directions around the given start position by time or distance Added ability to filter search results by country Improved turn-by-turn navigation for truck: from now, the map shows only truck restriction icons relevant for the vehicle type Added a warner that informs about restriction for trucks on the route ahead Improved turn-by turn navigation for trucks: added ability to get truck restrictions on a route during navigation HERE iOS SDK Starter Edition version 3.13: Added support of new Apple iOS 13 and Xcode 11 Premium Edition version 3.13: Added support of new Apple iOS 13 and Xcode 11 HERE SDK is compatible with iPad OS now Feature Street Level Imagery was removed Added support of a Routing Isoline. The Routing Isoline describes potential routes user can take and provides a polygon indicating the maximum reach in all directions around the given start position by time or distance Added ability to filter search results by country Exposed new map object for labeled MapMarker Improved turn-by-turn navigation for truck: from now, the map shows only truck restriction icons relevant for the vehicle type Added a warner that informs about restriction for trucks on the route ahead Improved turn-by turn navigation for trucks: added ability to get truck restrictions on a route during navigation HERE Mobile SDK User Interface (UI) kit ( Version 2.1.2) This is a HERE SDK integration release. Major changes and features: Integrated the HERE SDK 3.12 release Updated the iOS dependencies Updated the Android dependencies Added support for Android X Added minor translation update Fixed minor issues The open source repositories can be found here: https://github.com/heremaps/msdkui-android https://github.com/heremaps/msdkui-ios The detailed release notes can be found here: https://github.com/heremaps/msdkui-android/releases https://github.com/heremaps/msdkui-ios/releases The following services had new releases with minor changes: Routing API ( Version 7 . 2 . 109) HERE Tracking API (Version 1.3.1)", "date": "2019-10-23"},
{"website": "Here", "title": "Find all the Popup Halloween Stores with this Handy Map", "author": ["Phil Johnston"], "link": "https://developer.here.com/blog/find-all-the-popup-halloween-stores-with-this-handy-map", "abstract": "With Halloween rapidly approaching we are happy to share the “This is Halloween” map to help you find nearby pop-up halloween stores across the US and Canada. Halloween is just around the corner, have you picked up your costumes and decorations? Perhaps you didn’t even think about it yet! From what we can tell, everyone is gearing up for the festivities by carving pumpkins and planning fun activities for this Halloween weekend! We thought we’d join in the spirit by making a map! To view the map head over to https://heremaps.github.io/developer-blog/this-is-halloween/ Tap the location Icon (in the top right) to find your nearby stores or check out the regional ones in exotic locations like Hawaii and Wood Buffalo, Canada! This map was made by working with the XYZ Hub API to store all the locations of each Halloween popup store and then rendering the data with Leaflet and Tangram. Our friend Jonah Adkins created this map for us. Check it out and please share it with your friends. Ps. Did you know we are running a map-making competition? With $20,000 US in prizes and more creativity than you can shake a wood broom at! We hope to see you create a map using the XYZ Studio or HUB and submit for your chance to win!  Learn more at https://t.her.is/heremapathon", "date": "2019-10-22"},
{"website": "Here", "title": "Great Guide to Generating Good GeoJSON", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/great-guide-to-generating-good-geojson", "abstract": "Let me begin by apologizing for the title. I saw a chance for alliteration and I had to take it. In my last article , I described what GeoJSON is and how it can be used. Today I wanted to demonstrate a few examples of how you can serve up existing data in GeoJSON. As always, I'd love to hear your own take on this and if you have an example you can share, drop me a comment below. With that out of the way, let's look at our examples. \"Good\" Data In our example, we're going to work with \"good\" data, which is simply my way of saying data that is 100% ready to be converted to GeoJSON. Our data lives in a MongoDB object store and consists of National Parks data. (As an FYI, the National Parks System already uses GeoJSON and you can find their data here ). Our Mongo collection consists of a name, a park code, and a longitude and latitude value. So in theory, all we need to do is get our data and then output in the right format. While the spec will give you specifics, in general our GeoJSON file is going to look like so: {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        // lots of features here\n             {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\", //GeoJSON supports other types\n                    \"coordinates\": [longitude, latitude]\n                },\n                \"properties\": {\n                    // ad hoc properties\n                }\n            }\n    ]\n} Given this basic form, let's look at a script that demonstrates this. const MongoClient = require('mongodb').MongoClient;\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'national-parks';\nconst client = new MongoClient(url, { useNewUrlParser: true, useUnifiedTopology: true });\n\nclient.connect(function (err) {\n\n    const db = client.db(dbName);\n\n    const collection = db.collection('parks');\n    collection.find({}).toArray( (err, docs) => {\n\n        let result = {\n            \"type\": \"FeatureCollection\",\n            \"features\": []\n        };\n\n        docs.forEach(d => {\n\n            let feature = {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Point\",\n                    \"coordinates\": [d.longitude, d.latitude]\n                },\n                \"properties\": {\n                    \"code\":d.code,\n                    \"name\": d.name\n                }\n            };\n\n            result.features.push(feature);\n        });\n\n        console.log(JSON.stringify(result));\n        client.close();\n\n    }); \n}); Alright, the top portion of the script is simply setup stuff so that I can communicate with a local MongoDB server. I connect to the database and then ask for every document. I set up a result object and as I iterate over each document, I add to the features of it. That's it. Notice how the longitude and latitude values go into the coordinates array and then the rest of my data simply become properties . If my object was more complex I could simply loop over each property and output that dynamically, ignoring the location values. And that's it. My script simply outputs to the console but in the real world it could be used within an Express route or a serverless function rather easily. Here's an example of the output with most of the data stripped out: {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -71.13112956925647,\n                    42.32550867371509\n                ]\n            },\n            \"properties\": {\n                \"code\": \"FRLA\",\n                \"name\": \"Frederick Law Olmsted National Historic Site\"\n            }\n        },\n        // a heck of a lot more\n    ]\n} \"Not So Good\" Data For the next version, let's look at bad… I mean \"not quite as good\" data. Our previous example was easy since we had location data already. But what if we don't? Our next set of data is a collection of cats. Each cat object consists of a name, a gender, and an address string. In order to generate GeoJSON, we need a way to get a precise address from the string based address. For that we're going to use HERE's Geocoding API . This API lets you translate string based addresses into precise locations (as well as the reverse, and other features). In order to do so you can simply pass the address string as searchtext to the API. https://geocoder.api.here.com/6.2/geocode.json?searchtext=someAddress&app_id=YOUR_APP_ID&app_code=YOUR_APP_CODE Let's look an example similar to the previous one, but that now adds calls to the geocoding API to get the data it needs. const MongoClient = require('mongodb').MongoClient;\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'cats';\nconst client = new MongoClient(url, { useNewUrlParser:true, useUnifiedTopology: true });\nconst fetch = require('node-fetch');\n\nconst app_id = 'sdwyQs1YA25FUX6cI7Ko';\nconst app_code = 'SX9_A9lBaqJYoWX_DIO1ag';\n\nasync function getLocation(s) {\n\n    let url = `https://geocoder.api.here.com/6.2/geocode.json?searchtext=${encodeURIComponent(s)}&app_id=${app_id}&app_code=${app_code}`;\n    let httpResult = await fetch(url);\n    let result = await httpResult.json();\n    return result.Response.View[0].Result[0].Location;\n}\n\nfunction getCats() {\n\n    return new Promise((resolve, reject) => {\n\n        client.connect(err => {\n            const db = client.db(dbName);\n            const collection = db.collection('cats');\n\n            collection.find({}).toArray((err, docs) => {\n                if(err) reject(err);\n                client.close();\n                resolve(docs);\n            });\n\n        });\n\n    });\n}\n\n(async () => {\n\n    let cats = await getCats();\n\n    for(let i=0;i<cats.length;i++) {\n        let gpsLocation = await getLocation(cats[i].location);\n        cats[i].coordinates = [gpsLocation.NavigationPosition[0].Longitude, gpsLocation.NavigationPosition[0].Latitude]\n    }\n\n    let result = {\n        \"type\": \"FeatureCollection\",\n        \"features\": []\n    };\n\n    cats.forEach( c => {\n        let feature = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": c.coordinates\n            },\n            \"properties\": {\n                \"name\": c.name,\n                \"gender\": c.gender\n            }\n        };\n\n        result.features.push(feature);\n\n    });\n\n    console.log(JSON.stringify(result));\n})(); This script is a bit more complex as we've got a couple different asynchronous operations in play. First I get my array of cats. Then I iterate over each and call out to the API to 'translate' their location. The use of async and await make this somewhat less painful to write. Once the data is retrieved the script follows the same format as before - iterate and add features. Here's the output, again with some trimming. {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -92.05749,\n                    30.20666\n                ]\n            },\n            \"properties\": {\n                \"name\": \"Juniper Montage\",\n                \"gender\": \"female\"\n            }\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -97.73512,\n                    30.3581\n                ]\n            },\n            \"properties\": {\n                \"name\": \"Thor\",\n                \"gender\": \"male\"\n            }\n        }\n    ]\n} To be clear, this script is not optimized for repeated calls. In production I'd use a script that added longitude and latitude to the object store, or cached it elsewhere, so that you would not need to 're-geocode' the same address more than once. But hopefully this gives you enough of an example to get started! Use that Data for $$$ So now that you know how to take your data and create GeoJSON, it would be a perfect time to take a look at the Mapathon we are running over the next two months. All you have to do is take your awesome data, create a cool map, and enter for a chance to win cold hard cash!", "date": "2019-09-30"},
{"website": "Here", "title": "XYZ Mapathon: 10 Days Remain for Your Chance to Win from $20,000 Cash", "author": ["Phil Johnston"], "link": "https://developer.here.com/blog/xyz-mapathon-10-days-remain", "abstract": "Today marks the final countdown to enter the HERE XYZ Mapathon. With only 10 days left to apply, be sure to submit your concepts to participate in the competition. Don’t miss out on your chance to win up to $10,000 in cash. All top 10-teams will win cash prizes from the $20,000 purse. Ideas for maps can range from social, political, environmental or even just for fun maps like this Spooky Halloween map that we just released. Teams that pass the first round of judging will continue into the “Development” phase of the competition. In this phase your team will work with staff from HERE, who will try to help and provide feedback that could make your map a winner. We are very excited to see the ideas that inspire you. We are keen to see which topics drive you to create a map that tells a story and helps “Map your world”. Visit the HERE XYZ Mapathon page to learn more. This competition is void where prohibited and please do check rules for more information.", "date": "2019-10-24"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.8 release", "author": ["Amanda Taylor"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.8-release", "abstract": "Highlights for this release OLP Marketplace as a Neutral Server In December 2016, the European Automobile Association (ACEA) announced their plans to make vehicle sensor data available through external, third-party \"neutral servers\". The ACEA envisioned an ecosystem where third-parties could access vehicle data in a secure manner, in order to create innovative services and safer driving experiences. We agree, and have now extended the HERE OLP Marketplace to provide these Neutral Server capabilities, aligned with the ACEA Extended Vehicle concept, including: Access to vehicle sensor data - the Marketplace can now act as a secure, neutral, GDPR-compliant hub for data consumers to gain access to vehicle data from participating Automotive manufacturers Consent management - ensures privacy for owners and drivers of vehicles, by allowing them to grant and revoke consent for specific third-parties to access data generated by their vehicles ISO 20078 \"ExVe\" compliant interface - simplifies platform integration for data providers and consumers For Data Providers - the Marketplace offers a new distribution channel for Automotive manufacturers who want to make their vehicle data available to third-parties. HERE operates the secure, scalable data access point, offering your data to third-parties, handling the commercial details, while providing you with anonymized usage reporting. With integrated Consent Management, buyers and drivers of your vehicles can have the confidence that their privacy will be protected, with permission to access data fully under their control, and in compliance with privacy regulations such as GDPR. For Data Consumers - the Marketplace provides standardized ISO 20078-compliant access to OEM data. When subscribing to Neutral Server listings, Data Consumers license and access data from HERE, leveling the playing field by protecting the Data Consumer's identity from Data Providers. For more information on subscribing to Neutral Server data, refer to the Marketplace Consumer User Guide . Note: OLP Marketplace is currently not available in China. Japan Map Coverage HERE OLP Workspace now has highly detailed map coverage of Japan (not available in OLP China). The Japan map data has been published into HMC proprietary schema in a catalog named HERE Map Content Japan ( hrn:here:data:::here-map-content-japan-2 ). Users will be able to develop with this new Japan map coverage like any other map coverage from HERE, leveraging all the same capabilities found in Workspace, including the OLP SDK and its location library. Analytics availability in China New additions to OLP China will include the Optimized Map for Analytics (OMA) catalog, built from the China map available in that region; and, the OLP SDK for Python, bringing the analytics capabilities in that region to parity with what's available in OLP outside of China. Big Data Connectors Additional Big Data connectors are available with this release to facilitate your data analysis, consumption and processing via Flink and Spark Pipelines.  These connectors integrate OLP proprietary catalogs and layers with the industry standard formats of Flink (TableSource) and Spark (DataFrame).  Whereas before you needed to implement this functionality yourself, now you can use these connectors to leverage the full functionality of searching, filtering, mapping, sorting and more offered by standard Apache Flink and Spark frameworks. Spend less time writing low level pipeline/data integration code and more time on your use case specific business logic: A new Flink connector for reading from and writing to a stream layer. The Spark connector now also supports writing to a Versioned layer. This additional functionality completes the full read and write support for Versioned and Index layers. Changes, Additions and Known Issues SDK for Java and Scala To read about updates to the SDK for Java and Scala, please visit the SDK Release Notes . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Account & Permissions Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Data Issue: Partition list information normally available within the Layer/Partitions tab of the Portal UI is not displaying correctly for newer Volatile layers created after September 10. This known issue is actively being worked on and should be resolved shortly. Temporary workaround: To get partition list information for new volatile layers created after September 10, please use the appropriate CLI command with one of the following parameters: --modified-since 2018 OR --modified-since <time-of-interest> Example: olp catalog layer partition list <your-catalog-HRN> <your-volatile-layer-ID> --modified-since 2018 Issue: Catalogs not associated with a realm are not visible in OLP. Issue: Visualization of Index Layer data is not yet supported. Issue: When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround: After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Pipelines Fixed : an issue where when a Stream pipeline version running with the High-Availability mode enabled is paused or canceled from the OLP Portal or a new pipeline version is created within the same pipeline, then the High-Availability mode remains enabled during Resume, re-Activation of the existing pipeline version or during the Activation of the new pipeline version. The correct behavior is that the high-availability mode is disabled by default and we have released a fix to enable the correct behavior. Issue : A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue : If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue : The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround : Duplicate the dashboard or create a new dashboard. Issue : For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround : Restart the stream pipeline. Issue : When a paused Batch pipeline version is resumed from the Portal, the ability to change the execution mode is displayed but the change actually doesn't happen. This functionality is not supported yet and will be removed soon. Issue: When a paused pipeline is resumed from the Portal, the ability to change the runtime credentials is displayed but the change actually doesn't happen. This will be fixed soon and you will be able to change the runtime credentials from the Portal while resuming a pipeline version. Marketplace Added Neutral Server capabilities to Marketplace: For automotive data providers, you can now create a ticket with Technical Support for inquiring integration with our ISO 20078 compliant interface and let HERE Marketplace act as Neutral Server. Once your data is listed, Data Consumers can find your data via provider name: HERE Neutral Server. They can subscribe to the data by selecting available subscription options. For more information, refer to the Marketplace Consumer User Guide Added consent management for PII data distribution: For automotive data providers, Neutral Server can facilitate access to your data with personally identifiable information by managing your data subjects' consents before sharing. When data consumers subscribe to a data listing which contains PII, data consumers are directed to the consent management workflow for requesting data subjects' consents before the data access is granted. For more information, refer to the Neutral Server and Consent Management section in Marketplace Consumer User Guide Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue: When the Technical Accounting is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Notebooks Deprecated: OLP Notebooks has been deprecated, please refer to the advantages and enhancements offered in the new OLP SDK for Python instead. Download your old notebooks and refer to the Zeppelin Notebooks Migration Guide for further instructions. OLP SDK for Python Issue: Currently, only MacOS and Linux distributions are supported. Workaround: If you are using Windows OS, we recommend that you use a virtual machine. Optimized Map for Analytics (OMA) Added: OMA now includes all ADAS layer attributes.", "date": "2019-10-24"},
{"website": "Here", "title": "Now in 3D! – Learn How to Use the Camera in the New Javascript API 3.1", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/now-in-3d-learn-how-to-use-the-camera-in-the-new-javascript-api-3.1", "abstract": "The new version 3.1 of our JavaScript API brings a whole host of new exciting features, chief among them the arrival of vector tiles and a 3D renderer. This in turns means you are now longer limited to a top-down view of the map. Check this out. In addition to moving the camera along two axes and zooming, you can now also rotate and tilt the it. It's a whole new world! Of course, this also raises the question: How do you do this? First, the good news. You can still use setPosition() and setZoom() just as before. So after setting up a basic map (for example by using our examples in GitHub ), you can get a close-up look of Terminal A at TXL airport using this code snippet. map.setCenter({lat: 52.5544, lng: 13.29036});\n  map.setZoom(18.1); So far so good. The eagle-eyed among you may have spotted a tiny little difference, though. That's right, we've used a fractional zoom factor. With vector tiles there are no more preset zoom factors and you can zoom in to a very specific factor of 18.2817151. If that's your thing. Now then, how do we tilt and rotate the camera? After all, that's really what we're here for. Well, to set how we look at the map we use the function ViewModel.setLookAtData . This function takes a look-at data set as described in ViewModel.ILookAt as a parameter. The data set can contain any or all of the following properties: position , zoom , heading , tilt and bounds . map.getViewModel().setLookAtData({\n      position: {lat: 52.5544, lng: 13.29036}, \n      zoom: 18.1}); As we can see, we get the exact some view as before. Now, let's move on to the interesting parts, namely heading and tilt. The heading property allows us to rotate the camera. Heading can be a value from 0 to 360, with 0 indicating that the camera is looking from the North, 90 from the East, 180 from the South and 270 from the West. This means you normal map with north at the top, would have a heading of 180. Let’s use 0 to see the world upside down. map.getViewModel().setLookAtData({\n\tposition: {lat: 40.70808, lng: -74. 01426}, \n    zoom: 16, \n    heading: 0}); As we can see, this gives us a strange, yet familiar view. The tip of Manhattan, but on a south-up map. Next, let's use the tilt property. Tilt represents the angle between the look-at vector and normal to the surface along z-axis, which is fancy talk for making the camera look up or down. The value goes from 0 to 90, with 0 making the camera look straight down for a standard map view. Let's keep our other properties unchanged and add a tilt of 45 degrees. map.getViewModel().setLookAtData({\n\tposition: {lat: 40.70808, lng: -74. 01426}, \n    zoom: 16, \n    heading: 0, \n    tilt: 45}); As we can see, the camera is now looking up by 45 degrees in the direction of our heading. As we would expect, this means we are seeing less of Manhattan, but parts of Brooklyn and Governor's island have now come into view. This also brings up an interesting issue. What do we do if we want to ensure that the camera shows a specific area of the map? With all this tilting and rotation, this has suddenly become a lot more complicated. Fortunately, that's what the bounds property is for. All we need to provide is an H.geo.Polygon object and setLookAtData will ensure that everything within that polygon is visible to the user. Recently I wrote a blog post about the shapes features in the Geocoder API , which returns the outlines of areas such as countries or postal codes. Conveniently, the JavaScript API returns these areas as, you guessed it, H.geo.Polygon objects. So, I grabbed that project, converted it to JS 3.1 and made the camera zoom into a tilted view of the selected country using the following code snippet: lookAt = {\n            bounds: cameraBounds,\n            tilt: 45\n         }       \n\nmap.getViewModel().setLookAtData(lookAt); You can check out the complete project on GitHub. (Incidentally, migrating the project to version 3.1 wasn't too much work. All I needed to do was update the modules to version 3.1, replace the credentials with the new apikey and switch to vector tiles during map initialization. You can find more details in the migration guide .) That's it for today. Next time we'll look another exciting new feature: map customization!", "date": "2019-10-14"},
{"website": "Here", "title": "Integrating GeoJSON in Your Static Sites", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/integrating-geojson-in-your-static-sites", "abstract": "Honestly I worry that readers may be a bit bored with how much I'm talking about GeoJSON (be sure to see my introduction to the topic and then my follow up ). I mean, it's just a JSON flavor so is it really that interesting? But what I find so interesting about GeoJSON is how much it's format lets you do fun stuff with your data. Knowing you always have location available means you can plot your data (of course!) but also do sorting by distance, filtering to a certain distance, routing, and more. I'm a huge fan of the JAMStack. The \"JAM\" in JAMStack stands for JavaScript, APIs, and Markup. It's a fancy new way of saying \"static web site\", but as static web sites are far more powerful then they were in the past, a new name is appropriate. I thought it would be fun to take a look at how you could integrate GeoJSON data into the JAMStack. In this post I'm going to demonstrate four different integrations to hopefully inspire you to build your own. If you do, be sure to leave me a comment (and a link) about what you did. For all my examples, I'll be making use of the Eleventy static site generator. Please note that this is simply one of near five hundred options for generating JAMStack sites. While there are definitely particulars of the Eleventy platform that I'll be covering, the important thing to keep in mind is what I'm doing with my data. You should be able to apply these principles to any other engine of your choice. Our Data and Our Code For all of my demos, I'll be using a rather small list of features that cover three cats. Each cat has a name, gender, and of course, a location. Here's the entire source of that file. {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -90.0715, 29.9510 ]\n      },\n      \"properties\": {\n        \"name\": \"Fred\",\n    \t\t\"gender\": \"Male\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -92.7298, 30.7373 ]\n      },\n      \"properties\": {\n        \"name\": \"Martha\",\n    \t\t\"gender\": \"Female\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -91.1473, 30.4711 ]\n      },\n      \"properties\": {\n        \"name\": \"Zelda\",\n\t\t    \"gender\": \"Female\"\n      }\n    }\n  ]\n} Typically your data would probably include many more features, but we'll keep it short and sweet for our examples. If you want to play with any of the demos I show below, you can find the entire repository here: https://github.com/cfjedimaster/eleventy-demos/tree/master/geojson Example One For our first example, I'm going to keep it as simple as possible. I'm going to take the GeoJSON file, drop it in the appropriate place, and try to make use of it within my site. This end result will be pretty simple: So how did I build this? To use ad hoc data to your Eleventy site, you typically drop it within a _data folder. Eleventy has built in support for json files, but, there's a problem. GeoJSON files typically end with .geojson . There's an open ticket with the Eleventy project to allow for customization of this feature, but for the first example, I took the expedient route and renamed it to cats.json . Once the file is renamed and copied, my templates can make use of it. Here's how I built the screenshot above. <h1>Cats</h1>\n\n<ul>\n{% for cat in cats.features %}\n<li>{{ cat.properties.name }} is {{ cat.properties.gender }} and is \n\tlocated at {{ cat.geometry.coordinates[1] }}, {{ cat.geometry.coordinates[0] }}</li>\n{% endfor %}\n</ul> When you drop a file named cats.json into your _data folder, Eleventy will expose it to your templates as cats . Since I know that my cats are stored under the features property, I setup my iteration to go over each feature. Then, to display the name and gender , I remember that they exist under properties . And finally, I display latitude and longitude via geometry.coordinates . GeoJSON puts longitude first. And yes, I constantly get confused as to what is where. All in all, not too hard, but we had to rename our file, and our HTML template had to really dig into the particulars of GeoJSON in order to display our cats. This version of the application may be found in the v1 folder of the repository I shared above. Example Two Let's kick it up a notch and use another feature of Eleventy to make our data a bit easier to work with. Eleventy supports JSON and JavaScript files to source data for your templates. What if we keep our GeoJSON file as is, but then use a JavaScript file to read it and make it available? Here's how this could be done. const fs = require('fs');\n\nmodule.exports = function() {\n\tlet catData = JSON.parse(fs.readFileSync('./_data/cats.geojson', 'utf8'));\n\tlet cats = catData.features.map(c => {\n\t\treturn {\n\t\t\tname: c.properties.name,\n\t\t\tgender: c.properties.gender,\n\t\t\tlocation: {lng: c.geometry.coordinates[0], lat: c.geometry.coordinates[1] }\n\t\t}\n\t});\n\n\treturn cats;\n} I saved this file as cats.js so that it will eventually be exposed as cats to my template. I read in my original GeoJSON file and then loop over it. I wanted to make it easier for my template to use my data, so I map the name, gender, and location values into a simple object. Each cat then should be exposed like so: {\n\tname: \"Alfred E. Cat\",\n\tgender: \"male\", \n\tlocation: { lng: -90, lat: 30 }\n} You can see this in play in the new version of the HTML template. <h1>Cats</h1>\n\n<ul>\n{% for cat in cats %}\n<li>{{ cat.name }} is {{ cat.gender }} and is \n\tlocated at {{ cat.location.lat] }}, {{ cat.location.lng }}</li>\n{% endfor %}\n</ul> That's far simpler, and if for some reason my GeoJSON changes, or I switch to another format entirely, I can simply update cats.js to handle the new form. This version of the application may be found in the v2 folder of the repository I shared above. Example Three - Now with Maps Let's kick it up a notch. By using the HERE Map Image API , we can easily create static maps for each of our cat locations. The Map Image API is very easy to use. You simply craft a URL with your parameters and then use that URL in an image tag. Here's the updated layout template for this version: <h1>Cats</h1>\n{% for cat in cats %}\n<p>\n<img src=\"https://image.maps.api.here.com/mia/1.6/mapview?app_id={{ global.here_app_id }}&app_code={{ global.here_app_code }}&c={{cat.location.lat}},{{cat.location.lng}}&z=9\">\n\n{{ cat.name }} is {{ cat.gender }} and is located at {{ cat.address }}.\n</p>\n{% endfor %} There's a few things to note in the URL. First, the API requires an app_id and app_code value. I included mine in a new data file called global.json : {\n\t\"here_app_id\":\"sdwyQs1YA25FUX6cI7Ko\",\n\t\"here_app_code\":\"SX9_A9lBaqJYoWX_DIO1ag\"\n} Next, I tell the api to center (via c ) on the cat's location. The last value I specified, z , specified the zoom. The API supports a heck of a lot more options, but I wanted to keep it simple for the demo and just show the general area where the cat may be found. This version of the application may be found in the v3 folder of the repository I shared above. Example Four And now for the final, and most awesome, version. (Ok, \"awesome\" may be a bit much.) In the previous example, we used a HERE API to render a map of the cat's location. For most people, that's a heck of a lot more useful than displaying the longitude and latitude. We can go even further though. By using HERE's reverse geocoding API we can translate the GPS locations to a human readable address instead. You can see the results below: In order to add this information, I modified cats.js as so: const fs = require('fs');\nconst fetch = require('node-fetch');\nconst global = require('./global');\n\nmodule.exports = async function() {\n\tlet catData = JSON.parse(fs.readFileSync('./_data/cats.geojson', 'utf8'));\n\n\tlet cats = catData.features.map(c => {\n\t\treturn {\n\t\t\tname: c.properties.name,\n\t\t\tgender: c.properties.gender,\n\t\t\tlocation: { lng: c.geometry.coordinates[0], lat: c.geometry.coordinates[1] }\n\t\t}\n\t});\n\n\t//https://stackoverflow.com/a/37576787/52160\n\tfor(const cat of cats) {\n\t\tconsole.log('do address for ' + cat.name);\n\t\tlet url = `https://reverse.geocoder.api.here.com/6.2/reversegeocode.json?app_id=${global.here_app_id}&app_code=${global.here_app_code}&prox=${cat.location.lat}%2C${cat.location.lng}%2C250&mode=retrieveAddresses&maxresults=1`;\n\n\t\tlet locationRequest = await fetch(url);\n\t\tlet location = await locationRequest.json();\n\t\tcat.address = location.Response.View[0].Result[0].Location.Address.Label;\n\n\t}\n\t\n\treturn cats;\n} You can see we still have the original code to modify the GeoJSON into a nicer format. Then we loop over that data and call the API to load in the address. This bit, cat.address = location.Response.View[0].Result[0].Location.Address.Label is where we grab the result. The API returns a lot of information, but we can grab just the simple text-based address. This version of the application may be found in the v4 folder of the repository I shared above. Wrap Up So I hope these examples inspire you both to look into using HERE's APIs as well as how you can add geographic data to your JAMStack-based web sites. As always, if you've got any questions, suggestions, or examples, just leave a comment below.", "date": "2019-11-04"},
{"website": "Here", "title": "Using Geocode API in Azure", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/using-geocode-api-in-azure", "abstract": "Developers targeting the Azure Platform can easily create their own serverless functions to provide location services. This is possible by using HERE location services for the Microsoft Azure Marketplace. There are three Azure Resource Manager (ARM) templates to simplify the integration of our REST services as Azure functions. The following templates are available, and this post will focus on the first: Serverless Functions - Deploys HERE location services as Azure functions that can be invoked directly within any Azure applications and/or solutions. Web App Backends - Deploys HERE location services as Azure functions along with Azure Service Bus and Cosmos DB to optimize for web application backend. Real-Time Data Streams - Deploys HERE location services as Azure functions along with Event Hub and Cosmos DB to optimize for real-time streaming applications. Scope and Requirements You can call our APIs from multiple client types. In this post you will learn how to consume our APIs fromAzure Functions = which in turn will be invoked from an HTML client. The following are prerequisites for getting started: HTML experience ( help ) JavaScript experience ( help ) Microsoft Azure account ( https://azure.microsoft.com ) HERE Developer account ( https://developer.here.com ) Deploying Serverless Functions At azure.microsoft.com , select Azure Marketplace . Search for \"HERE Maps\" and select HERE Maps & Location Services . At the landing page for HERE Maps & Location Services, choose GET IT NOW . Follow prompts until you are at the landing page for HERE Maps & Location Services template within the Azure Portal, then select Create . After choosing the basic configuration, you will be prompted to enter your HERE App ID and App Code . Once you have completed the process and deployed the template, navigate to App Services in the Azure Portal. Click on your recently created Function App, which will have its own unique identifier. Within the function app, select the mapImage under the Functions, and then click on the </> Get function URL . Copy the URL and save it to a text file. You will use it in your HTML client page. Consuming MapImage Function Consider the following javascript in an HTML page: const AZURE_FN = \"your-azure-url-id\";\nconst AZURE_FN_KEY = \"your-azure-function-code\";\nfunction processForm() {\n    let place = document.getElementById(\"placeInput\").value;\n    console.log(place);\n    if (place == \"\") {\n        alert(\"Need a place!\");\n        return false;\n    }\n    invokeGeoAPI(place);\n} \nfunction invokeGeoAPI(place) {\n    fetch(`https://${AZURE_FN}.azurewebsites.net/api/geocoder/6.2/geocode.json?searchtext=${place}&code=${AZURE_FN_KEY}`)\n        .then(response => response.json())\n        .then(response => {\n            console.log(response);\n            console.log(response.Response.View[0].Result[0].Location.DisplayPosition)\n    });\n} In the above script, be sure to replace the your-azure-url-id and your-azure-function-code values declared as constants and concatenated into URL string. The script calls the Azure function when a user types a place into an input box. The results are not displayed on the page, but in the developer's console in the browser. The Azure function returns the latitude and longitude of the place entered. Users can enter full addresses, city name, state name, country name, and so forth. For more commentary and additional uses, please watch our on-demand episode on this topic! Summary Developers can quickly utilize location services from HERE within Azure! To access the code files associated with this post, please visit our GitHub livestreams page for Azure Geocode. For more information about HERE, please visit our developer portal at developer.here.com", "date": "2019-10-31"},
{"website": "Here", "title": "Using Places API in Azure", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/using-places-api-in-azure", "abstract": "Are you an Azure developer? Would you like to see how easy it is to create your own Azure Functions to provide location services? At HERE, we made this very easy by making available our core location services at the Microsoft Azure Marketplace. Currently, there are three Azure Resource Manager (ARM) templates to simplify the integration of our REST services as Azure functions. The following templates are available, and this post will focus on the first (specifically using the Places API): Serverless Functions - Deploys HERE location services as Azure functions that can be invoked directly within any Azure applications and/or solutions. Web App Backends - Deploys HERE location services as Azure functions along with Azure Service Bus and Cosmos DB to optimize for web application backend. Real-Time Data Streams - Deploys HERE location services as Azure functions along with Event Hub and Cosmos DB to optimize for real-time streaming applications. What is the Places API? It allows developers to search for points of interest at a given geolocation. For more information, check out Places (Search) API . Scope and Requirements You can call our APIs from multiple client types. In this post you will learn how to consume our APIs from Azure Functions, which in turn will be invoked from an HTML client. The following are prerequisites for getting started: HTML experience ( help ) JavaScript experience ( help ) Microsoft Azure account ( https://azure.microsoft.com ) HERE Developer account ( https://developer.here.com ) Deploying Serverless Functions At azure.microsoft.com , select Azure Marketplace . Search for \"HERE Maps\" and select HERE Maps & Location Services . At the landing page for HERE Maps & Location Services, choose GET IT NOW . Follow prompts until you are at the landing page for HERE Maps & Location Services template within the Azure Portal, then select Create . After choosing the basic configuration, you will be prompted to enter your HERE App ID and App Code . Once you have completed the process and deployed the template, navigate to App Services in the Azure Portal. Click on your recently created Function App, which will have its own unique identifier (we will call this the app_id). Within the function app, select places under the Functions, and then click on the </> Get function URL . Copy the URL and save it to a text file. The end of the URL contains a querystring - code= {places-function-code} . Consuming the Places Function Consider the following javascript in an HTML page: // element on page where results will go\nconst display = document.getElementById(\"display\");\nconst AZURE_FN = \"your-azure-app-id\";\nconst AZURE_PLACES_CODE = \"your-places-function-code\";\nconst API = \"azurewebsites.net/api/places/v1/discover/explore\";\nlet atin = \"at\";\nlet geo = \"52.54435,13.35289\"; // berlin\n\nfunction invokeGeoAPI(search) { // search supplied by user\n  let url = `https://${AZURE_FN}.${API}?${atin}=${geo}&q=${search}&code=${AZURE_PLACES_CODE}`;\n  fetch(url)\n  .then(response => response.json())\n  .then(response => {\n    console.log(response);\n    display.innerHTML = \"\";\n    let items = response.results.items || response.results;\n    // helper function to display results\n    displayItems(items);\n  });\n} In the above script, be sure to replace the your-azure-app-id and your-places-function-code values declared as constants and concatenated into url string. When the script is executed, it displays all the locations that match the users input. For more commentary and additional uses, please watch our on-demand episode on this topic! Summary Developers can quickly utilize location services from HERE within Azure! To access the code files associated with this post, please visit our GitHub LiveStreams page for Azure Places. For more information about HERE, please visit our developer portal at developer.here.com", "date": "2019-11-05"},
{"website": "Here", "title": "XYZ Studio Version 1.5.6 Release", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/xyz-studio-version-1.5-release", "abstract": "Happy November and happy release day! We're proud to announce the release of XYZ Studio Version 1.5. I'm new here but I don't think we use code names for releases. Therefore I have decided to dub this the \"Optimus Prime Pre-Turkey Day Mega Release.\" Also, this is why I'm not allowed to name releases. While there's a number of changes in this release, there's two in particular I want to point out. First, we've added an easy to filter your features by properties. Consider the following dataset of cats, a... \"cat-alog\" if you will. (That was incredibly funny in my head... honest.) You'll notice there's a new \"Filter property\" link in the user interface. With this, you can select a property, a condition type (equals, not equals, etc), and then a value. XYZ Studio will then report on how many items matched that filter and apply a highlight. Filters give you quick insight into your data, which you can then turn into a style rule for some purrrrrmenance (sorry). Don't take my word on it though, check out this cool video demonstration by HERE engineer Chirag Pandit. The second update is automatic previews for videos, sounds, and images that exist in your feature properties. So for example, if my feature had a property, \"picture\", pointing to an image, the card could look like so: Note that the site name and fav icon for the host of the media is shown over the preview. That's it for now, but there's more details on the updates at our release notes . Be sure to let us know what you think!", "date": "2019-11-26"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.9 release", "author": ["Vaibhav Kalra"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.9-release-notes", "abstract": "Highlights Manage Support and Product Update Email Subscriptions Email o pt in and opt out management is now available in the profile section of the support portal . This includes  release announcements and change notifications for: HERE Open Location Platform Services HERE Location Services Release announcements highlight the latest product features and change notifications provide updates about scheduled maintenance. Note: The HERE support portal and subscription management are currently not available in China in conformance of regulatory rules. Stream Pipeline Resource Improvement Stream Pipeline Versions using Stream-2.x.x run-time environment can now be configured to use multiple task slots per Worker (Flink TaskManager). This functionality will improve the resource utilization of a memory-intensive Stream pipeline by allowing data caching and sharing within a Worker. It will also enable network connection sharing and reduce the network overhead. Running a stream pipeline with multiple task slots per Worker can considerably reduce its cost. NOTE: The maximum number of task slots allowed per Worker is 1000. Big Data Connectors The Spark connector integrates OLP proprietary catalogs and layers with the industry-standard format of Spark (DataFrame), allowing you to leverage search, filter, map, and sort capabilities offered by the standard Apache Spark framework. In addition to previously released functions, the Spark connector now supports: Deletion of Versioned layer metadata (i.e. over-writing partition metadata so the data is not referenced by the latest Catalog version). All operations for Volatile layers: Read, Write and Delete (deletion of data and metadata). With these updates, you can spend less time writing low-level pipeline/data integration code and more time on your use case-specific business logic. Validate Data Integrity This release provides capabilities to help ensure the integrity of your data in the Open Location Platform, helping meet ASIL and ISO 26262 standards compliance: The ability to set a Digest or Checksum, a form of data integrity checking, as a layer configuration has been extended to Index layers so this capability is now possible across Versioned, Volatile and Index layers. Within the layer configuration, you can select one of the following industry standard functions: MD5, SHA1 or SHA-256. As long as this metadata is set in your layer configurations, your data consumers will be able to see that a Digest was used and which algorithm specifically so they can leverage it for downstream validation. The ability to set a Cyclic Redundancy Check or CRC, an error detection mechanism, as a layer configuration for Versioned, Volatile and Index layers.  Within the layer configuration, you can select CRC-32C (Castagnoli). Setting this layer configuration, your data consumers will understand a CRC was used and which algorithm specifically so they can leverage it for downstream validation. This CRC implementation helps support the ISO 26262 standard. As with all layer configurations, it is possible to set this metadata through all Data interfaces: API, Portal, Data Client Library and the CLI.  Both configurations are optional and the default is \"None\". As a data producer, you calculate the digest and/or the CRC at the partition level according to your selected algorithm and write it to partition metadata. If you use the Data Client Library, it will perform these calculations for you based on the algorithm types you selected in the layer configuration. What's in the works Stay tuned for additional improvements to OLP that we're working on, including: Project-based administration for new resources - We are building upon our access management capabilities to introduce a new project-based permission model, enabling teams to easily administer collections of resources and realize automatic usage reporting with customer-defined projects. Time-based scheduling of Pipelines - Automate data processing by scheduling batch pipelines based on time, without the need for an external scheduling service. Spark UI for historical Batch Pipelines - Ensure business continuity by quickly troubleshooting historical Batch pipeline jobs using Spark UI. Spatial query improvements to better support Index layer queries - We continue to work on Index layer query performance, especially for large data sets.  That said, we will soon support queries submitted via any size bounding box, removing limits which impede such queries and result in error messages today. Big Data connectors - The Flink connector integrates OLP proprietary catalogs and layers with the industry standard format of Flink (TableSource), allowing you to leverage the full functionality of searching, filtering, mapping, sorting and more offered by the standard Apache Flink framework. The Flink connector will soon support the following additional operations, which means you can spend less time writing low level pipeline/data integration code and more time on your use case specific business logic: Versioned layer reads for metadata and data. Index layer reads and writes for metadata and data. Volatile layer reads and writes for metadata and data. Data consumers can complete commercial subscription process online - When browsing available HERE commercial data in the Marketplace, data consumers can complete the subscription process by accepting the standard pricing and terms online. After successfully subscribed to the data, customers will receive subscription billing on their monthly invoice. Changes, Additions and Known Issues SDK for Java and Scala To read about updates to the SDK for Java and Scala, please visit the SDK Release Notes . Web & Portal Added: Links to the Support Portal and Documentation are now available in the Launcher. These links remain available in the support menu as well. Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Account & Permissions Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Data Changed: OrgID is now added to Catalog HRNs to create greater isolation and protection between individual organizations. Eventually this change will also support the ability for Org Admins to manage all catalogs in their Orgs. With this release, Catalog HRNs updated to include Org information are listed in the OLP Portal and are returned by the Config API.  Data Client Library versions higher than 0.1.394 will automatically and transparently deal with this change. Referencing catalogs by old HRN format without OrgID OR by CatalogID will continue to work for (6) months until May 29, 2020. After May 29, 2020, it is important to note that Data Client Library versions 0.1.394 and lower will stop working. Note: Deployment of this change in China should follow within one week of RoW. Always use API Lookup in all workflows to retrieve catalog specific baseURL endpoints. Using API Lookup will mitigate impacts to your workflows from this change or any other changes in the future when baseURL endpoints change. With this change, API Lookup will return baseURLs with OrgID in HRNs for all APIs where previously API Lookup returned baseURLs with CatalogID or HRNs without OrgID. Directly using HRNs or legacy CatalogIDs or constructing baseURLs with them in an undocumented way will lead to broken workflows and will no longer be supported after May 29, 2020. Fixed: an issue where partition list information normally available within the Layer/Partitions tab of the Portal UI was not displaying correctly for newer Volatile layers created after September 10, 2019. Published Volatile layer partitions are now displaying correctly within the Partitions tab of Volatile Layer pages. Issue: The change released with OLP 2.9 to add OrgID to Catalog HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With OLP 2.9, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Also: The resolveDependency and resolveCompatibleDependencies  methods of the Location Library may stop working in some cases until this known issue is resolved. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work for (6) months. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Issue: The Data Archiving Library does not yet support the latest CRC or Digest features released for Index layers. Using the Data Archiving Library, the CRC and Digest calculations should be automatically calculated if these layer configurations are selected in the Index layer BUT they are not.  This issue will be corrected in the next OLP release. Issue: Catalogs not associated with a Org are not visible in OLP. Issue: Visualization of Index Layer data is not yet supported. Issue: When you use the Data API or Data Library to create a Data Catalog or Layer, the app credentials used do not automatically enable the user who created those credentials to discover, read, write, manage, and share those catalogs and layers. Workaround: After the catalog is created, use the app credentials to enable sharing with the user who created the app credentials. You can also share the catalog with other users, apps, and groups. Pipelines Issue : A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue : If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue : The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround : Duplicate the dashboard or create a new dashboard. Issue : For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround : Restart the stream pipeline. Issue : When a paused Batch pipeline version is resumed from the Portal, the ability to change the execution mode is displayed but the change actually doesn't happen. This functionality is not supported yet and will be removed soon. Issue: When a paused pipeline is resumed from the Portal, the ability to change the runtime credentials is displayed but the change actually doesn't happen. This will be fixed soon and you will be able to change the runtime credentials from the Portal while resuming a pipeline version. Marketplace Changed: Previously when you deactivated an active subscription, there was a 14-day grace period applied before the data access was disabled. This is now changed. You can deactivate an active subscription for a data consumer on the current date or select any future date up to 365 days in the future. Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Notebooks Deprecated: OLP Notebooks has been deprecated, please refer to the advantages and enhancements offered in the new OLP SDK for Python instead. Download your old notebooks and refer to the Zeppelin Notebooks Migration Guide for further instructions. OLP SDK for Python Issue: Currently, only MacOS and Linux distributions are supported. Workaround: If you are using Windows OS, we recommend that you use a virtual machine.", "date": "2019-11-20"},
{"website": "Here", "title": "The Secret Lives of APIs — Chapter 1: Map Image & Routing", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/secrets-of-the-map-image-api-chapter-1-routing", "abstract": "One of the things I like to do is to highlight neat features in our APIs that you may not yet know about. For example, did you know that our Geocoder API can tell you which side of the road people drive on for any given location? (Click here to find out how!) In this post, I'm going to look at the Map Image API. This API lives in the shadows of its bigger brothers, the interactive maps found in our Mobile and Web SDKs. However, it's both a powerful and lightweight API, which can be really useful in contexts where interactive maps don't make sense or simply cannot be used. Think of putting maps into emails or displaying locations on an Echo Show! Like many of our APIs, the Map Image API also hides a few neat features you may not be aware of, so I've decided to write a series of short blog posts to bring these hidden features to light. Today we're going to look at the routing feature in the Map Image API. Yep, the Map Image API can do routing! You may have already been aware that you can draw routes on the map when using the Map Image API. However, the Map Image API can actually be used to calculate these routes as well! Let's have a look at how this works. In order to calculate a route and display it on your map image, you need to use the waypoint parameters and provide a latitude and longitude for each parameter. In fact, beside your credentials, that's all you need to provide! The API will automatically size and zoom your image to fit the route and provide default values for everything you need, including the line style. Have a look at this example. https://image.maps.api.here.com/mia/1.6/routing\n  ?app_id=your_app_code\n  &app_code=your_app_id\n  &waypoint0=52.51428,13.4423\n  &waypoint1=52.50466,13.41569\n  &w=700\n  &h=400\n  &lc=1652B4\n  &lw=6 As you can see, we've added two waypoint parameters for the route. We've also added some optional parameters to make the result look nicer. Let's look at all of these in more detail: waypoint0, waypoint1 are the start and end point for the routing calculation. Note that you can use more than two waypoints, so feel free to add a waypoint3 , and so forth. w and h set the width and height of the image in pixels. The map view will be automatically adjusted to ensure the full route is visible, even if you set only one of these parameters. lc sets the color of the line showing the route. You can check the data types section of the documentation to see the various color formats you can use. lw sets the width the line showing the route. We've set it a little wider than the default value of 4. Note that you need to replace app_id and app_code with your own set of valid credentials. You can sign up for a free account to get these if you haven't done so yet. And finally, here's our map image with the calculated route displayed. Check out the full list of parameters for the routing resource in the documentation and stay tuned for more API secrets!", "date": "2019-11-26"},
{"website": "Here", "title": "How does the Snowfall in December compare to the past?", "author": ["Phil Johnston"], "link": "https://developer.here.com/blog/snowfall-in-december", "abstract": "Was that just another snowstorm? How did it stack up to prior years? Hard to tell? Answering questions like these are why we are sharing this map with you. The team over at ZCreative Labs worked with the HERE XYZ Data Storage Hub to create this great visualization of historical and current snowfall data.  Whether you are looking for fresh snow powder or the confidence that there will be little snow for your next cross country December tour, you can quickly get an idea of where to go with this map. Powered by the NOAA historical data archive called GHCN , the team worked hard to combine all the current and historical datasets into an XYZ Hub Space to create this map; helping compare past snowfall against the current conditions. Looking for snow? Wyoming, Montana and Utah are likely going to be your best bets for Christmas snowfall this year. You never know! Just like the stock market, \"past performance does not guarantee future results\".  We will all just have to check back and see as the month progresses. Check out the map for yourself. Ps - Granted the production map is focused on December, but during development the team hacked the data to show the beginning of the 2019 Thanksgiving break (November 27th). It turns out the highest amount of snowfall in the USA for that day was in North Lake Tahoe (likely Soda Springs Ski Resort ) receiving 28 inches of snow in a 24 hour period! (See below for a screenshot)", "date": "2019-12-04"},
{"website": "Here", "title": "HERE Fleet Telematics Custom Routes API", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/here-fleet-telematics-custom-routes-api", "abstract": "Logistics needs Last Mile services. For heavy goods, it is necessary that the delivery vehicle drops/ collects the goods from the unloading/loading docks to reduce manual effort, time and increase efficiency. Custom Routes can help guide delivery vehicles to the doors even in private locations. Consider an example where a truck needs to deliver food for animals at Berlin's Tierpark. A regular routing service will route the truck to the main gate. From here, the truck has to either be escorted by an employee or an internal truck completes the last mile delivery. Instead, we can create a custom route through a back door which will allow the truck to directly deliver the fodder at the unloading dock. This saves a lot of time and inconvenience and achieves a much more efficient last mile delivery without disrupting regular activities. For creating a custom route, we need to upload a layer defining the route from the gate to the loading dock. This can be done by a simple GET request. The layer name always starts with \"OVERLAY\" and is the key to access this route. ONLY the app_id and app_code associated with this layer has access to this layer. Thus, only the delivery truck will be to see this route. GET http://cre.api.here.com/2/overlays/upload.json\n        ?app_id={YOUR_APP_ID}\n        &app_code={YOUR_APP_ID}\n        &map_name=OVERLAYTIER\n        &overlay_spec=[{\n            \"op\":\"create\", \n            \"shape\":[[52.49464,13.52560],[52.49474,13.52594],[52.49487,13.52647],[52.49501,13.52701],[52.49514,13.52753],[52.49528,13.52806],[52.49541,13.52861],[52.49552,13.52906],[52.49563,13.52953],[52.49578,13.52999]],\n            \"layer\":\"LINK_ATTRIBUTE_FCN\",\n            \"data\":{\"TRAVEL_DIRECTION\":\"B\"}\n            }]\n        &storage=readonly **If your browser does not support characters \"[,],{,}\", use their HEX codes \"%5B,%5D,%7B,%7D,\" instead. Once the route is uploaded, you can now use the routing service to get the route with the additional parameter of the overlay name. let waypoint0 = '52.53086,13.38474',\n        waypoint1 = '52.49578,13.52999',\n        overlays = 'OVERLAYTIER',\n        api = \"cre.api.here.com/2/calculateroute.json?\",\n        mode = \"fastest;truck;\",\n        app_id = \"{YOUR_APP_ID}\",\n        app_code = \"{YOUR_APP_CODE}\",\n        storage = \"readonly\",\n        url = `http://${api}waypoint0=${waypoint0}&waypoint1=${waypoint1}&overlays=${overlays}&mode=${mode}&app_id=${app_id}&app_code=${app_code}&storage=${storage}`;\n\n        fetch(url)\n            .then(response => response.json())\n            .then(response => {\n                console.log(response);\n                //draw polyline using shape in response }\n            }, error => {\n                console.log(error);\n            }); The response will contain results similar to that of the response from a regular routing request. The shape objects for the route can be found under the individual legs. \"response\": {\n        \"metaInfo\": {\n            \"overlays\": \"true\"\n        },\n        \"route\": [\n            {\n                \"mode\": {\n                    \"type\": \"fastest\",\n                    \"transportModes\": [\n                        \"truck\"\n                    ],\n                    \"trafficMode\": \"disabled\"\n                },\n                \"boatFerry\": false,\n                \"railFerry\": false,\n                \"waypoint\": [\n                    {\n                        \"linkId\": \"+1199145808\",\n                        \"mappedPosition\": {\n                            \"latitude\": 52.49828,\n                            \"longitude\": 13.5232\n                        },\n                        \"originalPosition\": {\n                            \"latitude\": 52.49828,\n                            \"longitude\": 13.52321\n                        },\n                        \"spot\": 0.13684,\n                        \"sideOfStreet\": \"neither\",\n                        \"seqNrOnRoute\": 0,\n                        \"globalWayPointSeqNr\": 0,\n                        \"type\": \"stopOver\",\n                        \"mappedRoadName\": \"Am Tierpark\"\n                    },\n                    {\n                        \"linkId\": \"+1\",\n                        \"mappedPosition\": {\n                            \"latitude\": 52.49578,\n                            \"longitude\": 13.52999\n                        },\n                        \"originalPosition\": {\n                            \"latitude\": 52.49578,\n                            \"longitude\": 13.52999\n                        },\n                        \"spot\": 1.0,\n                        \"sideOfStreet\": \"neither\",\n                        \"seqNrOnRoute\": 1,\n                        \"globalWayPointSeqNr\": 1,\n                        \"type\": \"stopOver\",\n                        \"mappedRoadName\": \"CustomLink-1\"\n                    }\n                ],\n                \"leg\": [\n                    {\n                        \"length\": 1698,\n                        \"travelTime\": 250,\n                        \"link\": [\n                            {\n                                \"linkId\": \"1199145808\",\n                                \"length\": 50.0,\n                                \"remainDistance\": 1698,\n                                \"remainTime\": 250,\n                                \"shape\": [\n                                    52.49821,\n                                    13.52324,\n                                    52.49846,\n                                    13.52308,\n                                    52.4987,\n                                    13.52293\n                                ],\n                                \"functionalClass\": 3\n                            },... This method can also be used to block routes. Thus if you wish to prevent your fleet from using a certain bridge or certain road, you can block it using the block endpoint and mention the layer name while routing. Other use cases would include routing to private properties or internal roads within large properties. Let me know in the comments how you use the custom routes API!", "date": "2019-11-29"},
{"website": "Here", "title": "Introducing Search to HERE XYZ", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/introducing-search-to-here-xyz", "abstract": "Introducing Search to HERE XYZ Recently we added a major new feature to HERE XYZ, the ability to perform searches against your geographic data. This is a fairly complex feature and while we document it of course, I've spent the last few days digging deep into this and wanted to share some additional context and sample code to (hopefully!) make this simpler for our developers. As always, you can leave me a comment below if you've got any follow up questions. All of the code shown here is also available on a (rough) GitHub repo I've setup for various different HERE APIs. I'll share that link at the end. Alright, ready for some awesome deep search talk? Buckle up... Search via Tagging Before we get into the new hotness that is property search, remember that previously we've supported searching by use of tagging. While technically not a \"search\" per se, by using tags with your features you can return subsets of your data. So for example, given a set of cats stored in HERE XYZ, you could use tags to represent different breeds of cats, or as a way to flag cats available for adoption. The existing search API endpoint supports passing in a list of tags. So for example: https://xyz.api.here.com/hub/spaces/SPACE_ID/search?tags=ragdoll,fluffy Would return features in match either ragdoll or fluffy tags. To filter by tags and require all of them, you could do: https://xyz.api.here.com/hub/spaces/SPACE_ID/search?tags=ragdoll,adoptable As a way of matching both the breed and their ability to be adopted. This works but isn't really flexible and requires you to ensure you properly tag your content. Working with Search - Initial Setup A wise woman once said - to search, you first need something to search. For my tests, I wrote a Node script that generated a GeoJSON file of cats. Each cat was located in a random city and had the following properties: name: A random name. gender: Either male or female. age: A random number before 1 and 10. breed: A random breed. available: A boolean value representing if the cat is available for adoption. skills: A nested object with two properties, weapons and cooking. Both have random values representing what weapons that cat is skilled with and what types of food that cat has experience with. Yes, cats. totalFriends: An array of named cats that are friendly with this cat. Here's two examples: \"properties\": {\n\t\"name\": \"Zombified Butterfly Wings\",\n\t\"gender\": \"female\",\n\t\"age\": 5,\n\t\"breed\": \"toyger\",\n\t\"available\": true,\n\t\"friends\": [\n\t\t\"Silly Kitten Zombie\"\n\t],\n\t\"skills\": {\n\t\t\"weapons\": \"katanas\",\n\t\t\"cooking\": \"cookies\"\n\t}\n}\n\n\"properties\": {\n\t\"name\": \"Lord Dumpster Fire\",\n\t\"gender\": \"female\",\n\t\"age\": 3,\n\t\"breed\": \"siamese\",\n\t\"available\": false,\n\t\"friends\": [\n\t\t\"Sir Juniper\"\n\t],\n\t\"skills\": {\n\t\t\"weapons\": \"broadswords\",\n\t\t\"cooking\": \"cakes\"\n\t}\n} If you're interested in the script that generated this data, you can find it here: https://github.com/cfjedimaster/heredemos/blob/master/xyz_search/generateCatGeoJSON.js I took the output of this script, with different total number of features, and uploaded it into multiple spaces for testing. Working with Search - What Can You Search? So you have data in an HERE XYZ space. You've enabled the PRO set of features. What's next? First you need to figure out what properties you can search. This is a bit interesting and may be hard to follow at first, so let's take it slow. First - you can search all properties that contain simple values, but not arrays. Arrays are actually marked as searchable (more on that in a second), but you can't search them yet. Second - when you have more than ten thousand features in a space, HERE XYZ takes a look at your data, and based on advanced super-intelligent machine learning AI code, will make a determination if every property needs to be searchable. In other words, given five properties, it's possible HERE XYZ may decide that one property isn't used often and therefore shouldn't be searchable. Luckily, we provide both an API to determine what's searchable as well as a way to change what's searchable as well. And in fact, you may specifically want to disable search on properties you know do not need it. To determine what XYZ considers searchable in your space, make a call to the statistics endpoint with your space ID, like so: https://xyz.api.here.com/hub/spaces/SPACE_ID/statistics Here's a simple example of this: /*\n\nThis script runs the statistics endpoint on a hard coded space (should be moved to .env, will do so now)\nwhich reports on properties and their searchability.\n*/\n\nrequire('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\nconst SPACE_ID = process.env.SPACE_ID;\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/statistics?access_token=${ACCESS_TOKEN}`)\n.then(res => res.json())\n.then(res => { \n\tconsole.log(JSON.stringify(res.properties, null, '\\t'));\n}); The result (when focused on properties as you see above) will be an object that looks like so: {\n\t\"value\": [\n\t\t{\n\t\t\t\"key\": \"breed\",\n\t\t\t\"datatype\": \"string\",\n\t\t\t\"count\": 2000\n\t\t},\n\t\t{\n\t\t\t\"key\": \"gender\",\n\t\t\t\"datatype\": \"string\",\n\t\t\t\"count\": 2000\n\t\t},\n\t\t{\n\t\t\t\"key\": \"name\",\n\t\t\t\"datatype\": \"string\",\n\t\t\t\"count\": 2000\n\t\t}\n\t],\n\t\"estimated\": false, \n\t\"searchable\": \"ALL\"\n} Note the final value, searchable . This will be one of three values: ALL - Every property is searchable. PARTIAL - Some properties are searchable. NONE - No properties are searchable. If you get PARTIAL as a result, how do you know what's searchable? In this case, the list of properties will include a flag for searchable properties: {\n\t\t\"key\": \"age\",\n\t\t\"datatype\": \"number\",\n\t\t\"count\": 12000,\n\t\t\"searchable\": true\n},\n{\n\t\t\"key\": \"available\",\n\t\t\"datatype\": \"boolean\",\n\t\t\"count\": 12000\n},\n{\n\t\t\"key\": \"breed\",\n\t\t\"datatype\": \"string\",\n\t\t\"count\": 12000,\n\t\t\"searchable\": true\n},\n{\n\t\t\"key\": \"friends\",\n\t\t\"datatype\": \"array\",\n\t\t\"count\": 12000\n} In the example above, the presence of searchable on age and breed mean they can be searched, but available and friends can not. (Note - currently our docs are a bit outdated in that they show \"searchable\": false . The absence of the property implies falsehood. I've filed a bug report to make the docs right as I personally think the value should always be present. Again, this is a new feature so pardon the confusion!) If you wish to change what can be searchable, you need to use the PATCH method against the space. This is covered in the documentation and the only thing I'd add is that you should consider using this both for times when you want to enable a property to be search but also when you want to disable a property as well. The less work XYZ has to do with your data the better it can perform! Note that the ability to change what is searchable is currently a PRO feature only Working with Search - Let's Search! Alright, so just to be clear, we've covered how to enable search and how to figure out what properties can be searched. As well as how to possibly change those if we aren't happy. Now that we've done that, how do we search? A basic search query looks like so (remember that SPACE_ID should be replaced with the ID of your search): https://xyz.api.here.com/hub/spaces/SPACE_ID/search?p.something=value I'm asking the API to search against the something property and match against value . That's an equality check. You can also use other operators: https://xyz.api.here.com/hub/spaces/SPACE_ID/search?&p.age<=3 The above example will look for features where the age property has a value less than or equal to 3. You can use the following operators currently: = for equals != for not equals >= or =gte= for greater than or equal to > or =gt= for greater than <= or =lte= for less than or equal to < or =lt= for less than You can search against multiple properties by passing multiple p. parameters. https://xyz.api.here.com/hub/spaces/SPACE_ID/search?p.age<=3&p.breed=ragdoll The above example will do an AND search and require both properties to match the operators given. To do an OR search where you are ok with either value matching on a property, you can use this form: https://xyz.api.here.com/hub/spaces/SPACE_ID/search?p.breed=ragdoll,devon%20rex The result set from your searches will be standard GeoJSON with the features array limited to items that match your choice. You can modify this slightly though by asking for a filtered set of properties. As a final example, you can also perform a filter on the proeprties returned in the matched filters. To do this, specify the properties you want with the selection argument. For example: https://xyz.api.here.com/hub/spaces/SPACE_ID/search?access_token=${ACCESS_TOKEN}&p.breed=ragdoll&selection=p.breed This example will search against the breed property and filter the returned properties to just the breed value. Here's an example of how one result may look. {\n        \"type\": \"Feature\",\n        \"id\": \"9fa81d26b8064092f913aa1024b4e309\",\n        \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                        -112.0740373,\n                        33.4483771\n                ]\n        },\n        \"properties\": {\n                \"breed\": \"ragdoll\"\n        }\n} Searching on the Client So far you've seen how to use the REST-based API to work with search. You can apply the same property-based searches to the JavaScript library as well. You can either apply it at the constructor level : new here.xyz.maps.providers.SpaceProvider({\n    name: 'SpaceProvider',\n    level: 1,\n    space: 'SPACE_ID',\n    credentials: {\n        access_token: YOUR_ACCESS_TOKEN\n    },\n    propertySearch:{\n        'name': {\n            operator: '=',\n            value: ['Max','Petra']\n        },\n        'age': {\n            operator: '<',\n            value: 32\n        }\n    }\n}) You can also dynamically change property search values by using the setPropertySearch API. Let's consider a full example of how this could look. First, here's a simple implementation that renders our cat data. //specify your credentials to spaces\nvar YOUR_ACCESS_TOKEN = \"USE REAL VALUE\"; \n\n// configure layers\nvar layers = [\n\tnew here.xyz.maps.layers.TileLayer({\n\t\tname: 'Image Layer',\n\t\tmin: 3,\n\t\tmax: 10,\n\t\tprovider: new here.xyz.maps.providers.ImageProvider({\n\t\t\tname: 'Live Map',\n\t\t\turl: 'https://1.mapcreator.tilehub.api.here.com/tilehub/wv_livemap_bc/png/sat/256/{QUADKEY}?access_token=' + YOUR_ACCESS_TOKEN\n\t\t})\n\t})\n]\n\nvar mySpaceProvider = new here.xyz.maps.providers.SpaceProvider({\n\t// Name of the provider\n\tname: 'SpaceProvider',\n\n\t// Zoom level at which tiles are cached\n\tlevel: 3,\n\n\t// Space ID\n\tspace: 'TjJw79XK',\n\n\t// User credential of the provider\n\tcredentials: {\n\t\taccess_token: YOUR_ACCESS_TOKEN\n\t}\n});\n\nvar myLayer = new here.xyz.maps.layers.TileLayer({\n\t// Name of the layer\n\tname: 'mySpaceLayer',\n\n\t// Minimum zoom level\n\tmin: 3,\n\n\t// Maximum zoom level\n\tmax: 10,\n\n\t// Define provider for this layer\n\tprovider: mySpaceProvider\n})\n\nwindow.display = new here.xyz.maps.Map(document.getElementById(\"map\"), {\n\tzoomLevel: 4,\n\tcenter: {\n\t\tlongitude: -96, latitude: 37.73\n\t},\n\t// add layers to display\n\tlayers: layers\n});\n\ndisplay.addLayer(myLayer); Now, let's add a bit of interactivity. First, I'll add a dropdown: <p>\n\tBreed: \n\t<select id=\"breed\">\n\t\t<option></option>\n\t\t<option value='persian'>Persian</option>\n\t\t<option value='bengal'>Bengal</option>\n\t\t<option value='siamese'>Siamese</option>\n\t\t<option value='maine coon'>Maine Coon</option>\n\t\t<option value='sphynx'>Sphynx</option>\n\t\t<option value='ragdoll'>Ragdoll</option>\n\t\t<option value='birman'>Birman</option>\n\t\t<option value='chartreux'>Chartreux</option>\n\t\t<option value='toyger'>Toyger</option>\n\t\t<option value='devon rex'>Devon Rex</option>\n\t</select>\n</p> Then JavaScript to listen to changes to the dropdown. let breedSelect = document.querySelector('#breed');\nbreedSelect.addEventListener('change', (e) => {\n\tlet currentVal = breedSelect.querySelector('option:checked').value;\n\tconsole.log(currentVal);\n\tif(currentVal === '') mySpaceProvider.setPropertySearch(null);\n\telse mySpaceProvider.setPropertySearch('breed', '=', currentVal);\n}, false); Notice the two branches based on whether or not the first, empty, option was selected. Clearing a search filter is done by passing null to setPropertySearch . Otherwise you pass the property, comparator, and the value. Here's an example of the map before a filter has been applied: And here's how it looks with a filter: Wrap Up I hope this article helps you understand how to use this powerful new feature of XYZ. As always, if you've got questions, leave a comment below. You can find the complete set of demos I used here: https://github.com/cfjedimaster/heredemos/tree/master/xyz_search Note that you will need to make a .env file with your own key/space values in order to run the demos.", "date": "2019-12-11"},
{"website": "Here", "title": "October 2019 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/october-2019-release-notes-1-0", "abstract": "Welcome to the latest release of the HERE Location Suite. This post covers the D110 release of the HERE Location Suite. This release includes updates of: Maps API for JavaScript, Geocoder API, Routing API, Large Matrix Routing, Fleet Telematics API, Mobile SDKs for Android and iOS and HERE Mobile SDK User Interface (UI) kit. This release is mainly a maintenance release. The release highlights are: Large Matrix Routing API ETA tracking feature in Fleet Telematics API Driver rest time per country granularity in Fleet Telematics API Special Release of HERE Mobile SDK Premium Edition You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Maps API for JavaScript (Version 3.1.6.0) The support of the additional HERE XYZ endpoints was added Routing API (Version 7.2.110) We introduced note elements of the response for potentially difficult turns on the route. Now, when the route involves taking difficult turns despite it was requested to avoid them, the response will include respective warnings provided as the Note element of RouteType and ManeuverType. Large Matrix Routing API (Version 1.0.1) The Large-Scale Matrix Routing service is now available on the developer portal. It enables to calculate the best routes through one or more locations, showing distances and/or ETAs from up to 10,000 origins and destinations. Compute a routing matrix with up to 10,000 origins and 10,000 destinations. Specify a region with a maximum diameter of 400 km or automatically derive one. Use traffic information in the calculation of the routing matrix. Calculate routes for cars or trucks. Fleet Telematics API (Version 3.0.24) New feature \"ETA Tracking\": For route calculation also send your GPS trace so far. Routing then provides an improved ETA, considering your exact position, rest times taken hence upcoming rest times and matched or skipped planned waypoints. Driver rest times can now be switched on across countries: Specify &restTimes=local to consider the driver rest time (hours of service) regulations of each country along the route. HERE Mobile SDK Premium Edition Android and iOS – Special Release (Version 3.13.3) Fixed issue that license key cannot be decoded on 32bit devices.  – iOS specific Fixed issue with NMAKit private API usage.  – iOS specific Fixed issue with dependency to UIWebView that is deprecated. – iOS specific Fixed issue typo in the new filtering feature method to ‘setAddressFilter’. – Android specific Fixed 'signal X, code Y' exceptions. – Android specific HERE Mobile SDK User Interface (UI) kit (Version 2.1.3) This is a HERE SDK 3.13 integration release. Major changes and features: Android Tested with the HERE SDK 3.13 release Fixed minor issues Removed PowerMock from projects dependencies Handled deprecations iOS Integrated the HERE SDK 3.13 release Updated to Xcode 11.1 Updated deployment target to iOS 11 Fixed minor issues The detailed release notes can be found here: https://github.com/heremaps/msdkui-android/releases https://github.com/heremaps/msdkui-ios/releases https://cocoapods.org/pods/HEREMapsUI The following services had new releases with minor changes: Geocoder API (Version 6.2.191)", "date": "2019-12-04"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.10 release", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.10-release", "abstract": "Highlights Simplify user administration, resource management, and usage tracking with Projects Create projects and manage access to a project for development of new catalog, schema or pipeline resources. Usage of these project resources is automatically tracked and summarized on the credit usage report . With this release, any new catalogs, schemas, and pipelines created in a project are accessible only by that project. However, the catalogs that are explicitly shared with customers from the OLP-HERE Org may be referenced from any project. What are Projects and why are they useful? A project is a collection of resources and optimizes data access between resources Projects represent trust boundaries within an Org Users and apps with project access have automatic access to project resources Projects have automatic tracking of usage by Project-ID Projects enable access control for different stages of production Use projects to restrict access to production-ready catalogs and pipelines. Project admins control which users, apps or groups have project access How do I use Projects? Start by creating a new project with the Projects Manager available from the Launcher in the HERE Platform. More information about using Projects can be found in the Teams and Permissions User Guide General Availability of Location Services in Workspace Location Services APIs (Search, Routing, Transit, and Vector Tiles Service), previously available via the 2.6 release in closed beta, are now available to all HERE Workspace users. To learn more about these Location Services, select the Services in the Launcher: Use of these APIs will be charged at a $/€ rate per transaction or as otherwise specified in your agreement with HERE. Service Description Unit Price Per Unit ( $/ €) Location Services Search One box search, forward geocoder, reverse geocoder, autosuggest, places ID lookup Transaction** 0.0005 Routing Vehicle, pedestrian, truck, transit Transaction** 0.0005 Transit Next departure and station search and intermodal routing Transaction** 0.0005 Rendering Vector Tiles Transaction** 0.0005 **Transaction m eans one API Request for all Open Location Services, except as follows: Service Transaction Definition Search Autosuggest: 10 API requests equal 1 Transaction Rendering Vector Tiles: 5 API requests equal 1 Transaction. Transit Intermodal: One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal_alternatives parameter in the API request. If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction. Run Batch Pipelines on a recurring time-schedule Batch Pipeline Versions can now be scheduled to run based on time. This eliminates the need of an external scheduling system and the costs associated with it. The time-schedule can be set via a CRON expression using the OLP CLI, Web Portal or the Pipeline API. For example, \"0 0 * * *\" represents \"Run once a day at midnight\". See Activating a Pipeline Version for more details. Inspect Historical (Completed or Failed) Batch Pipelines via Spark UI Use the Spark UI to inspect the historical (completed or failed) batch pipelines using the Batch-2.1.x run-time environment. The Spark UI provides the execution and performance details of a Spark job in order to quickly fine-tune or troubleshoot the pipeline configuration or logic and decrease time to production. To access the Spark UI, go to the Jobs tab of a pipeline version and click the link to open the Spark UI from a job, or use the OLP CLI to copy the link from the job details. NOTE: The batch-2.1.0 environment includes the following 2 new libraries: \"com.amazonaws.aws-java-sdk: 1.7.4\" \"org.apache.hadoop.hadoop-aws: 2.7.3\" These libraries are not mentioned in the list of libraries within the 2.10 SDK but are still available. This will be fixed in a future release. More efficiently query Index storage Spatial query improvements have been made to more efficiently query Index layers.  You can now submit location-based data queries via any size bounding box, more efficiently querying large data sets without receiving errors. Based on customer feedback, we've also improved documentation to specify current limits on the number of comma separated values which can be entered in a query via the \"=in=\" operator.  Both changes represent usability enhancements, which we hope incrementally improve your Index storage experience. Big Data connectors The Flink connector integrates proprietary catalogs and layers with the industry-standard format of Flink (TableSource), allowing you to leverage search, filter, map, and sort capabilities offered by the standard Apache Flink framework. In addition to previously released functions, the Flink connector now supports: Read and Write operations on Index layers. Read operations on Versioned layers. With these updates, you can spend less time writing low-level pipeline/data integration code and more time on your use case-specific business logic. Location Referencing Location Library support for Location Referencing has started! If you are ingesting traffic data (e.g. RTTI) that are encoded in TISA TMC/TPEG2 format, you will be able to have the events and their locations converted to usable Stable Topology Segment IDs so they are suitable to be processed in your pipelines. Naturally, the TPEG2 binary-encoded container that wraps the incoming data stream will also be decoded so that the conversion can take place. Simplified attribute access Beginning with this release more HERE Map Content attributes will be added to the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library. The attributes will be added iteratively over time. In 2.10, we added Functional Class, which describes the level of importance of a road in terms of relative traffic volume, e.g. motorway, collector, residential street, etc . Support for Scalable Vector Graphic (SVG) icons in Data Inspector The Visualization library offers a new way to customize data visualization by adding relevant SVG (Scalable Vector Graphic) icons to your data visualization, such as weather, incidents, points of interest, and more. You can define custom icons for \"Point/MultiPoint\" features by configuring a set of specific GeoJSON style properties. The \"marker-image\" property accepts a valid data URL, making it possible to display the following: base64-encoded PNG images, SVGs, and external images. Images can also be referenced by name, reducing the overall GeoJSON size. Icons size and position are configurable through custom renderer plugins. Status history now available on status.here.com/history A new tab, Status history, has been added to status.here.com. Details about past closed events can be found on this page. Descriptions for each status have also been added to status.here.com when mousing over the icons at the top of the page. Changelog We have introduced a changelog for HERE Platform APIs . The language is technical and gives developers a clear view on the specific API changes, additions, fixes, deprecations and known issues. In contrast to the Release Announcements found here, the changelog provides granular insights of individual API changes rather than the discovery of new end to end features. Also, the changelog is a near real-time view of the changes to each API, whereas the Release Announcements are distributed on a monthly cadence. For now, it will cover the OLP CLI and the SDK for Java and Scala - essentially replacing our previous SDK Release Notes. Next year, we will continue adding more APIs to it. Changes, Additions and Known Issues SDK for Java and Scala To read about updates to the SDK for Java and Scala, please visit the SDK Release Notes . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Account & Permissions Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Data Changed: Now rolled out in China: OrgID is added to Catalog HRNs to create greater isolation and protection between individual organizations. This change also supports the ability for Org Admins to manage all catalogs in their Orgs. With this release, Catalog HRNs updated to include Org information are listed in the OLP Portal and are returned by the Config API.  Data Client Library versions higher than 0.1.394 will automatically and transparently deal with this change. Referencing catalogs by old HRN format without OrgID OR by CatalogID will continue to work for (6) months or until June 30, 2020. After June 30, 2020, it is important to note that Data Client Library versions 0.1.394 and lower will stop working. Note: Always use API Lookup in all workflows to retrieve catalog specific baseURL endpoints. Using API Lookup will mitigate impacts to your workflows from this change or any other changes in the future when baseURL endpoints change. With this change, API Lookup will return baseURLs with OrgID in HRNs for all APIs where previously API Lookup returned baseURLs with CatalogID or HRNs without OrgID. Directly using HRNs or legacy CatalogIDs or constructing baseURLs with them in an undocumented way will lead to broken workflows and will no longer be supported after June 30, 2020. Changed: OrgID is added to existing Schema HRNs and will be added to newly created Schema HRNs based on the Organization ID of the user creating a schema via the maven archetype tool in the OLP SDK. Including OrgID in the Schema HRN provides greater isolation and protection of data artifacts between organizations. This change also supports the ability for Org Admins to manage all schemas in their Orgs. References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. Schemas listed in the Portal and elsewhere will be listed using the new HRN construct with OrgID. Separately and as part of this feature release, Schema Group IDs will be reserved to the OrgID which published the first schema to the platform using that Group ID so other organizations cannot publish artifacts using the same Group ID. Fixed: The Data Archiving Library supports the latest CRC and Digest features released for Index layers. Using the Data Archiving Library, the CRC and Digest calculations are automatically calculated if these layer configurations are selected in the Index layer. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and. depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Deprecated: As of June 30, 2020, all data streaming related workflows must be updated to use at least SDK version 2.9.  The Data Client Library behavior as it relates to compressing and decompressing streaming data will strictly adhere to stream layer configuration settings. Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Also: The resolveDependency and resolveCompatibleDependencies methods of the Location Library may stop working in some cases until this known issue is resolved. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work for (6) months. Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  Portal currently will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index Layer data is not yet supported. Pipelines Changed: The Pipeline Developer Guide and Pipeline User Guide have been merged into a single guide, Pipelines Developer's Guide, to make it more task-oriented, eliminate duplication, and to improve the organization of the information. Issue : A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue : If several pipelines are consuming data from the same stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue : The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround : Duplicate the dashboard or create a new dashboard. Issue : For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround : Restart the stream pipeline. Issue: When a paused Batch pipeline version is resumed from the Portal, the ability to change the execution mode is displayed but the change actually doesn't happen. This functionality is not supported yet and will be removed soon. Marketplace Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. SDK for Python Issue: Currently, only MacOS and Linux distributions are supported. Workaround: If you are using Windows OS, we recommend that you use a virtual machine. Visualization Library Changed: UI changes in the Data Inspector's Status Bar positioning and behavior. The Status Bar has been moved into the Toolbar, thus accentuating its relevance not only for Map View but also for other Data Inspector events. Errors and warnings are now more discoverable and better communicated, making your Visualization Library experience a bit more usable and productive. Changed: Custom renderer plugin development has been improved due to a series of enhancements to the Data Inspector's Plugin Editor, including its usability and performance. In particular, we updated the version of the Monaco Editor module and fixed several non-critical bugs, which, nonetheless, caused certain user-experience annoyances. Fixed: An issue with decoding volatile layer data in the Portal's Data Inspector. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 Stream-1.5.x (with Apache Flink 1.2.1) for Pipelines OLP 2.6 August 2019 February 1, 2020 Deprecation Summary: Existing Stream pipelines that use the Stream-1.5.x run-time environment will continue to operate normally until February 1, 2020. During this period, Stream-1.5.x run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-1.5.x environment, please use OLP SDK 2.5 or older. After February 1, 2020 we will remove the Stream-1.5.x run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Stream Pipelines to the new Stream-2.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Stream pipeline to the new Stream-2.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 2 Batch-1.5.x (with Apache Spark 2.1.1) for Pipelines OLP 2.6 August 2019 February 1, 2020 Deprecation Summary: Existing Batch pipelines that use the Batch-1.5.x run-time environment will continue to operate normally until February 1, 2020. During this period, Batch-1.5.x run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-1.5.x environment, please use OLP SDK 2.5 or older. After February 1, 2020 we will remove the Batch-1.5.x run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the new Batch-2.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Batch pipeline to the new Batch-2.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 OrgID added to Catalog HRN (RoW) OLP 2.9 November 2019 May 29, 2020 Deprecation Summary: Referencing catalogs by old HRN format without OrgID OR by CatalogID will continue to work for (6) months until May 29, 2020. 4 OrgID added to Catalog HRN (China) OLP 2.10 December 2019 June 30, 2020 Deprecation Summary: Referencing catalogs by old HRN format without OrgID OR by CatalogID will continue to work for (6) months until June 30, 2020. After June 30, 2020, it is important to note that Data Client Library versions 0.1.394 and lower will stop working. 5 OrgID added to Schema HRN (Global) OLP 2.10 December 2019 June 30, 2020 Deprecation Summary: References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. 6 Data Client Library data compression behavior OLP 2.10 December 2019 June 30, 2020 Deprecation Summary: As of June 30, 2020, all data streaming related workflows must be updated to use at least SDK version 2.9.  The Data Client Library behavior as it relates to compressing and decompressing streaming data will strictly adhere to stream layer configuration settings.", "date": "2019-12-19"},
{"website": "Here", "title": "HERE Tracking now available in the AWS Marketplace", "author": ["Alex Osaki"], "link": "https://developer.here.com/blog/here-tracking-now-available-in-the-aws-ecosystem", "abstract": "Cyber Monday and its week long extension are here in full force and with that at least a dozen of emails in our inboxes, hundreds of deals waiting for our weary credit cards and hundreds of thousands of packages on the way to online shoppers around the world. The digital relative of Back Friday has spread way beyond the borders of the US since its birth in 2005. Last year saw $7.9 billion in online sales in the States alone, which once again beat the previous year's totals. Taking a look into the engineering room of the shopping event reveals a complex and precise operation for everyone involved from the warehouse over to the transport and the delivery to the customer. Let’s take Amazon as an example: Globally, the site serves 310 million active customers. SMBs on the US site sell an average of 4,000 items per minute, or 5.7 million items on a regular day. If you compare that to the 175 million items sold on 2018's Cyber Monday – you can see that a comprehensive toolset is needed to handle such operations at scale. If your team manages a supply chain, operates a logistics service, or manages any system that depends on the timely, accurate movements of goods and services, you can relate – and appreciate the promise of end-to-end visibility in that system. This is where HERE Tracking comes into play – our platform for deploying and building tracking solutions for logistics and supply chain operations within the HERE ecosystem. To make it easier to get you started, the HERE Tracking platform-as-a-service is now available through the AWS marketplace . No matter the size of your company – a start-up or an enterprise, you can adapt HERE Tracking to your use case. Sign up for a free account and you can use HERE Tracking for 90 days to see how it works and understand whether its capabilities are right for your company. Head over to the AWS Marketplace to get started. Anyone on AWS, regardless of technical expertise, can accurately evaluate the HERE Tracking PaaS . So, even if you don’t have tracking hardware, we offer an app to use your phone as a tracker, with options configurable through our web dashboard at app.tracking.here.com . This dashboard also showcases the breadth of HERE Tracking’s features: current and historical visibility, indoor and outdoor tracking, geofencing and notifications, and the use of location data to add context to information being reported from a tracker. After all, the best way for AWS users to make informed decisions about a product is to have the opportunity for gaining hands-on experience with it. See HERE Tracking in the AWS marketplace to get started. Comment below with any questions or feedback.", "date": "2019-12-03"},
{"website": "Here", "title": "Announcing Two New Authentication Types", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/announcing-two-new-authentication-types", "abstract": "We are pleased to announce two new types of authentication for HERE location services: API Keys and OAuth 2.0 Tokens . These new types of authentication are available now! To utilize our new security types, you will need a developer account. If you do not have one, you can register here: HERE Developer account ( https://developer.here.com ) Why change? HERE recommends use of API Keys or OAuth 2.0 Tokens for improved security. APP CODE credentials are the least secure of the authentication credential types. Existing accounts using APP CODE credentials will continue to be supported. However, we encourage you to start transitioning to the new authentication types to take advantage of improved security. The first step in selecting an authentication model is to generate the app. The screen capture below shows a new developer account project page with \"Generate App\" buttons for products such as JavaScript and REST: Once an app is generated, you can now choose which authentication model the product supports. For example, the JavaScript product supports API Keys , while REST supports API Keys and OAuth 2.0 Tokens . Let's learn a little more about each option. API Keys API Key credentials provide for simple and secure authentication of your application. Utilize the API Key credentials key-rotation feature to ensure continued security of your application over time. This is done by creating a second API Ke y for your application and deleting the original key when it is no longer required. You can use a maximum of two API Keys at once for each application. The following screen capture shows an app has been generated for JavaScript, and a \"Create API key\" button is now enabled: To generate the API Key , click the \"Create API key\" button. The resulting API Key credential is provided as shown here: Let's learn a little more about the next option. OAuth 2.0 Tokens HERE Token Credentials conform to the OAuth 2.0 industry standard protocol for Bearer Access Tokens. HERE provides REST APIs to obtain these secure access tokens that may be used for up to 24 hours by your application for the purpose of authenticating requests to the HERE platform. In REST, after generating an app, click the \"Create credentials\" button. You will get confirmation of credentials as shown here: Important Note With the introduction of OAuth 2.0 Token and API Key authentication types there are also new domain names for HERE services. In order to use the new authentication types please use the domain names listed here . Summary HERE has introduced the use of API Keys or OAuth 2.0 Tokens for improved security. Existing accounts using APP CODE credentials will continue to be supported. For HERE SDK for IOS & Android (Starter & Premium Edition), only APP CODE credentials are supported. All other newly generated apps will require API Key or OAuth 2.0 Token credentials. More detailed information about all authentication types for HERE services can be found at our Authentication and Authorization Developer Guide.", "date": "2019-12-11"},
{"website": "Here", "title": "All I want for Christmas is an XYZ Release!", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/all-i-want-for-christmas-is-an-xyz-release", "abstract": "I know what you're thinking. What would be the best, most excellent, and incredibly useful gift this Christmas? How about a new XYZ release? Yes! That's what I was thinking too! You're my new best friend. Not only do we have a new Studio release for you, we've updated the CLI too. Let's unwrap these gifts and get right to it! HERE XYZ Studio 1.6.0 First up is our updates to XYZ Studio . To start with, we've made it easier to hide properties in cards. Previously you had to do this in the data editor, but you can now do it directly in the \"Cards\" interface: Note that you won't see the \"eye\" icon until you mouse over the particular field. Click once to hide and once again to make it visible again. The next change is to the Viewer. We've added the \"Places\" search box in the upper right hand corner: If you're not familiar with this feature, the Places search returns points of interest on the map, like cities, important buildings, and so forth. The Viewer was also updated with two minor UI changes. First, you display the description of your project: Next is a label that's been added to the card title. If you aren't sure what the \"title\" of a card is, this is simply the first property you display for your cards. The label now gives some context as to what the actual value represents. You can see it highlighted below. Finally, the Data Hub now has a \"Copy\" icon for the space ID. I really like this since typo-ing space IDs is like my superpower. Oh, did I say \"Finally\" - because if so I lied. We've also added a festive holiday theme to XYZ Studio that you need to see for yourself! HERE XYZ CLI 1.1.0 and 1.1.1 For our CLI we have not one but two updates. Here's the release notes: HERE CLI v1.1.0 ⬆️⬆️⬆️ Upload ⏫⏫⏫ • We now echo the space ID after an upload finishes, making it easier to find and copy • Upload progress is less chatty, with percentage updated on the same line • While uploading a CSV, if a row does not have any coordinates, we assign it a null geometry and tag it as null_island (meaning you can use tags to access and repair these records) • Lots of streaming enhancements • More reliable shapefile conversion and reprojection • Custom delimiters were breaking streaming (so we fixed that, duh) • Property-based tags are now only written as property@value 🕴🕴🕴 XYZ Pro 🕴🕴🕴 • config is more useful and powerful • The tagrules and searchable commands have been moved under config • More useful titles and descriptions of Virtual Spaces ⬢⬡⬢ Hexbins ⬢⬡⬢ • More reliable hexbinning of large spaces (>10 GB) • You can now hexbin down to zoom 17-18 (useful for aggregating road / probe data) • Better structuring of objects (property names are added to subcounts) • Fixing issues when existing hexbin spacse belongs to another user, or if spaces are shared • Better bbox support, especially with negative lats/lons 🖋🖊🖌 Other 🖋🖊🖌 • Nicer table formatting HERE CLI v1.1.1 🗝🗝🗝 This minor release contains enhancements involving tokens and authentication . 🔑🔑🔑 • Added support for Location Services API Key authentication. • Added server side hexbin clustering capability to tokens generated when viewing space on web via CLI. • Support for changes in the Hub API. You can update your current installation by simply running npm install -g @here/cli . When done you can run here -V to confirm.", "date": "2019-12-20"},
{"website": "Here", "title": "November 2019 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/october-2019-release-notes-1-0-0", "abstract": "Welcome to the latest release of the HERE Location Suite. This post covers the D111 release of the HERE Location Suite. This release includes updates of: Maps API for JavaScript, Geocoder API, Geocoder Autocomplete API, Routing API, HERE Tracking, Fleet Telematics API and Map Data for Mobile SDK . This release is mainly a maintenance release. The release highlights are: Bicycle routing (beta) is now supported in matrix calculations Sensors support in HERE Tracking System status page is now available on the HERE developer portal You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Maps API for JavaScript ( Version 3.1.8.1) We added getters and setters for the \"elevation\" and \"extrusion\" properties of the H.map.Polygon object. H.map.Marker now respects the \"altitude\" component of the geometry. The new H.map.Icon \"stickHeight\" option enables the extrusion of the icon in the screen space. The rendering of the skybox was improved - it does not overlap with the extruded features of the map. Routing API ( Version 7 . 2 . 111) Beta version of bicycle routing is now supported in matrix calculations. HERE Tracking ( Version 1.5.0) We added support for Sensors. Users can ingest sensor data, and create custom rules for Sensors and be notified with events related to sensors. Fleet Telematics API ( Version 3.0.25) Usage of live traffic along the route can be customized: How long into the future to use the current live traffic speeds before phasing out into traffic patterns. The following services had new releases with minor changes: Geocoder API ( Version 6 . 2 . 195) Geocoder Autocomplete API ( Version 6 . 2 . 195) Map Data for Mobile SDK Version 8.30.102.152 (November 2019) IMPORTANT INFORMATION: System status page now available System status for HERE Location Services can be found at status.here.com . Use this site, or use the system status API , to check for any events impacting HERE services.", "date": "2019-12-12"},
{"website": "Here", "title": "HERE at the top spot in location index maintaining its lead over competition", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-at-the-top-spot-in-location-index-maintaining-its-lead-over-competition", "abstract": "What a start of 2020! For the sixth consecutive year, HERE Technologies secured the number one spot in Strategy Analytics’ Location Based Services (LBS) benchmark report. In its annual competitive assessment of global location-platform market leaders, Strategy Analytics recognized HERE as the industry category leader in map-making, automotive, industry vision and openness. HERE also scored highly on map freshness and was highlighted for aggressive improvements in POI search, developer community and visualization. Nitesh Patel, Director, Strategy Analytics commented: “Once again HERE is the leading location platform in Strategy Analytics’ annual benchmarking review. We remain impressed with HERE’s future vision for the location technology sector, backed by product innovation, strategic investment and partnership with key players across multiple industries, including automotive, enterprise, and mobility, among others. HERE is well placed for growth as location services and location intelligence are becoming critical enablers for a broad range of businesses and enterprises. HERE remains a leading supplier of location platform services to the automotive industry and is expanding the distribution of its location platform services across multiple sectors through key developer clouds, like AWS, Microsoft Azure, MuleSoft and SAP.” Edzard Overbeek, CEO of HERE Technologies, said: “As the value of location intelligence is becoming of more strategic importance to all industries, it is great to see new customers, partners, developers and investors selecting HERE Technologies. Combining our leadership position around location intelligence with our location platform strategy, we look forward to a phase of accelerated growth and a great start to 2020 at CES.”", "date": "2020-01-03"},
{"website": "Here", "title": "The Secret Lives of APIs — Part Deux: Map Image & Public Transport Logos", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/secrets-of-the-map-image-api-part-deux-map-image-public-transport-logos", "abstract": "One of the things I like to do is highlight neat API features you may not yet know about. For example, did you know that the Map Image API supports Routing? (Click here to find out how!) In this blog post, I'm once again going to look at the Map Image API. This API lives in the shadows of its bigger brothers, the interactive maps found in our Mobile and Web SDKs. However, it's both a powerful and lightweight API, which can be really useful in contexts where interactive maps don't make sense or simply cannot be used. Think of putting maps into emails or displaying locations on an Echo Show! Like many of our APIs, the Map Image API also hides a few neat features you may not be aware of, so I've decided to write a series of short blog posts to bring these hidden features to light. Today we're going to look at how to generate the logos of public transit companies using the Map Image API. Let’s have a look at a quick example. https://image.maps.api.here.com/mia/1.6/companylogo\n  ?app_id=your_app_id\n  &app_code=your_app_code\n  &logoid=1611547c89c9be1164df5a04d8f393f9\n  &;w=250\n  &;h=250\n  &f=0 As we can see, when using the “companylogo” resource, the API returns an image of a logo instead of a map. In this case, you may recognize the logo as that of the S-Bahn in Germany. Let’s look at the various parameters we’ve used. app_id/app_code : These are your credentials. If you don’t have a set of credentials yet, go ahead an sign up for our Freemium account here on the portal. logoid : This is the unique id for the logo you want to generate an image of. h/w : As you would probably guess, these are the dimensions (height/weight) of the image in pixels. f : This represents the image format. In this case, we’ve chosen PNG, though other formats like JPG (1) or SVG (5) are also available. You can take at look at the documentation to see a complete list of parameters and values. Now you’re probably wondering, where the heck we are getting the logoid from. The answer is that we’re getting it from the Routing API! When request a public transport route using the Routing API, it can provide you with the logoid for the transit lines used in the route. However, it will not do so by default. Because the Routing API is so powerful, it will not return all available information in every response, as the response would become unwieldy. To request this additional information, you can use various attribute parameters. In our case, we want to use the “lineattributes” parameter and the “companyLogo” value. Let’s look at an example. https://route.api.here.com/routing/7.2/calculateroute.json\n  ?app_id=your_app_code\n  &app_code=your_app_id\n  &mode=fastest;publicTransport\n  &waypoint0=52.5208,13.4093\n  &waypoint1=52.5034,13.3295\n  &combineChange=true\n  &lineattributes=companyLogo As you can see, this is a standard routing request, except that we are also asking for the company logo id to be included in the line information. Here’s the snippet from the response, which contains the id we are looking for under \"filename\". \"publicTransportLine\": [\n    … ,\n    {\n        \"lineName\": \"S9\",\n        \"lineForeground\": \"#80004D\",\n        \"lineBackground\": \"#80004D\",\n        \"companyName\": \"\",\n        \"companyShortName\": \"\",\n        \"companyLogo\": {\n            \"resourceType\": \"vendorIcon\",\n            \"filename\": \"1611547c89c9be1164df5a04d8f393f9\"\n        },\n        \"destination\": \"S+U Friedrichstr. Bhf\",\n        \"type\": \"railRegional\",\n        \"id\": \"L2\"\n    },\n\t…\n] Note that not every public transport line necessarily has a logo in the database. That said, why not try it in New York to get the logo of the MTA (59f265c196ffe8335dcf887b4f8ed48d) or Paris to get the logo of the Métro (5f4a858eb573203acc40eb5585017fae). Until next time, when we will reveal even more API secrets!", "date": "2020-01-15"},
{"website": "Here", "title": "Create Your Own Geocode Serverless Application", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/create-your-own-geocode-serverless-app", "abstract": "Geocoding is an essential feature of location services. With geocoding we can attribute friendly names to geolocation coordinates or vice-versa. AWS developers can take quickly create add this feature within their own development environment using the AWS Serverless Application Repository . This post will show how you can deploy HERE Geocode Serverless Application for use in your development projects. This will allow you to access geocoding features from HERE via your own custom API! To accomplish this, you will need credentials at the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com Deploying the HERE Geocode Serverless App After account credentials are confirmed, to find the HERE MapImage application, browse to the AWS Serverless Application Repository . After clicking the \"Browse all applications\" button, you will be prompted to do your search. Type \"geocode\" as shown below, then select the Geocode title in the results shown. Once the landing page for the Geocode application is shown, enter your HERE API Key in the highlighted area shown below, then deploy. It will take a little time for the deployment process to complete. You are prepared for the next step once you see the \" Your application has been deployed \" message shown. Accessing Your Geocode Application Part of the newly created Geocode application is the API endpoint to execute it. The following screen capture shows how to execute a simple test via the AWS API Gateway: With the above URL construct in mind, consider the following script in an HTML client: let API_ID = \"your-api-id\"; function processForm() {\n    let place = document.getElementById(\"placeInput\").value;\n    console.log(place);\n    if (place == \"\") {\n        alert(\"Need a place!\");\n        return false;\n    }\n    invokeGeoAPI(place);\n}\n\nfunction invokeGeoAPI(place) {\n    fetch(`https://${API_ID}.execute-api.us-east-1.amazonaws.com/Prod/geocode/api/geocoder/6.2/geocode.json?searchtext=${place}`)\n        .then(response => response.json())\n        .then(response => {\n            console.log(response);\n        });\n} The above script calls a constructed URL which points to the new geocode application via Amazon API Gateway. You must replace the value of API_ID with the value generated from your API Gateway when the Geocode app was deployed. After the fetch completes the entire response is simply logged. NOTE: You may need to uncomment a line of code in the newly generated lambda to enable CORS. For more information, please enjoy our recorded session on this topic:", "date": "2020-01-23"},
{"website": "Here", "title": "December 2019 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/december-2019-release-notes", "abstract": "Welcome to the latest announcements for the HERE Location Suite (which also just so happens to be the first of 2020!) This post covers the D112 release of the HERE Location Suite. This release includes updates of: Fleet Telematics API, Mobile SDKs for Android and iOS and Map Data for Mobile SDK. This release is mainly a maintenance release. The release highlights are: Two New Authentication Types for improved security Toll system transponders support in Fleet Telematics API New Mobile SDKs for Android and iOS with routing and navigation based on custom map data support, school zone warner, avoid countries during route construction and other improvements You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Suite Services and Products, see the sections below: Fleet Telematics API (Version 3.0.26) New features: Routing avoid tunnels (activate e.g. by &mode=fastest;truck;traffic:disabled;tunnel:-2) Specify which toll system transponders you have, to enjoy the cheaper tariffs (activate e.g. by &tollPass=SunPass,E-Z Pass) HERE Android SDK Starter Edition version 3.14: SDK Starter edition Version 3.14 is deprecated. Only critical defects will be fixed in future releases. Premium Edition version 3.14: Added a warner that informs about school zone restrictions ahead Implemented routing and navigation based on custom map data. The feature provides an opportunity to add private roads for your facilities, block road links that may be closed for short term construction works, etc. This is a Beta feature. Added ability to use real-time traffic information during offline mode Improved turn-by-turn navigation for trucks: added ability to get a distance to truck restrictions on a route during navigation Allowed calculation of the distance to geofence within the offline mode Added ability to retrieve current country information from geo-coordinates (like country code and measurement system) Extended routing options with the possibility to avoid specific countries during route construction Provided API to disable map marker jumping during dragging Implemented resorting algorithm for list of points of map polygon to avoid self-intersection figure Implemented font auto-resizing to fit fixed-size truck restriction icon HERE iOS SDK Starter Edition version 3.14: Added support for new devices: iPhone 11, iPhone 11 Pro, iPhone 11 Pro Max, iPad 7 SDK Starter edition Version 3.14 is deprecated. Only critical defects will be fixed in future releases. Premium Edition version 3.14: Added support for new devices: iPhone 11, iPhone 11 Pro, iPhone 11 Pro Max, iPad 7 Added a warner that informs about school zone restrictions ahead Implemented routing and navigation based on custom map data. The feature provides an opportunity to add private roads for your facilities, block road links that may be closed for short term construction works, etc. This is a Beta feature. Added ability to use real-time traffic information during offline mode Improved turn-by-turn navigation for trucks: added ability to get a distance to truck restrictions on a route during navigation Allowed calculation of the distance to geofence within the offline mode Added ability to retrieve current country information from geo-coordinates (like country code and measurement system) Added a callback that informs about country border crossing Extended routing options with the possibility to avoid specific countries during route construction Provided API to disable map marker jumping during dragging Implemented resorting algorithm for list of points of map polygon to avoid self-intersection figure Added API to retrieve bounding box for map polygon Implemented font auto-resizing to fit fixed-size truck restriction icon The following services had new releases with minor changes: Map Data for Mobile SDK Version 8.30.103.151 (December 2019) Other HERE Location Services got support of a new way of authentication with an API Key or token. IMPORTANT INFORMATION: Announcing Two New Authentication Types: Starting December 11, HERE has introduced the use of API Keys or OAuth 2.0 Tokens for improved security, as announced on our developer blog . Existing accounts using APP CODE credentials will continue to be supported. For HERE SDK for IOS & Android (Lite & Premium Edition), only APP CODE credentials are supported. All other newly generated apps will require API Key or OAuth 2.0 Token credentials. More detailed information about all authentication types for HERE services can be found at our Authentication and Authorization Developer Guide . System status page now available System status for HERE Location Services can be found at status.here.com . You can also use the system status API to check for any events impacting HERE services.", "date": "2020-01-17"},
{"website": "Here", "title": "Create Your Own Search Serverless Application", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/create-your-own-search-serverless-app", "abstract": "Whenever we need to know what is here or there, the Search (Places) API provides many dimensions of querying points of interest around the world. AWS developers can graft in this search feature quickly within their own development environment using the AWS Serverless Application Repository . This post will show how you can deploy HERE Search (Places) Serverless Application for use in your development projects. This will allow you to query location data from HERE via your own custom API! To accomplish this, you will need credentials at the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com Deploying the HERE Search Serverless App After account credentials are confirmed, to find any serverless application, browse to the AWS Serverless Application Repository . After clicking the \"Browse all applications\" button, you will be prompted to do your search. Type \"HERE Places\", then select the Places result as shown below. You will be redirected to the landing page for the Places application. Under \"Application settings\" enter your HERE REST API Key (obtained from your developer profile) in the highlighted area shown below, then deploy. It will take a little time for the deployment process to complete. You are prepared for the next step once you see the \" Your application has been deployed \" message shown. Accessing Your Search Application Part of the newly created Search application is the API endpoint to execute it. The following screen capture shows how to execute a simple test (food places in Phoenix, AZ USA) via the AWS API Gateway: Accessing from HTML Client For testing from HTML client, you may need to go into the source code of the lambda function and uncomment the headers as shown below: Now consider a request made to the Search Application from an HTML client: const display = document.getElementById(\"display\");\nconst url = \"https://your-api-id.execute-api.us-east-1.amazonaws.com/\";\nconst stage = \"Prod\";\nconst resource = \"places/v1/autosuggest\"\nconst atin = \"at\";\nconst geo = \"33.4345,-112.0674\";\n\n// call search serverless application \nfunction invokeGeoAPI(search) {\n    fetch(`${url}${stage}/places/api/${resource}?${atin}=${geo}&q=${search}`)\n        .then(response => response.json())\n        .then(response => {\n            console.log(response);\n            display.innerHTML = \"\";\n            let items = response.results.items || response.results;\n            displayItems(items); // call helper function\n        });\n}\n\n// when user clicks search button\nfunction processForm() {\n    let search = document.getElementById(\"searchInput\").value;\n    console.log(search);\n    if (search == \"\") {\n        alert(\"Need a search!\");\n        return false;\n    }\n    invokeGeoAPI(search); // function defined above\n} The above script calls a constructed URL from all the consts declared which points to the new search application via Amazon API Gateway. You must replace the value of your-api-id with the value generated from your API Gateway when the Search app was deployed. After the fetch completes the entire response is processed in a helper function which displays to screen. For more information, please enjoy our recorded session on this topic:", "date": "2020-01-30"},
{"website": "Here", "title": "HERE Fleet Telematics: Calculate Toll Costs Along a Route", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/here-fleet-telematics-calculate-toll-costs-along-a-route", "abstract": "Fleet management applications not only give you an overview of the health of your fleet, but also ways to optimize your operations in terms of time and costs. One of the ways to optimize the fleet is to be aware of all the costs involved in the route before scheduling it. Toll costs may not seem like a lot individually, but they add up over time. This blog is a continuation of the Fleet Telematics series and explores the TOLL COST API and its features. If you have been following our previous blogs, you might have noticed that we have revised our authentication types with improved security. So, if you are still using the APP_ID and APP_CODE methods of authentication, I would encourage you to get your APIKEY from your projects page. For those who do not have an account yet, sign up for a freemium account at developer.here.com . Now, with new (great?) authentication types, come new (great?) domain names. Any Spidey fans? No? OK :(. Take a look at what the new domains look like for HERE Location Services. For this blog, we are going to take a look at the FLeet Toll Cost API and so the domain fleet.ls.hereapi.com Lets begin with setting up a simple routing call for a truck with our new domain. You can also refer to the Truck routing blog for this. let api ='fleet.ls.hereapi.com/2/calculateroute.json',\n            apiKey = 'YOUR REST KEY',\n            waypoint0 = '38.72639,-9.14949',\n            waypoint1 = '47.54881,7.58782',\n            mode = 'fastest;truck;',\n            representation ='display',\n\n            url = `https://${api}?apiKey=${apiKey}&waypoint0=${waypoint0}&detail=1&waypoint1=${waypoint1}&mode=${mode}&representation=${representation}`;\n            fetch(url)\n                .then(response => response.json())\n                .then(response => {\n                    console.log(response)\n                }, error => {\n                    console.error(error);\n                }); What we have here is a simple routing call with waypoint0 as the starting point and waypoint1 as the end point and truck as the mode of transport. So far, the response does not look very different from that with the basic routing domain route.ls.hereapi.com/routing/7.2/calculateroute.json response: {…}\n​​      language: \"en-us\"\n​​      route: (1) […]\n        ​0: {…}​​​\n            boatFerry: false\n            ​​​​leg: (1) […]\n                ​​​​​0: Object { length: 2046937, travelTime: 79774, trafficTime: 79774, … }\n                ​​​​​length: 1\n            ​​​​mode: {…}\n            ​​​​​   trafficMode: \"disabled\"\n            ​​​​​   transportModes: Array [ \"truck\" ]\n            ​​​​​   type: \"fastest\"\n            ​​​​railFerry: false\n            ​​​​summary: {…}\n                ​​​​​baseTime: 79774\n                ​​​​​distance: 2046937\n                ​​​​​flags: Array []\n                ​​​​​trafficTime: 79774\n                ​​​​​travelTime: 79774\n            ​​​​waypoint: (2) […]\n            ​​​​​   0: Object { linkId: \"+996218283\", spot: 0.49411, sideOfStreet: \"neither\", … }\n                ... Now we add the magic parameter! Harry: What is it? Dumbledore: It's Love! I promise this was the last one. The parameter is tollVehicleType . Add that to the parameters and you will have: fetch(https://${api}?apiKey=${apiKey}&waypoint0=${waypoint0}&detail=1&waypoint1=${waypoint1}&mode=${mode}&representation=${representation}&tollVehicleType=truck) . The response will have a new parameter under response.route[] cost: {…}\n        ​​​​​currency: \"EUR\"\n        ​​​​​details: {…}\n            ​​​​​​driverCost: \"0.0\"\n            ​​​​​​optionalValue: 0\n            ​​​​​​tollCost: \"397.65\"\n            ​​​​​​vehicleCost: \"0.0\" As you can see, you will get the total toll cost for the route in the response. Adding driver_cost and vehicle_cost to the url parameters will also add the total driver and vehicle cost for the route. Is that enough though? Knowing the total toll cost for the trip helps, but what helps even more is a detailed toll booth to toll booth analysis of it. If you take a look at the documentation for the Fleet Toll Cost API, you will see that with this API, you can get details like:- total summary cost per link road cost per country cost per toll system This can be achieved by adding a simple yet powerful parameter called rollups The rollups parameter decides the level of detail you want with the toll costs. Thus the options are: none -toll cost per link total -total toll costs tollsys -toll cost per toll system summary country -toll cost per country summary country;tollsys -toll cost per country and toll system summary Your final call will look something like this: let api ='fleet.ls.hereapi.com/2/calculateroute.json',\n            apiKey = 'YOUR REST APIKEY',\n            waypoint0 = '38.72639,-9.14949',\n            waypoint1 = '47.54881,7.58782',\n            mode = 'fastest;truck;',\n            representation ='display',\n            tollVehicleType = 'truck',\n            driver_cost = '40',\n            vehicle_cost = '0.5',\n            rollups = 'none,tollsys,country,total',\n\n            url = `https://${api}?apiKey=${apiKey}&waypoint0=${waypoint0}&detail=1&waypoint1=${waypoint1}&mode=${mode}&representation=${representation}&driver_cost=${driver_cost}&vehicle_cost=${vehicle_cost}&tollVehicleType=${tollVehicleType}&rollups=${rollups}`;\n            fetch(url)\n                .then(response => response.json())\n                .then(response => {\n                    console.log(response)\n                }, error => {\n                    console.error(error);\n                }); The response will include: response: {…}\n​​      language: \"en-us\"\n    ​   route: (1) […]\n    ​​​     0: {…}\n    ​​​​        boatFerry: false\n            ​​​​cost: {…}\n                ​​​​​currency: \"EUR\"\n                ​​​​​details: Object { driverCost: \"889.35\", vehicleCost: \"1013.16\", tollCost: \"303.85\", … }\n                ​​​​​totalCost: \"2206.37\"\n            ​​​​​leg: Array [ {…} ]​​​​\n            mode: Object { type: \"fastest\", transportModes: (1) […], trafficMode: \"disabled\" }   ​​​​\n            railFerry: false    ​​​​\n            summary: Object { travelTime: 80041, distance: 2026324, baseTime: 80041, … }    ​​​​\n            tollCost: {…}    ​​​​​\n                costsByCountry: (4) […]    ​​​​​​\n                    0: Object { country: \"PRT\", amountInTargetCurrency: 41.2 }    ​​​​​​\n                    1: Object { country: \"ESP\", amountInTargetCurrency: 28.49 }   ​​​​​​\n                    2: Object { country: \"FRA\", amountInTargetCurrency: 233.1 }    ​​​​​​\n                    3: Object { country: \"CHE\", amountInTargetCurrency: 1.06 }    ​​​​​​\n                    length: 4    ​​​​​​   ​​​​​\n                costsByTollSystem: (8) […]    ​​​​​​\n                    0: Object { tollSystemId: \"5004\", name: \"BRISA\", languageCode: \"ENG\", … }    ​​​​​​\n                    1: Object { tollSystemId: \"7249\", name: \"SCUTVIAS\", languageCode: \"ENG\", … }    ​​​​​​\n                    2: Object { tollSystemId: \"5023\", name: \"ASCENDI\", languageCode: \"ENG\", … }    ​​​​​​\n                    3: Object { tollSystemId: \"5055\", name: \"BIDEGI\", languageCode: \"ENG\", … }    ​​​​​​\n                    4: Object { tollSystemId: \"7607\", name: \"ASF\", languageCode: \"ENG\", … }    ​​​​​​\n                    5: Object { tollSystemId: \"7155\", name: \"ATLANDES\", languageCode: \"ENG\", … }    ​​​​​​\n                    6: Object { tollSystemId: \"5016\", name: \"APRR\", languageCode: \"ENG\", … }    ​​​​​​\n                    7: Object { adminId: \"20138137\", amountInTargetCurrency: 1.06 }    ​​​​​​\n                    length: 8\n                onError: false\n    ​​​​​            routeTollItems: (171) […]\n                    [0…99]\n                    [100…170]    ​​​​​​\n                    length: 171\n                ..... From here you can extract the detailed cost, choose routes with lower toll costs or visualize the different toll booths along the routes and provide the driver a notification in advance. If you are interested in a detailed usage of the Toll Cost API, check out the tutorial by my colleague Sudheer. Until then, happy mapping!", "date": "2020-01-29"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.11 release", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.11-release", "abstract": "Highlights Marketplace consumer - fully complete subscriptions online (not available in China) When browsing a listing where standard pricing and terms are visible, data consumers can click-through the entire subscription process online without offline negotiations with the providers. This simplifies and accelerates data access and the buying process.  After the subscription process is completed successfully, you will start seeing the subscription billing on your monthly platform invoice. Efficiently query Index storage using International Organization for Standardization (ISO) country codes This release contains updates to the Index layer Query API which enable you to efficiently query data by country in addition to your other query parameters. You can now include an ISO country code in the query parameter thereby simplifying your query request. This change represents a usability enhancement, which improves the Index storage experience. Developers using OLP China will see query results limited to ISO country codes specific to that region: CHN, HKG, MAC. New data connector available - more easily integrate Volatile data and Flink pipelines The Flink connector integrates proprietary catalogs and layers with the industry-standard format of Flink (TableSource), allowing you to leverage search, filter, map, and sort capabilities offered by the standard Apache Flink framework. In addition to previously released functions, the Flink connector now supports Volatile layer reads and writes for metadata and data. See Flink Connector documentation for more information about all supported layer types, data formats and operations. With these updates, you can spend less time writing low-level pipeline/data integration code and more time on your use case-specific business logic . Location referencing - encode events in an industry standard format In addition to adding TISA TMC/TPEG2-encoded traffic data decoding capability to the Location Library, you are now also able to encode the events and their locations from Stable Topology Segment IDs to the TISA TMC/TPEG2 format so that you can send this data to external systems in an industry standard format (e.g. to traffic broadcast systems) . Simplified attribute access - additional HERE Map Content attributes available As noted in the 2.10 release, we will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library.  In this release, we added the remaining attributes from the Road Attributes layer from the HERE Map Content catalog. Example attributes include Access Characteristics and more. For more detail on the added attributes, please see: HERE Map Content- Road Attributes layer Unified data inspection experience - find partitions on a map or choose from a list of partitions This release comes with a redesigned layer details page to bring a more unified and seamless data inspection experience to the Portal. The Partitions tab has been removed and its functionality has been fully integrated into the Inspect tab. There are two new toggle buttons in the Data Inspector’s Toolbar (top-left corner). Click Map view to inspect layers on top of the map. As before, this currently works only with Versioned and Volatile layers that are HERE partitioned and that have a GeoJSON plugin or that are of type GeoJSON. Use the Partitions list button to access a panel that lists all the partitions in a layer. As before in the separate tab, this works for Versioned and Volatile layers, independent of the partitioning scheme or the kind of data they contain. Decoding requires that the data layer is either connected with a Protobuf schema or is of type GeoJSON. Like before in the separate tab, the new Partitions list panel can only display 100k entries. This is to keep the application performant and responsive. You may still use the search box to search through all partitions in the layer with no limitations. Changes, Additions and Known Issues SDK for Java and Scala To read about updates to the SDK for Java and Scala, please visit the HERE Open Location Platform Changelog . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client Library will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Also: The resolveDependency and resolveCompatibleDependencies methods of the Location Library may stop working in some cases until this known issue is resolved. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work for (6) months. Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  Portal currently will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported. Pipelines Issue : For Stream (Flink) pipelines, the Splunk logs do not contain the logs specified inside the executable Jar file. Workaround : Redirect the standard out and error back to System.out and System.err by adding the below lines as the first thing in the main method: System.setOut(new PrintStream(new FileOutputStream(FileDescriptor.out))); System.setErr(new PrintStream(new FileOutputStream(FileDescriptor.err))); Issue : A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue : If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue : The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround : Duplicate the dashboard or create a new dashboard. Issue : For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround : Restart the stream pipeline. Location Services Issue: Lack of usage reporting for location services launched in 2.10 (Routing, Search, Transit, and Vector Tiles). Workaround : Raise a request via Contact us to get details of your usage report. Marketplace Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. SDK for Python Fixed: Windows is now supported along with MacOS and Linux distributions. Changed: The SDK for Python can now be installed using your own docker build as well. This enables a simpler automated build that executes several command-line instructions in succession. Refer to the Build Your Own Docker section in the SDK for Python Setup Guide for further details. Summary of active deprecation notices across all components", "date": "2020-01-30"},
{"website": "Here", "title": "Displaying an Interactive Map with Python and Flask - Part 1", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/here-map-with-python-flask", "abstract": "When you look at the past year’s trends , you will find that the developers and companies are increasingly adopting Python. In fact, it's the fastest-growing programming language! The reasons for this is simple, Python is one of the easiest language to learn and yet powerful enough to perform modern age development tasks like Automation, Web Development, Digital Transformation, Cloud Computing, Internet of Things, Machine Learning, Artificial Intelligence and many more. One of the most sought-after vertical today is Location Awareness and Analytics, as many application in our life needs a location component. For instance, take any application on your mobile phone and it has most likely asked for your location. Now, imagine what can be achieved by combining the most powerful language (Python) and highly in demand capability (location awareness). This blog post provides the first steps towards a location-powered Python application. So what are we doing here? We are creating a simple Python Flask App for displaying HERE Map on a browser in an HTML page. Prerequisites Python must be installed on your system and you require a Freemium account on developer.here.com . You will also need an API Key from the Developer Portal (which we will use in the code). Simply sign up for your free account and generate API key on your account page. Writing Python Code for Web Development For seamless integration of Python with an HTML page we use Python based web frameworks, here we are using Flask, which is a simple and powerful micro-framework for web application development in Python. Flask as a library can be downloaded using the following command: pip install flask Write the following code in a new python file: The above code represents a simple flask template in which we have imported two sub-packages of flask, viz., Flask and render_template . Also, we have created a function called the “map_func”. This function returns a Jinja2 html page. A HTML file will be required to show the Map on the browser. For this, we need to create an HTML file in a folder called “ templates ”, and then name the file as “ map.html ”. In the <head> of HTML file, add the following <script> elements to load the API code libraries: After this, we need to initialize the communication with the back-end services and initialize the map in the <body> of HTML inside the <script>: You can find detailed explanation of platform object and map object here . The complete HTML code looks like this: Running the code Open the command prompt or terminal and run the Python code. Alternatively, you can also run code in the IDE like Spyder, PyCharm, etc. An IP address will appear, http://127.0.0.1:5000 . Copy this address and paste it in any of the browser application (Chrome, Mozilla, Internet Explorer, Safari, etc.) and you will see a HERE Map with the specified Latitude and Longitude! Conclusion You saw how to integrate HERE Map in Python with the help of the web micro-framework, Flask. Of course this is just the start, but we are well on our way towards exciting use cases such as asset tracking, logistic solutions, delivery tracking, UAV route mapping and many more. In the next part we will be diving deeper into HERE Maps. Stay tuned!", "date": "2020-01-27"},
{"website": "Here", "title": "The Secret Lives of APIs — Phase III: Map Image & Statistics Graphs", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/the-secret-lives-of-apis-phase-iii-map-image-statistics-graphs", "abstract": "One of the things I like to do is highlight neat API features you may not yet know about. For example, did you know that the HERE Map Image API can generate the logos of public transport companies? (Click here to find out how!) In this blog post, we'll be taking yet another look at the Map Image API. This API lives in the shadows of its bigger brothers, the interactive maps found in our Mobile and Web SDKs. However, it's both a powerful and lightweight API, which can be really useful in contexts where interactive maps don't make sense or simply cannot be used. Think of putting personalized maps into your customers’ emails or visualizing a response in an Alexa skill card! Like many of our APIs, the Map Image API also hides a few neat features you may not be aware of, so I've decided to write a series of short blog posts to bring these hidden features to light. Today we're going to look at how to display statistics graphs like circles and bar charts using the Map Image API. Let’s have a look at an example map. This map shows the annual passenger volume at the largest airports in Germany, Portugal, Finland and Romania, visualized using circle graphs. In addition to these graphs, there are also some text labels on the map. The objects are displayed using the respective national colors. The map is created using the following API call: https://image.maps.ls.hereapi.com/mia/1.6/stat\n&?apiKey={{apiKey}}\n&w=1200\n&h=700\n&t=1\n&f=0\n&ot=0\n&o0=50.04925,8.57255;70;red;black\n&o1=38.77012,-9.12868;31;maroon;green\n&o2=60.31852,24.96671;22;blue;white\n&o3=44.57036,26.07558;15;navy;red\n&tx0=50.04925,8.57255;FRA 70M;yellow\n&tx1=38.77012,-9.12868;LIS 31M;green\n&tx2=60.31852,24.96671;HEL 22M;white\n&tx3=44.57036,26.07558;OTP 15M;yellow Let’s look at the various parameters in detail. apiKey : This key is part of your application credentials. If you don’t have a set of credentials yet, go ahead and sign up for our Freemium account here on the portal. h/w : As you would probably guess, these are the dimensions (height/weight) of the image in pixels. f : This represents the image format. In this case, we’ve chosen PNG, though other formats like JPG (1) or SVG (5) are also available. t : This allows you to choose the map scheme. In this case, we’ve chosen a satellite map. Check the documentation for more options and remember that you can use the style parameter for even more customization options. Of course, none of these parameters are new to you if you’ve ever used to Map Image API before. It’s the rest of them that generate the charts and are therefore of special interest for us. ot : This flag allows you to select whether you want to display circle or bar charts. The default (0) is circle. o0, 01, … : Each of these parameters defines a circle or chart object on the map. There are up to four fields you can set here (and we've set them all). These are: coordinate : Latitude and longitude of the object. In our example these are the locations of the four airports. This is required. value : The statistical value that the chart object represents. Can be integer or float. In our example we’ve set the passenger volume in millions. This is required. fill color : The fill color for the chart object. Optional. outline color : The outline color the chart object. Check the documentation for details on color formats. (If you’re heraldically inclined you may wish to replace my crude color approximations with more accurate AARRGGBB colors. If you care about aesthetics, you may wish to change the colors entirely.) Also optional. Omit this if you're really into default blue charts. We’ve also added some text labels on the map using the tx0, tx1, … parameters to increase readability. Note that since these aren’t directly tied to the chart objects, we’ll refer you to this example for more details. Before we finish, let’s have a quick look at an example with bar charts. This map shows the same data, but as bar charts. We’ve omitted the text labels here to keep the corresponding API call short: https://image.maps.ls.hereapi.com/mia/1.6/stat\n&?apiKey={{apiKey}}\n&o0=50.04925,8.57255;70;red;black\n&o1=38.77012,-9.12868;31;maroon;green\n&o2=60.31852,24.96671;22;blue;white\n&o3=44.57036,26.07558;15;navy;red\n&w=1200\n&h=70\n&t=1\n&f=0\n&ot=1\n&olp=1\n&shd=1 First, note that we’ve set ot to 1, which means we are generating bar charts. Next, let’s look at the additional parameters we’ve used in this call. · olp : This parameter lets you define the location point for the chart object. For circles it made sense that its location (the airport) was in the center (0), but for bar charts it makes more for this to be at the bottom, so we’ve set this to 1. · shd : Did you notice the drop shadows behind the bar charts? This parameter turns them on or off. This also works for circles. Until next time, when we will reveal the secret life of the Map Image API with heatmaps!", "date": "2020-01-31"},
{"website": "Here", "title": "How to integrate Bose AR with HERE Location Services", "author": ["HERE Technologies"], "link": "https://developer.here.com/blog/bosear", "abstract": "Recently, we announced a strategic partnership with Bose, the brand that you know for best-in-class audio, innovation, and noise cancelation.  Bose launched Bose AR in 2018 which allows developers to create immersive multidimensional spatial audio experiences and unique location applications.  And now Bose AR developers will be able to easily integrate HERE Location Services to their apps . We’re also excited to provide sample code and how-to’s so that each of the hundreds of thousands of HERE developers may now Bose AR enable their apps. In this blog post we’ll show you how to leverage the Bose IMU to capture direction of travel: Who hasn’t come out of a subway or building and started walking in one direction only to find out a block or two later that you’re heading in the wrong direction?  With this simple code you’ll be able to take the heading from your Bose Frames or QC/NC headsets and reflect that direction on a map by overriding the HERE Map’s position indicator. This is a building block to many solutions you can leverage Here’s location information to add more context to the Bose device’s sensor data. This code overwrites the positioning icon on the HERE mobile SDK map from the phone’s heading which can be fickle to the true heading provided by the Bose IMU: Another option you have as a HERE developer integrating the Bose AR Kit is to maintain the phone’s heading but leverage the IMU’s yaw and tilt to interpolate field of vision.  This is useful when a user is on the move and wants to know more about a point of interest or wants to use the Bose AR capabilities to orient themselves (“just to the right of the Chase Bank you’re looking at”). You’ll need to work out the logic between the direction of travel and field of vision states to provide a seamless user experience; most applications you may dream up will have elements of both.  For example, I’m driving and I look at a building in the distance and ask, “What’s that mountain over there?” and in that instance the pointer icon would not change from direction of travel but rather the app would use the information from the IMU to know field of vision to disambiguate the request.  Later, as the user parks and exits their vehicle, the directional pointer may change to control via the IMU.  Finally, a developer may want to flip between states with context as a user may want heading and then along the way make queries or need orientation. We’re thrilled about our partnership with Bose and can’t wait to see what you all dream up! //HERE DevRel /*\n * Copyright (c) 2011-2019 HERE Europe B.V.\n * All rights reserved.\n */\n \nimport UIKit\nimport NMAKit\nimport BoseWearable\nimport simd\n \nclass MainViewController: UIViewController {\n    \n    class Defaults {\n        static let latitude = 49.260327\n        static let longitude = -123.115025\n        static let zoomLevel : Float = 13.2\n    }\n    \n    @IBOutlet weak var mapView: NMAMapView!\n    \n    var positionIndicator : NMAMapLocalModel?\n    var mapFixed = false\n    \n    private var boseConnected = false\n    private var token: ListenerToken?\n    private let sensorDispatch = SensorDispatch(queue: .main)\n \n    var session: WearableDeviceSession! {\n        didSet {\n            session?.delegate = self\n        }\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // create geo coordinate\n        let geoCoordCenter = NMAGeoCoordinates(latitude: Defaults.latitude,\n                                               longitude: Defaults.longitude)\n        \n        // set map view with geo center\n        mapView.set(geoCenter: geoCoordCenter, animation: .none)\n        // set zoom level\n        mapView.zoomLevel = Defaults.zoomLevel\n        \n        //listen for position updates\n        NotificationCenter.default.addObserver(self,\n                                               selector: #selector(MainViewController.didUpdatePosition),\n                                               name: NSNotification.Name.NMAPositioningManagerDidUpdatePosition,\n                                               object: NMAPositioningManager.sharedInstance())\n        \n        initiateBoseSessions();\n        NMAPositioningManager.sharedInstance().startPositioning()\n    }\n    \n    //listen to any position updates and set the map view to use location\n    @objc func didUpdatePosition() {\n        guard let position = NMAPositioningManager.sharedInstance().currentPosition,\n            let coordinates = position.coordinates else {\n                return\n        }\n        coordinates.altitude = 0\n \n        if(!mapFixed){\n            mapView!.set(geoCenter: coordinates, animation: .linear)\n            mapFixed = true;\n            createCustomPositionIndicator(coordinates: coordinates)\n        }\n        else{\n            positionIndicator?.coordinates = coordinates;\n        }\n    }\n \n    /*this method creates a custom NMAMapLocalModel to serve as the representation of the position indicator.\n     The advantage of using NMAMapLocalModel is that we'll be able to control the YAW of the icon as BOSE\n     angle data is updated*/\n    private func createCustomPositionIndicator(coordinates: NMAGeoCoordinates){\n        var mesh = NMAFloatMesh()\n        let size = 5.0 as Float\n        var vertices : [Float]\n        vertices = [-size/2, -size/2, 0,-size/2,\n                    size / 2, 0.0,size / 2,\n                    -size/2, 0.0,size/2,   size/2, 0.0]\n        mesh.setVertices(UnsafePointer(&vertices), count: 4)\n        \n        var textureCoordinates : [Float]\n        textureCoordinates = [0.0, 0.0,\n                    0.0,  1.0,\n                   1.0,  0.0,\n                   1.0,  1.0]\n        \n        mesh.setTextureCoordinates(textureCoordinates, count: 4)\n        \n        var triangles : [Int16]\n        triangles = [2,1,0,1,2,3]\n        \n        mesh.setTriangles(UnsafePointer(&triangles), count: 2)\n        \n        var image = NMAImage.init(uiImage: UIImage.init(imageLiteralResourceName: \"indicator.jpg\"))\n \n        positionIndicator = NMAMapLocalModel.init(mesh: mesh)\n        positionIndicator!.autoscaled = true\n        positionIndicator!.setTexture(image)\n        positionIndicator!.coordinates = coordinates\n        \n        mapView.add(mapObject: positionIndicator!)\n    }\n    \n    /*\n     Initiate Bose Session\n     */\n    private func initiateBoseSessions(){\n        sensorDispatch.handler = self\n        self.sensorDispatch.handler = self\n        \n        let sensorIntent = SensorIntent(sensors: [.rotation, .accelerometer], samplePeriods: [._20ms])\n \n        let mode: ConnectUIMode\n        if let device = MostRecentlyConnectedDevice.get() {\n            mode = .reconnect(device: device)\n        }\n        else {\n            mode = .alwaysShow // some other way to connect\n        }\n        \n        // Perform the device search and connect to the selected device. This\n        // may present a view controller on a new UIWindow.\n        BoseWearable.shared.startConnection(mode: mode, sensorIntent: sensorIntent) { result in\n            switch result {\n            case .success(let session):\n                // A device was selected, a session was created and opened. Show\n                // a view controller that will become the session delegate.\n                self.boseConnected = true;\n                print(\"bose session started\")\n                self.session = session\n                self.listenForWearableDeviceEvents()\n                self.listenForSensors()\n                self.configureGestures()\n                \n            case .failure(let error):\n                // An error occurred when searching for or connecting to a\n                // device. Present an alert showing the error.\n            print(\"error: \\(error)\")\n \n            case .cancelled:\n                // The user cancelled the search operation.\n                break\n            }\n        }\n    }\n    \n    private func listenForWearableDeviceEvents() {\n        // Listen for incoming wearable device events. Retain the ListenerToken.\n        // When the ListenerToken is deallocated, this object is automatically\n        // removed as an event listener.\n        token = session.device?.addEventListener(queue: .main) { [weak self] event in\n            self?.wearableDeviceEvent(event)\n        }\n    }\n    \n    private func listenForSensors() {\n        // Configure sensors at 50 Hz (a 20 ms sample period)\n        session.device?.configureSensors { config in\n            // Here, config is the current sensor config. We begin by turning off\n            // all sensors, allowing us to start with a \"clean slate.\"\n            config.disableAll()\n \n            // Enable the rotation and accelerometer sensors\n            config.enable(sensor: .rotation, at: ._320ms)\n            config.enable(sensor: .accelerometer, at: ._320ms)\n        }\n    }\n \n    func configureGestures() {\n        session.device!.configureGestures { config in\n            // First, disable all currently-enabled gestures.\n            config.disableAll()\n \n            // Next, configure the gestures we are interested in.\n            config.set(gesture: .doubleTap, enabled: true)\n        }\n    }\n \n    private func wearableDeviceEvent(_ event: WearableDeviceEvent) {\n        switch event {\n        case .didWriteSensorConfiguration:\n            // The sensor configuration change was accepted.\n            print(\"did write sensor configuration\")\n \n        case .didFailToWriteSensorConfiguration(let error):\n            // The sensor configuration change was rejected with the specified error.\n            print(\"wearableDeviceEvent error: \\(error)\")\n \n        case .didWriteGestureConfiguration:\n            // The gesture configuration change was accepted.\n            print(\"did write gesture configuration\")\n \n        case .didFailToWriteGestureConfiguration(let error):\n            // The gesture configuration change was rejected with the specified error.\n            print(\"wearableDeviceEvent error: \\(error)\")\n \n        default:\n            break\n        }\n    }\n}\n \nextension MainViewController: WearableDeviceSessionDelegate {\n \n    func sessionDidOpen(_ session: WearableDeviceSession) {\n        // Session opened successfully. Note that the session passed to the\n        // startConnection completion handler is already open. This delegate\n        // method is only useful when re-opening a session.\n        print(\"Opened session\")\n        }\n    \n \n    func session(_ session: WearableDeviceSession, didFailToOpenWithError error: Error?) {\n        // The session failed to open. Present the error to the user. As above,\n        // the session passed to the startConnection completion handler is\n        // already open. This delegate method is only useful when re-opening a\n        // session.\n        print(\"error: \\(error)\")\n    }\n \n    func session(_ session: WearableDeviceSession, didCloseWithError error: Error?) {\n        // The session closed. If error is nil, this was an expected closure\n        // (e.g., the connection was requested to be closed).\n \n        if error != nil {\n            print(\"error: \\(error)\")\n        }\n    }\n}\n \nextension MainViewController: SensorDispatchHandler {\n \n    func receivedAccelerometer(vector: Vector, accuracy: VectorAccuracy, timestamp: SensorTimestamp) {\n//        print(\"receivedAccelerometer, vector: \\(vector), vectorAccuracy:\\(accuracy), sensorTimeStamp: \\(timestamp)\")\n        // handle accelerometer reading\n    }\n \n    func receivedGyroscope(vector: Vector, accuracy: VectorAccuracy, timestamp: SensorTimestamp) {\n        // handle gyroscope reading\n//        print(\"receivedGyroscope, vector: \\(vector), vectorAccuracy:\\(accuracy), sensorTimeStamp: \\(timestamp)\")\n \n    }\n \n    func receivedGesture(type: GestureType, timestamp: SensorTimestamp) {\n        // handle gesture\n//        print(\"receivedGyroscope, gesureType: \\(type) timestamp: \\(timestamp)\")\n \n    }\n    \n    /*\n     On rotation, get yaw based on BOSE hardware. Then set the position indicator YAW accordingly\n     */\n    func receivedRotation(quaternion: Quaternion, accuracy: QuaternionAccuracy, timestamp: SensorTimestamp) {\n        let qMap = Quaternion(ix: 1, iy: 0, iz: 0, r: 0)\n        let qResult = quaternion * qMap\n \n        let pitch = qResult.xRotation\n        let roll = qResult.yRotation\n        let yaw = Float(-qResult.zRotation)\n        \n        //Convert YAW from radians to degrees\n        var yawDegrees = (yaw  * 180 / .pi) as Float\n \n        //indicator JPG's default position is pointing south, so adding 180 to normalize position\n        let trueYaw = positionIndicator!.yaw + 180 as Float\n        \n        //find positive degree value\n        if(yawDegrees < 0 as Float){\n            yawDegrees = 360 as Float + yawDegrees\n        }\n        \n        //keeping a threshold delta of 2 degrees before reflecting direction change on the map\n        if(abs(trueYaw - yawDegrees) > 2){\n            //180 is because of indicator JPG's default position is pointing south. rotating 180 fixes this.\n            positionIndicator!.yaw = yawDegrees - 180\n        }\n    }\n}", "date": "2020-01-13"},
{"website": "Here", "title": "Helping Cyclists Stay Safe Using HERE Studio", "author": ["Olaf Wysocki"], "link": "https://developer.here.com/blog/helping-cyclists-stay-safe-here-studio", "abstract": "As part of their young developer outreach, HERE conducts workshops in collaboration with the GIS departments of many universities across Europe. One such workshop took place in my uni, the Technical University of Munich where the we learned how to use HERE Location Services and HERE Studio. Below I am going to describe what my team built using the HERE APIs and how it could help cyclists be extra vigilant while cycling in Berlin. Besides being a very popular means of transportation across EU, cycling comes with its risks. In the EU there are more than 2000 people who become victim of fatal accidents involving bikes. One of the most dangerous cities in Europe is Berlin where 5191 cyclists were involved in accidents and 11 of them were killed in 2018. I calculated these numbers using a GIS software based on \"Unfallatlas\" data which is maintained by The Federal Statistical Office . To showcase how you can use GIS tools to raise awareness about accident prone areas in your city, I have taken Berlin as an example because of the density of accidents, available open data, actions of authorities & citizens. We will look into following analyses: The most dangerous zones in Berlin Spots where accidents have happened at night/twilight/dusk, not in the range of streetlights Accidents in winter on a slippery surface Accidents with vehicles on roads with speed limit >30km/h Accidents per road junction without traffic bike signs and traffic lights Now let me show you how to share these results to increase awareness among commuters and aid public authorities in their actions using a similar map . Start here: Get your credentials Yeah, I know this is always this most boring part of the creation of a web map. However, HERE made it quite simple. Just register at developer.here.com and go to your account and generate your JavaScript API key and your REST API key. Copy that to your IDE and… you can forget about it and start your job! const here = {\n   apikey: \"Your JS API key\",\n   apiKey: \"Your REST API key\"\n}; Get access to a freemium data storage solution First of all, our data has to be accessible via the Internet to make it available for a wide audience. HERE provides a very handy solution for that – HERE Studio Data Hub . Here you can store lots of data and query it for free (to some, very wide, extend). Now let us go to the Here Studio webpage, set up an account and go to Data Hub. Now you can simply create new space and drag and drop your data. For web browser, GeoJSON files are most suitable, although you can upload shapefiles or CSV as well.For more on GeoJSON, visit Raymond Camden posts. Our data is stored but now we would like to have access from external environments to those files. How to do that? Go to: xyz.api.here.com/token-ui/index.html There you can generate tokens, which could be understood as keys to access each feature and the whole project itself. You can tick all access rights or just select some of them. Do not forget to click generate token for the whole project (it will appear in green bar). Start building your web map var map = L.map('map', { boxZoom: false });\nvar layer = Tangram.leafletLayer({\n   scene: 'scene.yaml', This is an initialization of a map. You can spot very mysterious names like Tangram , Leaflet . Long story short – those are open source libraries (cool!) for JavaScript tailored to modern cartographers' needs. I really recommend checking them and familiarize with their documentation – possibilities of those rendering libraries are just awesome. In the last line, you can spot the scene: ‘scene.yaml’ which tells to computer ‘get the styling from this file’. Within a scene.yaml file one can prepare very sophisticated visualisations of data. I would like to focus on how we are able to combine our data in Here Studio (our superb warehouse) with a script for visualisation. sources:\n    xyz_osm:\n        type: MVT\n        url: https://xyz.api.here.com/tiles/osmbase/256/all/{z}/{x}/{y}.mvt\n        max_zoom: 16\n        url_params:\n            access_token: 'ACCESS_TOKEN_TO_THE_PROJECT'\n\n    mostDangerousRoadJunctions:\n        url: https://xyz.api.here.com/hub/spaces/HERE_GOES_UNIQUE_FEATURE_ID/tile/web/{z}_{x}_{y}\n        type: GeoJSON\n        url_params:\n            access_token: 'ACCESS_TOKEN_TO_THE_PROJECT'\n\n    slowDown:\n        url: https://xyz.api.here.com/hub/spaces/HERE_GOES_UNIQUE_FEATURE_ID /tile/web/{z}_{x}_{y} \n        type: GeoJSON\n        url_params:\n            access_token: 'ACCESS_TOKEN_TO_THE_PROJECT' Take a look at HERE_GOES_UNIQUE_FEATURE_ID this is the place where you should put a unique ID from Token manager which we generated before. Besides, you have to provide a token to the project itself (ACCESS_TOKEN_TO_THE_PROJECT). Moreover, we can make use of OpenStreetMap data (again free!) provided by HERE (xyz_osm). Thanks to those operations we have prepared data for further styling like this: slowDown:\n        base: points\n        blend: overlay\n        blend_order: 362\n        texture: img/slowDown.png and extend it: _slowDown:\n        data: {source: slowDown}\n        filter: { $zoom: { min: 12 } }\n        draw:\n          points:\n            style: slowDown\n            size: 36px\n            interactive: true Nice, we have our data accessible via the Internet. Now what? The answer is – (almost) everything that you want! Though, we have to focus on one solution which can really help public organizations. Up to now, we presented spots and regions which can help increase awareness of hazards on which cyclists are exposed and probably give a better understanding of dangerous places for authorities. We can go even further and prepare an interactive map for public bodies to analyze the spatial distribution of ambulances in Berlin taking into account real-time traffic data and locations of ambulance stations. Seems interesting? So, take a deep breath and let us go through it! Calculate ranges for ambulances in Berlin based on real-time traffic data I really like the idea that some cities provide they data for free (otherwise, how would we go through this tutorial?) but even better is that private companies like HERE share their spatial information freely. That is exactly what we would like to do now – use HERE location services to get the location of ambulance stations within borders of the city. function addAuthoritiesPlace(){\n   let params = {\n     \"apiKey\" :\"YOUR REST API KEY\",\n     \"in\":  centerBerlin.lat + ',' + centerBerlin.lng +\";r=100000\",       // meters\n     \"name\": \"Ambulance Services\",\n     \"size\": \"50000\"\n   } We are now creating parameters for this query (you can take the apiKey from our first step or paste it here again). The parameter “in” says in what range we would like to search for “places”. In this case, we start in the center of Berlin and analyze radius of 10 000 m. On the other hand, we have also parameter “name” which selects a specific category in which we are interested (this case – Ambulance Services). HERE provides a truly long list of categories that you can check here. “Size” prevents accessing more than x (50 000 in this case) number of features. The complete query: function addAuthoritiesPlace(){\n   let params = {\n     \"apiKey\" :\"YOUR REST API KEY\",\n     \"in\":  centerBerlin.lat + ',' + centerBerlin.lng +\";r=100000\",       // meters\n     \"name\": \"Ambulance Services\",\n     \"size\": \"50000\"\n   }\n\n   let query = Object.keys(params)\n              .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))\n              .join('&')\n   let url = 'https://places.ls.hereapi.com/places/v1/browse?' + query\n \n \n   fetch(url, {\n     \"method\": \"GET\"\n   })\n   .then(response => response.json())\n   .then(response => {\n     console.log(response)\n     for (i=0; i  < response.results.items.length; i++)\n       {  \n\n       newpos= {lat: response.results.items[i].position[0], lng: response.results.items[i].position[1]}\n\n       addMarker(newpos)\n       \n       } \n   })\n } You have probably spotted the addMarker function call – we are going to talk about definition of that function in a minute. We can also inherit the styling of our features inside our script file using Leaflet. Thanks to that I have my own icon inherited within my map. var myIcon = L.icon({\n   iconUrl: 'icons/ambulance.png',\n   iconSize: [38, 38],\n   iconAnchor: [22, 94],\n   popupAnchor: [-3, -76],\n   shadowSize: [68, 95],\n   shadowAnchor: [22, 94]\n}); What we would like to do as well is adding interactivity to our app. The idea behind is to add markers and on double mouse click fire the calculation of our range. So reachability is constrained to starting position placed in one of our ambulances services selected by user. That is exactly what is triggered by addMarker function. It defines way of adding Ambulance Services to the map with specific custom icon and allows interactivity (certain action) when one of point is double clicked. What kind of “interactivity” is that? Please, go further! function addMarker(newpos, html){\n   ev_marker = L.marker([newpos.lat, newpos.lng], {icon: myIcon})\n   ev_marker.addTo(map).on('dblclick', onDblClick)\n } At this point we have to use our JavaScript apikey. Routing service is one of many HERE APIs providing interactivity to our solution. In this case it allows us to check maximal range for ambulances from ambulances services points. First, we have to call the API. var platform = new H.service.Platform({ apikey: here.apikey });\n//\nvar router = platform.getRoutingService(); Now we can start constructing the request. Do you still remember? We wanted to have our range on double click but only calculating possible ranges from the ambulance’s locations. That is why we are using positions (lat, lng) from events (double click on our feature). We can set up mode , in other words – what type of route we would like to take (shortest/fastest) and what type of vehicle do we use (or maybe just walk?). So we say take the fastest road, use a car (because we want to help ASAP and we have an ambulance), but still, we have to watch out for traffic ( traffic:enabled ). The traffic is real-time data at the moment of firing the query(!). Moreover, we would like to say: “restrict the time of arrival to 15 min\" because if it is not within this time range, we will take other ambulance” (‘range’: ’900’ means 15 min and ‘rangetype’ specifies ‘time’ as our restriction). function onDblClick(e) {\n   //if feature clicked twice - > fire routing\n   //routing parameters\n   \n   var myStart = e.latlng.lat + ',' + e.latlng.lng\n   var routingParams = {\n   'mode': 'fastest;car;traffic:enabled',\n   'start': myStart,\n   'range': '900', // 15 (15x60secs) minutes of driving \n   'rangetype': 'time'\n} Based on that we will get the spatial range controlled by those parameters. So-called isoline routing (for more on Isoline Routing service) allows us to proceed with maximum ranges and we are able to draw it on the map. Take a look at the full part: var onResult = function(result) {\n   var center = new H.geo.Point(\n     result.response.center.latitude,\n     result.response.center.longitude),\n   isolineCoords = result.response.isoline[0].component[0].shape,\n   //isolinePolygon,\n   isolineCenter\n \n\n   // Create a polygon and a marker representing the isoline:\n   //43.2323, 12.2312, 44.32112, 13.13213 --> [[43.2323, 12.2312], [44.32112, 13.13213],...]\n   var list1 = isolineCoords.toString()\n   var string = list1.split(',');\n\n   // Create array of float for each pair of coordinate\n   var a = string.length;\n   for (i = 0; i < a; i++) {\n      string[i] = parseFloat(string[i]);\n   }\n\n   // Initialize an array to store the new values\n   var b = string.length / 2;\n   var array = [];\n   for (i = 0; i < b; i++) {\n      array[i] = [0, 0];\n   }\n\n   // Create an array of array of coordinates\n   var k = 0;\n   for (i = 0; i < b; i++) {\n      for (j = 0; j < 2; j++) {\n         array[i][j] = string[k];\n         k++;\n      }\n   }\n   \n   // Add the polygon to the map & remove when 1 already exist:\n   \n   if (isolinePolygon != undefined) {\n      map.removeLayer(isolinePolygon);\n   };\n\n   isolinePolygon = L.polygon(array)\n   isolinePolygon.addTo(map)\n\n   map.fitBounds(isolinePolygon.getBounds());\n   //map.setView([isolinePolygon.getCenter().lat, isolinePolygon.getCenter().lng], map.getZoom());\n   \n   var isolinePopup = L.popup({className: 'customIso', closeButton: false});\n   isolinePopup\n\n   .setLatLng([isolinePolygon.getCenter().lat, isolinePolygon.getCenter().lng])\n   .setContent('</p ><p>How far can I get in 15 min?')\n   .openOn(map); \n    \n }\n\n // Call the Routing API to calculate an isoline:\n\n function onDblClick(e) {\n   //alert(e.latlng.lat + ',' + e.latlng.lng);\n   //if feature clicked twice - > fire routing\n   //routing parameters\n   \n   var myStart = e.latlng.lat + ',' + e.latlng.lng\n   var routingParams = {\n   'mode': 'fastest;car;traffic:enabled',\n   'start': myStart,\n   'range': '900', // 15 (15x60secs) minutes of driving \n   'rangetype': 'time'\n}\n\n   router.calculateIsoline(\n      routingParams,\n      onResult,\n      function(error) {\n      alert(error.message)\n      }\n    );\n\n} Conclusion To recreate this for your city, check out also my GitHub repository and the cyclist related project.", "date": "2020-02-07"},
{"website": "Here", "title": "Displaying an Interactive Map with Python and Flask - Part 2", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/displaying-an-interactive-map-with-python-and-flask-part-2", "abstract": "Last week, we started integrating HERE maps into a Python Flask, which resulted in displaying a map. If you want to start from the very beginning or would like to revisit it, you can check it out here . Now, we are going to dig a bit deeper into it by adding features and functionalities to our map. First of all, we will be re-using the code that we built in our previous blog, so you will need to go through it once. Working with Raster One of the basic ingredients in creating a map is defining how you want to see your map. HERE gives you an option of either fetching the map data in a vector or a raster format. Calling both of them is very simple, all you need to do is use the method - createDefaultLayers() , defined under the Platform class. You would have already done this in the previous blog, with the following code  - vector.normal.map We will now explore the Raster format. It gives you multiple choices of style (it is also easier to use), especially the satellite imagery. Let's check it out. We have three different map types - normal, satellite and terrain. Each contains a set of named layers - map, transit, xbase, base, and labels. We can combine them as shown in the table below - Map Type/Layer map transit xbase base labels normal normal.map normal.transit normal.xbase normal.base normal.labels satellite satellite.map NA satellite.xbase satellite.base satellite.labels transit terrain.map NA terrain.xbase terrain.base terrain.labels You can call all the map styles from the table, using raster and a dot followed by values in the table. You can see how we used raster.terrain.map , similarly we can create different combinations from the table mentioned above. For more information on raster, you may visit the official page . Making our Map Responsive The map we created is just an image, a static one, non-responsive to touches, taps and mouse clicks. There is no fun in a static image, what we are looking for instead, is some action, where we can do something with mouse clicks like looking around for different cities and countries. For this, we have the ‘events’ module. The best thing about the events module is that you don't need to write different code for different browsers on different platforms, it handles all the complexity for you. All you need to do is to use it and not worry about anything else. How are we going to use it? By loading a module called ‘mapsjs-core.js’ in the <head> of HTML file - Next, with the help of Map object, instantiate the MapEvents class and lastly, add an events listener to the map. This is how it will look like - To see it working, after running the python code and opening the address http://127.0.0.1:5000 , you will need to open Console on your browser. Which can be done by simply pressing 'ctrl+shit+I' and clicking on 'Console'. You can change parameters and see the effect, in map.addEventListener instead of ‘tap’ write ‘dbltap’ and see what you get. So basically you can change the events as per your need and requirement. The Events module gives you the following events - Pointer - pointerup, pointerdown, pointermove, pointerenter, pointerleave, pointercancel Drag - dragstart, drag, dragend Tap - tap, dbltap Long Press - longpress We can also have a full interaction like pan, zoom and pinch-to-zoom by adding only one line of code - Adding controls and UI components to the Map HERE provides ready-made map controls through the UI module named ‘mapsjs-ui.js’. All you have to do is add following in the in the <head> of HTML file of the existing code - Now, we have added a CSS file link too, because we want our map to look appealing. By adding just one line of code, we get a default UI and apart from zoom-in and zoom-out feature, we get a collection of default map layers. If required, we can also add an info bubble that allows us to show a bubble at a particular position containing HTML content on the map. You can explore the UI components further here . The complete code with all the changes will look like this  - This concludes our two parts tutorial on creating an interactive map with Python Flask.", "date": "2020-02-09"},
{"website": "Here", "title": "HERE Mapathon Recap - Part One", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-mapathon-recap-part-one", "abstract": "Last fall, HERE and Agorize ran a multiweek \"mapathon\" designed to encourage people to use build maps using their content and HERE XYZ . This was open to anyone (developer, designer, unicorn) across the planet.  To say that we were blown away by the participation would be an understatement. We had hundreds of entries (some representing individuals but most representing groups of people) from nearly every continent. These entries were eventually pared down to one hundred submissions that were reviewed by HERE and Agorize. After our review, we had ten finalists for the Mapathon that had a chance to do a final pitch (live) to a panel of judges. (That final event was streamed live and can be watched here .) In this blog, I'm going to review the first five finalists. I'll follow this up with another blog where I review the next four finalists and will wrap with a third entry talking about our winner. I hope you find these entries as inspiring and exciting as we did! Finalist 1: OnixMaps The first finalist used maps of \"down here\" to show what can interferes with \"up there\". This entry from Brittany Yee attempted to create a map of the impact of light pollution on the night time skies. This includes sources like building lights, advertising, and streetlights. Yee thought by building a map showing skyglow (one particular form of light pollution) it might help governments find areas that could be targeted for improvement. Her map was easily one of the most impressive looking. You can find her live demo running at https://here-mapathon-ece8f.firebaseapp.com/ . More details about her project can be found here . Finalist 2: Guardians The Guardians group (made up of four team members) worked on an issue we saw multiple times in this content, the impact of flooding. They built a demo that attempted to simulate and forecast flooding impacts on urban environments, mixing elevation, soil type, and drainage data into their project. They added a timeline aspect to their final project that was very interesting as well. You can run their demo at http://88.198.134.196/mapathon/v4/ . Details about their project may be found here . Finalist 3: NUSANTARA Our third entry comes from two developers looking to raise awareness of forest fires in Indonesia. Using their data they created multiple maps. The first mapped out fire hotspot distribution in Indonesia covering the time period of January to November 2019. The next map visualized smoke hazards over the same period. Their third map demonstrates areas that were prone to fires. The final map they created showed how many people lived in the areas affected by smoke hazards. You can finds links for all of their maps and details on their project page. Finalist 4: Menstrumappers This team of two have been working hard to help improve education about menstrual hygiene. Many women around the world struggle to get access to adequate information, to sanitary products, or to proper medical attention regarding women’s health. Lack of access to these essential aspects of women’s health can lead to “period deaths” due to lack of access, as well as myths and shaming brought on by cultural taboos. Their project consisted of three maps. The first illustrated period deaths and their causes. The second map showed the location of social organizations dedicated to menstrual outreach and education. Their final map attempted to show where menstrual products could be acquired. You can find links for all their maps and more information about the effort at their project page . Finalist 5: Endeavoring to View Our World The final entry we will look at this in blog is from a set of developers and engineers from an energy company in Australia. They mapped two different sets of data that ultimately combine to give a story about power access in the region they covered. The first detailed the loss of power due to storms over a time period. Their next map then shows coverage of solar power generation over time. Their project information may be found here: https://matthewjparker.github.io/EndeavourEnergy/", "date": "2020-01-23"},
{"website": "Here", "title": "HERE Studio: The Product Formally Known as XYZ", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/the-product-formally-known-as-xyz", "abstract": "TL;DR: We've got a naming change for HERE XYZ. For all users of our custom maps creation tool in the room I'm writing a short and sweet summary of what's going on so you can read and get on with your day as quickly as possible. In a nutshell, we have streamlined our naming across the board, including HERE XYZ. In this case, we felt that \"XYZ\" wasn't necessarily descriptive of what we're offering and it was time for a change. First, HERE XYZ Studio will now be called HERE Studio . This is the web application to make custom maps using the point and click interface. The URL will change in the future and we will redirect you from the old location to the new one. Secondly, the APIs we used to refer to as the XYZ APIs will now be known as the Data Hub API. None of the URLs will change for now. And finally, the CLI is going to renamed Super Kitten Awesome Command Line Fun Time. No, wait, I meant Data Hub CLI. Again though, how you use the CLI won't be changing. That's it. Oh, and we will be formally launching advanced Data Hub features with a paid tier soon. It's been mentioned in the docs a bit as \"PRO\" (for example, one of the features related to search is PRO only) but there hasn't actually been a way to move to this new tier. That will be possible shortly.", "date": "2020-02-11"},
{"website": "Here", "title": "Top Ten Developer Blog Posts of 2019", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/top-ten-developer-blog-posts-of-2019", "abstract": "The previous year was a huge year for developers and HERE, mostly because of the wisdom of HERE Technologies deciding to hire me as a new developer evangelist! OK, I'm joking about that part (mostly), but we had a huge year with multiple updates to our developer offerings as well as a lot of great content posted here. By my quick estimate, we published over a hundred different technical blog posts last year covering a wide variety of frameworks, platforms, and products. Here's a list of our top posts, curated both by views as well as my own personal preference. 10. Have a Better Wild Ryde with AWS and HERE Let's start off with a short but important one. I wasn't aware of the courses Amazon created to help learn AWS, but anything that involves unicorns sounds like a heck of a fun time. In this article we talk about the courses HERE provides that extend upon these AWS courses and help you learn how to work with HERE services. View the Post 9. Validate Street Addresses with Vue.js and the HERE Geocoder Autocomplete API The Geocoder Autocomplete API makes it easy to match user input with properly formatted and complete address information. In this example, a previous version made with React is now built using the Vue.js framework (my personal favorite). Vue (heh) the Post 8. Find Out Which Side of the Road to Drive on Using the HERE Geocoder API I absolutely love this post as it describes a feature I never would have guessed our APIs had - administrative data about geographic regions. As the title says, by using the Geocoder API, you can ask for information about the region returned which includes (among other cool details) what side of the road drivers use. View the Post 7. Geofencing Regions with JavaScript and HERE Geofencing refers to the process of defining a geographic region that is bound on all sides. Once you have a geofence, you can then determine if points exist inside or outside of the fence. In this post, we walk you through how to define geofence regions and check if points are inside using HERE APIs and tools. View the Post 6. Great Guide to Generating Good GeoJSON I feel a bit guilty for including one of my own in this list, but it did get a good amount of views and has easily the most obnoxious title in this entire list. In this blog, I go into detail about how you can take data and convert it to GeoJSON, discussing different strategies on converting, and improving, your data. View the Post 5. Developing Location-Aware Alexa Skills I'm a huge fan of voice assistants and Alexa in particular. As a developer, they make it incredibly easy to build skills (think apps) for their platform. In this post, we document what you need to do to get location data from users working with your skill. If you haven't yet looked at developing for voice assistants, you should check out this great article on Smashing Magazine: Creating Voice Skills For Google Assistant And Amazon Alexa View the Post 4. How does the Snowfall in December compare to the past? This is a fairly short post but an awesome demo. By making use of NOAA historical data and HERE Studio, the fine folks at ZCreative Labs created a cool visualization that shows how much snow has fallen in December over the past couple of years. You can jump right to the demo or visit the post by using the link below. View the Post 3. Introducing harp.gl – 3D Vector Maps for the Web Back in June we proudly announced the best release of a new open source 3D map renderer named harp.gl. Built to be a flexible web-friendly map library, it lets developers create beautiful, and highly performant map visuals. You can see more about the project over at GitHub: https://github.com/heremaps/harp.gl View the Post 2: How to Render a Map of San Diego's Smart City Streetlights with HERE XYZ, Python and Tangram Another IoT related entry, this post goes into detail about San Diego's incredibly sophisticated city-wide IoT network that provides data about pedestrian and vehicle data picked up from sensors on street lights. The post goes into retrieving this data using Python and once again integrating HERE APIs to improve the result set. View the Post 1: Read GPS Data with a Raspberry Pi Zero W and Node.js I'm a sucker for good examples of IoT usage and this is a great one. In this post Nic Raboy describes using a cheap Pi devices to read location data and then post that data to our APIs to get a human-readable address for the location. View the Post", "date": "2020-02-03"},
{"website": "Here", "title": "HERE Mapathon Recap - Part Two", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-mapathon-recap-part-two", "abstract": "Earlier this month, I shared the first set of winners from our Mapathon . This contest was designed to get people (designers and developers) to work together taking public data and HERE Studio to create impactful maps. My previous post covered the first five runner ups and today I'm going to continue sharing more awesome examples from our community! Finalist 6: EForEffect The EForEffect team looked into mapping health resources in Malaysia as a way to help issues with wait times and over-crowding. By mapping out the health-related data (population and life expectancy, the number of medical professionals, total hospitals and clinics, and finally the total number of diseases) available now, decisions about future improvements could be made easier, especially in terms of where budgetary dollars are most needed. You can find their demo here: https://eforeffectheremapathon.herokuapp.com/ . More details about their project may be found here . Audience Prize: Guan Software Crew Our next runner up won the \"Audience Prize\" for the show as the most liked by people watching the final video stream for the mapathon. Their creation, Fe-Map, helps raise awareness of gender-based murder. Over half of women murdered were killed by intimate partners or other family members. The team attempted to map out data related to these murders to give viewers a better idea as to how prevalent these crimes are. Their project generated two maps ( first and second ) and you can read more about their project here . 3rd Place: MAPM In third place was MAPM, a group that used mapping to help you find a new place to live. By adding data that home searchers may care about (access to green spaces, public transportation, noise pollution levels, and so forth), a prospective buyer can determine which areas of a city may be best suited for them. Their interactive map lets the viewer determine which factors they care about the most. Read more about their project here . 2nd Place: Commute Reducer The second place submission was a beautiful map called Commute Reducer. This team made use of public US government data to map out the economic cost lost due to commuting. The more intense the color of a region the worse the impact is. The map has an incredibly cool kind of retro look to it that I love. You can demo it here and see more about the project here .", "date": "2020-02-10"},
{"website": "Here", "title": "Create Your Own Weather Serverless Application", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/create-your-own-weather-serverless-app", "abstract": "A condition that impacts people no matter where they live is weather. For some applications, it is important to capture current weather or the forecast to provide the best user experience. Because weather conditions happen at locations, HERE offers a Weather API to make sure developers can obtain what they need for their solutions. In addition to being offered as a RESTful API,  AWS developers can include the weather feature quickly within their own development environment using the AWS Serverless Application Repository . This post will show how you can deploy HERE Weather Serverless Application for use in your development projects. This will allow you to query location data from HERE via your own custom API! To accomplish this, you will need credentials at the following: A developer account at http://developer.here.com An AWS account at http://aws.amazon.com Deploying the HERE Weather Serverless App After account credentials are confirmed, to find any serverless application, browse to the AWS Serverless Application Repository . After clicking the \"Browse all applications\" button, you will be prompted to do your search. Type \"HERE Weather\", then select the Places result as shown below. You will be redirected to the landing page for the Weather application. Under \"Application settings\" enter your HERE REST API Key (obtained from your developer profile) in the highlighted field \"HereApiKey\"as shown  below, then deploy. Also note the highlighted link above to the technical documentation for instructions on how to implement. After selecting deploy, it will take a little time for the process to complete. You are prepared for the next step once you see the \" Your application has been deployed \" message shown. Accessing Your Weather Application Part of the newly created Weather application is the API endpoint to execute it. The following screen capture shows how to execute a simple test via the AWS API Gateway: Accessing from HTML Client For testing from HTML client, you may need to go into the source code of the lambda function and uncomment the headers as shown below: Now consider a request made to the Weather Application from an HTML client which is also using the HERE JavaScript SDK: const JSAPIKEY = \"YOUR-JAVASCRIPT-APIKEY\";\nconst AWS_API = \"YOUR-API-GATEWAY-ID\";\nconst AWS_URL = `https://${AWS_API}.execute-api.us-east-1.amazonaws.com/Prod/weather/api/weather/1.0/report.json`;\n\n// Obtain reference to #mapContainer in DOM\nlet container = document.getElementById('map');\n\n// Store initialized platform object\nlet platform = new H.service.Platform({apikey:JSAPIKEY});\n\n// Store reference to layers object\nlet layers = platform.createDefaultLayers();\n\n// Create map object initialized with container and style\n// Set map style - example M.Layers.satellite.map\nlet map = new H.Map(container, layers.vector.normal.map, {\n    center: {lat:19.7519, lng:-99.1276},\n    zoom: 4,\n    pixelRatio: window.devicePixelRatio || 1\n});\n\n// Create behavior object initialized with map object\nlet behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n// Store UI object associated with map object and layers object\nlet UI = H.ui.UI.createDefault(map, layers);\n\nfunction getWeather(lat,lng) {\n    //let options = \n    let options = `product=observation&oneobservation=true&latitude=${lat}&longitude=${lng}`;\n    let url = `${AWS_URL}?${options}`;\n    fetch(url)\n    .then(response => response.json())\n    .then(response => \n    {\n        console.log(response);\n        let observation = response.observations.location[0].observation[0];\n        alert(observation.description);\n    })\n    .catch(error => console.log(error));\n}\n\nfunction initMapTap(map) {\n    map.addEventListener('tap', function (evt) {\n    var coord = map.screenToGeo(evt.currentPointer.viewportX,\n        evt.currentPointer.viewportY);\n    let lat = coord.lat;\n    let lng = coord.lng;\n    console.log('Coordinates:' + Math.abs(lat.toFixed(4)) +\n        ((lat > 0) ? 'N' : 'S') +\n        ' ' + Math.abs(lng.toFixed(4)) +\n        ((lng > 0) ? 'E' : 'W'));\n    getWeather(lat,lng);\n    });\n}\ninitMapTap(map); The above script calls a constructed URL from all the consts declared which points to the new weather application via Amazon API Gateway. You must replace the value of YOUR-JAVASCRIPT-APIKEY with the JavaScript APIKEY from the HERE developer profile, and YOUR-API-GATEWAY-ID with the value generated from your API Gateway when the weather app was deployed. Running the script in the browser shows a weather info alert when the map is clicked on as seen below. For more information, please enjoy our recorded session on this topic:", "date": "2020-02-21"},
{"website": "Here", "title": "January 2020 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/january-2020-release-notes-0", "abstract": "Welcome to the latest announcements for the HERE Location Services. This post covers the D113 release of HERE Location Services. This release includes updates of: Maps API for JavaScript, Batch Geocoder API, Geocoder API, Geocoder Autocomplete API, Routing API, HERE Tracking, Fleet Telematics API and Map Data for Mobile SDK . This release is mainly a maintenance release. The release highlights are: New routing, customization and restrictions related functionalities added in Fleet Telematics API New endpoints Journeys API and Indoor Geofencing API added in HERE Tracking product Truck attributes rendering and other improvements in new JavaScript API release You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Services, see the sections below: Maps API for JavaScript (Version 3.1.11.0) H.map.Style now supports \"import\" statements in the configuration files. Traffic flow lines are rendered under the labels when enabled via UI elements. XYZ provider does not restrict GET parameters to the pre-defined values. New methods for the XYZ service enable feature editing. Method \"toGeoJSON\" on all map objects produces GeoJSON output for the easy serialization of objects. Vector tiles are fetched only once the layer is split. The rendering of the truck attributes was added to the default map styles. Batch Geocoder API (Version 6.2.60) The map reference fields have additional fields available in results: mapReferenceMapId, mapReferenceMapReleaseDate, mapReferenceAddressId HERE Tracking (Version 1.6.0) We added support for Journeys. Users can create and track shipments, and perform delay analysis over the logistics paths. We added support for multiple webhook notification URLs. Users can now subscribe to receive only certain types of notifications to a URL. We added support for indoor geofencing. It enables developers to create indoor geofences with floor definition. Geofence related events are now available through the event log. Fleet Telematics API (Version 3.0.27) New features: Router meets the waypoint on the correct side of the street If the heading is provided in a waypoint, routing tries to stop on the link into this driving direction. This avoids making goods or passengers cross a busy street. However, if it would take a big detour the router will not stop on the desired side. Both the search radius and the penalty can be customized. Router can avoid or prefer certain links Custom routing can now consider user specific penalties or bonus for road links. If certain streets are cumbersome or well suited for certain vehicle types of a fleet, a custom road overlay can define individual penalties or bonus for using these streets. Add your own turn restrictions for routing Customers can avoid that their trucks get stuck at certain dangerous intersection turns. Customizable penalty to avoid U-turns Users can specify a penalty for U-turns on the route. Add your own EV Charging stations for \"Routing with EV charging along the route\" In addition to the HERE EV charging locations, routing can use custom layers (uploaded via Custom Locations service) Define your own restriction types (virtual traffic signs), like \"on this link only our at least 50kph enabled class 3+ cars are allowed\" Each custom link restriction has a vector of maximum values, the car in the routing request has a vector of values, which must fit within the link's values. Use cases: special vehicle classes, special permissions required, special vehicle properties like ground clearance, special road restrictions Limit extended: The Corridor Search radius limit is raised from 2000m to 5000m. Map Data for Mobile SDK (Version 8.30.104.157 (January 2020)) Improved the way U-turns are identified as inconvenient maneuvers for entire map. This fix was previously released only for North America segment of the map to validate its correct behavior. The following services had new releases with minor changes: Geocoder API (Version 6.2.197) Geocoder Autocomplete API (Version 6.2.199) Routing API ( Version 7 . 2 . 113) IMPORTANT INFORMATION: Two New Authentication Types: Starting December 11, HERE has introduced the use of API Keys or OAuth 2.0 Tokens for improved security, as announced on our developer blog . Existing accounts using APP CODE credentials will continue to be supported. For HERE SDK for IOS & Android (Lite & Premium Edition), only APP CODE credentials are supported. All other newly generated apps will require API Key or OAuth 2.0 Token credentials.", "date": "2020-02-11"},
{"website": "Here", "title": "The Secret Lives of APIs — Book Four: Map Image & Heat Maps", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/the-secret-lives-of-apis-book-four-map-image-heat-maps", "abstract": "One of the things I like to do is highlight neat API features you may not yet know about. In this blog post, we'll once again be taking a closer look at the Map Image API. This API lives in the shadows of its bigger brothers, the interactive maps found in our Mobile and Web SDKs. However, it's both a powerful and lightweight API, which can be really useful in contexts where interactive maps don't make sense or simply cannot be used. Think of putting personalized maps into your customers’ emails or visualizing a response in an Alexa skill card! Like many of our APIs, the Map Image API also hides a few neat features you may not be aware of, so I've decided to write a series of short blog posts to bring these hidden features to light. Today we're going to look at how to display heat maps using the Map Image API. Let’s have a look at an example map. This maps shows both a circular heat area and a triangular heat area over Manhattan. It is generated using the following API call: https://image.maps.ls.hereapi.com/mia/1.6/heat\n&?apiKey=YOUR_API_KEY\n&a0=40.73735, -73.99262\n&rad0=1000\n&l0=0\n&a1=40.73735, -73.99262\n&rad1=700\n&l1=1\n&a2=40.73735, -73.99262\n&rad2=500\n&l2=3\n&a3=40.70142,-74.01537,40.72569,-74.01095,40.71489,-73.9761\n&l3=0\n&a4=40.70671,-74.01155,40.72209,-74.00657,40.71516,-73.98812\n&l4=1\n&a5=40.71029,-74.00808,40.71914,-74.00476,40.7142,-73.9961\n&l5=3\n&op=55\n&w=1200\n&h=700\n&f=0 Let’s look at the various parameters in detail. apiKey : This key is part of your application credentials. If you don’t have a set of credentials yet, go ahead and sign up for our Freemium account here on the portal. h / w : As you would probably guess, these are the dimensions (height/weight) of the image in pixels. f : This represents the image format. In this case, we’ve chosen PNG, though other formats like JPG (1) or SVG (5) are also available. Of course, none of these parameters are new to you if you’ve ever used to Map Image API before. It’s the rest of them that generate the heat maps which are of special interest to us. ax : These parameters define the heat areas. You can either use a single location with a latitude,longitude pair (see a0) or a polygon with a series of latitude,longitude pairs (see a3). radx : When using a single location you can indicate the size of the heat map around it by defining a radius with this parameter. lx : This allows you to select the color of each area you’ve created. If you don’t like the default colors, you can define your own using the plt parameter. op : This allows you to define the opacity of the heat areas from 0-100. As you’ll note this feature doesn’t really generate heat maps on the fly from data points, but merely simulates the look of a heat map. In essence you are drawing fuzzy areas on the map and then stacking them on top of each other. It's not the most sophisticated system, but it allows you to create some neat visualizations with a single API call! Check out the documentation for more details and feel free to play with some other parameters like noblur (guess what it does!) and sb (which allows your do add scale bars). See you soon, when we will uncover more API secrets!", "date": "2020-02-18"},
{"website": "Here", "title": "HERE Mapathon Winner: Helping Flood Prevention in Dar es Salaam", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-mapathon-the-winner", "abstract": "Welcome to third and final entry in our recap series covering the finalists of our Mapathon. If you haven't yet, be sure to read the first and second post covering the rest of our finalists. Today however we're going to cover the grand prize winner, OpenMap Development Tanzania. OpenMap Development Tanzania is a group of enthusiastic developers from Dar es Salaam, Tanzania. Located on the eastern coast of Africa, Dar es Salaam has a large majority of it's land in lowlands that are susceptible to flooding. While the city is going through many changes, flooding is a significant problem for it's citizens and economy. Another issue for the region is the growth of \"unplanned\" settlements. Over 70% of the population lives in such areas. These areas are especially in risk by flooding and are difficult to protect by city officials. The team gathered together three sets of data to help show what areas are most susceptible to flooding as a way to help city planners best address this problem in the future. All three sets of data were generated by the communities themselves, which really helps illustrate how important this is to the populace. The first set of data they used was a survey of 35,000 households concerning historical flooding. You can view this map here . The second set of data covered nearly 20,000 segments of water drainage, including details on the size of the drains and possible blockages. You can view this map here . The final set of data covered \"assets\" such as schools, landmarks, and other amenities to help point out what is, and what isn't, at risk. You can view this final map here : All in all, this was a truly remarkable project and absolutely deserving of a grand prize! You can read more about their project and watch the entire finale below!", "date": "2020-02-20"},
{"website": "Here", "title": "How we built an interactive map displaying the COVID-19 outbreak", "author": ["Richard Zimmermann"], "link": "https://developer.here.com/blog/how-we-built-an-interactive-map-displaying-the-covid-19-outbreak", "abstract": "Last week we released a map displaying the spread of COVID-19 over time . At a glance, the map provides an interactive overview of the latest situation, including the total number of confirmed cases, as well as deaths and recoveries. Furthermore, you can explore these numbers by country, and in the case of China — by province. In addition to the latest situation, users can also use the time slider to get a snapshot of the spread of the virus for any day since the 23rd of January 2020. You can explore each bubble on the map either by selecting it directly on the map (tap on mobile, hover on desktop), or by selecting the corresponding card in the sidebar. If you are looking for a specific city, you can also navigate using the autocomplete search box. Since phones are increasingly the dominant mode of consumption for web content, we put particular emphasis on the mobile experience. The mobile performance and usability of this app is perhaps its most useful feature. Data Working with live data from different data sources during an evolving virus outbreak meant that we had to adapt and be flexible regarding data collection and processing. It started with a public google spreadsheet maintained by the Center for Systems Science and Engineering CSSE at Johns Hopkins University JHU. That spreadsheet changed over time, with columns being added and removed, time formats changing and other complications arising. We settled on an initial workflow where we drew data from the google sheet and pushed that data into the HERE Data Hub. Eventually, JHU shut down the spreadsheet and moved their data to GitHub. This was a welcome move, since GitHub offered a much better environment for working with open data. Meanwhile the data reporting has stabilized with one update every 24h. The continued efforts of the team at JHU and others involved heavily on GitHub has made all of this possible. To provide more frequent data updates for the situation in China, we decided to source data directly from the DXY website every 60 minutes. This process is automated, and the data is merged with what is published by JHU about once a day and all of this is pushed to the HERE Data Hub to be consumed by our app. In addition to being the data backbone of the app the HERE Data Hub therefore also acts as a buffer. Products used Our COVID19 tracker app is built on the JAMStack using Gatsby and React. For the map itself we opted for Leaflet and Tangram, powered by the HERE Data Hub and HERE Vector Tile API . To allow users to search for specific places, we used the HERE Geolocation Autocomplete API . We also leveraged serverless technology to schedule scrapers, fetch the data, and push that data to the HERE Data Hub. All of these processes run separately and don't directly impact the app. The app itself is built once upon deployment, and is served as a static site, which means it can be hosted on any server that can host static HTML pages. Once it is loaded on the client side it becomes a dynamic React app that automatically re-fetches data from the HERE Data Hub. Data visualization method When designing maps you will always face certain trade-offs. Projections and scales are particularly important to consider. Apart from some experimental implementations and tricks that can be used in some situations, most mapping tools relying on map tiles today are still limited to the Mercator projection. The familiarity to users, level of detail, and performance these tools provide however are very useful when creating these kinds of exploratory maps. Our map displays data as scaled bubbles, indicating confirmed cases as absolute numbers, rather than normalized values in relation to the population of the place. With absolute counts, choropleth maps are generally not a good option. A choropleth map would have also made it difficult to display data from the Diamond Princess cruise ship, requiring a custom solution for that data point. We opted for a linear scale to show an accurate relationship of the absolute numbers on a global scale. There are also merits to using the logarithmic scale here, as it provides a way to show the differences between smaller bubbles. Right now for example, Italy and France show bubbles that very close in size, even though the former has 300 cases and the latter has 16 cases. At the same time, the global relationships are more accurately represented using the linear scale, which shows the extreme concentration of cases in China. It's always a trade-off. Logarithmic scales also tend to be more difficult to understand, and are likely to cause more confusion than linear ones. Especially early on during the outbreak maps using the logarithmic scale gave the impression that the virus was much wider spread than the data suggested. The linear scale is also the reason why there is such a disproportionate emphasis on the cases in Hubei. According to the data from JHU and DXY, as of the time of writing this article, Hubei province has 65,000 confirmed cases. Guangdong is the province with the second largest amount of cases at 1,300 . That is a factor of 1 50, and there are very few places that have more than 1,000 cases at the moment. We use a minimum size of the bubble to show cases, mainly because of usability, particularly on mobile devices. The most important thing to consider when choosing methods and making decisions on how to visualize data is that the projection, scales, and method you choose will always affect the story you are telling in one way or another.", "date": "2020-02-26"},
{"website": "Here", "title": "Avoiding Areas Using the HERE Routing API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/avoiding-areas-using-the-here-routing-api", "abstract": "Avoiding things is fun! For example, I love to avoid traffic jams, parties and personal responsibility. Some of these are harder to avoid than others, but fortunately our Routing API is here to help! It provides us with a whole range of options to calculate routes that avoid things. Things like specific roads, sketchy areas and bus rides. Don't avoid this new series of blog posts, where we will cover all of them. Today we will learn how to avoid areas! First, let’s look at a standard call to our Routing API (v7). https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_apiKey\n&mode=fastest;car\n&waypoint0=52.53086,13.38474\n&waypoint1=52.54417,13.39156 There’s not much to explain here. We have two waypoints, a routing mode (we’re asking for the fastest route by car) and an apiKey for authentication ( sign up for our Freemium plan to get 250.000 routing calls for free every month). If we display this route on a map, it looks like this. Note that you can check out this example in our Web SDK to see how to display a route on map. Conveniently, the JavaScript API uses the same routing parameters as the REST API. Have a look at this code snippet, which calls the Routing API in JS. function calculateRoute(platform) {\n  var router = platform.getRoutingService(),\n    routeRequestParams = {\n      mode: 'fastest;car',\n      waypoint0: '52.5160,13.3779', \n      waypoint1: '52.5185,13.4283'      \n    };\n\n  router.calculateRoute(\n    routeRequestParams,\n    onSuccess,\n    onError\n  );\n} To make sure that this route avoids a specific area, we can use the avoidareas parameter of the Routing API. We need to pass it a bounding box using two locations (top-left and bottom-right of the box). https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_apiKey\n&mode=fastest;car\n&waypoint0=52.530861,13.38474\n&waypoint1=52.54417,13.39156\n&avoidAreas=52.54226,13.39165;52.54135,13.39457 Let’s draw this area on the map and see if the new route takes a path around it. Note that if you want to draw the area on the map using our Web SDK, you can use a map object such as H.map.Rect as seen in this code snippet. function drawAreas(map) {    \n  var firstArea = new H.map.Rect(new H.geo.Rect(52.51856,13.39751,52.51602,13.40431));  \n  map.addObject(firstArea);  \n} Looks like avoiding things is pretty easy! Let’s avoid some more things and add another area to avoid. The Routing API supports avoiding up to 20 areas at once. To do so, we can simply add more bounding boxes and separate them with an exclamation mark. https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_apiKey\n&mode=fastest;car\n&waypoint0=52.530861,13.38474\n&waypoint1=52.54417,13.39156\n&avoidAreas=52.54226,13.39165;52.54135,13.39457!52.523,13.41447;52.52041,13.42069 One last time, let’s draw this on a map and see what happens. Success! Stay tuned for more posts on how to avoid things like highways and sharp turns. (No news yet on how to avoid personal responsibility, but I’ve filed a ticket with a feature request.)", "date": "2020-03-05"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.12 release", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.12-release", "abstract": "Highlights Connect devices directly to the Open Location Platform with the SDK for C++ and SDK for TypeScript Two open-source SDKs are available to connect devices directly to OLP: The SDK for C++ enables you to connect devices like smartphones, IoT robots and cars, facilitating read/write data access, authentication and error handling on connected devices. With this release you are able to use cached map data without connectivity. The SDK for TypeScript enables read access to data in OLP from your web applications and connected devices. This SDK release supports read access to Versioned, Volatile and Index layers. Both SDKs are open-source projects and can be found on GitHub here: C++ and here: TypeScript . More information about both SDKs can be found here: C++ and here: TypeScript . Access additional HERE Map Content - Navigation Attributes via the Optimized Map for Location Library The following navigation attributes from the HERE Map Content catalog are now available: Road Divider, Road Usage, Speed Category, Low Mobility, Local Road, Lane Count, Lane Category and Intersection Internal. We will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library. For more detail on the added attributes, please see: HERE Map Content- Navigation Attributes layer Generate API Key credentials directly in OLP The Platform Access Manager now enables you to create API Key credentials, the recommended credential type to use for web based applications. With this addition, you can generate both OAuth 2.0 token and API Key credentials for each unique APP ID. API Key credentials provide for simple and secure authentication of your application. Utilize the API Key credentials key-rotation feature to ensure continued security of your application over time. This is done by creating a second API Key for your application and deleting the original key when it is no longer required. You can use a maximum of two API Keys at once for each application. At this time, there are two Platform Location Services that support authentication with API Key credentials (this support is not yet available in China). Using these two examples, you can substitute the API Key credential generated in Platform Access Manager for the \"API_KEY_HERE\" placeholder text: Routing https://router.hereapi.com/v1/routes?apikey=API_KEY_HERE &destination=52.490613,13.418212&origin=52.535326,13.384566&return=polyline,actions,instructions,summary&transportMode=car Rendering - Vector Tiles https://vector.hereapi.com/v2/vectortiles/base/mc/11/1100/673/omv?apikey=API_KEY_HERE Support for additional Platform Location Services as well as support of those services in China will be announced at a later time. Changes, Additions and Known Issues SDK for Java and Scala Changed: Continued documentation improvements have been made for Java and Scala developers. With this release, the experience is further streamlined by merging this documentation with the tutorials. Detailed dependency information has also been added for the SDK as well as the Pipeline Environments. Changed: The Data Visualization Library has been renamed to Data Inspector Library to better align it with the naming of the Inspect tab of the Data section in the Portal UI. Also, this TypeScript-based Library is separated from the OLP SDK for Java and Scala. Java and Scala developers might use the Library for visual debugging of their pipeline apps - mostly though directly via the application in the Portal UI. At the same time, other audiences can create their customized Data Inspector app to allow users without Platform access to review Platform data through a hosted service. To read about more updates to the SDK for Java and Scala, please visit the HERE Open Location Platform Changelog . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Added: Three new layers of content have been added to the HERE Map Content catalog ( hrn:here:data::olp-here:rib-2 ); the layers include Postal Area Boundaries, Postal Code Points and Electric Vehicle Charging Stations. Fixed: Resolved an issue found post production release to support backward compatibility of Catalog version dependency HRN comparisons (used in version resolution). With the rollout of the new Catalog HRN format including OrgID (i.e. realm) in OLP 2.9, the Catalog dependency version resolution function would not successfully find compatible versions when the dependencies contain a mix of Catalog HRNs using old and new HRN formats. To address this issue, the following changes were made globally after the OLP 2.10 release: Metadata API (in \"Gets catalog versions\" in https://developer.here.com/olp/documentation/data-api/api-reference-metadata.html ) will return dependency HRNs in old and new formats at the same time for all historical and newly committed Catalog versions. Deprecated: Catalog HRNs without OrgID will no longer be supported in any way after July 31, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after July 31, 2020 , Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before July 31, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after July 31, 2020 . Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will currently not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported. Pipelines Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. Deprecated: The Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment. See the Migration section in the Pipelines Developer Guide . Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. SDK for Python Added: You can now use the SDK for Java and Scala with Jupyter notebooks on AWS EMR environments. Added: The spark-ds-connector has been replaced with the latest SDK for Java and Scala Spark Connector. This supports both read and write capabilities using Scala within Jupyter notebooks. Sample notebooks have been updated with this latest Spark Connector. Deprecated: The spark-ds-connector has been deprecated. Please upgrade to the latest SDK for Python version which includes the latest SDK for Java and Scala Spark Connector and updated sample notebooks. Instructions for how to upgrade are in the Update to Latest SDK section of the SDK for Python Setup Guide . Summary of active deprecation notices across all components", "date": "2020-02-27"},
{"website": "Here", "title": "Migrating from Google Static Maps", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/migrating-from-google-static-maps", "abstract": "Users of Google Static Maps may be interested in trying out our static map solution, the HERE Map Image API . Both services support a similar idea, creating static map images that can be used on the web, email, and other devices. In this post I'll give a bit of background on both and then give comparative examples of how to build the same solution in both products. Getting Started As this guide is primarily about moving from Google's service, I want to start off with a quick overview of how a developer would get started with both solutions. For Google's Static Map API, you can begin at the Overview . You will be required to have an account with Google and a project setup in order to create a key to use with your requests. For pricing (as of January 2020), you pay 0.002 cents per use up to 100,000 calls per month. However Google has a 200 dollar monthly credit for qualifying accounts. You can get more details on their pricing page. For HERE's Map Image API, you can start learning more at our Introduction page. You will need an account but will not need to provide a credit card to use the API. As of January 2020, our pricing information specifies a free tier allowing for 250,000 calls per month. Comparing that to Google, your cost would be $300 after the $200 dollar monthly credit is applied. Feature Overview Roughly speaking, here's a feature breakdown between the two platforms. Let's start with what both platforms share in common. The ability to specify a map's location based on latitude and longitude. The ability to specify image size, zoom level and image file type. The ability to pass a text version of an address. The ability to use different map types (default, satellite, etc). The ability to add markers. In terms of features that the HERE Map Image API has that Google does not: The ability to show routing information. Google's API can draw straight lines from one point to another, but not \"routes\" (ie how a person would actually drive/walk/etc from one point to another). The ability to show numerical information on the map via heatmap style graphics and simple bar charts. The ability to draw \"regions\" on a map with customized styling. The ability to get road sign images and company logos. \"Hello World\" with Map Images Here's an example of the simplest possible map for both platforms. Given a location of 30.22,-92.02, how would you construct maps for both products? Here's the Google URL: https://maps.googleapis.com/maps/api/staticmap?center=30.22,-92.02&zoom=12&size=400x400&key=MYKEY I specified the center, zoom, and size attributes. Technically zoom wasn't required but it defaults to the planet which is not very helpful. Here's the result: Here's the URL with HERE's Map Image API: https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=MYKEY&c=30.22,-92.02 The center point is passed via the c attribute. Height, width, and zoom can be left out and defaults are used. Here's the result: To make it closer to Google's version, you can add values for height, width, zoom, and format: https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=MYKEY&c=30.22,-92.02&w=400&h=400&z=12&f=0 Which results in: So to boil it down, you would make the following changes: Change size=widthXheight to two parameters, w and h Change the center=lat,lon parameter to c=lat,lon Use the format attribute (f) to specify 0 for PNG values. (Our default, 1, returns JPGs.) Some Examples Now that you've seen a basic example, let's look at a few examples that cover some real world scenarios. We just demonstrated how to center a map based on a longitude and latitude pair of values. How about placing markers? Let's consider three markers at positions: 30.19,-91.98 30.17,-92.03 30.21,-92.03 For each marker we will label them A, B and C and use a red color. For Google, markers can be defined a few different ways depending on whether or not you need marker-specific styles. While our style is consistent for each marker (just use the color red), the label changes for each which means we can't go with one style declaration for all. Instead I specify one markers attribute for all three markers. Here is how the URL looks with line breaks for added readability. https://maps.googleapis.com/maps/api/staticmap? center=30.22,-92.02&zoom=12&size=400x400 &markers=color:red%7Clabel:A%7C30.19,-91.98 &markers=color:red%7Clabel:B%7C30.17,-92.03 &markers=color:red%7Clabel:C%7C30.21,-92.03 &key=MYKEY In the URL above, %7C is the URL encoded version of the pipe character. Each marker defines a color, label, and position as the last character. Here's the result: HERE Map Images also support \"per\" marker styles but we can specify an attribute, poitxs, to signify automatic labeling based on letters. The default value, 0, would output numbers (1, 2, 3 and so on). Specifying 1 means to use letters (A, B, C and so on). We can also specify the color once using poifc. Here's the final URL: https://image.maps.ls.hereapi.com/mia/1.6/mapview?apiKey=MYKEY &c=30.22,-92.02&w=400&h=400&z=12&f=0 &poi=30.19,-91.98,30.17,-92.03,30.21,-92.03 &poilbl=1&poitxs=18&poifc=ff0000 Notice that markers are defined by the poi attribute in a list where the first element is the first latitude and the second element is the first longitude. This continues in pairs such that the third item is the second latitude and the fifth item is the third. Finally, I specified poitxs=18 to set a size that is a bit closer to the Google version. The default is a bit smaller. Now let's consider another example - presenting a map based on a text-based address. For Google, this is done by replacing the latitude and longitude values in the center attribute with an address. For example: https://maps.googleapis.com/maps/api/staticmap? center=200%20Terminal%20Dr,%20Lafayette,%20LA%2070508 &zoom=12&size=400x400 &key=MYKEY For HERE, you have to be slightly more specific and specific attributes for the search. The more you specify, the more precise. Here's the same search using HERE's API: https :// image.maps.ls.hereapi.com/mia/1.6/mapview? apiKey=MYKEY &n=200 &s=Terminal%20Dr &ci=Lafayette &zi=70508 &w=400&h=400&z=12 In the example above, n stands for the street number, s the street, ci the city and zi the zip code. If you don't have your address information ready to send like this, you can use our Geocoder API to convert the address. (And I've already filed a ticket internally to expose this option to the Map Image API!) Routing with the Map Image API As a final example, let's look at something you can't do with the Google Maps API, rendering a route. While there's multiple options you can use (see the routing API docs for more information), the simplest version is to pass in the beginning and ending locations via waypoint attributes. So for example: https://image.maps.ls.hereapi.com/mia/1.6/routing ?apiKey=MYKEY &w=400 &h=400 &f=0 &waypoint0=30.22,-92.02 &waypoint1=34.22,-91.02 waypoint0 represents the first location and waypoint1 represents the final one. You can provide more waypoints and the service will route from one to another. Here's how it looks. Again, remember that this is the simplest example with no customization of styles. Learn More I hope this helps you understand the power of our Map Image API. You should also check out the Guide and the full set of interactive examples .", "date": "2020-02-27"},
{"website": "Here", "title": "HERE Studio and Maps API for JavaScript", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-xyz-and-maps-api-for-javascript", "abstract": "A few months ago we released support for working with HERE Studio and our client-side JavaScript maps library. While it was previously possible to view your HERE Studio data in any form you desired, we wanted to make it even easier for folks using our mapping library to load in HERE Studio features. In this post I'm going to share two simple examples of how this can be done in your own projects. For my testing, I'm using a large Studio space with a few hundred features based on the American National Park system. You can see a Studio version of the data right here. Alright, so let's get started. I'm going to begin with a map centered on America with no other data. <!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Test XYZ</title>\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n    <style>\n      #mapContainer {\n\t\twidth: 750px;\n\t\theight: 700px;\n      }\n    </style>\n  </head>\n  <body>\n    <div id=\"mapContainer\"></div>\n\n    <script>\n\tconst KEY = \"c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw\";\n\tvar platform = new H.service.Platform({\n\t\tapikey: KEY\n\t});\n\n\t// Obtain the default map types from the platform object:\n\tvar defaultLayers = platform.createDefaultLayers();\n\n\tvar map = new H.Map(\n\t\tdocument.getElementById('mapContainer'),\n\t\tdefaultLayers.vector.normal.map,\n\t\t{\n\t\t\tzoom: 3,\n\t\t\tcenter: { lat: 38.7984, lng: -96.3944 },\n\t\t\tpixelRatio: window.devicePixelRatio || 1\n\t\t}\n\t);\n\n\tvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n\t// Create the default UI:\n\tvar ui = H.ui.UI.createDefault(map, defaultLayers);\n\n\t</script>\n  </body>\n</html> Taking it from the top, we begin by loading in libraries for core MapJS functionality as well as events, services, and UI support. A map is created centered on, roughly, the middle of America, and default UI and behavior is added. This is how we get things like click to pan and mouse wheel zooming. I'll be sharing links to all of the code at the end, but for now you can test this here: https://cfjedimaster.github.io/heredemos/mapsjs/test0_xyz.html Alright, now let's start adding in our HERE Studio data. I began by using our docs ( Display an HERE Studio space on the Map ) and then added this code: const XYZ_TOKEN = 'AFJj375eSbmD0w3reC4aGQA';\nconst service = platform.getXYZService({\n\ttoken: XYZ_TOKEN,\n});\n\nconst XYZ_SPACE = '73KBVoD8';\nconst mySpaceProvider = new H.service.xyz.Provider(service, XYZ_SPACE, {\n});\n\nconst mySpaceLayer = new H.map.layer.TileLayer(mySpaceProvider);\n// add a layer to the map\nmap.addLayer(mySpaceLayer); The token above was generated using our online token tool and set to allow read only access for my space.  I then define a new \"XYZService\", specify my space, and create the provider and layer. Finally, I just add it to my map. You can see the result of this here: https://cfjedimaster.github.io/heredemos/mapsjs/test1_xyz.html This nicely shows my data, but doesn't actually tell me what the data represents! For that, let's modify the code to add a click event. Whenever the user clicks on a feature we'll display a bubble showing all of the feature data. For this update I want to thank my coworker Mujammil Ansari. Here's the modification. mySpaceProvider.getStyle().setInteractive(['xyz'], true);\n\nlet bubble;\n// Add 'tap' event listener, that opens info bubble\nmySpaceProvider.addEventListener('tap', function (evt) {\n\tlet position = map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY),\n\t\tdata = evt.target.getData(),\n\t\trows = Object.keys(data.properties)\n\t\t.map((key) => `${key}:${data.properties[key]}`);\n\n\tif (!bubble) {\n\t\tbubble = new H.ui.InfoBubble(position, { content: '' })\n\t\tui.addBubble(bubble);\n\t}\n\tbubble.setContent(`\n\t<div style=\"max-height:300px; overflow:auto\">\n\t<table id=\"bubbleInfo\" style=\"font-size:10px\">\n\t${rows.join('')}\n\t</table>\n\t</div>`);\n\n\tbubble.setPosition(position);\n\tbubble.open();\n\n\tmap.setCenter(position, true);\t\n}); The modification begins by adding interactivity to the Studio information on the map. Then it adds a tap handler. The tap handler handles defining a bubble as well as an HTML block that gets all of the properties from the feature. Finally this bubble is opened and centered on the map. The result may be a bit different you expect: As you can see, your features include properties that HERE Studio adds itself as part of it's data management process. Before we discuss how to fix this, you can view this version here: https://cfjedimaster.github.io/heredemos/mapsjs/test2_xyz.html Alright, so how do we make the card a bit nicer? One way would be to write code to hide properties like \"id\" and any that include \"@ns:com.here.xyz\". While that would work, we still wouldn't have control over the HTML. Since we actually know our data and know it includes a Code and Name value, we can hard code the bubble and make it a bit nicer: mySpaceProvider.addEventListener('tap', function (evt) {\n\tlet position = map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY),\n\t\tdata = evt.target.getData();\n\t\t\t\t\n\tif (!bubble) {\n\t\tbubble = new H.ui.InfoBubble(position, { content: '' })\n\t\tui.addBubble(bubble);\n\t}\n\tbubble.setContent(`\n\t<div style=\"max-height:300px; overflow:auto;width: 300px;\">\n\t<h2>${data.properties['properties.Name']}</h2>\n\tCode: ${data.properties['properties.Code']}\n\t</div>`);\n\n\tbubble.setPosition(position);\n\tbubble.open();\n\n\tmap.setCenter(position, true);\t\n}); The change here is primarily to the content of the bubble. I've set a width and hard coded it to assume properties.Name and Code. The result is a bit nicer: You can test this version here: https://cfjedimaster.github.io/heredemos/mapsjs/test3_xyz.html If you want to play with the code for these demos, you can find them (along with other simple demos) at my repository here: https://github.com/cfjedimaster/heredemos", "date": "2020-03-06"},
{"website": "Here", "title": "Create Your Own Geocode Serverless Application - on the JAMStack", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/create-your-own-geocode-serverless-application-on-the-jamstack", "abstract": "As developers in our industry know, we love coming up with new names for things. The \"JAMStack\" is the latest in this trend. JAMStack refers to static web sites that make use of JavaScript and serverless technology to be dynamic. So a static site... that isn't. JAM stands for JavaScript, APIs, and Markup. A typical JAMStack site will use JavaScript on the client to enable interactivity and use APIs to interact with services providing data and other features. Markup typically refers to markdown. Most JAMStack sites will use a static site generator that will take markdown files and output HTML. That's not required though - you can write simple HTML or generate a single page application with a front-end framework like Vue.js. Let's look at an example of using HERE APIs on a simple JAMStack site. Let's start off by taking a look at the result. I built a simple one page application that lets you input a starting and ending location. Once you do that, the application will give you a route between both points. For a little extra information, it also reports on the weather in both locations. It may be stormy where you are now but beautiful where you're ending up. I used the following aspects in my demo: HTML - ok, that's obvious - but I point this out to say that due to the small size of the demo, I didn't bother with a static site generator. Vue.js - To handle the interactivity of the demo I used a bit of Vue.js. I didn't create a SPA, it's just  a simple script tag, but Vue works great for simple progressive enhancement of HTML pages. Serverless functions - Instead of directly accessing HERE APIs via JavaScript in the browser, I set up two serverless end points that proxy the calls to HERE. This lets me hide my API key and massage that data a bit as well. Finally, I deployed my site on Netlify . There's multiple places you can host a JAMStack site, but Netlify is my favorite. When I'm not using Netlify, I also use Zeit . You can read more about the JAMStack at https://jamstack.org. You can play with my demo here: https://netlifyhere.netlify.com/ . The source code everything I'm sharing my be found here: https://github.com/cfjedimaster/netlifyhere . Alright, with that long preamble out of the way, let's talk about the app! First, I'll discuss the HTML and JavaScript of the front end. The HTML portion handles loading my CSS, JavaScript, and handles the dynamic layout that Vue's going to enhance and make awesome. <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t<title>Netlify HERE</title>\n\t<link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n\n\t<div id=\"app\">\n\t\t<h2>Netlify HERE Demo</h2>\n\t\t<p>\n\t\t\tThis app demonstrates using HERE services via serverless functions hosted on a static site. Enter a starting\n\t\t\tdestination and final destination in the fields below. The app will then find the weather at both locations\n\t\t\tas well as determine a route between them.\n\t\t</p>\n\n\t\t<form>\n\t\t\t<p>\n\t\t\t<label for=\"start\">Starting Location:</label>\n\t\t\t<input type=\"text\" v-model=\"start\" id=\"start\">\n\t\t\t</p>\n\n\t\t\t<p>\n\t\t\t<label for=\"end\">End Location:</label>\n\t\t\t<input type=\"text\" v-model=\"end\" id=\"end\">\n\t\t\t</p>\n\t\t\t\t\n\t\t\t<p>\n\t\t\t\t<button @click.prevent=\"generateData\">Get Weather and Route</button>\n\t\t\t</p>\n\t\t</form>\n\n\t\t<div v-if=\"loading\">\n\t\t\t<p><i>I'm gathering your data now, please stand by!</i></p>\n\t\t</div><div v-else-if=\"hasResult\">\n\t\t\t<h2>Results</h2>\n\t\t\t<p>\n\t\t\t\tThe weather at your starting location is <b>{{ weatherStart.description }}</b> \n\t\t\t\twith a low of {{ weatherStart.lowTemperature }} and a high of {{ weatherStart.highTemperature }}.\n\t\t\t</p>\n\t\t\t<p>\n\t\t\t\tThe weather at your destination is <b>{{ weatherEnd.description }}</b> \n\t\t\t\twith a low of {{ weatherEnd.lowTemperature }} and a high of {{ weatherEnd.highTemperature }}.\n\t\t\t</p>\n\t\t\t<p>\n\n\t\t\t\tYour route will take {{ summary.duration | formatSeconds }} and cover {{ summary.length | formatDistance }}:\n\n\t\t\t\t<ul>\n\t\t\t\t\t<li v-for=\"step in steps\">{{step.instruction}}</li>\n\t\t\t\t</ul>\n\t\t\t</p>\n\t\t</div>\n\n\t</div>\n\t\n\t<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n\t<script src=\"app.js\"></script>\n</body>\n</html> The first part of the layout handles prompting for the starting and end location. The next part handles displaying the results. I print out a weather report for both locations and then return the steps of the route between them (along with a quick summary). For folks new to Vue, the tokens you see in the HTML end up being replaced by real data. The v-if and v-for directives get executed as you imagine they would. Now let's look at the JavaScript in the Vue application. // Summarize to hours or seconds, it's rough but ok\nVue.filter('formatSeconds', s => {\n\tlet hours = Math.floor(s/(60*60));\n\tif(hours > 2) return hours + ' hours';\n\tlet minutes = Math.floor(s/60);\n\treturn minutes + ' minutes';\n});\n\n// Always meters, switch to miles\nVue.filter('formatDistance', s => {\n\treturn Math.floor(s/1609) + ' miles';\n});\n\n\nconst app = new Vue({\n\tel:'#app',\n\tdata: {\n\t\tstart:'Lafayette, LA',\n\t\tend: 'Chicago, IL',\n\t\tweatherStart:'',\n\t\tweatherEnd:'',\n\t\tsteps:[],\n\t\tsummary:null,\n\t\tloading:false,\n\t\thasResult:false\n\t},\n\tmethods: {\n\t\tasync generateData() {\n\t\t\tthis.hasResult = false;\n\t\t\tthis.loading = true;\n\t\t\tconsole.log('running generateData, values are '+this.start+' and '+this.end);\n\t\t\tthis.weatherStart = await getWeather(this.start);\n\t\t\tthis.weatherEnd = await getWeather(this.end);\n\t\t\tlet route = await getRoute(this.start, this.end);\n\t\t\tthis.steps = route.actions;\n\t\t\tthis.summary = route.summary;\n\t\t\tthis.loading = false;\n\t\t\tthis.hasResult = true;\n\t\t}\n\t}\n});\n\nasync function getRoute(x,y) {\n\tlet resp = await fetch(`/.netlify/functions/getRoute?start=${x}&end=${y}`);\n\tlet data = await resp.json();\n\treturn data;\n}\n\nasync function getWeather(location) {\n\tlet resp = await fetch(`/.netlify/functions/getWeather?location=${location}`);\n\tlet data = await resp.json();\n\treturn data;\n} My application begins with two formatting functions that help make data in the front end a bit more readable. After that, the real meat of the application begins. I set up my data (with some defaults to save me from having to type while I tested) and then define the function that's called when the user hits the submit button back in the HTML. generateData fires off HTTP calls to my two serverless end points. First to get the weather and then to get the route. Once done it saves those values. And that's it. Basically my code is just handling formatting and user interaction. The real stuff is over on the serverless side. Netlify added it's serverless support back at the beginning of 2019. It uses Amazon Lambda behind the scenes but hides the complexity of Lambda behind a much easier to use system. Developers can write simple JavaScript (or Go) functions and Netlify handles creating a URL for them. A simple Netlify function may look like this: exports.handler = async (event, context) => {\n  const name = event.queryStringParameters.name || \"World\";\n\n  return {\n    statusCode: 200,\n    body: `Hello, ${name}`\n  };\n}; Given that this is named \"helloWorld.js\", Netlify would make it accessible on your site as yourdomain.com/.netlify/functions/helloWorld. Again, this is just a front-end to Amazon Lambda, but it's significantly simpler to use than Amazon. Plus, you can include your serverless functions along with the rest of your site in the same repository. Another useful aspect of Netlify Functions is that they allow you to define environment variables and then make use of them in your code. This is how I can share my code on a public GitHub repository - I simply address the environment variable for my keys instead of directly accessing them. Let's take a look at the first serverless function, getWeather. /* eslint-disable */\nconst fetch = require('node-fetch');\n\nconst HERE_APP_CODE = process.env.HERE_APP_CODE;\nconst HERE_APP_ID = process.env.HERE_APP_ID;\n\nexports.handler = async function(event, context, cb) {\n\n  let location = event.queryStringParameters.location;\n  if(!location) {\n    return {\n      statusCode:500,\n      body:'Must define location'\n    }\n  }\n\n  let url = `https://weather.cc.api.here.com/weather/1.0/report.json?app_code=${HERE_APP_CODE}&app_id=${HERE_APP_ID}&product=observation&name=${encodeURIComponent(location)}&metric=no`;\n\n  let response = await fetch(url);\n  let data = await response.json();\n\n  // filter it down a bit\n  let result = data.observations.location[0].observation[0];\n  // high and low temps are to the hundreds, no one cares about that\n  result.lowTemperature = Math.floor(result.lowTemperature);\n  result.highTemperature = Math.floor(result.highTemperature);\n  \n  return {\n    headers: {\n      'Content-Type':'application/json'\n    },\n    statusCode: 200,\n    body: JSON.stringify(result)\n  };\n\n} The function begins by checking to ensure that a location query parameter was sent, if not, an immediate error is returned. Next it creates a URL that hits the HERE Weather API . Once the API is hit, I then manipulate the results a bit to make it simpler for the front end. I also notice that temperatures were reported to the hundreds place, so for example, not just 78 degrees but 78.02. Since most humans can't tell the difference I just simplified those values. Here's an example result of calling this function. {\n\t\"daylight\": \"D\",\n\t\"description\": \"Light rain. Mostly cloudy. Mild.\",\n\t\"skyInfo\": \"16\",\n\t\"skyDescription\": \"Mostly cloudy\",\n\t\"temperature\": \"75.00\",\n\t\"temperatureDesc\": \"Mild\",\n\t\"comfort\": \"74.97\",\n\t\"highTemperature\": 74,\n\t\"lowTemperature\": 60,\n\t\"humidity\": \"85\",\n\t\"dewPoint\": \"70.00\",\n\t\"precipitation1H\": \"0.00\",\n\t\"precipitation3H\": \"*\",\n\t\"precipitation6H\": \"*\",\n\t\"precipitation12H\": \"*\",\n\t\"precipitation24H\": \"*\",\n\t\"precipitationDesc\": \"Light rain\",\n\t\"airInfo\": \"*\",\n\t\"airDescription\": \"\",\n\t\"windSpeed\": \"12.64\",\n\t\"windDirection\": \"180\",\n\t\"windDesc\": \"South\",\n\t\"windDescShort\": \"S\",\n\t\"barometerPressure\": \"29.77\",\n\t\"barometerTrend\": \"\",\n\t\"visibility\": \"7.00\",\n\t\"snowCover\": \"*\",\n\t\"icon\": \"18\",\n\t\"iconName\": \"sprinkles\",\n\t\"iconLink\": \"https://weather.cc.api.here.com/static/weather/icon/27.png\",\n\t\"ageMinutes\": \"69\",\n\t\"activeAlerts\": \"26\",\n\t\"country\": \"United States\",\n\t\"state\": \"Louisiana\",\n\t\"city\": \"Lafayette\",\n\t\"latitude\": 30.2241,\n\t\"longitude\": -92.0198,\n\t\"distance\": 2.32,\n\t\"elevation\": 11,\n\t\"utcTime\": \"2020-03-04T12:53:00.000-06:00\"\n} You'll notice there's a lot of information here I don't use. I could further optimize my application by having the serverless function only return exactly what my Vue code is using. That would make things a bit quicker for the user as well. Now let's take at the routing aspect. This one's a bit more complex because we have to use two APIs. The Routing API requires a precise location in longitude and latitude. We can't expect our users to know those values. So to make it work for them entering text-based locations we make use of the Geocoding API as well. Let's take a look at that function. /* eslint-disable */\nconst fetch = require('node-fetch')\n\nconst HERE_API_KEY = process.env.HERE_API_KEY;\n\n\nexports.handler = async function(event, context) {\n\n  let location1 = event.queryStringParameters.start;\n  let location2 = event.queryStringParameters.end;\n  if(!location1 || !location2) {\n    return {\n      statusCode:500,\n      body: 'Must pass start and end parameters.'\n    }\n  }\n\n  let location1Position = await getLocation(location1);\n  let location2Position = await getLocation(location2);\n  let route = await getRoute(location1Position.lat+','+location1Position.lng, location2Position.lat+','+location2Position.lng );\n\n  let data = route.sections[0];\n  delete data.polyline;\n\n  return {\n    headers: {\n      'Content-Type':'application/json'\n    },\n    statusCode: 200,\n    body: JSON.stringify(data)\n  }\n}\n\nasync function getLocation(x) {\n   let url = `https://geocode.search.hereapi.com/v1/geocode?q=${encodeURIComponent(x)}&apikey=${HERE_API_KEY}`;\n   let response = await fetch(url);\n   let data = await response.json();\n   // assume first result\n   return data.items[0].position;\n}\n\nasync function getRoute(x, y) {\n  let url = `https://router.hereapi.com/v8/routes?transportMode=car&origin=${x}&destination=${y}&units=imperial&return=summary,actions,instructions,polyline&apikey=${HERE_API_KEY}`;\nconsole.log(url);\n  let response = await fetch(url);\n  let data = await response.json();\n  return data.routes[0];\n\n} As with the previous function, I begin with some simple validation. This one takes two arguments representing the beginning and end of the route. I first geocode the locations to translate the free form inputs into a longitude and latitude. Then I simply use the routing API using the new values. As before, I do a bit of manipulation on the result to make it simpler for the front end code to use. And that's it! As a reminder, you can test this out yourself here and see the code on my repository .", "date": "2020-03-09"},
{"website": "Here", "title": "February 2020 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/january-2020-release-notes-0-0", "abstract": "Welcome to the latest announcements for the HERE Location Services. This post covers the D114 release of HERE Location Services. This release includes updates of: HERE Geocoding and Search, Routing API, Vector Tiles API, Public Transit API, Intermodal Routing API,  Maps API for JavaScript, Geocoder API, Geocoder Autocomplete API, Fleet Telematics API, HERE SDK for Android and iOS, Map Data for Mobile SDK and HERE Mobile SDK UI Kit. The release highlights are: Launch of HERE Location Services on Platform on HERE developer portal. Launch of the first HERE Location Services on Platform in Japan Fleet Telematics API extends Toll Cost support to Australia, adds new features related to custom geometry layers and other enhancements. Release of the new HERE SDK 4.2.1.0 Lite and Explorer Editions. You will find all API documentation on the Developer Portal . For more detailed information about the major improvements of the HERE Location Services, see the sections below: HERE Location Services on Platform The following HERE Location Services on Platform are available on the developer.here.com: Geocoding and Search v7 , Routing API v8 , Vector Tiles API v2 , Public Transit v4 and Intermodal Routing v2 . HERE Location Services coming to Japan. Already available Geocoding & Search, Routing and Vector Tile Service. HERE Geocoding and Search ( Version 7) We are pleased to state that with this release, HERE Geocoding and Search is Generally Available on both the HERE Platform and developer.here.com and provides coverage across most parts of the world, with the exception of China and South Korea. Japan is currently available only to those customers licensed to HERE Platform Workspace. HERE Geocoding and Search provides the following capabilities and benefits: Increased POI coverage Daily high-priority data updates Capabilities to add your own data sets to your search-based application (available only to those customers licensed to HERE Platform Workspace) Places Geocoding: The Geocode endpoint now recognizes and utilizes POI names to increase precision. For a complete list of features, see the Developer's Guide . Routing API ( Version 8.1.0) Added duration and baseDuration to vehicle span in response. Added baseDuration to the vehicle summary in response. Added exclude request parameter supporting excluding coutries. Extended the documentation of error codes returned by the service. The Routing API is an HTTP JSON REST API that offers easy and fast route calculation between two or more locations for several regions in the world. For a list of features, see the Developer's Guide . Vector Tiles API ( Version 2.0.0) The HERE Vector Tile Service allows you to request tiles containing vector data using content from the HERE Platform. This is an initial release. For a list of features, see the Developer's Guide . Public Transit API ( Version 4.0.0) Public Transit offers three REST APIs that allows you to use agency data, external services and data collected by HERE to discover public transit options, request public transit routes and transit-related information. This is an initial release. For a list of features, see the Developer's Guide . Intermodal Routing API ( Version 2.0.0) Public Transit offers three REST APIs that allows you to use agency data, external services and data collected by HERE to discover public transit options, request public transit routes and transit-related information. This is an initial release. For a list of features, see the Developer's Guide . Maps API for JavaScript ( Version 3.1.12.0) The display of the map features: borough, district, village, hamlet and neighborhood was improved in order to increase label density. We added the Japan-specific map style (applicable for the core layer of the Vector Tiles API). H.Map#getObjectsWithin allows to request the objects (polygons, polylines, markers) within the designated map area. Fleet Telematics API ( Version 3.0.28) Toll Cost for Australia Environmental Zones with License Plate regulations License plate registration ids are taken into account. On certain days only even/odd numbers are allowed (e.g. in Jakarta), or on certain weekdays only numbers ending with 1,2 are allowed (e.g. in Mexico-City). Usage preference for private roads Arrival time routing together with toll cost calculation/optimization Custom roads overlay uploads tolerating & reporting errors. It will still allow to upload a working part of the changes. The failing change operations are reported in the \"issues\" section of the response. HERE SDK for Android and iOS (Lite Edition) ( Version 4.2.1.0) Lite Variant for very low-end devices, with Tangram rendering Added functionality to orbit the camera around a specified point. Added functionality to zoom the camera around a specified point relative to the given factor. Added Authentication API to obtain a valid token that can be used to initiate queries to HERE REST APIs. HERE SDK for Android and iOS (Explore Edition) (V ersion 4.2.1.0) Explore Variant with HARP rendering, supported by the HARP customization tool Added new functionalities related to camera states and camera observers (to get camera callbacks). Added functionality to update a polyline shape Added Authentication API to obtain a valid token that can be used to initiate queries to HERE REST APIs. HERE Mobile SDK User Interface (UI) kit ( Version 2.1. 4) This is a HERE SDK 3.1 4 integration release. Major changes and features: Android Tested with the HERE SDK 3.14 release Fixed minor issues Upgrade to Gradle 6.0 Added RoutingError param in BaseGuidancePresenter handleRerouteFailed() because of changes in HERE SDK 3.14 Updated project dependencies iOS Integrated the HERE SDK 3.14 release Updated deployment target to iOS 12 Fixed minor issues See also : https://github.com/heremaps/msdkui-android/releases https://github.com/heremaps/msdkui-ios/releases https://cocoapods.org/pods/HEREMapsUI The following services had new releases with minor changes: Geocoder API (Version 6.2.201) Geocoder Autocomplete API (Version 6.2.201) Map Data for Mobile SDK (Version 8.30.105.154, February 2020)", "date": "2020-03-11"},
{"website": "Here", "title": "Self-hosted HERE Location Services Now Available On The Microsoft Azure Marketplace", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-self-hosted-azure-marketplace-location-services-maps", "abstract": "Last year we committed to better serving our community on the Microsoft Azure Cloud . We started by offering access to HERE Location Service s directly from the Azure Marketplace (SaaS) as serverless functions. Today w e are proud to announce we are taking our commitment further by offering an additional set of HERE Location Services available as a Virtual Machine (VM) deployment in a high-availability architecture managed in the customer tenant . Routing, Geocoding, Map Tiles APIs are available in this environment as the core tools of location technology Routing – provides access to and use of global, real-time and historical traffic information. Forward Geocoder and Reverse Geocoder – provides comprehensive coverage in 196 countries and several territories with a high-precision mapping of geo-coordinates or addresses. Map Tiles – shows fresh day-time map tiles in multiple styles (e.g. base, aerial) including rendered live-traffic tiles for flow overlay. Self- h osted Virtual Machine deployments offer the security and speed of on-premise hosting without the physical need for IT infrastructure and on-site support. As digital transformation moves from the private to the public sector, we are seeing a strong demand for a s elf- h osted Virtual Machine environment. These APIs provide everyone on the Microsoft Azure Marketplac e an opportunit y to be innovative and creative while at the same time ensuring high performance and advanced security protection. These core APIs are used to support location technology solutions across a number of different markets. Fleet management and emergency services: Create safe and efficient routing solutions for multiple vehicle types Provide the most efficient routing options based on real-time traffic conditions Mobility: Provide routing options for pedestrians and public transportation Help your city run more smoothly with improved traffic flow and transportation network usage Business Intelligence: Understand trends and behavior of citizens in relation to their location and mobility patterns Understand shifting market dynamics to inform real-estate investments Verify insurance claims and authenticate transactions To get started, visit the Microsoft Azure Marketplace and for the latest Azure developer content go here.", "date": "2020-03-10"},
{"website": "Here", "title": "Geocoding a Location Using Python and Flask", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/understanding-geocoding-with-python", "abstract": "I have always wondered how an application is able to show a particular address on a map. You provide an address and in return, get a beautiful looking map. For instance, all of us have used ride-sharing applications. These ask you for a destination, you type an address and it's location is immediately highlighted on a map. There are many examples of this, ranging from food and package delivery to safety and health management. If yo think about, it's remarkable how often we use this particular feature in our everyday lives. Lets see how it works by creating our own search application with the help of Python and few HERE APIs. I would suggest you to check my previous blog on how to start with a Map using Python. Prerequisites Your machine should have Python installed (I have Python 3.8) and if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you signed up, you can generate your free API key and get 250.000 free transactions every month. Getting the Geocoder API The fascinating feature of an application, where it takes an address from you and shows it on a map is handled by Geocoder API . This API finds you the geo-coordinates of a known address, place, locality or administrative area, even if the query is incomplete or partly incorrect. After we've create our API Key, we have to acquire Geocoder API. This API will convert our text (e.g. a city name) to a geo-coordinate (latitude and longitude). The API is RESTful one, and returns a JSON, containing detailed information about the location that we searched. The basic API call looks like this. https://geocode.search.hereapi.com/v1/geocode?apikey=YOUR_API_KEY&q=ADDRESS_TO_SEARCH Here the apikey is part of the credentials you generated when signing up for your Freemium account and the value of q is a query string for the location you want to geocode. We are going to parse the JSON response using Python to acquire the latitude and longitude of a searched location. Working with Python Part of what makes Python so powerful is the huge collection of available libraries. We need to import one Python library here, requests , to handle GET requests and their response. Install the library with ' pip install requests ' using Python IDE (PyCharm, Spyder, etc) or terminal/command prompt depending on how you are working on Python (I am using the command prompt), and then import it in the code. In the above code, we are asking user to enter a location (a city) and parsing the JSON to get latitude and longitude of that location (location is acquired by user). To see the values, you add print (latitude) and print (longitude) at the end of the code. Introducing Flask Now, we have latitude and longitude of a place. Next, we have to show it in a HERE map on a browser. This can be done easily with the help of flask. Flask is a simple and powerful micro-framework for web-applications in Python. For this, we need a library named flask, which can be downloaded using the command - pip install flask Now, let’s integrate all the values collected so far - latitude, longitude and API Key into the flask code. The above code represents a simple flask template in which we have imported two sub-packages of flask, viz., Flask and render_template . Also, we have created a function called the “map_func”. This function returns a jinga2 html page and passes the API Key, latitude and longitude to our HTML code (yes, we will need HTML too). Working with HTML, JavaScript and Map API A HTML file will be required to show the Map on the browser. For this, we need to create an HTML file in a folder called “templates”, and then name the file as “map.html” In the <head> of HTML file, add the following <script> elements to load the API code libraries, The <meta> tag ensures optimum performance of the view on mobile devices, and rest of the two <script> tag loads the JavaScript module of Map APIs. Next, we need to initialize the communication with the back-end services and initialize the map in the <body> of HTML inside the <script>. The detailed information of Map API can be found here and of Marker, here . The complete Python Code. All you need is to provide your own API key from Developer Portal to api_key in the above code. The complete HTML code(HTML file should be inside the templates folder and make sure that the template folder and python code are in same location). Running the Code Open command prompt or terminal and run the Python code(as shown in image below). Alternatively, you can also run code in an IDE like Spyder, PyCharm, etc. You will now be asked to enter a location. For your first test, enter only one word, preferably the city. Later you can try for an address. As you can see below, I have entered 'Berlin' as the location. An IP address will appear, http://127.0.0.1:5000 in response to the city you enter (see in the above image). Copy this address and paste it in any of the browser application (Chrome, Mozilla, Microsoft Edge, etc). In response you will get the map image showing a marker on Berlin. Conclusion You saw how to plot a location on a Map when you just have a name. In the process we used Geocoder API for text to geo-coordinate conversion, Map API for plotting the geo-coordinate on a Map and Python to make it all happen. In next part we will explore more feature that can be included. Till then, keep learning!", "date": "2020-03-17"},
{"website": "Here", "title": "Advanced Map Data Sets - What? Why? Where?", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/advanced-map-data-sets-what-why-where", "abstract": "When you use a mobility app like HERE WeGo for your daily commute, you can see that everyday points-of-interest like public transport stations, hospitals, schools, parks, etc. are highlighted on the map. This makes the map convenient for everyday use. But when you use maps for specific use cases like logistics, you want to see more relevant information on the map. This is one of the many use-cases where Advanced Map Layers and Data Sets can add value to your application. The Advanced Data Sets API gives you access to a hidden chest of map layers and data sets which are a part of the rich HERE map data. This data is available in the form of attributes. These attributes can be names of EV charging stations, the text displayed on road signs, the curvature of the road, and much more. The way this data is arranged is as follows: There are attributes in the form of key: value pairs These attributes are grouped in the form of Layers A call to the fleet telematics layer end point will list all layers currently available under the advanced data set. Note: This list can change often. Make this call to get the updated list every once in a while. https://s.fleet.ls.hereapi.com/1/doc/layers.json?apiKey={{YOUR_REST_API_KEY}} This call will give you a LONG list of layers and their attributes. And by LONG , I mean really LOOONG . Lets discuss a part of this response. The above call will give you something like this: ...\n    {\n        \"name\": \"PUBLIC_TRANSPORT_POI\",\n        \"type\": \"geom\",\n        \"tileLevel\": 13,\n        \"attributes\": [\n            \"PLACE_ID\",\n            \"NAMES\",\n            \"LINK_ID\",\n            \"CAT_ID\",\n            \"CAT_NAME\",\n            \"DISPLAY_LAT\",\n            \"DISPLAY_LON\",\n            \"SIDE_OF_STREET\",\n            \"PERCENT_FROM_REFNODE\",\n            \"POI_ID\",\n            \"LAT\",\n            \"LON\"\n        ],\n        \"featureMapping\": \"PDE-Base\"\n    },\n    {\n        \"name\": \"ROAD_ROUGHNESS_FC4\",\n        \"type\": \"attr\",\n        \"tileLevel\": 12,\n        \"attributes\": [\n            \"LINK_ID\",\n            \"FROM_AVG_ROUGHN_CAT\",\n            \"TO_AVG_ROUGHN_CAT\",\n            \"FROM_AVAILABLE_ROUGHN_TYP\",\n            \"TO_AVAILABLE_ROUGHN_TYP\",\n            \"FROM_AVG_IRI\",\n            \"TO_AVG_IRI\"\n        ],\n        \"featureMapping\": \"PDE-Premium-Road-Info\"\n    },\n    ... So, the response gives you the name of the layer, which is essential in calling the layer when you need to use it. The response describes the type of the layer. The type of layers can be \"attr\" which is attributes or \"geom\" which is geometry. Layers with the type geometry contain points or other map geometry objects which can be displayed as a layer over the default map. Layers with the type attributes contain attributes in the form of key:value pairs. The response also contains the tileLevel . The tile level describes the scope of this data. This value is nothing but the zoom level of the tile. The lower the tile level, the more area the tile covers. To know more about how tiles are described, read about the system of map tiles . The response then lists all the attribute names associated with the layer. The value in featureMapping tells you if you need a premium account to access this layer or you can use it with a Freemium account. In the above response, the featureMapping for the layer PUBLIC_TRANSPORT_POI is PDE-Base . Thus it is available under freemium. While that for the layer ROAD_ROUGHNESS_FC4 is PDE-Premium-Road-Info , which, as the name mentions, is a premium feature. If you don't have a freemium account yet, get one at developer.here.com . The call to the layers end point simply lists the layer names and attribute names. To get more detail about what these attributes are and what they mean, you will need to make another call to the layer end point, this time specifying the layer name. Let's see an example. https://s.fleet.ls.hereapi.com/1/doc/layer.json?layer=ROAD_ROUGHNESS_FC2&apiKey={{YOUR_REST_API_KEY}} RESPONSE {\n        \"description\": \"The Road Roughness layers provide multiple representations of the measured roughness of a link.\",\n        \"attributes\": {\n            \"LINK_ID\": \"Permanent link ID. Positive 64 bit Integer that globally identifies the road, carto or building footprint link, also across map releases. Link IDs are never reused.\",\n            \"FROM_AVG_ROUGHN_CAT\": \"Indicates the average Roughness Category applied to the link driving from reference node . Possible values: 1 – Good 2 – Fair 3 – Poor \",\n            \"TO_AVG_ROUGHN_CAT\": \"Indicates the average Roughness Category applied to the link driving towards reference node . Possible values: 1 – Good 2 – Fair 3 – Poor \",\n            \"FROM_AVAILABLE_ROUGHN_TYP\": \"Indicates the type of incident encountered along the link driving from reference node. Comma separated, possible values: 1 – Bump 2 – Dip\",\n            \"TO_AVAILABLE_ROUGHN_TYP\": \"Indicates the type of incident encountered along the link driving towards reference node. Comma separated, possible values: 1 – Bump 2 – Dip\",\n            \"FROM_AVG_IRI\": \"The average of the IRI values along driving from reference node, use to determine Roughness Category. Possible values: 0 - 99\",\n            \"TO_AVG_IRI\": \"The average of the IRI values along driving towards reference node, use to determine Roughness Category. Possible values: 0 - 99\"\n        },\n        \"referencedStaticContents\": [],\n        \"tileRequestsLevel\": 10,\n        \"tileX\": 934,\n        \"tileY\": 669,\n        \"isStaticContent\": false\n    } As you can see, this call makes the picture clear with what these attributes and their values actually mean. Notice the attribute isStaticContent in the end? While we talked about the coverage of these attributes and the type of geometry, there are certain attributes which are not tied to a specific location. Such attributes are called Static attributes. You can find a general list of available layers: Static and Non-Static here If you already know the attribute you are looking for and need the names of the layers it is available in, you can also make a reverse call which will give you a list of attribute names and the layers which contain it. https://s.fleet.ls.hereapi.com/1/doc/attributes.json?apiKey={{YOUR_REST_API_KEY}} RESPONSE ...\n    {\n        \"name\": \"TIME_ZONE\",\n        \"description\": \"Time zone defined in hours and minutes, with an offset from UTC. As an example, EST is -060 and CET is 010. Time Zone information is published only for the highest administrative level to which the time zone applies (e.g. Administrative Level 1 in Europe, Administrative Level 2 in the U.S.).\",\n        \"layers\": [\n            \"ADMIN_PLACE_0\",\n            \"ADMIN_PLACE_1\",\n            \"ADMIN_PLACE_2\",\n            \"ADMIN_PLACE_8\",\n            \"ADMIN_PLACE_9\",\n            \"ADMIN_REGULATIONS\"\n        ]\n    },\n    ... There are several ways in which these attributes and their values can be utilized in your application. Stay tuned to this series where we will take a look at these methods with examples!", "date": "2020-03-12"},
{"website": "Here", "title": "Reverse Geocoding a Location Using Python and Flask", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/reverse-geocoding-a-location-using-python", "abstract": "Have you ever seen the output of a GPS device? It's usually a set of numbers representing the geographic coordinates of a location, known as latitude and longitude. These numbers are unique and uses two-dimensional coordinates system based on the Earths surface, for example 48.2181679,16.3899064 represents a point somewhere on earth. Unfortunately, we often cannot easily understand these coordinates unless they are resolved into the closest street address. For the above mentioned coordinates, nearest address will be \" Heinestraße 42, 1020 Vienna, Austria \", which is way easier to understand and remember. Fortunately, we can use a Geocoding API to convert geographic coordinates into street addresses and vice versa. In this blog post, we are going to learn how to convert the geographic coordinates of a location into a street address with the help of the reverse geocoding feature of the HERE Geocoding and Search API and the Python programming language . Prerequisites Since we are using Python, your machine should have Python installed (I have Python 3.8) and if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you signed up, you can generate your free API key and get 250.000 free transactions every month. Ideally you should have location data in CSV format coming in from a GPS or IoT device. But for our example we will generate our own data. Working with Reverse Geocoding Endpoint The reverse geocoding endpoint of the Geocoding and Search API helps in finding nearest possible address to a specific geographic coordinates. All you need is to append the latitude and longitude values with your API key to the endpoint URL. https://revgeocode.search.hereapi.com/v1/revgeocode\n?at=12.98022751,77.60104064\n&apikey=YOUR_API_KEY The apikey is from the Freemium account generated on developer portal and the value of at is latitude and longitude value separated by a comma. The REST API returns a JSON response containing nearest address along with additional details. ...\n{\n\t\"items\":[\n    \t  {\t\"title\":\"Union Street, Shivajinagar, Bengaluru 560001, India\",\n        \t\"resultType\":\"street\",\n            \"address\":\t{\n            \t\"label\":\"Union Street, Shivajinagar, Bengaluru 560001, India\",\n                \"countryCode\":\"IND\",        \n                \"countryName\":\"India\",\n                \"state\":\"Karnataka\",\n                \"county\":\"Bengaluru\",\n                \"city\":\"Bengaluru\",\n                \"district\":\"Shivajinagar\",\n                \"street\":\"Union Street\",\n                \"postalCode\":\"560001\"\n                \t\t},\n             \"position\":{\n             \t\"lat\":12.98025,\n                \"lng\":77.60099\n                \t\t},\n             \"access\":[\n             \t\t{\t\n                    \t\"lat\":12.98025,\n                        \"lng\":77.60099\n                    }\n                      ],\n              \"distance\":6,\n             \"mapView\":\n              \t\t{\n                    \t\"west\":77.60116,\n                        \"south\":12.98021,\n                        \"east\":77.60097,\n                        \"north\":12.98072\n                     }\n                    }\n                   ]\n                  } Generating the Data Latitude and longitude data is generally sent from a device located in field, like an asset tracking hardware or health monitoring system. The data coming to the back-end server is stored in a CSV file from where it can be further analysed. Instead of sending data from a device, we are generating and storing it in CSV format using Python. import random\nimport time\n\nlatitude = 12.9716\nlongitude = 77.5946\nfile_name = 'data.csv'\n\ndef generate_random_data(lat, lon, num_rows, file_name):\n\twith open(file_name,'a') as output:\n    \toutput.write('timestamp,latitude,longitude\\n')\n        for _ in range(num_rows):\n            time_stamp = time.time()\n            generated_lat = random.random()/100\n            generated_lon = random.random()/100\n            output.write(\"{},{},{}\\n\".format(time_stamp, lat+generated_lat, lon+generated_lon))\n\ngenerate_random_data(latitude,longitude, 10, file_name) Function generate_random_data takes 4 arguments as input; latitude, longitude, number of rows and file name, and creates a CSV file named 'data.csv'. The file created has three columns, namely, timestamp, latitude and longitude with 10 rows of data. Reading CSV file There are many ways to read CSV file in Python, using Pandas library is the most efficient one. Install the library using the command pip install pandas For more details on how to install a library, see my previous blog in the Python blog series. import pandas as pd \n\n#To read 6th row data\ndata = pd.read_csv(\"data.csv\",skiprows=5,nrows=1) \n\n#To print the values\nprint(data)\n\n#To convert values into list\nlist_value = data.values.tolist()\n\n#Latitude and Longitude\nlatitude = list_value[0][1]\nlongitude = list_value[0][2]\n\n#You can print the latitude and longitude using print() function Parsing JSON Response After getting the latitude and longitude value from CSV, we need to pass them to the Geocoding and Search API to get a JSON response. For making a GET request, we need requests library which can be easily downloaded using the command pip install requests import requests\n\n# api-endpoint\nURL = \"https://revgeocode.search.hereapi.com/v1/revgeocode\"\n\n#API key\napi_key = 'YOUR_API_KEY'\n\n# Defining a params dictionary for the parameters to be sent to the API \nPARAMS = {\n\t\t\t'at': '{},{}'.format(latitude,longitude),\n\t\t\t'apikey': api_key\n         }\n\n# Sending get request and saving the response as response object \nr = requests.get(url = URL, params = PARAMS) \n  \n# Extracting data in json format \ndata = r.json() \n\n#Taking out title from JSON\naddress = data['items'][0]['title'] \n\nprint(address) The print command at the end gives us the nearest address to the passed geographic coordinates. Using Flask for creating a Map What makes location data so interesting is that we can visualize it on a map and do whole bunch of other stuff with it. Now, we have all the values needed (latitude, longitude, address, API key) to show our address on a map. For this, we need a library named flask, which can be downloaded using the command pip install flask from flask import Flask,render_template\n\napp = Flask(__name__)\n@app.route('/')\n\ndef map_func():\n\treturn render_template('map.html',apikey=api_key,latitude=latitude,longitude=longitude,address=address)\n\nif __name__ == '__main__':\n\tapp.run(debug = False) The code takes us to a HTML page which renders a map for us. Including HTML, JavaScript and Maps API A HTML file with JavaScript code is enough to plot a beautiful looking map. The file name is map.html . <html>  \n<head>\n<meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<link rel=\"stylesheet\" type=\"text/css\"href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n</head>\n  \n<body style='margin: 0'>\n<div style=\"width: 100%; height: 100%\" id=\"mapContainer\"></div>\n\n<script>\t\n      // Initialize the platform object:\n      var platform = new H.service.Platform({\n        'apikey': '{{apikey}}'\n      });\n\t  \n\t   const lat = {{latitude}};\n\t   const lon = {{longitude}};\n\t\n\t// Obtain the default map types from the platform object\n      var maptypes = platform.createDefaultLayers();\n\n      // Initialize a map:\n      var map = new H.Map(\n        document.getElementById('mapContainer'),\n        maptypes.raster.terrain.map,\n        {\n          zoom: 17,\n          center: { lat: lat, lng: lon }  \n        });\n\t\t\n\t// Enable the event system on the map instance:\n\t  var mapEvents = new H.mapevents.MapEvents(map);\n\t\n\t// Instantiate the default behavior, providing the mapEvents object:\n\t var behavior = new H.mapevents.Behavior(mapEvents);\n\n\t//window.addEventListener('resize',()=> get.ViewProt().resize())\n\tvar marker = new H.map.Marker({ lat: lat, lng: lon });\n\t\t\n\t// Add the marker to the map:\n\tmap.addObject(marker);\n\t\n\t// Create the default UI:\n\tvar ui = H.ui.UI.createDefault(map, maptypes);\n\t\n\t// Add event listener to the marker:\n\tmarker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: lon, lat: lat }, {\n                content: '<p> <h4>Address</h4>{{address}}</p>'\n             });\n\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\t\n\n</script>\n</body>\n</html> The code plots the latitude and longitude on a map and shows a marker on the location. When marker is clicked, a box pops up showing the address we passed. The detailed information of Map API can be found here and of Marker, here . Complete Python code import pandas as pd \nimport requests\nfrom flask import Flask,render_template\n\n#---------Reading CSV to get latitude and Longitude---------\ndata = pd.read_csv(\"data.csv\",skiprows=5,nrows=1) \n\nlist_value = data.values.tolist()\n#print(list_value[0])\n\n#Latitude and Longitude\nlatitude = list_value[0][1]\nlongitude = list_value[0][2]\n\n#---------Making API call and JSON Parsing---------\n# api-endpoint\nURL = \"https://revgeocode.search.hereapi.com/v1/revgeocode\"\n\n#API key\napi_key = 'YOUR_API_KEY'\n\n# defining a params dict for the parameters to be sent to the API \nPARAMS = {\n\t\t\t'at': '{},{}'.format(latitude,longitude),\n\t\t\t'apikey': api_key\n         }\n\n# sending get request and saving the response as response object \nr = requests.get(url = URL, params = PARAMS) \n  \n# extracting data in json format \ndata = r.json() \n\naddress = data['items'][0]['title'] \n\n#---------Flask Code for creating Map--------- \napp = Flask(__name__)\n@app.route('/')\n\ndef map_func():\n\treturn render_template('map.html',apikey=api_key,latitude=latitude,longitude=longitude,address=address)\n\nif __name__ == '__main__':\n\tapp.run(debug = False) Running the Code Run the code using any Python IDE like Spyder or PyCharm else simple use command prompt or terminal to execute the code. Copy the address http://127.0.0.1:5000 and paste it in the browser application. When clicked on the marker, the address passed in the code will pop up. This concludes our tutorial on reverse geocoding a location with the help of HERE Geocoding and Search API. Now you can build your own Internet of Things Tracking Application where you can show the nearest address of an asset on the map. Stay tuned for more Python tutorials!", "date": "2020-03-24"},
{"website": "Here", "title": "100 Days of Code With HERE", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/100-days-of-code-with-here", "abstract": "An amazing way to learn a new skill is to learn a little bit of it , every day. We at HERE Technologies want you to get acquainted with location technology through m ap APIs provided by us by launching 100 Days Of Code with HERE Starting from the 1 st of April 2020, we will post 1 task on our twitter handle @heredev every day for 100 days . In solving the tasks, you will be using the HERE JavaScript and REST APIs found at developer.here.com . The Documentation section will help you find the solutions. Feel free to tweet your solutions back at us with the tags #100DaysOfCode and #100DaysOfCodeWithHERE . We will also provide you the solutions in various forms: Preview video on twitter with solution to the previous day task Blogpost with solutions for 5 days of tasks on our developer blogs Video tutorial with solutions for 5 days of tasks on YouTube If you have any questions during the 100 Days, feel free to dm us , post your questions on our developer blogs and YouTube videos or post the question on our slack channel Happy coding with 100DaysOfCode !", "date": "2020-03-30"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.13 release", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.13-release", "abstract": "Highlights Submit multiple VINs to expedite Neutral Server Consent Management As a Marketplace consumer subscribed to Neutral Server listings, you can now submit multiple VINs (Vehicle Identification Numbers) when creating a new or editing an existing consent request. A list of VINs can be programmatically submitted using a single CSV or JSON file enabling you to process multiple VINs with the use of an external API. The Consent Manager simplifies the integration between HERE and Data Consumers' systems and reduces human interactions when using Neutral Server to request access to PII data. Delete catalog versions to manage storage costs of your Versioned layer data Deleting catalog versions helps you manage storage costs and gives you more granular lifecycle management controls for your Versioned layer data. Safely remove (delete) older versions manually or automatically to manage how long your Versioned data is stored. Deleting a catalog's version safely removes data from Versioned layers only and in a way which doesn't break existing dependencies between different Versioned layers. Deleting catalog versions maintains catalog configuration information and therefore the overall data integrity of the Versioned layers within a catalog. You will find this functionality via the \"More\" menu on the Catalog Details Page as long as there are Versioned layers in the catalog. Example of manual deletion controls: Access additional HERE Map Content: Advanced Navigation Attributes via the Optimized Map for Location Library The attribute \"Railroad Crossing\" from the Advanced Navigation Attributes layer in the HERE Map Content catalog is now also available in the Optimized Map for Location Library. We will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library. For more detail on the added attribute, please see: HERE Map Content- Advanced Navigation Attributes layer Location Referencing: encode/decode locations in the OpenLR format regardless of source or target map format The popular OpenLR open standard for Dynamic Location Referencing is added to the Location Library. Events and locations can be decoded and encoded with this format, allowing locations localized on one map to be found on another map to which the data have been transferred, even if the map formats are completely different from each other. Centralized SDKs, Tools, and examples to improve discoverability Following the addition of new SDKs to the platform in the last release, the platform web pages have been restructured with this release. platform.here.com/sdk now lists all the platform SDKs, Tools and the CLI. The Java and Scala examples that were previously distributed with the CLI are now all published on GitHub https://github.com/heremaps/here-workspace-examples-java-scala . Note, openlocation.here.com/resources/code-examples still has Java and Scala examples that are not yet published to this GitHub repository. The CLI now has its own page: https://platform.in.here.com/sdk/cli . If you are new to the platform and are a Windows user, an installer for the CLI is now available to make the setup easier; it's available at platform.here.com/cli . Get information about scheduled maintenance on the Status Page The HERE Status page at https://status.here.com/status/status now supports information about scheduled maintenance. Organization Account Owners are notified of maintenance as well as additional users within an organization who have opted in to receive Change Notifications in the support portal. Changes, Additions and Known Issues SDK for Java and Scala To read more information about the SDK for Java and Scala , please visit the HERE platform changelog . SDK for C++ To read more information about the SDK for C++, please visit the HERE platform changelog . Added: The latest release enables you to authenticate via the SignInFederated API and you are now able to request an authentication token using your own request body. Added: It is possible to download metadata for a specified list of partitions. You can also specify additionalFlags that you are interested in. For example, you can specify: data size, compressed data size, crc or checksum. Added: The SDK lets you retrieve data via the GetData API with TileKey. The metadata for surrounding tiles is downloaded in one request, this enables you to retrieve map tiles faster . SDK for TypeScript To read more information about the SDK for TypeScript, please visit the HERE platform changelog . Added: The SDK for TypeScript now enables you to read data from Stream layers. SDK for Python Added: The SDK for Python installation has been updated with simpler steps using Conda. Refer to the SDK for Python Setup Guide for the latest updates. Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Deprecated: For security reasons, the platform will start validating schema reference changes in layer configurations as of September 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If a non-existing or non-accessible schema is associated with any layer after this date, any attempt to update any configurations of that layer will fail. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before September 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will currently not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported. Pipelines Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. HERE Content Deprecated: Within the Real Time Traffic catalog ( https://platform.here.com/data/hrn:here:data::olp-here:olp-traffic-1 ) the Incidents2.4 layer is being deprecated and has been labeled as such since August 2019. This is a step in the effort to migrate to the new Delta Incidents layer which is now available in the same catalog. There will no longer be new incidents published in the Incidents2.4 layer by April 30, 2020. Once this happens, volatile data will no longer have incidents after 1hr of their time-to-live. As this will be a schema change, there are instructions in the layer description on how to migrate. Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Added: You can attach an optional link or PDF file (e.g. executed agreement) to a subscription during the activation process. Once the link or PDF file is attached, both you and your subscriber can access it in the subscription detailed page. Added: You can add multiple VINs ((Vehicle Identification Numbers) when creating or editing consent request while requesting access to PII data via Neutral Server. The list can be added as a single CSV or JSON format file with max. size of 2 MB Changed: When consuming catalog data or schemas using Java or Scala, the Maven plugin will be automatically installed. We recommend that you update to the new Maven wagon plugin version. Please, refer to the documentation to learn how to do this. The plugin has been open sourced and can be found on https://github.com/heremaps/here-artifact-maven-wagon . Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components", "date": "2020-03-30"},
{"website": "Here", "title": "Expanding Our Self-Serve Offering: Meet the HERE Data Hub Add-On", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/expanding-the-introducing-the-here-data-hub-add-on", "abstract": "A year and a half ago we radically changed the way we offer access to our platform and introduced our Freemium plan for developers . Since then, we have seen our community grow and embrace our location APIs as well as benefit from the generous offering to test our data and build exciting solutions! Today , I am excited to present a new addition to our pricing plan that will give you that little extra – the add-on option for advanced data storage and management with Data Hub. Now, let's explore the benefits you get with the Data Hub add-on option. First off, our Freemium plan remains as easy to start with as before – you can get started within seconds, without entering any payment information (until you exceed the allowable limits). Since we introduced the plan in 2018 and launched our location data management service HERE Studio and HERE Data Hub (previously known as HERE XYZ) in 2019, we received feedback from our developer community that you'd like more flexibility when it comes to the API and data storage access, especially for heavy HERE Data Hub users. The community spoke and we listened : As of today, we have added the possibility to have a HERE Data Hub specific add-on on top of Freemium that gives you all the goodies of Freemium plus additional benefits for power HERE Data Hub users. For an additional 45$ (45€) a month, developers will get: Data transfer per month 10GB – four times the amount compared to Freemium Database storage per month 10GB – twice as much as with Freemium Pay per additional Data transfer 100MB / 0.45€ Pay per additional Database storage 5GB / 3€ Data Hub advanced features Support via StackOverflow If you are not familiar with the tool, HERE Data Hub is a real-time, geospatial database in the cloud where you can upload, store, edit and publish geospatial data. It offers a command line interface and an API to interact with data. ​You can g et geodata in and out by using well-defined methods as long as they speak GeoJSON ​. Think sophisticated map making. The advanced features which are part of the add-on include Schema Management , Rule based tagging , Activity Log , On demand indexing , Hexbin through CLI and Virtual Spaces . In the coming weeks and months, we will bring additional products which can be added on to the Freemium offering so developers can pick and choose what they need. Tune in on April 1st, 2020 for the first episode of the new season of HERE Expeditions (formerly known as Explore HERE Studio) for more on HERE Studio and Data Hub – follow here for more: https://t.her.is/heredevTV . For more updates on our plans, or to show off what you've built with HERE Data Hub, get in touch with us on Twitter @heredev . Want to connect with other HERE developers? Join our Slack space.", "date": "2020-03-20"},
{"website": "Here", "title": "Where's HERE?", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-online-in-april-2020", "abstract": "One of the great things about being in a DevRel organization is the ability to connect with our developer community face to face at events, meet ups, hackathons, you name it. You may have noticed that lots of companies and events these days are shifting from being in-person to virtual, given the social distancing guidelines during our global pandemic. HERE is no different. With that in mind, we thought it’d be good to give you a run down of where we’ll “be” this month – virtually, of course, because social distancing. You probably know by now that we’re active on Twitch . Well, you can expect a lot more of us there in the coming weeks. We started a new series “Home Office Hours” where we spend time with one of our evangelists to see what they’re up to while at home, and have kicked off season 2 of “HERE Expedition” (formerly known as Explore XYZ) to show you the latest in HERE Studio and HERE Datahub. Fret not if you missed the first few episodes of those shows, all our livestreams are posted on our YouTube channel. Where else can you find us? Glad you asked, read on, my friend. Geo Challenge | Online hackathon for the developer community in Serbia | Started April 1, 2020 MIIGAiK Eco Hack | Online hackathon for environmentalists in Russia | Starts today! April 3-5, 2020 Pandemic TechHack | Online hackathon focused on supporting Egypt’s response to COVID-19 | April 5-8, 2020 HERE Expedition Season 2 Episode 2 - Maps and JAMstack: Raymond Camden will discuss different ways of using our maps and APIs in the JAMstack. (hey, that’s me!) | April 15, 2020 @ 10:00AM PST Coming soon! We're launching a multi-week online Covid-19 hackathon in the APAC region. Stay tuned for more info - we're planning multiple webinars and a few livestreams to support participants throughout the hackathon. | April - May 2020 Check back here for updates to this month’s calendar and to find out where we’ll be next month. In the meantime, you can always join the HERE developer community on Slack , or give us a holler on Twitter . Oh, and one last thing – have you been following along with our #100daysofcode challenges? This is a way for you to hone your skills bit by bit, day by day. You can find the solutions to our challenges on Twitter , our Developer Blog , and on YouTube .", "date": "2020-04-03"},
{"website": "Here", "title": "Microsoft highlights HERE Location Services in their Dynamics 365 Customer Insights Preview", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/microsoft-highlights-here-location-services-in-their-dynamics-365-customer-insights-preview", "abstract": "Today marks a proud day for the team at HERE Technologies. Microsoft’s James Phillips, President of the Business Applications Group, lead an in-depth preview of the latest innovations across Dynamics 365 and Microsoft Power Platform. During the Microsoft Business Applications Virtual Launch Event, James announced Customer Insights and the new third-party data integration with partners like HERE. Specifically, HERE was highlighted as a location data provider for Microsoft’s Dynamics 365 Customer Insights (CI) product. This integration enables Microsoft CI customers to enrich their customer information with licensed HERE location data. During the demo, HERE was showcased as the location data third party enrichment provider inside the CI product (similar to a marketplace) enabling Microsoft’s customers to benefit from location enabled insights. For example, customer data can be employed to plot trade area analysis, address validation and to forecast likely customers based on proximity. Through this new agreement, Microsoft is bringing HERE to the thousands of Dynamics 365 users and customers who span from SMBs to global enterprises. Integrating HERE Location Data with Customer Insights enables HERE’s customers with a powerful, AI driven customer data BI platform that increases their realized value from HERE. Working with HERE, Microsoft is integrating a connector from Customer Insights to HERE’s Location Services APIs. Existing customers, along with new customers who will sign up for a Freemium plan via developer.here.com, will get access to HERE APIs from within Customer Insights via the Connector.", "date": "2020-04-02"},
{"website": "Here", "title": "HERE Developers Livestreams: Join our Growing Community on Twitch!", "author": ["Peter Mallahan"], "link": "https://developer.here.com/blog/join-our-growing-community-on-twitch-here-developers-livestreams", "abstract": "If you're really into gaming, like the most of us on our team, you’ve probably heard of Twitch. Did you know though that HERE has a Twitch channel? For the past year, our developer evangelists have been walking our viewers through a wide range of technologies and platforms. From cloud platforms like AWS and Azure, to hackathons and map design – we dedicate an hour discussing and troubleshooting code. The best part of our livestreams is that they’re live and you get to ask all your questions, and get answers immediately! If you are wondering what we will be talking about on the next few livestreams, watch the video below to get a feeling of our past sessions and what we wil b e building on the upcoming streams. Follow our channel to get instant updates and notifications when we go live: twitch.tv/heredev We look forward to seeing you there!", "date": "2020-03-23"},
{"website": "Here", "title": "How to Migrate from Google Maps to HERE Maps (2020 edition)", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/how-to-migrate-from-google-maps-to-here-maps-2020-edition", "abstract": "Nearly two years Jayson DeLancey discussed how to migrate from Google Maps to HERE's JavaScript Maps library. It's been sometime since that initial post so I thought it would be a great time to do an update. In this post I'm going to demonstrate three different simple use cases with client side maps. I'll begin by demonstrating how to add a map centered at a particular location. Next, I'll show how to add one static marker to the map. Finally I'll show an example where data is loaded from a remote resource and then added to the map as a set of dynamic markers. For all examples, you will need a key to enable map usage in your projects. You can go here for your Google key (requires a Google account, setting up a project, enabling the Maps API, generating a key) and here to sign up for your HERE developer account (requires an account, a project, and then your key). Let's Make a Map Alright, so let's start off with the simplest example possible - just putting a map on the page. Because I'm writing this I'll center the map on the most important location on the planet - Lafayette, Louisiana. Let's start with Google Maps. First, you add a script tag to your page: <script src=\"https://maps.googleapis.com/maps/api/js?key=YOUR-KEY-HERE&callback=initMap\"\n    async defer></script> Two things to note here. First, you need to include your key in the src attribute. Google lets you restrict key usage to specific domains so that isn't a concern. Next, you define the function to execute after the maps library has loaded. In the exmaple above this is \"initMap\". The JavaScript to load a map at our position looks like this: var map;\nfunction initMap() {\n\tmap = new google.maps.Map(document.getElementById('map'), {\n\t\tcenter: {lat: 30.22, lng: -92.02},\n\t\tzoom: 8\n\t});\n} The code instantiates a new Maps object with a specific center and zoom property. Note it's assuming a div on the page with the ID of map. You can see the entire source of this particular demo here . Here's the result: Alright, let's take a look at the HERE version. First, we break up our library into different parts based on what you need. Technically just one JS and CSS resource would be required, but to replicate the default UI controls and touch/mouse controls in the Google map, we're going to load in multiple libraries: <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" /> Next the JavaScript to add the map. Note that as before, we're skipping the HTML where we define a div to hold the map. const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\nvar platform = new H.service.Platform({\n\t'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n\tdocument.getElementById('mapContainer'),\n\tdefaultLayers.vector.normal.map,\n\t{\n\t\tzoom: 8,\n\t\tcenter: { lat: 30.22, lng: -92.02 },\n\t\tpixelRatio: window.devicePixelRatio || 1\n\t}\n);\n\n// allow for default touch/drag support\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n// Create the default UI:\nvar ui = H.ui.UI.createDefault(map, defaultLayers); There is - for sure - a bit more code here, but again the default with HERE Maps is to assume less and give you a bit more control over how the map is going to work. So both of the last lines are how default behaviors and UI are added, if you want them. You can view the entire source for the map here . Here's the result: X Marks the Spot Now that we've seen how to convert a Google Map to HERE Maps, let's consider an example with a marker. In both cases, I'm going to add a hard coded marker that's in the same place as the center of the map, but certainly that is not a requirement. First, the Google Maps version: var marker = new google.maps.Marker({position: {lat: 30.22, lng: -92.02}, map: map}); Here's how it looks: Now let's look at the HERE Map's version: map.addObject(new H.map.Marker({lat:30.22, lng:-92.02})); And here is how it looks: You can go to my repository for the Google and HERE versions. Dynamic Markers For our third and final comparison, lets consider a more advanced example. For this demo we're going to take information from a USGS feed representing earthquake data in GeoJSON data. The original Google example for this shows a version using JSON/P, but I've updated their demo to use the regular JSON feed as it supports CORS now. let map;\n\nasync function initMap() {\n\tmap = new google.maps.Map(document.getElementById('map'), {\n\t\tcenter: {lat: 2.8, lng: -187.3},\n\t\tzoom: 3\n\t});\n\n\tlet resp = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson');\n\tlet data = await resp.json();\n\n\tfor (var i = 0; i < data.features.length; i++) {\n\t\tvar coords = data.features[i].geometry.coordinates;\n\t\tvar latLng = new google.maps.LatLng(coords[1],coords[0]);\n\t\tvar marker = new google.maps.Marker({\n\t\t\tposition: latLng,\n\t\t\tmap: map\n\t\t});\n\t}\n} I've marked the \"initMap\" function as async and then used the Fetch API to retrieve the GeoJSON data. I iterate over the data and add a marker for each result. Here's how it looks: Now here's the HERE version: const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\nvar platform = new H.service.Platform({\n\t'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n\tdocument.getElementById('mapContainer'),\n\tdefaultLayers.vector.normal.map,\n\t{\n\t\tzoom: 3,\n\t\tcenter: {lat: 2.8, lng: -187.3},\n\t\tpixelRatio: window.devicePixelRatio || 1\n\t}\n);\n\n// allow for default touch/drag support\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n// Create the default UI:\nvar ui = H.ui.UI.createDefault(map, defaultLayers);\n\nloadData();\n\nasync function loadData() {\n\tlet resp = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson');\n\tlet data = await resp.json();\n\n\tfor (var i = 0; i < data.features.length; i++) {\n\t\tvar coords = data.features[i].geometry.coordinates;\n\t\tmap.addObject(new H.map.Marker({lat:coords[1], lng:coords[0]}));\n\t}\n} For the most part it's virtually the same except for the call to add the marker. Here's how it looks: You can go to my repository for the Google and HERE versions. I hope these demos were useful and be sure to see our other guides in the Switch to HERE guide!", "date": "2020-03-31"},
{"website": "Here", "title": "HERE Data Hub: The Advanced Features At A Glance", "author": ["Katie Kowalsky"], "link": "https://developer.here.com/blog/here-data-hub-adds-new-add-on-plan-and-advanced-features", "abstract": "It’s been a year since we launched HERE Data Hub and HERE Studio (formerly known as XYZ Data Hub and XYZ Studio), our cloud-based location data management service and we have exciting news to share. You can now take your data to the next level with our monthly add-on plan, available on developer portal. Mithun talks about this new Add-on plan more here: Expanding Our Self-Serve Offering: Meet the HERE Data Hub Add-On For $45 (€45) a month, your database storage and data transfer amounts expand to be 10GB per month. This offering also gives you access to the HERE Data Hub advanced features that allow to manage your data with even more convenience and gives you access to new visualization features. We’re also sweetening the deal for our Pro users, giving them access to the Data Hub add-on plan. New features included with the HERE Data Hub add-on plan are: On-demand indexing, allows you to turn on search indexes for quick searches by data properties later. Virtual Spaces gives you control over multiple spaces at once with JOIN-like functionality. Hexbins in the CLI can create massive data visualizations and complete control over how you simplify your data. Schema Validation keeps your Space organized and consistent by setting JSON parameters of what data can be uploaded and what properties should exist. Activity Log is your way of checking changes made to a space for version control tracking. Rule-based Tagging allows for automatic feature tagging based on property values. Hexbins generated with a historic tornado dataset from 1950 to 2018, data from NOAA Filter by properties that you index on the fly instead of setting that up at data upload. Learn how to use all these new features with two new tutorials, available on the Developer Portal Tutorial Page . We hope you try out these new features and can’t wait to see what you can build. Tell us what you want to see added and share examples of projects you’re building on our Data Hub Slack Channel or our HERE Developer Twitter .", "date": "2020-03-25"},
{"website": "Here", "title": "Avoiding Traffic Jams using the HERE Routing API", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/avoiding-traffic-jams-using-the-here-routing-api", "abstract": "Avoiding things is fun! For example, I love to avoid traffic jams, parties and personal responsibility. Some of these are harder to avoid than others, but fortunately our Routing API is here to help! It provides us with a whole range of options to calculate routes that avoid things, from sketchy areas to bus rides. Don't avoid this ongoing series of blog posts, in which we will cover all of them. Today we will learn how to avoid traffic jams! First, let’s look at a standard call to our Routing API (v7) for a short drive in London. https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_api_key\n&waypoint0=51.44221,-0.08096\n&waypoint1=51.44224,-0.03834\n&mode=fastest;car There’s not too much to explain here. We have two waypoints, a routing mode (we’re asking for the fastest route by car) and an apikey for authentication ( sign up for our Freemium plan to get 250.000 routing calls for free every month). If we display this route on a map, it looks like the following: Note that you can check out this example in our Web SDK documentation on how to display a route on a map. As you can see in this code snippet, the JavaScript API uses the same routing parameters we are discussing here. function calculateRouteFromAtoB (platform) {\n  var router = platform.getRoutingService(),\n    routeRequestParams = {\n      mode: 'fastest;car',\n      waypoint0: '51.44221,-0.08096', \n      waypoint1: '51.44224,-0.03834',      \n    };\n\n  router.calculateRoute(\n    routeRequestParams,\n    onSuccess,\n    onError\n  );\n} Now if we turn on traffic flow on the map, we see that this route goes right through a massive traffic jam on the South Circular Road. (Note that this was true, when I was running these examples. Current traffic conditions will of course be different for you. Feel free to experiment using your favorite traffic-prone area.) You can turn on traffic flow for any of our web maps, simply by creating default layers and adding a default UI. This will add UI elements to the bottom right of the map, where you can toggle various layers, including traffic flow. Once again, check the example linked above on how to do this. Because we can see the traffic flow on the map, we obviously have live traffic information available. In order to avoid the traffic jam, we need to make sure the Routing API takes this information into account. To so, we change the routing mode as follows. https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_api_key\n&waypoint0=51.44221,-0.08096\n&waypoint1=51.44224,-0.03834\n&mode=fastest;car;traffic:enabled Once again, let’s draw this on a map and see what happens. We can see that the route has changed. While we can’t avoid part of the traffic jam to the east (likely due to the limited number of railroad crossings, which make diversions tricky), taking the longer route around the park is actually faster! Another feature of the Routing API that can help you avoid traffic jams, is the ability to calculate several alternative routes. This allows you to look at several routing options and pick the one that is best suited for you. To do this, we need to add the alternatives parameter. In the following example, we are asking for three alternatives. https://route.ls.hereapi.com/routing/7.2/calculateroute.json\n?apiKey=your_api_key\n&waypoint0=51.44221,-0.08096\n&waypoint1=51.44224,-0.03834\n&mode=fastest;car;traffic:enabled\n&alternatives=3 And that’s it for avoiding traffics jams! Next time, we’ll learn how avoid my least favorite form of public transport, the bus!", "date": "2020-04-01"},
{"website": "Here", "title": "Solutions Day 0-5: 100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-0-5-100daysofcode", "abstract": "I hope you are as excited as I am about #100DaysOfCodeWithHERE. For those who have stumbled upon this blog accidentally, we at HERE Technologies are running a series called 100 Days of Code with HERE. The aim of this series is to get you acquainted with location technology thorough APIs that HERE has to offer. Starting the 1st of April, we have been posting 1 task every day through our twitter handle @heredev . We will be doing this for a total of 100 days. After every 5 days, we will post a blog and a video with solutions for the previous 5 days. At the end of 100 days, not only will you learn about HERE map APIs and documentation, but will also learn the basics to build a location technology based application of your own. Day 0/100 So Day 0/100 of #100DaysOfCodeWithHERE is pretty straight forward. You need to create a freemium account on developer.here.com . You can either follow this little gif or take a look at this mini video . Once you have these credentials, you will get access to over 20 APIS and will get 250K transactions per month! Let's get going with the actual tasks now Day 1/100 The task was to create a frame for a basic HTML+ JS application and to add the HERE map core and map services source within the <head> and </head> tags. So let's create a basic HTML frame. <!DOCTYPE html>\n    <html lang=\"en\">\n        <head>\n            <title>100DaysOfCode</title>\n            <meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" />\n            <!-- map core -->\n            <!-- map services -->\n        </head>\n    </html> Now to start with the JS maps, go to developer.here.com/documentation . You will see that all the APIs are intuitively arranged where you first have maps and then other services to build on top of the maps. Now go to Interactive Maps and click on JS and then Get Started Here you will find the map core and service libraries to add to your application to be able to use the HERE map APIs. Lets add the source to the section. <head>\n    <!-- map core -->\n    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script>\n    <!-- map services -->\n    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script>\n</head> Day 2/100 Once we have added the libraries, lets create a div to hold the map and initialize the platform. ...\n<body>\n    <div id=\"mapContainer\" style= \"align-self: center; width: 100vw; height: 80vh; background-color: #a87bdf;\"></div>\n</body>\n<script>\n        // Initialize platform with JS API KEY\n    var platform = new H.service.Platform({\n        apikey: \"YOUR_JS_APIKEY\"\n    });\n</script> This is how we establish communication with the backend services provided by the HERE REST APIs. You will find the JavaScript Key in the Project section of your account you created on Day 0/100. Once we initialize the platform, we are going to initialize the map in the next task Day 3/100 In this task, we will first obtain the default map style from the platform object and then state the map type which is normal . We then go on to set the initial zoom level and center of the map. The easiest way to get the location you want in terms of latitude and longitude is to go to wego.here.com , enter the name/ address of place you want, you will see the latitude and longitude in the left pane under see more info => see more . Lets see the code. <script>\n  ...\n\n  // initializing default layers for the map\n  var defaultLayers = platform.createDefaultLayers();\n  // rendering map within the container on the page\n  var map = new H.Map(\n          document.getElementById('mapContainer'),\n          defaultLayers.vector.normal.map, // rendering vector map with NORMAL map view.\n          {\n              zoom: 11, // Initial zoom level of map\n              center: {lat: 52.53086, lng: 13.38474} // Initial center of map\n          });\n</script> The createDefaultLayer() calls the default styles of the map. This includes- What shade of blue should the sea be, what should be the thickness of the polyline that describes the national highways, etc. If you want to set custom styles, you can either set the style before loading the map, or after loading the map. You can read more about custom styles in the documentation. The task also explicitly mentions the vector map which loads the vector data provided with the help of the WebGL rendering engine. You can also choose to load a Raster map which will load map images. You can read more about Vector maps and Raster maps in the Map Types section. Implementing the above code will give you a static map which you cannot zoom or pan. Let's complete the tasks for day 4 and 5 to add those Day 4/100 This task was to add the UI element- control panel to the map to be able to zoom it and change the base map after loading. You can also change the position of the control panel and customize aspects of it. To do this, you will have to add the ui libraries and the default stylesheet and then call on the basic ui elements. Ofcourse you can find how to do it in the documentation . Lets take a look at the code <head>\n    <!-- source for map ui -->\n    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script>\n    <!-- style sheet for map UI -->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/>\n</head>\n<script>\n    ...\n    // creating default UI for map\n    var ui = H.ui.UI.createDefault(map, defaultLayers);\n</script> Day 5/100 To pan the map, you click on the map and drag it across to the place you want to focus. This means, you need to tell your map what to do on clicking and dragging. Events like clicking and dragging, fall under map events . You can associate different behaviours to different events like displayign an info-bubble on mouse tap . HERE map APIs provide panning of the map under default behavior. To enable this, you need to add the source for map events, and call the default behaviour function <head>\n    <!-- source for map events -->\n    <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script>\n</head>\n<script>\n    ...\n    // initialize basic map events \n    var mapEvents = new H.mapevents.MapEvents(map);\n    // Initialize for map behaviour on events\n    var behavior = new H.mapevents.Behavior(mapEvents);\n</script> By putting all this together, you should get an interactive map with basic style and UI <!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>100DaysOfCode</title>\n        <meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" />\n        <!-- map core -->\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script>\n        <!-- map services -->\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script>\n        <!-- source for map ui -->\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script>\n        <!-- style sheet for map UI -->\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/>\n        <!-- source for map events -->\n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script>\n    </head>\n    <body>\n        <h1 style=\"text-align: center;\">100 Days of Code with HERE</h1>\n        <!-- Container to hold map -->\n        <div id=\"mapContainer\" style= \"align-self: center; width: 100vw; height: 80vh; background-color: #a87bdf;\"></div>\n    </body>\n    <script>\n        // Initialize platform with JS API KEY\n        var platform = new H.service.Platform({\n            apikey: \"YOUR_JS_APIKEY\"\n        });\n        // initializing default layers for the map\n        var defaultLayers = platform.createDefaultLayers();\n        // rendering map within the container on the page\n        var map = new H.Map(\n                document.getElementById('mapContainer'),\n                defaultLayers.vector.normal.map, // rendering vector map with NORMAL map view.\n                {\n                    zoom: 11, // Initial zoom level of map\n                    center: {lat: 52.53086, lng: 13.38474} // Initial center of map\n                });\n        \n        // creating default UI for map\n        var ui = H.ui.UI.createDefault(map, defaultLayers);\n        // initialize basic map events \n        var mapEvents = new H.mapevents.MapEvents(map);\n        // Initialize for map behaviour on events\n        var behavior = new H.mapevents.Behavior(mapEvents);\n    </script>\n</html> You have successfully completed 5 days our of 100DaysOfCodeWithHERE. If you have any questions about what we have covered in these 5 days, you can leave your questions in the comments here or tweet to us at @heredev . We have also released a video tutorial if you are more of a video person on our YouTube channel. Until then, happy coding!", "date": "2020-04-07"},
{"website": "Here", "title": "Requesting HERE OAuth Bearer Token Using Python", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/requesting-here-oauth-bearer-token-using-python", "abstract": "As you may have noticed, we have recently introduced two new options for authentication. You can now use either an API Key or an OAuth 2.0 Bearer Token to access the HERE Location APIs. While using an API Key is straightforward, using OAuth can be bit more complicated. However, it decouples authentication from authorization, meaning that applications can access resources without exposing their credentials. In this blog post we will learn how to request a HERE OAuth Bearer Token using Python. If you're not familiar with how OAuth works, you can think of it as a hotel key card system. If you have a card, you can use it to access your room. How do you get it? First, you have to get yourself authenticated at the hotel reception using your passport and your reservation. Then the hotel gives you a key card to access your room. However you can only access your room for the duration of your stay and access can be revoked at any time. The hotel key card in our case is a token, generated using OAuth. This token will allow us to access all HERE APIs. Lets get our token then! Generating OAuth Token Credentials The first step for acquiring a token is to generate OAuth credentials from developer.here.com . You can get the complete steps for generating credentials here . The 'credentials.properties' file created from above contains two values of interest, the Access Key ID and the Access Key Secret . We will be needing them going forward. A 'credentials.properties' file looks like this. here.user.id = HERE-USER_ID\nhere.client.id = YOUR_CLIENT_ID\nhere.access.key.id = YOUR_ACCESS_KEY\nhere.access.key.secret = YOUR_ACCESS_KEY_SECRET\nhere.token.endpoint.url = https://account.api.here.com/oauth2/token Creating the Oauth Signature For requesting a token, we need to pass the OAuth signature in the Authorization Header of a request. Signature plays an important role as it is used for authenticating a user or application. It requires us to create a base string containing various parameters and then pass it into an HMAC-SHA256 hashing algorithm. Creating the Parameter String We need 6 key-value pair for generating a signature grant_type - Value always remains same, \"client_credentials\" oauth_consumer_key - The Access Key ID value we acquired from credentials.properties file oauth_nonce - A unique string which never repeats oauth_signature_method - Always use \"HMAC-SHA256\" oauth_timestamp - The number of seconds since the Unix epoch, in simple words, the current time oauth_version - Always use \"1.0\" The values of the parameter looks like this. grant_type = 'client_credentials'\noauth_consumer_key = 'HERE.ACCESS.KEY.ID' #From credentials.properties file\noauth_nonce = str(int(time.time()*1000))\noauth_signature_method = 'HMAC-SHA256'\noauth_timestamp = str(int(time.time()))\noauth_version = '1.0' The important thing here is that the type of all 6 parameters has to be string. For calculating nonce and timestamp we have used the time module of Python. Next, we alphabetically combine all the parameters as a single string, separating each key value pair with an ampersand character (\"&\") and then URL-encoding it. def create_parameter_string(grant_type, oauth_consumer_key,oauth_nonce,oauth_signature_method,oauth_timestamp,oauth_version):\n    parameter_string = ''\n    parameter_string = parameter_string + 'grant_type=' + grant_type\n    parameter_string = parameter_string + '&oauth_consumer_key=' + oauth_consumer_key\n    parameter_string = parameter_string + '&oauth_nonce=' + oauth_nonce\n    parameter_string = parameter_string + '&oauth_signature_method=' + oauth_signature_method\n    parameter_string = parameter_string + '&oauth_timestamp=' + oauth_timestamp\n    parameter_string = parameter_string + '&oauth_version=' + oauth_version\n    return parameter_string\n\nparameter_string = create_parameter_string(grant_type, oauth_consumer_key,oauth_nonce,oauth_signature_method,oauth_timestamp,oauth_version)\n\nencoded_parameter_string = urllib.parse.quote(parameter_string, safe='') The parameter_string is a simple concatenated output containing key-value pair separated by an ampersand character. With the help of the urllib python library, we got our URL-encoded output in encoded_parameter_string . It looks like this. parameter_string grant_type=client_credentials&oauth_consumer_key=XXXXXXXXXX&oauth_nonce=1585745318447&oauth_signature_method=HMAC-SHA256&oauth_timestamp=1585745318&oauth_version=1.0 encoded_parameter_string grant_type%3Dclient_credentials%26oauth_consumer_key%3DXXXXXXXXXX%26oauth_nonce%3D1585745318447%26oauth_signature_method%3DHMAC-SHA256%26oauth_timestamp%3D1585745318%26oauth_version%3D1.0 Creating Signature Base String Next we need to add the HTTP method (POST), base URL and encoded parameter string into a single string called base string. url = 'https://account.api.here.com/oauth2/token'\n\nencoded_base_string = 'POST' + '&' + urllib.parse.quote(url, safe='')\nencoded_base_string = encoded_base_string + '&' + encoded_parameter_string Base string looks like this. POST&https%3A%2F%2Faccount.api.here.com%2Foauth2%2Ftoken&grant_type%3Dclient_credentials%26oauth_consumer_key%3DXXXXXXXXXX%26oauth_nonce%3D1585747084344%26oauth_signature_method%3DHMAC-SHA256%26oauth_timestamp%3D1585747084%26oauth_version%3D1.0 POST, URL and encoded parameter string separated by ampersand (\"&\") Creating Signing Key The signing key is the URL-encoded access key secret, followed by an ampersand (\"&\"). The access key secret is the value of \"here.access.key.secret\" property in credentials.properties file. access_key_secret = 'HERE.ACCESS.KEY.SECRET'#From credentials.properties file\nsigning_key = access_key_secret + '&' Combining all to create OAuth Signature The signature base string and the signing key created above, are passed to the HMAC-SHA256 Hashing Algorithm and the output is converted to a base64 string. Finally, we have our OAuth Signature. def create_signature(secret_key, signature_base_string):\n    encoded_string = signature_base_string.encode()\n    encoded_key = secret_key.encode()\n    temp = hmac.new(encoded_key, encoded_string, hashlib.sha256).hexdigest()\n    byte_array = b64encode(binascii.unhexlify(temp))\n    return byte_array.decode()\n\noauth_signature = create_signature(signing_key, encoded_base_string)\n\nencoded_oauth_signature = urllib.parse.quote(oauth_signature, safe='') The create_signature method takes secret key and base string as an input, performs hashing, converts the output into a base64 string. Then we URL-encode the output for further usage. Requesting Token Once we have our signature, the rest of the process is straight forward. All we require now is to create an Authorization header for the request and then make a request. For this, first we will combine - oauth_consumer_key - The value of \"here.access.key.id\" from credentials.properties file oauth_nonce - Already have oauth_signature - The value of encoded_oauth_signature from above oauth_signature_method - \"HMAC-SHA256\" oauth_timestamp - Already have oauth_version - \"1.0\" and append them to a string beginning with “OAuth”. body = {'grant_type' : '{}'.format(grant_type)}\n\nheaders = {\n            'Content-Type' : 'application/x-www-form-urlencoded',\n            'Authorization' : 'OAuth oauth_consumer_key=\"{0}\",oauth_nonce=\"{1}\",oauth_signature=\"{2}\",oauth_signature_method=\"HMAC-SHA256\",oauth_timestamp=\"{3}\",oauth_version=\"1.0\"'.format(oauth_consumer_key,oauth_nonce,encoded_oauth_signature,oauth_timestamp)\n          }\n    \nresponse = requests.post(url, data=body, headers=headers)\n\nprint(response.text) The request body must contain grant_type value as 'client_credentials', always. The output of the code looks like this- {\n\"access_token\":\"eyJhbGci...\",\n\"token_type\":\"bearer\",\n\"expires_in\":86399} The Complete Code A lot of libraries are needed to be imported which are not mentioned in the above steps. So lets see how the complete code looks like. import requests #Needed for making HTTP requests\nimport time #Needed to generate the OAuth timestamp\nimport urllib.parse #Needed to URLencode the parameter string\nfrom base64 import b64encode  #Needed for create_signature function\nimport hmac  #Needed for create_signature function\nimport hashlib #Needed for create_signature functionx\nimport binascii#Needed for create_signature function\n\ngrant_type = 'client_credentials'\noauth_consumer_key = 'HERE.ACCESS.KEY.ID' #From credentials.properties file\naccess_key_secret = 'HERE.ACCESS.KEY.SECRET'#From credentials.properties file\noauth_nonce = str(int(time.time()*1000))\noauth_timestamp = str(int(time.time()))\noauth_signature_method = 'HMAC-SHA256'\noauth_version = '1.0'\nurl = 'https://account.api.here.com/oauth2/token'\n\n# HMAC-SHA256 hashing algorithm to generate the OAuth signature\ndef create_signature(secret_key, signature_base_string):\n    encoded_string = signature_base_string.encode()\n    encoded_key = secret_key.encode()\n    temp = hmac.new(encoded_key, encoded_string, hashlib.sha256).hexdigest()\n    byte_array = b64encode(binascii.unhexlify(temp))\n    return byte_array.decode()\n    \n# concatenate the six oauth parameters, plus the request parameters from above, sorted alphabetically by the key and separated by \"&\"\ndef create_parameter_string(grant_type, oauth_consumer_key,oauth_nonce,oauth_signature_method,oauth_timestamp,oauth_version):\n    parameter_string = ''\n    parameter_string = parameter_string + 'grant_type=' + grant_type\n    parameter_string = parameter_string + '&oauth_consumer_key=' + oauth_consumer_key\n    parameter_string = parameter_string + '&oauth_nonce=' + oauth_nonce\n    parameter_string = parameter_string + '&oauth_signature_method=' + oauth_signature_method\n    parameter_string = parameter_string + '&oauth_timestamp=' + oauth_timestamp\n    parameter_string = parameter_string + '&oauth_version=' + oauth_version\n    return parameter_string\n   \nparameter_string = create_parameter_string(grant_type, oauth_consumer_key,oauth_nonce,oauth_signature_method,oauth_timestamp,oauth_version)\nencoded_parameter_string = urllib.parse.quote(parameter_string, safe='')\nencoded_base_string = 'POST' + '&' + urllib.parse.quote(url, safe='')\nencoded_base_string = encoded_base_string + '&' + encoded_parameter_string\n\n# create the signing key\nsigning_key = access_key_secret + '&'\n\noauth_signature = create_signature(signing_key, encoded_base_string)\nencoded_oauth_signature = urllib.parse.quote(oauth_signature, safe='')\n\n#---------------------Requesting Token---------------------\nbody = {'grant_type' : '{}'.format(grant_type)}\n\nheaders = {\n            'Content-Type' : 'application/x-www-form-urlencoded',\n            'Authorization' : 'OAuth oauth_consumer_key=\"{0}\",oauth_nonce=\"{1}\",oauth_signature=\"{2}\",oauth_signature_method=\"HMAC-SHA256\",oauth_timestamp=\"{3}\",oauth_version=\"1.0\"'.format(oauth_consumer_key,oauth_nonce,encoded_oauth_signature,oauth_timestamp)\n          }\n    \nresponse = requests.post(url, data=body, headers=headers)\n\nprint(response.text) Conclusion The value of access token is our actual token, and it is valid for 24 Hour. You can use token to make all HERE API calls.  Although you can continue to use API Key if you like, but if you want to go for a production environment, OAuth is the right way.", "date": "2020-04-07"},
{"website": "Here", "title": "March 2020 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/january-2020-release-notes-0-0-0", "abstract": "Welcome to the latest announcements for the HERE Location Services. This post covers the D115 release of HERE Location Services. This release includes updates of: Routing API, Maps API for JavaScript, Geocoder API, Batch Geocoder API, Tracking, Fleet Telematics API, HERE SDK for Android and iOS and Map Data for Mobile SDK . The release is a maintenance release. For more detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation on the Developer Portal . HERE Location Services on Platform Routing API (Version 8.1.2) Added elevation value for return parameter. You will find the Release Notification on the Developer Portal . HERE SDK for Android and iOS (Lite Edition) ( Version 4.2.2.0) Added a TileServerProvider interface that allows a custom implementation to generate dynamic URLs for a RasterLayer . This can be useful to set different raster layer sources based on the region in the world. Added SimpleTileServerProvider as a convenience implementation that sets a static tile URL provider. HERE SDK for Android and iOS (Explore Edition) ( Version 4.2.1.0) Added new built in map schemes: MapScheme.GREY_DAY and MapScheme.GREY_NIGHT. Added two new layer names: TRAFFIC_FLOW and TRAFFIC_INCIDENTS to the MapScene. Layers struct to be used for switching on/off traffic flow and incidents. Added SVG support with MapImage constructor that supports SVG Tiny images. Added MapImageFactory.fromFile factory method for creating map images from SVG Tiny map images. Maps API for JavaScript ( Version 3.1.14.0) The new Geocoding and Search API v7 and Routing API v7 REST services were added. We enabled the ability to store vector tiles, provided by the Vector Tile API, for offline use. The performance of style updates of the map objects was improved. HERE Location Services Fleet Telematics API ( Version 3.0.29) Reach waypoint on the correct side of street. Legal driver rest times can be automatically considered for the current country. In addition to the total vehicle gross weight and weight per axle, now also the weight per tandem axle can be specified. Route summary per country (distance and travel time). If toll calculation/optimization is active than the country summary will also contain the tollRoadDistance . Routing API ( Version 7.2.114) Added an option to consider side of street when arriving at a waypoint Tracking 1.6.1 We added support for Tracking Projects created through admin.tracking.here.com. We added new APIs for fetching metadata of resources. The following services had new releases with minor changes: Geocoder API version 6.2.60 Batch Geocoder API version 6.2. 60 Map Data for Mobile SDK (Version 8.30.106.154, March 2020)", "date": "2020-04-15"},
{"website": "Here", "title": "Migrating from Google Places to HERE Geocoding and Search", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/migrating-from-google-places-to-here-geocoding-and-search", "abstract": "If you're a current user of Google's Places service, you may be interested in switching over to HERE's Geocoding and Search product. We recently did a pretty big update to the service (see Touring our New Geocoding and Search API for some examples) so now is a great time to talk about how developers can migrate from one to the other. Broadly speaking, Google's Places API is split across a few different services: Place Search and Details - lets you either search for locations based on text input and/or location or returns information about one particular location. Autocomplete - which provides both matches for an input as well as possible query terms to suggest. Photos - returns photos of locations. In this guide I'm going to focus on the first of the two features above. Currently we do not support photos of locations but we constantly look for ways to improve our APIs and data so be sure to check later. Let's begin by talking about search. Finding Locations Google's place search is broken across multiple different APIs: \"Find Place\" , which takes user input and returns one place. \"Nearby Search\" , which takes a location and optional user input to return a list of places. \"Text Search\" , which takes user input that may or may not contain partial address information along with option location data and attempts to find places that match. What is returned for each service is a bit different. Find Place returns the bare minimum by default unless you ask or additional fields. Some fields are \"free\" (no additional charge outside of the regular API cost) but then there are two \"levels\" of fields with increasing costs. The later two APIs return more information in their results which touch upon the higher tier pricing. Their documentation includes this warning to that effect: \"Nearby Search and Text Search return all of the available data fields for the selected place (a subset of the supported fields), and you will be billed accordingly There is no way to constrain Nearby Search or Text Search to only return specific fields. To keep from requesting (and paying for) data that you don't need, use a Find Place request instead.\" Unfortunately, as stated above \"Find Place\" does just that, returns \"a\" place. Their docs for nearby search pricing say this: Nearby Search requests return a list of places, but do not support specifying which fields are returned. Nearby Search requests return a subset of the supported data fields. You are charged for the Nearby Search request starting at 0.032 USD per each, as well as all of the data-type SKUs (Basic Data, Contact Data, and Atmosphere Data). So to be clear, that's a cost for using the API as well as a cost for getting additional data about locations found. Conversely, HERE does not charge for particular fields of data in our results and will only charge based on use of the API itself. With that out of the way, let's consider a few common scenarios and compare how to do them in Google Places versus HERE. We'll consider the following examples: Based on my location (which we will hard code to the same value), look for the string \"cajun\". Based on my location (again, hard coded to a value), look for the string \"cajun\" and specify a restaurant filter. Given one result, ask for details. Let's start with the inital example, finding places with the string \"cajun\" using the Google Places API, Nearby Search. Your URL could look like so: https://maps.googleapis.com/maps/api/place/nearbysearch/json?key=KEY&keyword=cajun&location=30.22,-92.02&radius=5000 Outside of the key, the important bits are the keyword , location , and radius values. The result object below shows the result with most of the results removed to keep the size down a bit. {\n   \"html_attributions\": [],\n   \"results\": [\n      {\n         \"geometry\": {\n            \"location\": {\n               \"lat\": 30.230667,\n               \"lng\": -92.030914\n            },\n            \"viewport\": {\n               \"northeast\": {\n                  \"lat\": 30.23192767989273,\n                  \"lng\": -92.02973862010728\n               },\n               \"southwest\": {\n                  \"lat\": 30.22922802010729,\n                  \"lng\": -92.03243827989273\n               }\n            }\n         },\n         \"icon\": \"https://maps.gstatic.com/mapfiles/place_api/icons/restaurant-71.png\",\n         \"id\": \"0c0d0de636f6a00c591ead4014591c036671da3f\",\n         \"name\": \"Julien's Po Boys\",\n         \"opening_hours\": {\n            \"open_now\": true\n         },\n         \"photos\": [\n            {\n               \"height\": 2979,\n               \"html_attributions\": [\n                  \"<a href=\\\"https://maps.google.com/maps/contrib/101792845719304682703\\\">Julien's Po-Boys</a>\"\n               ],\n               \"photo_reference\": \"CmRaAAAAjssr4VOcn7z5RiA6vXB_a1lcJwUOcakkV_RZ_oTLdNiXga_u7p0W0PbS0BhrCBSMo9ZgEVlcc9XttwQ4Ma7qHRgWKhNGuYB13U8EtNpyQn1c8_7iCCuzL9w5UjYyCXghEhDDByB796grq_v63n4MTG2VGhRVPluVxc25vi-JNzLzf4dv3pv65g\",\n               \"width\": 3024\n            }\n         ],\n         \"place_id\": \"ChIJa2a_l36cJIYRwXBcb1idJ3g\",\n         \"plus_code\": {\n            \"compound_code\": \"6XJ9+7J Lafayette, Parish Governing Authority District B, LA\",\n            \"global_code\": \"86296XJ9+7J\"\n         },\n         \"price_level\": 2,\n         \"rating\": 4,\n         \"reference\": \"ChIJa2a_l36cJIYRwXBcb1idJ3g\",\n         \"scope\": \"GOOGLE\",\n         \"types\": [\n            \"restaurant\",\n            \"food\",\n            \"point_of_interest\",\n            \"establishment\"\n         ],\n         \"user_ratings_total\": 182,\n         \"vicinity\": \"1900 W University Ave, Lafayette\"\n      },\n\t  // ITEMS REMOVED HERE!\n   ],\n   \"status\": \"OK\"\n} HERE provides two separate search APIs. Discover is used for free form text searching where results are ranked by how well they match the search term. Browse supports searching as well but is better suited for finding results within categories. Browse results are always sorted by distance. For this first use case, it makes sense to use Discover. Here's how that URL would look: https://discover.search.hereapi.com/v1/discover?apikey=KEY&q=cajun&at=30.22,-92.02 The two important parameters here are q and at . Note that the Google API requires a center location and a radius. HERE's API can support that as well by using the in parameter instead. https://discover.search.hereapi.com/v1/discover?apikey={{apiKey}}&q=cajun&in=circle:30.22,-92.2;r=5000 See our API docs for more information about the in parameter and others. Here's the result of the above call, again with many entries removed to keep the size down a bit. {\n    \"items\": [\n        {\n            \"title\": \"Lucky Deuces Casino\",\n            \"id\": \"here:pds:place:8403fv6k-895e95ca19bf067af48f3b2a6ba50ada\",\n            \"resultType\": \"place\",\n            \"address\": {\n                \"label\": \"Lucky Deuces Casino, 3002 Daulat Dr, Duson, LA 70529, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Louisiana\",\n                \"county\": \"Acadia\",\n                \"city\": \"Duson\",\n                \"street\": \"Daulat Dr\",\n                \"postalCode\": \"70529\",\n                \"houseNumber\": \"3002\"\n            },\n            \"position\": {\n                \"lat\": 30.24588,\n                \"lng\": -92.19461\n            },\n            \"access\": [\n                {\n                    \"lat\": 30.24535,\n                    \"lng\": -92.1946\n                }\n            ],\n            \"distance\": 2924,\n            \"categories\": [\n                {\n                    \"id\": \"100-1000-0000\"\n                },\n                {\n                    \"id\": \"200-2300-0021\"\n                },\n                {\n                    \"id\": \"600-6000-0061\"\n                }\n            ],\n            \"foodTypes\": [\n                {\n                    \"id\": \"101-070\"\n                }\n            ],\n            \"contacts\": [\n                {\n                    \"phone\": [\n                        {\n                            \"value\": \"+13378735400\"\n                        },\n                        {\n                            \"value\": \"+13378738500\"\n                        }\n                    ],\n                    \"www\": [\n                        {\n                            \"value\": \"http://www.lucky2s.com/\"\n                        }\n                    ],\n                    \"email\": [\n                        {\n                            \"value\": \"luckydeucescasino@gmail.com\"\n                        }\n                    ]\n                }\n            ],\n            \"openingHours\": [\n                {\n                    \"text\": [\n                        \"Mon-Sun: 00:00 - 00:30\"\n                    ],\n                    \"isOpen\": true,\n                    \"structured\": [\n                        {\n                            \"start\": \"T000000\",\n                            \"duration\": \"PT00H30M\",\n                            \"recurrence\": \"FREQ:DAILY;BYDAY:MO,TU,WE,TH,FR,SA,SU\"\n                        }\n                    ]\n                }\n            ]\n        },\n\t\t// ITEMS REMOVED HERE\n    ]\n} In terms of data returned, consider the following changes: At a top level, items in Google's API are found at the results level. For HERE it is in items. Result locations for Google are found at the geometry property. For HERE it is at position. Google does not return a human-readable address. HERE returns it as the address property. Google returns photos. As stated above, this is not a feature of our API (yet). Google returns a property, opening_hours.open_now which tells you if the location is open. The HERE API returns that as well as both human-readable hours open and machine parseable versions. Google doesn't return any contact information. HERE returns multiple forms of contact when available. Google returns information about the type of result in a types array. HERE returns an array of categories. Unfortunately they are in id form and you would need to translate them in your code. This will be improved soon! For restaurants, an additional array named foodTypes is returned. You can find documentation for all id values here . Now let's consider another example, imeplenting a category filter. In Google's Places API, this is done via the type parameter. Here's how you would search for \"cajun\" within the restaurant category: https://maps.googleapis.com/maps/api/place/nearbysearch/json?key=KEY&keyword=cajun&location=30.22,-92.02&radius=5000 &type=restaurant For HERE, you first need to figure out the category ID. You can find these documented here: Places Categories and Cuisines . The category ID for restaurant is 100-1000-0000. Therefore the URL would look like so: https://browse.search.hereapi.com/v1/browse?apiKey=KEY&at=30.22,-92.02&categories=100-1000-0000&name=cajun However, we support an *extremely* detailed food type categorization system as well. In that system you'll see there is a category, 101-070, that represents \"American-Cajun\". This means we can remove \"cajun\" from the text paramter and use the more specific ID instead: https://browse.search.hereapi.com/v1/browse?apiKey=KEY&at=30.22,-92.02&categories=101-070 What about detail results? As described above, Google will return subsets of fields based on the type of search being used. They have a Place Details API to return more information, but again be aware of the different billing used for what fields are returned. HERE does have an API to return specifics on one particular location ( Lookup ), but as our search APIs return the same information, you probably do not need to use this. (One small note, when searching you may get one additional field, distance , that you do not get in the lookup API. It wouldn't make sense there.) Keeping in mind you probably won't need to, here's how you would migrate a call from Google to HERE. First, the Google Places request: https://maps.googleapis.com/maps/api/place/details/json?place_id=ChIJ65TLvh2dJIYRPFNC6EsaGqM&fields=name,rating,formatted_phone_number&key=KEY Note that specific fields are requested. If you do not pass the fields parameter, all fields are returned. (But again, remember you may be charge more for the call.) Using the Lookup API, your request would look like so: https://lookup.search.hereapi.com/v1/lookup?apikey=KEY&id=here:pds:place:8409vqef-c2e32cec334649f694d4e8ca75f8914a It's probably obvious, but you can't use ID values from Google Places data to look up data in HERE's database. Autosuggest Both Google and HERE support an \"autosuggest\" feature that attempts to match partial user input, like \"caj\" to places of interest that match the term as well as fall within a certain range to be close enough to the user making the request. As the user types, the results should become even more helpful (hopefully) in terms of anticipating what the user is trying to find. For both Google and HERE, you have access to a simple REST-based API to make direct network requests as well as a client-side library for mobile platforms and JavaScript. Here is an example of Google's REST-based API for autosuggest: https://maps.googleapis.com/maps/api/place/autocomplete/json?input=caj&key=KEY&location=30.22,-92.02&radius=5000 Here's the corresponding version in HERE's autosuggest API: https://autosuggest.search.hereapi.com/v1/autosuggest?apikey=KEY&q=${encodeURIComponent(text)}&at=30.22,-92.02 The main differences are changing input to q and location to at . As a reminder, HERE's services also let you specify circular ranges with a radius if you wish. Because of the complexity of how your map may be built, we can't offer a simple replacement for using autosuggest with JavaScript applications, but you can see an example of that integration in our docs. Wrap Up Hopefully this migration article has explained how to transition from Google's APIs to our own, but if you need more help there's plenty of resources to be found. Be sure to check the documentation when you get started. You can join our developer community on Slack or ask your question on StackOverflow and someone from HERE or the community will reply.", "date": "2020-04-13"},
{"website": "Here", "title": "Integrating Your Call Center with Location Services", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/integrating-your-call-center-with-location-services", "abstract": "Over the past few weeks I've been doing some digging into the RingCentral suite of APIs. RingCentral provides APIs focused on messaging, everything from phone and SMS handling to group chat. You can explore their APIs more in depth on their developer site . When I first started playing around with their APIs, I focused more on the SMS aspect as that's something (texting I mean) that I tend to use every day. But then I started looking more into their call handling (you know, voice calls) features and I saw some interesting possibilities. One API in particular seemed interesting to me - the Call Log . As you can imagine, this API provides the ability to search for calls made to and from a phone number. It provides an incredible amount of detail on each call, including information about who the call was made to or who it was from. This information includes the geographic location for the call which immediately made me think of how I could integrate it with our own APIs. I thought it would be fun to build a demo that combined both the RingCentral API suite and our tools. In order to replicate what I've built, you will want to sign up for a free RingCentral developer account . Once you've done that, you can spend some time in their Getting Started guide to familiarize yourself with their developer portal. You will need to have at least one developer application using the \"Read Call Log\" permission as well. The RingCentral folks did a great job with their documentation so I won't repeat it here, but know that while I'll be demonstrating their API with JavaScript, you can use any language you want for your development. Finally, in order to get some data, I actually made calls both to and from the developer number you get as part of their system. I'll warn you now my data is going to be a bit boring, but obviously in real world conditions you'll have a lot more interesting data to play with. To work with our APIs, you'll want to sign up for a free developer account here as well. You'll then need to add an API key to use with our REST-based APIs. Both we and RingCentral provide a very generous free tier so you can just keep your credit card put away! Alright, so once you've got your developer accounts set up, how can we integrate the two services? First, let's demonstrate what we're going to build. Given that RingCentral's Call Log API tells you from where a call came or to where a call was placed, our demo is simply going to map all of these locations on a map. Remembering that I said my data is a bit boring and limited, here's how it looks when rendered on a map: Building this required two main steps. First, I built a serverless endpoint to load the call log for an account. This was done with RingCentral's API. Then I built a serverless endpoint to translate each call record's location into a geographic location. This was done with our Geocoding API . As for how I used the serverless aspect, I used Netlify Functions and a simple static web site. I discussed this in depth a few days ago in this blog post: Create Your Own Geocode Serverless Application - on the JAMStack . Definitely take a minute or two to look over that post if you're unfamiliar with integrating APIs and the JAMStack. Now that we know what we are building and how we're building it, let's look at the components. The first thing I'll share is the serverless endpoint to retrieve a call log. The API reference provides information about arguments and result types. For my call, I specified that I wanted \"Detailed\" information (which as you can guess will return as much information as possible) and that I wanted all calls placed since January 1, 2020. This was somewhat arbitrary. In a real production environment you would probably have a different date set. So for example, I'd imagine limiting your data to one week or one month. I also used their pagination support to return as many calls as possible. I had a bit of difficulty with their docs in this one particular area so I'll warn folks now that the \"fetch data and keep fetching while there's more\" aspect may not be perfect. With that out of the way, here's the code I built. const fetch = require('node-fetch');\n\nconst SDK = require('@ringcentral/sdk').SDK;\n\nRINGCENTRAL_CLIENTID = 'your client id';\nRINGCENTRAL_CLIENTSECRET = 'your client secret';\nRINGCENTRAL_SERVER = 'https://platform.devtest.ringcentral.com';\nRINGCENTRAL_USERNAME = 'a ring central phone number';\nRINGCENTRAL_PASSWORD = 'my password brings all the boys to the yard';\nRINGCENTRAL_EXTENSION = '101';\nvar rcsdk = new SDK({\n    server: RINGCENTRAL_SERVER,\n    clientId: RINGCENTRAL_CLIENTID,\n    clientSecret: RINGCENTRAL_CLIENTSECRET\n});\nconst platform = rcsdk.platform();\n\nexports.handler = async function(event, context) {\n\n  await rcLogin();\n  let callLog = await rcCallLog();\n\n  return {\n    headers: {\n      \"Content-Type\":\"application/json\"\n    },\n    statusCode: 200,\n    body: JSON.stringify(callLog)\n  }\n\n}\n\nasync function rcLogin() {\n  return platform.login({\n    username: RINGCENTRAL_USERNAME,\n    password: RINGCENTRAL_PASSWORD,\n    extension: RINGCENTRAL_EXTENSION\n  });\n}\n\nasync function rcCallLog() {\n \n  let result = [];\n  let hasMore = true;\n  let page = 1;\n  let perPage = 100;\n  let url = '/restapi/v1.0/account/~/extension/~/call-log';\n  while(hasMore) {\n    let resp = await platform.get(url, {\n      view: 'Detailed',\n      dateFrom:'2020-01-1',\n      perPage:perPage,\n      page:page\n    });\n    let data = await resp.json();\n    result = result.concat(data.records);\n    if(data.navigation.firstPage.uri !== data.navigation.lastPage.uri) {\n      page++;\n    } else hasMore = false;\n  }\n  return result;\n\n} This function makes use of the RingCentral JavaScript SDK to simplify calls to the API. It's a good API wrapper and I definitely suggest using it. With the SDK I make a call to log the account in and then fetch the call log. This particular demo is tied to one phone number and password but could be expanded to be more dynamic. The end result is an array of call data. Here's what one call looks like, and as I said, it's quite detailed. {\n\t\"uri\": \"https://platform.devtest.ringcentral.com/restapi/v1.0/account/272299004/extension/272299004/call-log/AMc4eBTIRS_3DUA?view=Detailed\",\n\t\"id\": \"AMc4eBTIRS_3DUA\",\n\t\"sessionId\": \"9407926005\",\n\t\"startTime\": \"2020-03-10T19:10:38.547Z\",\n\t\"duration\": 161,\n\t\"type\": \"Voice\",\n\t\"direction\": \"Outbound\",\n\t\"action\": \"RingOut PC\",\n\t\"result\": \"Call connected\",\n\t\"to\": {\n\t\t\"phoneNumber\": \"+15044446512\",\n\t\t\"location\": \"New Orleans, LA\"\n\t},\n\t\"from\": {\n\t\t\"name\": \"Raymond Camden\",\n\t\t\"phoneNumber\": \"+14703177709\",\n\t\t\"extensionId\": \"272299004\"\n\t},\n\t\"extension\": {\n\t\t\"uri\": \"https://platform.devtest.ringcentral.com/restapi/v1.0/account/272299004/extension/272299004\",\n\t\t\"id\": 272299004\n\t},\n\t\"telephonySessionId\": \"s-661473cc51ba4c33ac7c88faf3774676\",\n\t\"transport\": \"PSTN\",\n\t\"lastModifiedTime\": \"2020-03-10T19:13:40.033Z\",\n\t\"billing\": {\n\t\t\"costIncluded\": 0,\n\t\t\"costPurchased\": 0\n\t},\n\t\"legs\": [\n\t\t{\n\t\t\t\"startTime\": \"2020-03-10T19:10:17.260Z\",\n\t\t\t\"duration\": 183,\n\t\t\t\"type\": \"Voice\",\n\t\t\t\"direction\": \"Outbound\",\n\t\t\t\"action\": \"RingOut PC\",\n\t\t\t\"result\": \"Accepted\",\n\t\t\t\"to\": {\n\t\t\t\t\"phoneNumber\": \"+13374128987\",\n\t\t\t\t\"location\": \"Lafayette, LA\"\n\t\t\t},\n\t\t\t\"from\": {\n\t\t\t\t\"name\": \"Raymond Camden\",\n\t\t\t\t\"phoneNumber\": \"+15044446512\",\n\t\t\t\t\"extensionId\": \"272299004\"\n\t\t\t},\n\t\t\t\"extension\": {\n\t\t\t\t\"uri\": \"https://platform.devtest.ringcentral.com/restapi/v1.0/account/272299004/extension/272299004\",\n\t\t\t\t\"id\": 272299004\n\t\t\t},\n\t\t\t\"reason\": \"Accepted\",\n\t\t\t\"reasonDescription\": \"The call connected to and was accepted by this number.\",\n\t\t\t\"telephonySessionId\": \"s-661473cc51ba4c33ac7c88faf3774676\",\n\t\t\t\"transport\": \"PSTN\",\n\t\t\t\"billing\": {\n\t\t\t\t\"costIncluded\": 0,\n\t\t\t\t\"costPurchased\": 0\n\t\t\t},\n\t\t\t\"legType\": \"RingOutClientToSubscriber\"\n\t\t},\n\t\t{\n\t\t\t\"startTime\": \"2020-03-10T19:10:38.547Z\",\n\t\t\t\"duration\": 161,\n\t\t\t\"type\": \"Voice\",\n\t\t\t\"direction\": \"Outbound\",\n\t\t\t\"action\": \"RingOut PC\",\n\t\t\t\"result\": \"Call connected\",\n\t\t\t\"to\": {\n\t\t\t\t\"phoneNumber\": \"+15044446512\",\n\t\t\t\t\"location\": \"New Orleans, LA\"\n\t\t\t},\n\t\t\t\"from\": {\n\t\t\t\t\"name\": \"Raymond Camden\",\n\t\t\t\t\"phoneNumber\": \"+14703177709\",\n\t\t\t\t\"extensionId\": \"272299004\"\n\t\t\t},\n\t\t\t\"extension\": {\n\t\t\t\t\"uri\": \"https://platform.devtest.ringcentral.com/restapi/v1.0/account/272299004/extension/272299004\",\n\t\t\t\t\"id\": 272299004\n\t\t\t},\n\t\t\t\"telephonySessionId\": \"s-661473cc51ba4c33ac7c88faf3774676\",\n\t\t\t\"transport\": \"PSTN\",\n\t\t\t\"legType\": \"RingOutClientToCaller\",\n\t\t\t\"master\": true\n\t\t}\n\t]\n} That's a whole heaping mess of data! What we care about though falls into three sections. First is \"direction\" - this will be either \"Outbound\" or \"Inbound\". Once we know the direction, we either look at \"to\" for \"Outbound\" calls or \"from\" for \"Inbound\" calls. We will always (as far as my testing shows) have a \"location\" field we can use. In the example above you can see it's \"New Orleans, LA\". This brings us to our next part - our Geocoding API . This API lets us pass a value like the location above and get back a longitude and latitude value. In my previous blog post I built this endpoint already, but here it is again: /* eslint-disable */\nconst fetch = require('node-fetch')\n\nconst HERE_API_KEY = process.env.HERE_API_KEY;\n\nexports.handler = async function(event, context) {\n\n  let location = event.queryStringParameters.location;\n  if(!location) {\n    return {\n      statusCode:500,\n      body: 'Must pass location parameters.'\n    }\n  }\n\n  let locationPosition = await getLocation(location);\n\n  return {\n    headers: {\n      'Content-Type':'application/json'\n    },\n    statusCode: 200,\n    body: JSON.stringify(locationPosition)\n  }\n}\n\nasync function getLocation(x) {\n   let url = `https://geocode.search.hereapi.com/v1/geocode?q=${encodeURIComponent(x)}&apikey=${HERE_API_KEY}`;\n   let response = await fetch(url);\n   let data = await response.json();\n   // assume first result\n   return data.items[0].position;\n} This endpoint takes in one argument via the query string, \"location\", and then uses the Geocoding API to return the position. When run with the location \"Lafayette, LA\", here's the result: {\"lat\":30.22032,\"lng\":-92.01705} Now that we've got the serverless functions up and running. The last thing we need to do is visualize it. For that we'll use our Maps JavaScript library. I set up a quick HTML page with just a div for the map. I then used this JavaScript to setup and initialize the map. const KEY = 'my key';\nvar platform = new H.service.Platform({\n\t'apikey': KEY\n});\n\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n\tdocument.getElementById('mapContainer'),\n\tdefaultLayers.vector.normal.map,\n\t{\n\t\tzoom: 5,\n\t\tcenter: { lat: 30.22, lng: -92.02 },\n\t\tpixelRatio: window.devicePixelRatio || 1\n\t}\n);\n\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\nvar ui = H.ui.UI.createDefault(map, defaultLayers); This map is centered on Louisiana to make it a bit nicer for my particular needs, but you could center it in America, or show the entire globe. Next it's time to load data and render the markers on the map: loadData(map);\n\nasync function loadData(map) {\n\t// first get my call log\n\tlet callLogResp = await fetch('/.netlify/functions/callLog');\n\tlet callLog = await callLogResp.json();\n\t// Ok, now to geocode\n\t// credit for this - https://medium.com/@antonioval/making-array-iteration-easy-when-using-async-await-6315c3225838\n\tconst pArray = callLog.map(async l => {\n\t\tlet loc = '';\n\t\tif(l.direction === 'Outbound') {\n\t\t\tloc = l.to.location;\n\t\t} else {\n\t\t\tloc = l.from.location;\n\t\t}\n\t\tconst geocodeRequest = await fetch('/.netlify/functions/getGeocode?location='+loc);\n\t\treturn geocodeRequest.json();\n\t});\n\tconst geoData = await Promise.all(pArray);\n\n    /*\n\tOk, at this point, callLog is an array of calls and geoData is corresponding array of locations.\n\tLet's add our markers\n\t*/\n\tlet group = new H.map.Group();\n\tmap.addObject(group);\n\tgroup.addEventListener('tap', evt => {\n\t\tvar bubble =  new H.ui.InfoBubble(evt.target.getGeometry(), {\n\t\t\tcontent: evt.target.getData()\n\t\t});\n\t\tui.addBubble(bubble);\n\t}, false);\n\n\tfor(let i=0; i<callLog.length; i++) {\n\t\tlet marker = new H.map.Marker({lat:geoData[i].lat, lng:geoData[i].lng});\n\t\tmarker.setData(`\n${callLog[i].direction} Call\n\t\t`);\n\t\tgroup.addObject(marker);\n\t}\n} Alright, lets break this down. The loadData function begins by calling the endpoint that gets the call log. Next we need to iterate over the results and geocode each one. Notice how we check the direction of the call to determine where the address is. Once we have all our data, we can then iterate and generate markers for each. For my markers I simply added the direction. You can see the marker in action here: Remember that the call log contains a lot of information. We could definitely add more to the marker here to make it more interesting. In fact, there's a whole slew of things that would be easy to do to make this more useful: Instead of showing every call with the same marker, we could use different markers for in versus out-bound calls. We could differentiate based on time. For example, I assume that a call center would get more calls from the east coast early in the morning since they wake up first. As the day goes on, I'd expect call volumes to gradually move west. But I may be wrong. Our Maps library would definitely make it possible to show and hide markers based on a time filter. We could differentiate locations that get larger volumes of calls. Right now it's just one marker per location, but if we use different icons to represent the level of calls, it would better highlight what geographic regions are more important to our business. I hope this example has been useful and I absolutely encourage you to look out for other ways to integrate our APIs with other services!", "date": "2020-04-10"},
{"website": "Here", "title": "Touring our New Geocoding and Search API", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/touring-our-new-geocoding-and-search-api", "abstract": "A few months back, we released a new version of our Places (Search) API. While the older version is still supported, developers looking to add location-based search to their applications should absolutely take a look at our new Geocoding and Search APIs. In this article I'm going to give you a quick tour of some of the cooler parts of the updated APIs. Then I'm going to wrap with an example application I call - \"Plan a Night\" - it's going to use a bit of randomness to find places to go out near you, once, you know, we're actually allowed to go out again! I'm going to cover three main aspects of the API covering three unique features - our autosuggest API, our discover API, and our browse API. Lets start off by talking about autosuggest . This feature let's users type in search terms in a free form manner. Our API will then attempt to find matches, being forgiving of mispellings and partial entries. While you can (and should) check the API reference , a typical autosuggest request will pass a search term and a geograpic filter that's either a simple center point, or a \"region\" defined by politcal boundries, a circle around a point with a radius, or a custom box. To keep things simple, here's how you would search for \"cagun\" (again, I'm mispelling on purpose) results focused around my home town: https://autosuggest.search.hereapi.com/v1/autosuggest?at=30.22,-92.02&limit=10&apikey={{apiKey}}&q=cagun This returns an array of items. Here's one item just as an example: {\n\t\"title\": \"Cajun Field\",\n\t\"id\": \"here:pds:place:8409vqec-5d50a5b72bcb4a65ad229f272ae12965\",\n\t\"resultType\": \"place\",\n\t\"address\": {\n\t\t\"label\": \"Cajun Field, 201 Reinhardt Dr, Lafayette, LA 70506-4252, United States\",\n\t\t\"countryCode\": \"USA\",\n\t\t\"countryName\": \"United States\",\n\t\t\"state\": \"Louisiana\",\n\t\t\"county\": \"Lafayette\",\n\t\t\"city\": \"Lafayette\",\n\t\t\"street\": \"Reinhardt Dr\",\n\t\t\"postalCode\": \"70506-4252\",\n\t\t\"houseNumber\": \"201\"\n\t},\n\t\"position\": {\n\t\t\"lat\": 30.21459,\n\t\t\"lng\": -92.04069\n\t},\n\t\"access\": [\n\t\t{\n\t\t\t\"lat\": 30.21422,\n\t\t\t\"lng\": -92.04045\n\t\t}\n\t],\n\t\"distance\": 2077,\n\t\"categories\": [\n\t\t{\n\t\t\t\"id\": \"800-8400-0000\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"800-8600-0180\"\n\t\t}\n\t],\n\t\"highlights\": {\n\t\t\"title\": [\n\t\t\t{\n\t\t\t\t\"start\": 0,\n\t\t\t\t\"end\": 5\n\t\t\t}\n\t\t],\n\t\t\"address\": {\n\t\t\t\"label\": [\n\t\t\t\t{\n\t\t\t\t\t\"start\": 0,\n\t\t\t\t\t\"end\": 5\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n} There's a lot to digest here but I'll point out the most crucial (in my opinion) aspects below: First is the title. This is typically what you would display to the user. Next is the address and position values. The address is what you would show to the user and position would be used with our maps. The distance to the result in meters, you know, the unit of measurement pretty much the entire planet uses. And then categories, which lets you determine the type of place the item is. Categories get pretty deep and you can find documentation for them here . There's one more aspect of the result you may want to pay attention to - the resultType. In the above example you can see it's \"place\". Other values like \"unit\" and \"locality\" exist, but one in particular may be useful - \"categoryQuery\". When your item is of this type, it's like the API suggesting you browse within a particular category of results. In fact, this type of item will have an \"href\" property. Here's an example: https://autosuggest.search.hereapi.com/v1/discover?q=restaurants&_ontology=restaurant&at=30.22%2C-92.02 You can use this URL to request items that match the category and still find results based on the location of the initial search. Do note though that the apikey value is not present and you'll have to add that manually. Want to see it in action? Check out the full, if simple, demo below. It uses Vue.js to search as you type in a field. This particular demo is tied to my geographic location but you could easily modify it to use the browser's Geolocation API to use your current position. (Or if you're a mapping nerd like I'm turning into, you may know your latitude and longitude already. ;) See the Pen HERE Autosuggest by Raymond Camden ( @cfjedimaster ) on CodePen . Alright, now let's turn our attention to the two other aspects of this new product, Discover and Browse. These are somewhat similar APIs and which you use will depend on your exact need. Discover is used when want the user to type in a search term to find results. This search term can be very broad and understands things like proximity (X near Y) and even chains. This allows for neat things like asking for a bank near a Subway. Browse is used more often when you have a specific category in mind. While you can still combine this with a textual search, you would use this when you know what type of result you want, so for example, all night clubs that have \"beer\" in their name. To help bring this home a bit, let's look at a few example of each. First, let's search for comic books near my location: https://discover.search.hereapi.com/v1/discover?q=comic books&at=30.22,-92.02 As with autosuggest, the result is an array of items, here's one as an example: {\n\t\"title\": \"Acadiana Comic & Collectibles\",\n\t\"id\": \"here:pds:place:8409vqec-2b1784049740487cb6fba868184132d7\",\n\t\"resultType\": \"place\",\n\t\"address\": {\n\t\t\"label\": \"Acadiana Comic & Collectibles, 2506 Johnston St, Lafayette, LA 70503-3238, United States\",\n\t\t\"countryCode\": \"USA\",\n\t\t\"countryName\": \"United States\",\n\t\t\"state\": \"Louisiana\",\n\t\t\"county\": \"Lafayette\",\n\t\t\"city\": \"Lafayette\",\n\t\t\"street\": \"Johnston St\",\n\t\t\"postalCode\": \"70503-3238\",\n\t\t\"houseNumber\": \"2506\"\n\t},\n\t\"position\": {\n\t\t\"lat\": 30.20875,\n\t\t\"lng\": -92.03577\n\t},\n\t\"access\": [\n\t\t{\n\t\t\t\"lat\": 30.20861,\n\t\t\t\"lng\": -92.0357\n\t\t}\n\t],\n\t\"distance\": 1965,\n\t\"categories\": [\n\t\t{\n\t\t\t\"id\": \"600-6700-0087\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"600-6900-0103\"\n\t\t}\n\t],\n\t\"contacts\": [\n\t\t{\n\t\t\t\"phone\": [\n\t\t\t\t{\n\t\t\t\t\t\"value\": \"+13372349639\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"email\": [\n\t\t\t\t{\n\t\t\t\t\t\"value\": \"acadianacomics@att.net\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t],\n\t\"openingHours\": [\n\t\t{\n\t\t\t\"text\": [\n\t\t\t\t\"Tue: 11:00 - 16:00\",\n\t\t\t\t\"Wed: 10:00 - 19:00\",\n\t\t\t\t\"Thu, Fri: 11:00 - 19:00\",\n\t\t\t\t\"Sat: 11:00 - 15:00\"\n\t\t\t],\n\t\t\t\"isOpen\": false,\n\t\t\t\"structured\": [\n\t\t\t\t{\n\t\t\t\t\t\"start\": \"T110000\",\n\t\t\t\t\t\"duration\": \"PT05H00M\",\n\t\t\t\t\t\"recurrence\": \"FREQ:DAILY;BYDAY:TU\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"start\": \"T100000\",\n\t\t\t\t\t\"duration\": \"PT09H00M\",\n\t\t\t\t\t\"recurrence\": \"FREQ:DAILY;BYDAY:WE\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"start\": \"T110000\",\n\t\t\t\t\t\"duration\": \"PT08H00M\",\n\t\t\t\t\t\"recurrence\": \"FREQ:DAILY;BYDAY:TH,FR\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"start\": \"T110000\",\n\t\t\t\t\t\"duration\": \"PT04H00M\",\n\t\t\t\t\t\"recurrence\": \"FREQ:DAILY;BYDAY:SA\"\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n} As you can see, this is a fairly detailed response. As before I suggest checking the API docs for a full reference, but here are a few things I'd call out. Title and address give you nice human-readable results to show the user. Position gives you something you can render on a map. Contacts provide multiple ways (if available) of rearching the business. And my favorite, openingHours provides both human readable and machine parseable forms of information related to when the business can be accessed. Note there's a shorthand \"isOpen\" you can quickly check. Now that we know the basics of the API, let's build a simple demo. I'm going to start off by creating a map centered on Lafayette. I zoomed in a bit though. var platform = new H.service.Platform({\n\t'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n\tdocument.getElementById('mapContainer'),\n\tdefaultLayers.vector.normal.map,\n\t{\n\t\tzoom: 14,\n\t\tcenter: { lat: 30.22, lng: -92.02 },\n\t\tpixelRatio: window.devicePixelRatio || 1\n\t}\n);\n\t\t\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\nvar ui = H.ui.UI.createDefault(map, defaultLayers); In my UI, I added a simple text field to allow user's to enter a search term. I added a button and used this handler with it: let box = document.querySelector('#searchBox');\nlet btn = document.querySelector('#searchBtn');\n\nbtn.addEventListener('click', async () => {\n\tlet resp = await fetch(`https://discover.search.hereapi.com/v1/discover?apikey=${apiKey}&q=${encodeURIComponent(box.value)}&at=30.22,-92.02&limit=10`);\n\n\tlet data = await resp.json();\n}); Notice I've focused my API call in the same location as the map. In order to render the results, I used a conbination of markers and info bubbles. Markers will be displayed for all the results and an info bubble is used when a user clicks on it. Our API returns a lot of information about each result and I decided to display just the title and human-readable address. There's a bit more JavaScript involved to handle all of that, but the Discover integration was rather simple. You can see the complete source code in the embed below. (Note that the embed may be a bit small. You can click to view it on CodePen and have a bit more space. See the Pen HERE Discover demo by Raymond Camden ( @cfjedimaster ) on CodePen . Alright, now let's look at the final of the three things I wanted to cover - the Browse endpoint. Unlike Discover which is a bit more free form, Browse is useful when you've got a specific category, or set of categories, you want to focus on. Browse can still take a search value to go along with the categories you want to use. I already shared the docs for categories above, but in general there's two types of categories. There's a broad set that define certain groups at different levels of specificity. I think the docs do a great job explaining this so I'm just going to steal (sorry, \"borrow\") their example. Using 100 for a category represent a level one, or top level, category descriptor named \"Food and Drink\". You can then go deeper and use 100-1000 to represent a restaurant. But wait - there's more. You can get one more level precise and use 100-1000-0001 to represent a \"Casual Dining\" place. If you like food (I do, I like food), then you're in luck. We also have an incredibly detailed food categorization feature as well. This lets you specify things like Cajun food, which is category 101-070. For Asian food, there are 22 different second level categories, like Chinese versus Korean, and then numerous options under that as well. As an example, 201-055 is Chinese Hot Pot (which if you've never had, you're missing out!). To use the API, you pass in the category (or multiple, separated by comma) and an option search filter called name: https://browse.search.hereapi.com/v1/browse?name=SOMETHING&at=30.22,-92.02&categories=203-026 As with Discover, you need to specify a location and you've got options for how to do that. Again, check the API docs for details. I built a demo of this API that basically just modifies the previous one. It's modified to search just for sushi (203-026) and again centered on my home town. Literally then the only change in the entire demo is here: let resp = await fetch(`https://browse.search.hereapi.com/v1/browse?apikey=${apiKey}&name=${encodeURIComponent(box.value)}&at=30.22,-92.02&categories=203-026&limit=10`); You can run this demo via the CodePen below, and again, if it's a bit too small, just click to view it in another tab. See the Pen HERE Browse demo by Raymond Camden ( @cfjedimaster ) on CodePen . The Great Random Night Out So imagine you aren't locked in your house and can actually spend the night out. After being indoors for so long, you may be forgiven for being a bit unsure of what exactly to do. In order to make things easier, my demo will select a random restaurant and a random item from the \"Going Out-Entertainment\" category. This is done by simply asking for a lot of results and selecting one. I built this as a simple Vue.js application. Here's the HTML portion: <div id=\"app\" v-cloak>\n  <div style=\"margin: auto;width: 400px;\">\n    <button :disabled=\"searching\" @click=\"doIt\">DECIDE FOR ME</button>\n  </div>\n  <div v-if=\"result\" class=\"results\">\n    <strong>Congratulations!</strong> \n    You will be eating at {{ restaurant.title }} (located at {{ restaurant.address.label}}) and then having fun at {{ entertainment.title }} (located at {{ entertainment.address.label}})\n  </div>\n</div> And here's the code: Vue.config.productionTip = false;\nVue.config.devtools = false;\n\nconst KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\n\nconst app = new Vue({\n  el:'#app',\n  data: {\n    result:false,\n    searching:false,\n    restaurant:null,\n    enertainment:null\n  },\n  methods: {\n    async doIt() {\n      this.result = false;\n      this.searching = true;\n      this.restaurant = await getRestaurant();\n      this.entertainment = await getEntertainment();\n      console.log(this.entertainment);\n      this.searching = false;\n      this.result = true;\n    }\n  }\n})\n\nasync function getRestaurant() {\n  let resp = await fetch(`https://browse.search.hereapi.com/v1/browse?apikey=${KEY}&at=30.22,-92.02&categories=100-1000-0000&limit=100`);\n  let data = await resp.json();\n  return data.items[getRandomInt(0, data.items.length)];\n}\n\nasync function getEntertainment() {\n  let resp = await fetch(`https://browse.search.hereapi.com/v1/browse?apikey=${KEY}&at=30.22,-92.02&categories=200-2000-0000&limit=100`);\n  let data = await resp.json();\n  return data.items[getRandomInt(0, data.items.length)];\n}\n\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive\n} The crucial bits here really are getRestaunrant and getEntertainment. Both do the exact same thing really with just a change to the desired category. Once the results are returned, a random item in the array is selected. (And notice that this could be a bit more bulletproof, it's possible that if you change your location that no restaurants or entertainment may exist. If so, don't change the code. Move.) You can play with this demo below: See the Pen Decide For Me by Raymond Camden ( @cfjedimaster ) on CodePen . I hope this little tour through our new Search API has been fun, and be sure to dig deep into the guide for more inspiration!", "date": "2020-04-08"},
{"website": "Here", "title": "Meet Counterpoint Research’s top location & mapping platform", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/meet-counterpoint-researchs-top-location-mapping-platform-ahead-of-google-and-tomtom", "abstract": "It’s no secret that building a reliable, scalable product or service involves working with best tools and platform available. That’s why we work so hard on providing you, our developers, with a global, dependable, and best-in-class location platform with unparalleled developer experience. We’re excited and proud to announce that for the third time in a row, HERE Technologies was named by Counterpoint Research as the world’s number one location platform. The 2020 Counterpoint Research Location Platforms Evaluation and Analysis compared the 25 leading location platform vendors, including Google, TomTom and Mapbox, in capabilities and execution. Since publishing its last benchmark in July 2018, Counterpoint greatly expanded its evaluation criteria. The new report evaluates the leading maps and location platform players, across six categories, on more than 60 capabilities and ecosystem success parameters. HERE leads the pack in all categories and across more than 40 of the criteria, including: Developer Ecosystem, Indoor Maps, ADAS/HD Maps, Geocoding, Traffic, Tracking & Positioning, Openness, Marketplace and more. Neil Shah, Vice President of Research, notes: “HERE continues to emerge as the world’s leading and most comprehensive location platform in our evaluation. Over the last eighteen months HERE has widened its lead compared to the competition, developing end-to-end capabilities, a broader and deeper portfolio of offerings, a string of partnerships and a large number of customer wins.\" We know this ranking is not just ours to celebrate – we owe this success to you, our developers! Thank you for choosing and trusting us to be your location platform, for joining our developer community, and for the invaluable feedback you provide that goes into making our platform offering even better. I’ve always believed the perfect developer experience is one that is continuously evolving to meet and exceed our developer needs and expectations. We can’t wait to see what you build next! Click here to download the full report.", "date": "2020-04-16"},
{"website": "Here", "title": "Shifting Security Left in the HERE Platform", "author": ["Doug Rickert"], "link": "https://developer.here.com/blog/shifting-security-left-in-the-here-platform", "abstract": "With each month, the HERE platform continues to expand not only on the features that our services offer, but the set of services offered to our customers. Alongside this growth, we are absolutely unwilling to waiver on our commitment to securing our services and the data hosted on our platform.  This creates an interesting challenge: how do you enable a company to grow quickly without taking on additional security risk? HERE is heavily investing in quite a few efforts in this area, and  we want to highlight one that we believe is having a huge impact: Shifting Security Left . To ensure security is not a bottleneck for rapid feature releases and product growth, we’ve increased investment in automated security tooling that can plug into our product development pipelines. At HERE, we are in the process of migrating products to Gitlab Pipelines for our Continuous Integration and Continuous Delivery (CICD) development process. This presents us with two great opportunities: Iterate on our templated security guidance so that we continue to provide easily adopted security guidance to developers Present this templated guidance to developers as they are codifying their CICD, in our case the .gitlab-ci.yml file Security in CICD is not at all new at HERE; we’ve been providing security guidance and automated tooling for HERE products long before our move to Gitlab. But this move allows us to revisit these practices and share our strategy with the community at large. A typical Gitlab Pipeline, or more precisely a .gitlab-ci.yml file, at HERE looks like this from a high level: stages: -       test-code -       build-package -       release-package -       build-image -       release-image -       deploy You’ll notice that there’s nothing specific to security in here. Developers test code, compile it, save off the result. Then our developers put the result into the environment where it’ll run, test that environment, and save it off. Then they deploy if the change is approved and destined for production. There is nothing new in the developer process in what is shown above. And we in Security believe that is key to building secure software over time. Our security requirements do not interject entire new stages into a developer’s CICD pipeline which require separate attention. This allows them to continue focusing on development without large, time-consuming interrupts. One templated piece of code added into a .gitlab-ci.yml file provides a development team in depth security insight early in the development cycle. GitLab pipelines can run a Static Code Analysis tool, for example, inline during a pipeline’s test-code stage. HERE developers already embrace static code analysis that detects performance and bad coding practices.  Our templated code leverages the same paradigm to test for security concerns. So where, then, do we actually “Shift Left”? Release Package In the release-package stage, our development teams upload their application package to our JFrog Artifactory server. JFrog Artifactory is a feature-rich tool for managing build artifacts of any kind, from logs to binaries. It tracks each resource’s version history and maintains metadata unique to a given artifact type, building a rich library of our software dependencies. Security shifts another increment leftward when we turn on JFrog’s Xray plug-in within Artifactory.  Once a package lands in Artifactory, Xray automatically scans that package looking for any known vulnerabilities associated with the components contained within the package. It will also do license compliance, but we use our own OSS Review Toolkit for that.  Nothing needs to be done by the developer to trigger the scan. The simple act of uploading the package to Artifactory, which happens as part of the CICD pipeline flow, triggers Xray’s scan. With these results, developers can take action to address known vulnerabilities, and feed the components they use back into our company’s threat intelligence team. This catalog allows our security team to easily query the packages in use by HERE within minutes of a new vulnerability being released.  That’s a game changer. With that kind of advanced notice, it’s possible to stay a step ahead of attackers’ ability to deploy exploits which abuse newly identified vulnerabilities. Build Image HERE platform heavily utilizes containers for application environments. As teams build these containers, we use a self-hosted container repository called Quay to store the containers.  This allows us to take control of our supply chain by not pulling directly from a 3 rd party. It also allows us to utilize Quay’s tool for container security analysis, called Clair. As soon as a container is uploaded to Quay, a scan is queued up for Clair. Much like Xray, this scan breaks the container down into its different elements and scans them for known vulnerabilities. As a scan finishes, there are a number of notification actions we can use to alert developers about vulnerabilities in their container images. Again, no manual trigger is required by developers other than uploading their container image to the container repository.  And that is another default step in their CICD pipeline flow. Completing the Picture Once a Gitlab Pipeline has finished, a development team and security both have the information about the security state of the software they’ve produced. They know that: Their code has been reviewed for vulnerabilities The software components they rely on have been reviewed for vulnerabilities The environment they put their application into has been reviewed for vulnerabilities This is not the entirety of HERE’s Shift Left plan. We also have additional security analysis tools that we are exploring to specifically: Reduce the time that it takes a developer to get feedback from a security scan Improve the coverage of our tooling across a broad developer ecosystem Tooling empowers developers by alerting them to a weakness as soon as it is possible to identify it. But a large part of security is about building a culture where security is a considered in every development iteration. To assist in that cultural maturity, we are building a Security Champions program. Security Champions help to level up their development area’s security acumen. The more security pushes left in the development cycle, the more comfortable it becomes for developers to make security choices without requiring full reviews from the formal Security teams. This post only highlights some of the security efforts we are excited about at HERE. As the year progresses, keep an eye out as we are looking forward to sharing even more.", "date": "2020-04-17"},
{"website": "Here", "title": "Solutions Day 6-10: 100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-6-10-100daysofcode", "abstract": "#100DaysOfCodeWithHERE continues! If you have no idea what I'm talking about, take a look at this blog which will tell you everything about #100DaysOfCode. In this blog, I will cover solutions for days 6 through 10. If you have missed the solutions for days 0-5 , you can read them in my previous blog or in the video format . (Please excuse the sound quality, my microphone is in a lockdown.) Let's begin! Day 6/100 The task for day 6 was to tilt the map and to rotate it such that the west half of the globe in the top of the map. Although this task is pretty straight forward, it may have been a little tricky to find the solution directly in the documentation. So, you may want to look at API reference for ViewModel . At the bottom of this page, you will find the object to set the tilt as well as the rotation angle, called the heading. <script>\n    ... \n    // adjust tilt and rotation of the map\n    \n    map.getViewModel().setLookAtData({\n    tilt: 60,\n    heading: 90 // angle relative to North\n    });\n    </script> Day 7/100 On day 7, we got our geographical position from the browser instead of hard-coding it into the application. You need to make sure your browser version supports it. With this task we had also given you a hint! If you did follow the hint and go to our blogs, you'll find that there's a blog which can help you with getting your position from the browser . In your code, it will look like: <script>\n    ... \n   \n    function getBrowserPosition(){\n   \n       if(navigator.geolocation) {\n               navigator.geolocation.getCurrentPosition(position => {\n                   console.log(position.coords);\n               });\n           } else {\n               alert(\"Geolocation is not supported by this browser!\");\n       }\n   };\n   \n   getBrowserPosition();\n   \n</script> Day 8/100 Once you have your position, it will be easy to put a marker in that position. You don't need to look far for markers as you will find them under the Map Objects within the Interactive Maps API. All the call needs is a position which you have acquired already. Let's see how that will look like. <script>\n    ... \n   \n    function getBrowserPosition(){\n   \n       if(navigator.geolocation) {\n               navigator.geolocation.getCurrentPosition(position => {\n                // console.log(position.coords);\n                let browserPosition = {lat:position.coords.latitude, lng:position.coords.longitude};\n                let marker = new H.map.Marker(browserPosition);\n                map.addObject(marker);\n               });\n           } else {\n               alert(\"Geolocation is not supported by this browser!\");\n       }\n   };\n   \n   getBrowserPosition();\n   \n</script> Looks cool doesn't it! Day 9/100 Day 9 just takes day 8 further by adding a SVG marker instead of the standard marker. Don't get me wrong, I like the standard markers, but I also want to customize my application. This isn't too hard either. Go to the section Marker Objects and you will immediately see a neat eample with a SVG marker. You can customize the marker in any way you want. I made mine a white circle within a green circle. You can easlily create a SVG marker with the help of many tools which let you draw shapes and export them as SVG. I make mine using the desktop version of draw.io . <script>\n...\nlet positionIcon = `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"21px\" height=\"21px\" viewBox=\"-0.5 -0.5 21 21\"><defs/><g><ellipse cx=\"10\" cy=\"10\" rx=\"10\" ry=\"10\" fill=\"#009900\" stroke=\"#000000\" pointer-events=\"none\"/><ellipse cx=\"10\" cy=\"10\" rx=\"3\" ry=\"3\" fill=\"#ffffff\" stroke=\"#000000\" pointer-events=\"none\"/></g></svg>`\n\n...\n\nfunction getBrowserPosition(){\n\n    if(navigator.geolocation) {\n            navigator.geolocation.getCurrentPosition(position => {\n                // console.log(position.coords);\n                let browserPosition = {lat:position.coords.latitude, lng:position.coords.longitude};\n                let posIcon = new H.map.Icon(positionIcon); // creating an Icon object\n                let marker = new H.map.Marker(browserPosition,{icon:posIcon}); // adding the icon to the marker\n                map.addObject(marker);\n            });\n        } else {\n            alert(\"Geolocation is not supported by this browser!\");\n    }\n};\n\ngetBrowserPosition();\n\n</script> Day 10/100 With day 10, we want to click anywhere on the map and get a position in the form of latitude and longitude. This task comes under event handling where clicking on the map would be an event, and getting the position on click is what you set the application to do after the event occurs. You guessed it right, head on to the map events section to learn about map event handling. As you can see, there's an event listener set up to handle the 'tap' event. <script>\n    ... \n    // Add event listener:\n    map.addEventListener('tap', function(evt) {\n        // Log 'tap' event\n        console.log(evt);      \n    });\n</script> {…}\n    Jk: true\n    a: false\n    changedPointers: Array []\n    currentPointer: Object { viewportX: 307, viewportY: 475.73333740234375, id: 0, … }\n    currentTarget: Object { Bd: false, rb: (2) […], L: false, … }\n    eventPhase: 2\n    f: false\n    originalEvent: pointerup { target: div\n    , buttons: 0, clientX: 705, … }\n    pointers: Array [ {…} ]\n    target: Object { Bd: false, rb: (2) […], L: false, … }\n    targetPointers: Array [ {…} ]\n    type: \"tap\"\n    ​... If you just log the event response, you will see that you get an object currentPointer which has information of the viewport of the place tapped or clicked on. We use this to get the position by using the map method screenToGeo which you will find in the API reference page of H.Map . Using this method, we can retreive the location of the tapped point which is of the type H.geo.Point . <script>\n    ... \n    // Add event listener:\n    map.addEventListener('tap', function(evt) {\n        // Log 'tap' and 'mouse' events:\n        let pointer = evt.currentPointer;\n        console.log(evt);\n        console.log(map.screenToGeo(pointer.viewportX, pointer.viewportY));      \n    });\n</script> Hope you found the content of these 5 days interesting. Be sure to tweet us your solutions on our Twitter handle @heredev. Keep following #100DaysOfCode and keep coding!", "date": "2020-04-12"},
{"website": "Here", "title": "Solutions Day 16-20: 100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-16-20-100daysofcode", "abstract": "Week 4 of #100DaysOfCodeWithHERE already! If you have no idea what I'm talking about, take a look at this blog which will tell you everything about #100DaysOfCode. In this blog, I will cover solutions for days 16 through 20. If you have missed the solutions for days 0-15, you can read them in my previous blogs or in the video format . Let's begin! Day 16/100 So far, the map that we have rendered is with the default style. Although the objects on top of the map have been styled plenty, we haven't really covered how to change the look and feel of the base map. With Day 16, we are going to style the map before rendering it, thus we will have a customized map style on load. While the task to change the font is quite small, it opens up new ways to explore all the default styles in the map and create a completely customized map which fits the theme of your application. Along with the documentation for map styles , there is a tool available to see the map style changes you make in real time. This tool is the map style editor . This editor has the default map style in a yaml format. You can make changes in this file, download the file and use it as a style template for your map on load. For changing the font, simply change the text_font_family into the font you want. Download the file as 'font_arial.yaml'. global:\n    text_font_family: Arial <script>\nvar map = new H.Map(\n...\n);\nvar provider = map.getBaseLayer().getProvider();\n\nvar mapStyle = new H.map.Style('font_arial.yaml', 'https://js.api.here.com/v3/3.1/styles/omv/');\n\nprovider.setStyle(mapStyle);\n\n... \n         \n</script> Day 17/100 If you need to make major changes in the map style, a yaml file is the way to go. Although if you want to make tiny changes after the map has already been loaded, you can pick out a specific feature and change it's style at runtime. This is what we will do as task 17/100. Here we are changing the color property of the feature hospital in the map. If you circle back to the map style editor , you will see that 'hospital' is a 'layer' under the layer 'landuse'. It's property 'color' lies under the 'draw' feature. <body> <button class=\"button\" style=\"vertical-align:middle\" onclick=\"highlightHosp()\"><span>Highlight hospitals </span></button> </body> <script> ... function highlightHosp(){ var hospStyle = provider.getStyle(); var hospConfig = hospStyle.extractConfig('landuse.hospital'); hospConfig.layers.landuse.hospital.draw.polygons.color = 'rgb(255,0,0)'; hospStyle.mergeConfig(hospConfig); } </script> Day 18/100 Changing the language of the map is pretty simple and possible in many ways. You can use the on-load or run-time methods like days 16 and 17 or there's an easier method which I will be using in the solution for day 18. The map language can be added as a parameter to the H.ui.UI.createDefault() library function. You can read about the supported languages in the Map controls and UI section of the documentation. <script>\n    ...\n\n    var map = new H.Map(\n        ...\n    );\n\n    // creating default UI for map\n\n    var ui = H.ui.UI.createDefault(map, defaultLayers,'de-DE'); \n\n</script> Day 19/100 If you follow the documentation from day 18, you will see that the task for day 19 is right below the UI language section. For day 19, we will change the position of the control panel which is part of the default UI of the map. To understand the terminology of the position on the map window, take a look at the API references for H.UI . Similarly you can also change the positions of the zoom control buttons and the scale indicator of the map. <script>\n    ...\n\n    var mapSettings = ui.getControl('mapsettings');\n\n    mapSettings.setAlignment('top-right');\n    \n</script> Day 20/100 You may have noticed that I often struggle with writing 'behavior' instead of 'behaviour' and 'color' instead of 'colour'. This is because I grew up learning 'British English' while the language we use in our company is 'American English'. Having said that, I am also used to calculating distance in meters, which is the default of the map. Although for those who use miles, you may want to switch to the IMPERIAL unit system. This is also the property of the map UI and can be found in the API references for H.UI <script>\n    ...\n    ui.setUnitSyste m(H.ui.UnitSystem.IMPERIAL);\n    \n</script> And there you go. We are through with 20 days of #100DaysOfCode. Hope you enjoyed this week of 100DayOfCodeWithHERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for 100DaysOfCode on YouTube . Happy coding!", "date": "2020-04-22"},
{"website": "Here", "title": "Solutions Day 11-15: 100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-11-15-100daysofcode", "abstract": "Week 3 of #100DaysOfCodeWithHERE! If you have no idea what I'm talking about, take a look at this blog which will tell you everything about #100DaysOfCode. In this blog, I will cover solutions for days 11 through 15. If you have missed the solutions for days 0-5 and days 6-10, you can read them in my previous blogs or in the video format . Let's begin! Day 11/100 In the last few days, we've rendered a map, placed a marker, created an event to click on the map and get the position from the screen. On day 11, we will put a marker as an image and use the data property of the marker. Take a look at this tutorial to add a custom marker to your map . The image marker works in the same way as the SVG marker. Instead of the SVG icon name, you pass the path to the image in the object Icon . While you are at it, use the property data to set data to this marker to display it in the next tasks <script>\n...\nvar imageIcon = new H.map.Icon('robot.png'); // path of the stored image\n\n// Add event listener:\nmap.addEventListener('tap', function(evt) {\n    // Log 'tap' and 'mouse' events:\n    let pointer = evt.currentPointer;\n    let pointerPosition = map.screenToGeo(pointer.viewportX, pointer.viewportY);\n    let pointerMarker = new H.map.Marker(pointerPosition,{icon:imageIcon}); \n    pointerMarker.setData(\"I'm Here\");  // using function setData to set the property data of the map object 'marker'\n    map.addObject(pointerMarker);\n         \n});\n</script> Day 12/100 Once we have set the data, we need a way to display it. In this task, we will display this data in an infobubble. Infobubble is a UI element where you can set the position of the bubble along with properties like content and state. You can find all the properties in the API reference for the Interactive Maps API documentation. Let's combine the task for day 11 and 12 and look at the code snippet. <script>\n...\n\n\nvar imageIcon = new H.map.Icon('robot.png');\n\n\n// Add event listener:\nmap.addEventListener('tap', function(evt) {\n    if(evt.target instanceof H.map.Marker){  // checking if the tapped obeject on the map is already a marker\n        var bubble =  new H.ui.InfoBubble(evt.target.getGeometry(), {\n        // read custom data\n        content: evt.target.getData()  // data set while adding the marker object \n        });\n        // show info bubble\n        ui.addBubble(bubble);\n    }\n    else{\n        // Log 'tap' and 'mouse' events:\n        let pointer = evt.currentPointer;\n        let pointerPosition = map.screenToGeo(pointer.viewportX, pointer.viewportY);\n        let pointerMarker = new H.map.Marker(pointerPosition,{icon:imageIcon}); \n        pointerMarker.setData(\"I'm Here\");\n        map.addObject(pointerMarker);\n    }  \n         \n});\n\n</script> Day 13/100 Before you can drag the marker, you need to make the marker volatile and enable the property 'draggable'. <script>\n...\n\n        let pointerMarker = new H.map.Marker(pointerPosition,{icon:imageIcon,volatility:true}); \n        pointerMarker.draggable = true;\n\n</script> Dragging a marker is basically 3 steps. You start dragging the marker, you take it to a new position and then you place it at the new position by releasing the clicked button. This implies that these are 3 distinct events and you need to write event listeners for all 3 events. The first event is 'dragstart'. Here you need to disable the default behavior on drag and calculate the offset between the current and new coordinates. Next is the 'drag' event itself where you provide this offset to your marker and move it's position. The third part is 'dragend' where you enable the default behavior of the map back again. <script>\n...\nfunction clickDragMarkers(map, behavior){\n\n    // disable the default draggability of the underlying map\n    // and calculate the offset between mouse and target's position\n    // when starting to drag a marker object:\n    map.addEventListener('dragstart', function(ev) {\n        var target = ev.target,\n            pointer = ev.currentPointer;\n        if (target instanceof H.map.Marker) {\n        var targetPosition = map.geoToScreen(target.getGeometry());\n        target['offset'] = new H.math.Point(pointer.viewportX - targetPosition.x, pointer.viewportY - targetPosition.y);\n        behavior.disable();\n        }\n    }, false);\n\n\n    // re-enable the default draggability of the underlying map\n    // when dragging has completed\n    map.addEventListener('dragend', function(ev) {\n        var target = ev.target;\n        if (target instanceof H.map.Marker) {\n        behavior.enable();\n        }\n    }, false);\n\n    // Listen to the drag event and move the position of the marker\n    // as necessary\n    map.addEventListener('drag', function(ev) {\n        var target = ev.target,\n            pointer = ev.currentPointer;\n        if (target instanceof H.map.Marker) {\n        target.setGeometry(map.screenToGeo(pointer.viewportX - target['offset'].x, pointer.viewportY - target['offset'].y));\n        }\n    }, false);\n\n}\n\nclickDragMarkers(map, behavior);\n\n</script> Day 14/100 Drawing a circle is kind of a breather after the slightly bigger task with the marker dragging. Like drawing a circle with your hand or in a drawing application, here too you need only two things: a center and the radius. The task is to center the circle where you end the dragging of the marker. This is a hint that we will add the circle in the 'dragend' event listener. As for the radius, it is represented in meters. This is a nice way to highlight areas in proximity based on distance. <script>\n    function clickDragMarkers(map, behavior){\n        ...\n        // re-enable the default draggability of the underlying map\n        // when dragging has completed\n        map.addEventListener('dragend', function(ev) {\n            var target = ev.target;\n            if (target instanceof H.map.Marker) {\n\n                var circle = new H.map.Circle(target.getGeometry(), 10000);\n                // Add the circle to the map:\n                map.addObject(circle);\n                behavior.enable();\n            }\n        }, false);\n    }\n\n</script> Day 15/100 A circle is a geo shape, an object of the map where more shapes like rectangle, polygon, polyline can also be drawn. These geo shapes have points of the type 'geometry', and distances in meters. You can read about all the geo shapes in the JS API documentation under the Map Objects > Geo Shapes . These geo shapes, like the other map objects like a marker, can also be customized. As task for day 15, we will change the fill color, the border color and thickness of the circle. All of this is possible with the property style of the geo shapes. <script>\n        ...\n        var circleStyle ={\n            fillColor: 'RGBA(153, 233, 242, 0.5)',strokeColor: 'RGB(11, 114, 133)',\n            lineWidth:3\n        };\n\n        function clickDragMarkers(map, behavior){\n            ...\n            // re-enable the default draggability of the underlying map\n            // when dragging has completed\n            map.addEventListener('dragend', function(ev) {\n                var target = ev.target;\n                if (target instanceof H.map.Marker) {\n    \n                    var circle = new H.map.Circle(target.getGeometry(), 10000,{style: circleStyle});\n                    // Add the circle to the map:\n                    map.addObject(circle);\n                    behavior.enable();\n                }\n            }, false);\n        }\n    \n    </script> Hope you enjoyed this week of 100DayOfCodeWithHERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for 100DaysOfCode on YouTube . Happy coding!", "date": "2020-04-17"},
{"website": "Here", "title": "Solutions Day 21-25: #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-21-25-100daysofcode", "abstract": "Week 5 of #100DaysOfCode with HERE whaaat! If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. In this blog post, I will cover solutions for days 21 through 25. If you have missed the solutions for days 0-20, you can read them in my previous blogs posts or in the video format . Let's begin! Day 21/100 We are starting day 21 with the mighty Geocoder . The Geocoding and Search API is a powerful tool to find the location of a place based on the postal address. The geocoder responds with a latitude and longitude as well as many other helpful parameters to a query with the address of the place. In the next few days, we will explore the Geocoding and Search API and all its different endpoints. Day 21 in itself is the most simple use of the geocoder. You pass a srtring with a partial address and you get all possible locations that match your string. I entered the most common street name here 'Hauptstarße' to see how many results I get and to no surprise found out that there are atleast 20 'Hauptstraße' on the Earth! // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n\n    function geocodeAndSearch(){\n\n        let geocoderParams = {\n            q : 'hauptstraße'\n        }\n\n        function onResult(result){\n            console.log(result);\n        }\n\n        geocoder.geocode(geocoderParams,onResult,alert);\n\n    }\n\n    geocodeAndSearch(); Day 22/100 The query from day 21 gives us too many results and does not make it easier in the situation of places with common names. On day 22, we will limit the number of results you can get with an address search. The Geocoding and Search API has different filters that you can apply to limit your search. You can read about different filters in the documentation . Here we are simply going to use the input parameter limit to limit the results. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n\n    function geocodeAndSearch(){\n\n        let geocoderParams = {\n            q : 'hauptstraße',\n            limit : 5\n        }\n\n        function onResult(result){\n            console.log(result);\n        }\n\n        geocoder.geocode(geocoderParams,onResult,alert);\n\n    }\n\n    geocodeAndSearch(); Day 23/100 Limiting the search by the number of results is one thing, although it makes more sense to limit it by geography. For day 23, we will limit the results by country. If you check the in parameter in the Geocoding and Search API , you will see that it has the option to limit the search to a country or countries when separated by commas. This filter is a hard filter thus it will not give you results beyond the countries you have specified. The countries are specified using the ISO 3166-1 alpha-3 country codes. Thus Germany will be represented as 'DEU' // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n\n    function geocodeAndSearch(){\n\n        let geocoderParams = {\n            q : 'hauptstraße',\n            in: 'countryCode:DEU',\n            limit : 5\n        }\n\n        function onResult(result){\n            console.log(result);\n        }\n\n        geocoder.geocode(geocoderParams,onResult,alert);\n\n    }\n\n    geocodeAndSearch(); Day 24/100 Limiting the results to a country made the results a little more meaningful. Although, there still are 5 'hauptstraße' in Germany. This time, I will enter a structured address with more information about the place I wish to find. This can be done with a qualified query. It is still a free form text, but a little structured where you can specify which part of the address is the street name, which is the house number, etc. As a result, I get the street 'hauptstraße' in Berlin, Germany. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n\n    function geocodeAndSearch(){\n\n        let geocoderParams = {\n            qq : 'street=hauptstraße;city=Berlin;country=Germany'\n        }\n\n        function onResult(result){\n            console.log(result);\n        }\n\n        geocoder.geocode(geocoderParams,onResult,alert);\n\n    }\n\n    geocodeAndSearch(); Day 25/100 The above queries show filters needed when the address has common names in it. For certain strings, the geocder directly gives the desired place. For instance, if we do a free form search for 'Invalidenstraße 116, Berlin', we get the location of the desired place immediately. What is interesting is the parameters that come along with the location. For day 25, we are interested in the parameter 'access'. Not only do we get the 'position' of the place, but we also get the access point of the building/ house. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n\n    function geocodeAndSearch(){\n\n        let geocoderParams = {\n            q : 'invalidenstraße 116, Berlin'\n        }\n\n        function onResult(result){\n            console.log(result);\n            map.addObject(new H.map.Marker(result.items[0].access[0]));\n        }\n\n        geocoder.geocode(geocoderParams,onResult,alert);\n\n    }\n\n    geocodeAndSearch(); If you expand the results, you will see that under the 'items' you get a parameter called 'access' which will give you the access point of that property {…}\n\n    items: (1) […]\n        0: {…}\n            access: (1) […]\n\t               0: {…}\n                lat: 52.531\n                lng: 13.38461\n                <prototype>: Object { … }\n            length: 1 This was the first week of the Geocoding and Search on #100DaysOfCode. We will have more of the this in the days to come. Hope you enjoyed this week of #100DayOfCode with HERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . While you're at it, why don't you take a look at the blog post announcing the release of our new mobile SDKs . Want to know how you can use maps to gamify biking? Check out the blog post by the participants of BCX20 who won third place in the mobility stream by building Speedy.bike . Also take a look at the step by step tutorial for the Geocoding and Search API . Happy coding!", "date": "2020-04-27"},
{"website": "Here", "title": "Incentivizing Cycling With the HERE APIs – Bosch Connected Experience 2020", "author": ["Bohdan Yeromenko, Artsiom Kaliaha, Prashanth Ramakrishnan, Viacheslav Oliinyk"], "link": "https://developer.here.com/blog/incentivize-cycling-with-here-apis-bosch-connected-experience-2020", "abstract": "On February 17 - 19 2020, team eXity participated in BCX 2020. During the competition we developed a new module called Speed.Bike for the COBI.BIKE ecosystem with HERE Technologies as the API provider for location technology. The theme of the competition was to use location, bikes, and rider data, as well as other custom sensor inputs to derive solutions for the operation of an eBike. The project secured a 3rd place in the mobility track at BCX 2020. Read on to know how we made it all happen! What is Speed.Bike? Speed.Bike is PoC of a new module within the Cobi.Bike ecosystem that allows cyclists equipped with COBI.BIKE hardware to take part in bicycle races using a simple matchmaking system where users can query for other cyclists during a bicycle competition. The service brings ideas of UX gamification by allowing users to earn reputation points through races, improve their rank among other cyclists, and compete for dominance in districts of a given city. The module is focused on people who are interested in competitive racing for fun or health benefits, while socializing with other cyclists in their city or other cities/countries. How did we turn an idea into a PoC? Taking into account the COBI.BIKE ecosystem and technologies available from our fellow partners from the competition, we came up with the following tech stack: HERE APIs for maps, navigation services, and map overlays NodeJS for server part and OpenShift as a docker container hosting JavaScript for web part with COBI.BIKE API integration Integration with maps HERE APIs are the core of the solution since they enable mapping, navigation, and routing services. In order to start building a project, we got our freemium API Keys from the developer portal . The very first challenge for our team during the competition was to define use cases, user stories and identify in what parts of the app it’s relevant and essential to utilize and implement maps alongside navigation. We have used a map in the following screens and user cases: Profile and city overview Navigation to the race place Race routing City control map We will shortly cover all of these use cases with the corresponding implementation. Profile and city overview screen show the user’s name and picture, a count of reputation points earned in previous races and a button to search for races. To integrate a map like this you simply load a set of HERE modules in the header of your web page and implement a small function to set up all the necessary components in JavaScript. For more information visit the official documentation . function initMap() {\n    var platform = new H.service.Platform({\n        apikey: \"tm-_YBiPMFzkGwKWCW8hC8Iwp0W3pqqOFSThHHe_FuQ\"\n    });\n    \n    var defaultLayers = platform.createDefaultLayers();\n    var map = new H.Map(\n        document.getElementById('mapContainer'),\n        defaultLayers.vector.normal.map,\n        {\n            zoom: 11,\n            center: {lat: 52.53086, lng: 13.38474}\n        });\n    \n    var ui = H.ui.UI.createDefault(map, defaultLayers);\n    ui.getControl('scalebar').setVisibility(false)\n    ui.getControl('mapsettings').setVisibility(false)\n    ui.getControl('zoom').setVisibility(false)\n\n    // Add basic map events like pan and zoom \n    var mapEvents = new H.mapevents.MapEvents(map);\n    var behavior = new H.mapevents.Behavior(mapEvents);\n} By choosing a race in the app you can navigate to the place where the race starts. For that, we used the HERE Routing API . This was achieved with a router, route parameters, and a callback in which you can easily design markers, route lines, route shapes, etc. // Get an instance of the routing service:\nvar router = platform.getRoutingService();\n\nvar routingParameters = {\n  // The routing mode:\n  'mode': 'fastest;bicycle',\n  // The start point of the route:\n  'waypoint0': 'geo!52.5219184,13.411026',\n  // The end point of the route:\n  'waypoint1': 'geo!52.5075881,13.3881868',\n  // To retrieve the shape of the route we choose the route\n  // representation mode 'display'\n  'representation': 'display'\n};\n\n// Call calculateRoute() with the routing parameters,\n// the callback and an error callback function (called if a\n// communication error occurs):\nrouter.calculateRoute(routingParameters, onResult,\n  function(error) {\n    alert(error.message);\n}); The same set of APIs with the instructions parameter are used in the race screen for navigating users to the finish line. After finishing a race you can win reputation points that influence your overall ranking in the city.! First of all, our team decided to show image overlays on the map. Furthermore, we committed to using GeoJSON format because of how simple it is to visualize it with HERE maps. In 3 lines of code, you can display a nice looking geo-JSON on the map. You just store it in your projects’ resource directory, load the file and display. function addOverlay(map) {\n  var reader = new H.data.geojson.Reader('res/berlin.json');\n  reader.parse();\n  // Assumption: map already exists\n  map.addLayer(reader.getLayer());\n} Integration with COBI Bikes API COBI.BIKE app for Android and iOS allows opening web sites as modules inside the app. It enables easy extension of basic functionality without updating/reinstalling the app. Here's an example . There is a Chrome extension for developers that emulates one type of COBI.BIKE on-wheel joystick controller. It allows you to test the app while you are developing it without redeploying and leaving your working place to test it with real hardware. Besides, there are pre-recorded rides, which you can easily review to test your use cases. The BOSCH Connected Experience was an exceptional experience in building services in 36 hours and with HERE maps it was even easier and more fun!", "date": "2020-04-23"},
{"website": "Here", "title": "HERE Technologies Achieves Red Hat OpenShift Operator Certification for Cloud-Native Location Services on Red Hat OpenShift", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/here-technologies-achieves-red-hat-openshift-operator-certification-for-cloud-native-location-services-on-red-hat-openshift", "abstract": "No matter the environment you develop or deploy, we offer ALL developers high quality location data, services and technical support at global scale. Today, we are adding one more ecosystem integration with the release of HERE Location Services on Red Hat OpenShift as a Kubernetes Operator via the Red Hat OpenShift Operator Certification. Developers on OpenShift can now integrate HERE geocoding, live traffic and fleet routing algorithm APIs more seamlessly into their applications. This helps simplify and speed deployments of enterprise-grade applications across cloud environments. Architecture behind enterprise solutions are increasingly complex as businesses digitize and address today’s competitive marketplace. In order to deliver world class products and services to customers, companies are pursuing on-premise, hybrid and multi-cloud deployments. The industry’s most comprehensive enterprise Kubernetes platform, Red Hat OpenShift is a trusted foundation for FORTUNE 1000 companies to build, deploy and optimize their software solutions across several environments. Software developers and data scientists working for companies across industries utilize the HERE platform to tap enterprise grade location data and technology, including fleet utilization, supply chain optimization, urban mobility and more. Each industry has vastly different needs from an architectural solution perspective. With a certified Red Hat OpenShift Operator, HERE is now a part of the Red Hat Partner Connect ecosystem and accessible to all of our customers via Red Hat OpenShift – I can't wait for you to start building with our location data. To get started with the HERE Location Services Operator, access it via the Red Hat registry her e.", "date": "2020-04-21"},
{"website": "Here", "title": "Introducing the new HERE SDKs for Android and iOS", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/introducing-the-new-here-sdks-for-android-and-ios", "abstract": "Today we are excited to announce the availability of our brand-new HERE SDKs for Android and iOS. These SDKs have been rebuilt from the ground up for your coding pleasure and are backed by more than 30 years expertise in mapping and location technology. They enable you to give your users access to the latest mapping data as well as your favorite location services from HERE, including Maps, Search, Directions and Traffic. We’re going to dive into some details and answer some questions below, but if you’re as excited as we are (and you should be!) why not go straight to the documentation and get started by building your first app? There are two approaches you can take. The easiest way to try the new SDKs is to go to GitHub and check out our new HERE SDK Examples . The readme.md has all the info you need to have your first example up and running! If you want to build something from scratch or integrate the SDK into an existing application, you should head over to the HERE SDK documentation and check out the Get Started section for Android or the Get Started section for iOS . Either way you’ll need a set of credentials, so go ahead and sign up for a Freemium account ! Alright, we’ve covered the most important part (getting started), so let’s dive into some more details. Most importantly, the new SDKs are available in three different editions: Lite , Explore and Navigate . These editions differ mainly by their map renderer. The Lite Edition uses a light-weight renderer which uses limited resources and provides support for a vast number of different mobile devices. The Explore and Navigate Editions use a premium renderer for visually appealing true 3D maps with a smooth map experience and highly performant map rendering. In addition, the Navigate edition also supports turn-by-turn navigation. You can visit the HERE SDK product page for a full list of features and a more detailed comparison of the various SDK editions. Stay tuned for lots of exciting content about the new SDKs, including a new series of HERE Waypoints on Twitch , blog posts and more. Remember to follow us on Twitter for the latest updates! I’m sure you have questions. Good thing that we have answers! Are the new SDKs part of the Freemium plan? The Lite and Explore Editions are available as part of your Freemium plan. The Navigate edition is currently available upon request. Which edition should I use? If in doubt, you should use the Explore edition. Use Navigate if you need turn-by-turn navigation. Consider Lite if you need to support older and less powerful devices. Check out the HERE SDK product page for a more detailed comparison of the SDK editions. What about the Starter and Premium Editions of the SDK? The Starter Edition has been deprecated. Consider moving to Lite or Explore. The Premium Edition with offline support remains available until 2021.", "date": "2020-04-22"},
{"website": "Here", "title": "Interview with COVID-19 Cruise Creator - Evan M AKA Atymic", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/interview-with-covid-19-cruise-creator-evan-m-aka-atymic", "abstract": "A few weeks ago, one of our developers created a fascinating map with our tools called the COVID-19 Cruise Tracker . As you can tell by the title, the map keeps track of cruise ships currently at sea. Cruise ships in particular have impacted by COVID-19 so the tracker is particularly useful as a way of seeing what's going on with them. Each ship is tracked along with total passangers and total number of cases. We decided it would be cool to interview the creator and get some insight into both him and why/how he built the tracker. HERE: Please introduce yourself and tell us a bit about your background. EVAN: Hey, I'm Evan, a full stack freelance developer from Sydney, Australia. I generally program in PHP & Vue, writing full stack Laravel apps but I love tinkering with new technologies and trying out cool tools. In the past, I've done fun stuff like getting PHP to run on the client side. HERE: What gave you the idea to build the Cruise Tracker? EVAN: When it broke that the Diamond Princess in Japan had hundreds of people on board infected with COVID it quicky became clear that it was the prefect environment for the virus to spread - enclosed spaces, recycled air, everyone touching the same surfaces, etc. About a week later, the Grand Princess off the coast of the United States also reported having a large quantity of people infected with the virus. When I checked a ship tracking tool, there were literally hundreds of cruise ships still criscrossing the oceans, so I decided the build a tool to track them all. HERE: Can you describe how you built it? EVAN: I started off with a pretty basic goal - display the cruise ships around Australia with the positive case count on a map marker. I built a quick little serverless function that loaded data from a google sheet (for easy data entry) and added the locations of each ship from marine location data. This quickly progressed into a full blown tracker with tooltips, sidebar, search & worldwide coverage. It took a little bit of playing around to get everything displaying right, and the icons positioned correctly, but overall the Here JS maps SDK is easy to use and provides pretty much everything you need. Each \"Ship\" is created as a marker on the map, and the html is rendered by a few small Vue components. Clicking the ship (either on the sidebar or on the map) shows the tooltip with more detailed information about the ship (passengers on board, case counts, notes & sources for the data). HERE: Why did you chose HERE? EVAN: I saw HERE's coronavirus tracker and had a look the through the docs for the map SDK, which seemed to be a good fit for what I was planning on doing. I've previously been scarred by the huge pricing jump on the google js maps, so the generous free tier seemed perfect! HERE: What worked well? EVAN: It was super easy to load the SDK and interact with it from inside Vue. With third party Typescript Types, you can get full blown IDE completion and documentation as well! HERE: What didn't? (We can take criticism!) EVAN: The markers are a bit hard to deal with (though I am probably abusing them) in the fact that the seem to be very buggy to update when the're out of the map viewport. For example, I want to make the map smoothly transition to the ship, but I couldn't figure out how to only trigger the tooltip to open once it was in view (opening it first causes it to never open since it's not in the viewport). (Note from the editor - we can work on providing an example of that!) HERE: What would you like to do next with the project? EVAN: I'm pretty happy with the feature set at this point, so we'll be keeping it updated with new data for the next month or so while there are still ships out at sea. I might open source the code for those interested, once I get it cleaned up. HERE: How can developers contact you? EVAN: You can check out my website at https://atymic.dev , which has my contact information along with other projects and blog posts. And that's a wrap. A huge thank you to Evan for answering our questions and building a cool tool. If this has inspired you, sign up for your free developer account and you can start building your own maps. Be sure to join our Slack if you need help and check our COVID-19 resources page for additional support.", "date": "2020-04-24"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.14 release", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.14-release", "abstract": "Highlights Customize Volatile layer storage capacity and redundancy to save cost The configuration options for Volatile layers have been updated to replace \"Package Type\" with the ability to customize storage capacity in increments of 100 MB. With this new feature, you can create custom sized Volatile layers where the minimum and default size is 100 MB so that you can tailor your storage capacity to your use case and budget requirements. Further, you can choose to store your volatile data redundantly or not. Together, these new options can help you greatly reduce and optimize the money you spend on Volatile layer storage. Note: Customizable Volatile layer storage capacity is possible for new Volatile layers only. While selecting no data redundancy does save cost, doing so waives all volatile layer data durability support and should be considered high risk. Documentation is updated to clarify Volatile layer storage redundancy options, factors and costs. Customers using Data Client Library versions less than 0.6.x will continue to see package types and sizes representative of various configured custom sizes (multiple size configurations can return the same package type response since the package sizes differ greatly). Access additional HERE Map Content The HERE Map Content catalog will start publishing a significant amount of additional content. The following catalog layers will be populated: Recreational Vehicle Attributes Bicycle Attributes Complex Road Attributes Warning Locations Truck Service Locations Fueling Stations Toll Cost Vehicle Regulations Flag Images Generalized Junctions & Signs 2D Landmarks 3D Landmarks All content will initially be offered without an additional premium content uplift for 8 weeks. After that, charges will apply. Note: Generalized Junctions & Signs, 2D Landmarks, 3D Landmarks are map-reference layers only, so HERE Visuals files can be properly coupled to the HERE Map. The actual product files ( e.g. landmark models ) will be published in a new Workspace catalog called “HERE Map Content – Visuals\" in the near future. Visually inspect all tiled HERE Map Content layers All tiled HERE Map Content layers have rendering scripts associated with them, that allows inspecting partition payloads visually via the Platform Portal (Inspect function). The scripts implement a basic styling of features, which can be easily overridden. Some initial examples are provided below. Access additional HERE Map Content: Navigation Attributes via the Optimized Map for Location Library The following navigation attributes from the HERE Map Content catalog are now available: Speed Limit, Supplemental Geometry, Travel Direction, and Urban flag. We will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library.  For more detail on the added attributes, please see: HERE Map Content- Navigation Attributes layer Get service reports in the support portal Platinum and Gold level support customers now have access to service reports including topics like latency and availability within the support portal . Changes, Additions and Known Issues SDK for Java and Scala To read more information about the SDK for Java and Scala, please visit the HERE Open Location Platform Changelog . Added: A new SDK component, the Data Client Base Library, is released and provides direct access to Data APIs. Along with this direct access, this library: Has no Akka dependencies so you do not need to interact with or understand Akka. Provides full control over retry strategies (number of retries, time-outs, etc.) Provides control over HTTP headers Enables counters and metrics per endpoint Is integrated with all Data APIs which were not included in the Data Client Library (e.g. the Ingest API, Notifications, etc.). This component is separate from the Data Client Library. Developers wishing to have more direct interaction with Data APIs for more specific/custom solutions can leverage this Data Client Base Library.  This component opens up Data APIs directly through a standalone client on a programmatic level. SDK for C++ To read more information about the SDK for C++, please visit the HERE Open Location Platform Changelog . Added: The option to use local system time for authentication. Added: The option to prefetch data of Volatile layers. Added: API to remove a single partition or tilekey from cache for Volatile and Versioned layers. SDK for Python Added: Write support for Versioned layers. A one step script has been added to simplify the installation, refer to the SDK for Python Set Up Guide for more details. Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Deprecated: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020. Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will currently not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Changed : In batch-2.1.0 run-time environment for batch pipelines, following libraries were upgraded in order to align with critical Data Client Library changes in the Platform SDK: com.squareup.okhttp3:okhttp from version 3.8.1 to version 3.12.10 com.squareup.okio:okio from version 1.13.0 to version 1.15.0 Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. HERE Content Added: additions to existing layers in the HERE Map Content catalog: Added alt_category attribute in Place message (found in layers: HERE Essential Places , HERE Places and Building Footprints) Added LocationAddressType for the Address Locations layer Added MatchLevelAttribute in the Places layer . Added Vehicle Checkpoint condition to Advanced Navigation layer Added Walking path and Bicycle path to supplemental geometry enum (found in the Navigation Attributes layer) Added exception list for the political view in AdministrativeContext (found in layers : Address Attributes and Administrative Places ) Added BicyclePathAttribute and deprecated DedicatedBicyclePathAttribute from Bicycle Attributes layer Deprecated: Within the Real Time Traffic catalog ( https://platform.here.com/data/hrn:here:data::olp-here:olp-traffic-1 ) the Incidents2.4 layer is being deprecated and has been labeled as such since August 2019. This is a step in the effort to migrate to the new Delta Incidents layer which is now available in the same catalog. There will no longer be new incidents published in the Incidents2.4 layer by April 30, 2020. Once this happens, volatile data will no longer have incidents after 1hr of their time-to-live. As this will be a schema change, there are instructions in the layer description on how to migrate. Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 July 31, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after July 31, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after July 31, 2020. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before July 31, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after July 31, 2020. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 OrgID added to Schema HRN (Global) 2.10 December 2019 July 31, 2020 Deprecation Summary: References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. 3 Data Client Library data compression behavior 2.10 December 2019 June 20, 2020 Deprecation Summary: As of June 30, 2020, all data streaming related workflows must be updated to use at least SDK version 2.9.  The Data Client Library behavior as it relates to compressing and decompressing streaming data will strictly adhere to stream layer configuration settings. 4 Spark-ds-connector replaced by SDK for Java and Scala Spark Connector 2.12 February 2020 August 19, 2020 Deprecation Summary: The spark-ds-connector will be deprecated (6) months from this release on August 19, 2020. Please upgrade to the latest SDK for Python version before then to get the latest SDK for Java and Scala Spark Connector. 5 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. Existing Batch pipelines that use the Batch-2.0.0 run-time environment will continue to operate normally until August 19, 2020. During this period, Batch-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-2.0.0 environment, please use OLP SDK 2.11 or older. After August 19, 2020 we will remove the Batch-2.0.0 run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. 6 Schema validation to be added 2.13 March 2020 September 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of September 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If a non-existing or non-accessible schema is associated with any layer after this date, any attempt to update any configurations of that layer will fail. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before September 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 7 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020.", "date": "2020-04-28"},
{"website": "Here", "title": "Introducing the new HERE SDK for Flutter (Beta)", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/introducing-the-new-here-sdk-for-flutter-beta", "abstract": "Last week we announced the release of our new HERE SDKs for Android and iOS. This was exciting news for us and hopefully for you! However, the more eagle-eyed among you might have noticed that we also quietly released the Beta version of another new SDK. Today we are making it official. We are excited to announce the release of our brand new HERE SDK for Flutter (Beta). This SDK is built on the same code base as the HERE SDKs for Android and iOS. All new SDKs have been rebuilt from the ground up for your coding pleasure and are backed by more than 30 years expertise in mapping and location technology. They enable you to give your users access to the latest mapping data as well as your favorite location services from HERE, including Maps, Search, Directions and Traffic. The DevRel team has received many requests for a Flutter SDK, particularly at hackathons and many mobile-related conferences we have attended, so this is a particularly exciting release for us. So, how do you get started? As with our Android and iOS SDKs, the easiest way to get started is to go to GitHub and check out our new HERE SDK Examples . The readme.md has all the info you need to get your first example up and running! If you want to build something from scratch or integrate the SDK into an existing application, you should head over to the HERE SDK documentation and check out the Get Started section . Either way you’ll need a set of credentials, so go ahead and sign up for a Freemium account ! We’d love to hear your feedback, so join us on the HERE Developers Slack channel , follow us on Twitter or leave your comments below. Which editions of the SDK are available for Flutter? The HERE SDK for Flutter is available in Explore and Navigate editions. Is the Flutter SDK part of my Freemium plan? Yes. The HERE SDK for Flutter Explore Edition is part of your Freemium plan. The Navigate edition is currently available on request. The HERE SDK for Flutter is in Beta. What does that mean exactly? First, you may run into some bugs. Second, the documentation is not complete yet. And finally, there is still some chance of API changes. How long will the Beta period for the HERE SDK for Flutter last? We expect the beta period for the HERE SDK for Flutter to last until Q3. This is subject to change.", "date": "2020-04-29"},
{"website": "Here", "title": "Solutions Day 26-30 : #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-26-30-100daysofcode", "abstract": "We are back with another week of #100DaysOfCode with HERE. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. In this blog post, I will cover solutions for days 26 through 30. If you have missed the solutions for days 0-25, you can read them in my previous blogs posts or in the video format . Let's begin! Day 26/100 With Day 26, we start exploring the rest of the endpoints of the Geocoding and Search API . While geocode gives you the generic address-to-geocoordinates solution, discover is more specific and gives you results based on your current position. This can be applied when you reach a new place and want to know 'what are some of the cool things to do here'. Here, we are searching for 'markets' while specifying our current position. // Get an instance of the geocoding service:\n  var geocoder = platform.getSearchService();\n\n  function geocodeAndSearch(){\n\n      let geocoderParams = {\n          q : 'markets', // free form query\n          at : '52.49105,13.37917' // position in the format latitude, longitude\n      }\n\n      function onResult(result){\n          console.log(result);\n      }\n\n      geocoder.discover(geocoderParams,onResult,alert);\n\n  }\n\n  geocodeAndSearch(); Day 27/100 The results from Day 26 give you a variety of results with places which can be identified as markets. One way to filter these results is by specifying a search radius. This can be done by using the in parameter of the discover endpoint . Here we specify our search field as a circle and specify the radius in meters. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n  \n    function geocodeAndSearch(){\n  \n        let geocoderParams = {\n            q : 'markets',\n            in : 'circle:52.49105,13.37917;r=1000'\n        }\n  \n        function onResult(result){\n            console.log(result);\n        }\n  \n        geocoder.discover(geocoderParams,onResult,alert);\n  \n    }\n  \n    geocodeAndSearch(); Day 28/100 If you expand the results from the query on Day 27, you will see that the results come with an important paramter along with the adddress and position of the places searched for. This paramater is the 'distance'. This is the distance of these places in meters, from the center of your search. The distance value can help the user choose the 'market' they want to go to. {…} ​\n        items: (8) […]\n            0: {…}\n    ​​​            access: (1) […]\n                    0: Object { lat: 52.49006, lng: 13.38577 } ​​​​\n                    length: 1\n                address: Object { label: \"Guuht, Kreuzbergstraße 1, 10965 Berlin, Deutschland\", countryCode: \"DEU\", countryName: \"Deutschland\", … }    ​\n                categories: Array(4) [ {…}, {…}, {…}, … ]   ​​​\n                contacts: Array [ {…} ]    ​​​\n                distance: 456    ​​​\n                foodTypes: Array [ {…} ]   ​​​\n                id: \"here:pds:place:276u33d8-9e827cde6ea64aefb6936cfc02c66296\"   ​​​\n                openingHours: Array [ {…} ]   ​​​\n                position: Object { lat: 52.49019, lng: 13.38576 }  ​​​\n                resultType: \"place\"  ​​​\n                title: \"Guuht\" For Day 28, we use this distance and display it on an Info-Bubble . We use the position of the places as the position of the info-bubble. function onResult(result){\n        //   console.log(result);\n        result.items.forEach(item => {\n            ui.addBubble(new H.ui.InfoBubble( item.position, {\n                content: 'distance: '+item.distance+' m'\n            }));\n        });\n\n      } Day 29/100 The endpoint Autosuggest can be used like an auto-complete for places and addresses. This can be done by providing an input field to the user where they can start typing their search query. The responses of the geocoder-autosuggest can be displayed as options for the selection by the user. For Day 29, we have taken the incomplete query 'star' in a bid to find the nearest starbucks. We query the geocoding and search API with the autosuggest endpoint . Note that the incomplete query q needs to be used with the parameters at or in . You can read more about it in the autosuggest section of the Geocoding and Search API . // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n  \n    function geocodeAndSearch(){\n  \n        let geocoderParams = {\n            q : 'star',\n            at : '52.491059,13.37917'\n        }\n  \n        function onResult(result){\n          console.log(result);\n        }\n  \n        geocoder.autosuggest(geocoderParams,onResult,alert);\n  \n    }\n  \n    geocodeAndSearch(); Day 30/100 On Day 27, we restricted our search to a circle with a radius. Guess what? You can also restrict searches in a box. For Day 30, we are modifying the autosuggest search query from Day 29 and adding the parameter in:bbox to restrict our search to a bounding box . When you wish to draw a polygon, you need to define the length of each side. For a bounding box in terms if location, you will need the position of a point (a geocoordinate) on all the sides of the box. We start with the left side and go anti-clock wise. Now as the left side is the vertical side, we use the vertical coordinate (longitude) of any point of this box. For the horizontal sides of this box, we use the horizontal coordinates (latitude). This this box can be defined with bbox:Left-longitude, bottom-latitude, right-longitude, top-latitude . If you are still confused, check out the documentation on this one. The autosuggest search will now be restricted to the bounding box we define with these coordinates. // Get an instance of the geocoding service:\nvar geocoder = platform.getSearchService();\n\nfunction geocodeAndSearch(){\n\n    let geocoderParams = {\n        q : 'star',\n        in : 'bbox:13.3817,52.50474,13.40432,52.51647'\n    }\n\n    function onResult(result){\n      console.log(result);\n    }\n\n    geocoder.autosuggest(geocoderParams,onResult,alert);\n\n}\n\ngeocodeAndSearch(); This week we covered the discover and autosuggest endpoints of the Geocoding and Search on #100DaysOfCode. We will explore the other endpoints of Geocoding and Search as well as other APIs in the days to come. Hope you enjoyed this week of #100DaysOfCode with HERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . While you're at it, why don't you take a look at the blog post announcing the release of our new HERE SDK for Flutter . Want to kmnow how to use the OAuth authentication method? Take a look at the step-by-step tutorial . Happy coding!", "date": "2020-05-02"},
{"website": "Here", "title": "IoT and Location Services: A Match Made in Heaven", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/iot-and-location-services-a-match-made-in-heaven", "abstract": "What is the Internet of Things? The Internet of Things (or IoT) is a massive ecosystem of physical objects embedded with electronics, software, sensors and network connectivity. All the embedded components help to collect and exchange data. The idea is to have intelligent device-to-device communication without any human intervention. Sources differ on the number of connected devices in IoT, but all of them have one thing in common, these numbers are in billions. How can this number go to billions? The answer lies in the term 'Things' in IoT. A 'Thing' could be a human with a heart monitor, an automobile with performance tracking sensors or an industrial robot with activity monitoring system. The possibilities are huge since IoT can be implemented on all the things in the world. And that is exactly where world is moving toward, a connected world where machines interact with each other autonomously. Role of Location in IoT In the world of IoT, every device is fitted with different sensors, generating an enormous amount of various types of unstructured data. IoT has changed the way we perceive data. We now understand that data is not comparable to gold but to oil. Just like crude oil, raw data is of not much value. It is only after processing the data correctly, it becomes valuable. But we do have an exception, data which is of high value and highly useful even in raw format. This is location data, latitude and longitude. Let us look at a few use cases involving location. Asset Tracking and Supply Chain Tracking - Track asset as they move anywhere in the world. Adding tracking capabilities increases the efficiency of the supply chain management. Connected Car -  Track a car outdoor or indoor precisely. Get features like location based weather report and improved distance calculation between source to destination. Wearables - Locate and track wearable devices accurately anywhere in the world. Devices like fitness or health bands, smart watches and wearable cameras. The true value of location in IoT lies in the contextual analysis of location data to achieve an intended outcome. This outcome could be a search result for a nearby food joint or a weather information of an area. The contextual data analysis can be achieved by leveraging the capabilities of location platforms like HERE . Imagine you are driving a smart car and your car indicates you a new route incorporating the sudden rush in traffic on your old route. A blessing for you as you now have saved around an hour. The scenario looks entirely different from a developer’s perspective builds this system. Why? Because developer has to get location data and pass it through a series of analytical algorithms to get the desired output, which in our case is a new route! The complete analysis could be less effective or less optimized, as a lot of different factor comes into picture. The solution to get away from all this hassle is to utilize Location Based Services. You can explore more about these services here . How does IoT works? To understand the role of location in IoT, it is imperative to understand how it works. Most IoT Ecosystem consists of four components IoT Device IoT Gateway Cloud User Interface / Application In some of the scenario IoT Device and Gateway together are called Edge Devices. Lets understand each component individually. IoT Device The main task of a device is to collect data from the surrounding environment and forward it to the cloud or an IoT gateway. The collected data could be as simple as a temperature value or as complex as a video feed. One way to understand an IoT device is to compare it with a human being. For example, our skin is able to detect changes in temperature. In short, it is a sensory organ. We could even  call it a sensor. The skin relays the temperature data to our brain, which decides whether to feel cold or warm by computing the relation between our current body state and acquired temperature data. The brain acts as a computing device, and if it computes the state to be cold, we quickly wear a sweater to keep ourselves warm. We perform action or actuation. If the cold is severe, we communicate our state to a doctor with the help of our mouth and ears which represents a full duplex communication. Mouth and ears are communication entities. IoT device also work in similar way, and it is embedded with following capabilities - Computing - Microcontroller and SBC (Single Board Computer) (Similar to a brain) Sensing - Analog and Digital Sensors (Similar to skin) Actuation - LED, a motor (Similar to legs and hands) (optional) Communication - WiFi, Bluetooth, LoRaWAN, NFC, ZigBee (Similar to mouth and ears) With the different combination of above components we are able to create an IoT device for different scenarios. Components selection depends on use case. The above diagram depicts an IoT device collecting location data with the help of GPS sensor, passing it to MCU (Microcontroller) or SBC (Single Board Computer) where data is processed, and lastly data can be moved forward to a Gateway or a cloud with the help of Wi-Fi communication module (like ESP01). IoT Gateway The task of Gateway is to manage bidirectional data traffic between different networks and protocol. It mostly works as a protocol converter solving interoperability issue between devices and cloud. Generally they are more powerful than IoT devices and are capable of handling communication requests from thousands of IoT devices at a time. IoT Gateway plays a major role in security by acting as a middle layer between devices and cloud to protect the low powered devices from malicious attack and unauthorized access. There are two types of Gateways we can work with IoT Gateway from Vendors - Companies who specializes in IoT Gateway DIY IoT Gateway - One you build with the help of SBCs like Raspberry Pi A lot of different tasks can be performed on the gateway depending on its processing capabilities, especially tasks like data analysis and machine learning model building. The Cloud The amount of data generated from IoT is massive and it requires a lot of processing and effort to manage this data efficiently. Cloud offers tools which helps to collect, process, store and manage data in real time. Any application or service is able to access the data remotely without any hassle. Cloud is able to integrate billions of devices, gateways, data, user requests and provides data analytics and machine learning. The cloud provides two architectural support for IoT. Client Server Architecture with HTTP protocol Publish Subscribe Architecture with MQTT protocol Both architectures have different implementation scenario with respective pros and cons. If you are thinking about which one suits your requirement, then you need to perform detailed analysis of your use case and do remember that price also plays a big role in not only selecting the right cloud but the architecture also. There are different cloud service providers to select from and all of them have a matured IoT ecosystem support to choose from. The major ones are AWS IoT Microsoft Azure IoT Hub IBM Watson IoT Platform Google Cloud IoT PTC ThingWorx Industrial IoT Platform. The User Interface User interface is the visible part of IoT Ecosystem which is accessible by a user. Application designers are entrusted with designing an easy to use user interface for effective interaction between user and services. There are two types of application that you will find in IoT. Mobile Application - iOS and Android Web Application - SPA (Single Page Application) and JS websites These applications are at the other end of the IoT Ecosystem and are used to control the IoT Device, query the result of data analytics performed on the cloud and monitor the state of IoT device. Conclusion When we look at the entire IoT Ecosystem as one complete picture, we can easily notice where location data and services can be integrated. From IoT device with a GPS sensor module sending data to a cloud like AWS, where we can store the data and perform heavy processing with location services like geocoding, searching a place, fleet telematics. To a mobile application which receives the location information of your IoT device from the cloud and plots it on the map. Location is involved at all the stages in IoT and act as an enabler. Location Services and IoT is indeed a match made in heaven.", "date": "2020-05-01"},
{"website": "Here", "title": "Join IBM and HERE at Call for Code 2020", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/join-ibm-and-here-at-call-for-code-2020", "abstract": "In addition to our shared experience during a global pandemic and lockdown, as a developer evangelist it feels really bizarre to not be able to meet our community in person and hear about the challenges you want to solve. While we wait for the world to transition into a new normal, we have joined a line-up of digital events to stay in touch with our community and support with our platform. Earlier this month we joined IBM's Call for Code 2020 – below are all details on how you can be part of it too and how you can join other developers in the fight against COVID-19 and climate change. HERE Technologies is part of the IBM challenge ecosystem which makes the 2020 Call for Code possible. This is a global initiative in response to COVID-19 and a second track which deals with the impact of climate change and how we can track and prevent it. The COVID-19 track has an expedited timeline, and the top 3 solutions will be announced next week on May 5 during IBM Think, now a digital experience . However, both tracks will remain open until July 31 st which is when final submissions are due. Winners will be announced in October 2020. What is our role at Call for Code 2020? HERE has submitted code and API access for the Call for Code starter kits – you can get started with them right away. The goal of the community approach is to provide a mobile application, along with server-side components, that serves as the basis for developers to build out a community cooperation application that addresses local needs for food, equipment, and resources. Get more details here. COVID-19 resources Community Cooperation – Starter kit Community Cooperation - Tutorial Community Cooperation - GitHub Natural Disaster/Climate Change Natural Disaster – Starter Kit Natural Disaster – Tutorial Natural Disaster - GitHub Next steps Accept the challenge! Follow this link to get started. In the coming weeks, keep an eye out for additional resources like tutorials and live stream Q+As to help you with your Call for Code location data needs. If you have any questions or comments , reach out on Twitter @heredev . Winners will be announced October 2020 and will receive $200,000. Also, with the support of IBM, your prototype will also be made a reality.", "date": "2020-04-30"},
{"website": "Here", "title": "Mapping all Star Wars filming locations", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/may-the-fourth-be-with-you", "abstract": "Every day to me is Star Wars day. However, most recognize May 4th as the unofficial Star Wars Day. To celebrate that, we created a map of the Star Wars Universe. How would that work since Star Wars takes place \"far, far away\"? Turns out, Wikipedia has a great resource of Star Wars filming locations here on Earth. In this post I will show you how to turn the map below into a HERE Studio map: I decided to take a look and see if I could get this data myself. I began by clicking the \"Edit\" link above the map and discovered, much to my joy, that it was actually already in GeoJSON! I copied and pasted it into Visual Studio Code and noticed right away that the GeoJSON wasn't actually valid. Visual Studio Code did a great job of flagging this: It's probably hard to see, but in the right hand gutter of the editor are a few red marks. Each mark is something that's invalid JSON which in this case was the embedded comments. I'm assuming Wikipedia simply strips these out before working with the map. The next issue was that properties included Wikipedia formatting rules, for example: \"title\": \"{{flagicon|UK}} [[Whippendell Woods]], [[Watford]]\",\n\"description\": \"Location for the planet Naboo [[File:Glade in Whippendell Wood - geograph.org.uk - 1763434.jpg|150px|alt=Whippendell Woods]]\", Initially I thought I'd write a quick Node.js script to iterate over the data and try to \"fix\" each with my Jedi-like coding skills. (Spoiler, I'm no code Jedi.) But then I realized I could probably fix it by hand in about ten minutes. I used some regular expressions in Visual Studio Code and plain grunt work to create a cleaner, simple GeoJSON file. In the end, each feature only had two properties, name and title. Here's an example. {\n  \"type\": \"Feature\",\n  \"properties\": {\n      \"title\": \"Onk Jemal, Tozeur\",\n      \"description\": \"Location for Mos Espa on Tatooine\"\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      7.842748, 33.99403\n    ]\n  }\n}, We could have more information of course. I'd love a list of the exact films used for that location. I'd also love to spell out the planet with maybe a link to Wookiepedia . But for now I'm keeping it simple. (\"Stay on target, Raymond!\") Alright, now that I've got some GeoJSON, let's head over to HERE Studio . The first thing I did was to create a new space in the Data tab. I then made a new project, edited a few settings, and imported my data. Bam. Done! I love Studio! Of course, the default color scheme isn't quite appropriate. In order to make it a bit nicer, I first changed the marker to an icon. The \"Attraction\" icon seemed perfect for this data: I tweaked a bit more and then hit the publish link. You can view the full version here or play with it below: There's certainly more that could be done, and if anyone would like a copy of the GeoJSON file, just ask. Also note that the map I created above was all done with a free developer account at HERE, so you could absolutely do this yourself as well! Have a wonderful Star Wars Day!", "date": "2020-05-04"},
{"website": "Here", "title": "Getting started with IBM Call for Code Community Collaboration", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/call-for-code-community-collaboration-starter", "abstract": "Last week we introduced our collaboration with IBM on Call for Code 2020. We are working with IBM on the Call for Code challenges to encourage developers to find ways to help fight both COVID-19 and climate change. To help with this, we've released two starter kits that give you, well, a start in building your project. In this post, I'm going to help you with the first starter kit on Community Collaboration . This starter kit imagines a scenario where a community needs to find a way to connect people who have items (food, masks, and so forth) with people who need items. The starter kits contains a Node.js server-side application to handle communication with IBM Watson and a React Native mobile application as the client. The React Native application makes use of HERE Maps support as well as Routing and Geolocation. In this post, I'm going to give a quick introduction to HERE Location Services used in the starter kit and give some tips and examples for how you could use them, and other services, if you decide to join this initiative. Remember that the \"Starter Kit\" is just that - a way to get started. You're completely welcome to use it in any way you wish, or not at all! First, let me start off with something not HERE or IBM related at all. In the React Native application, geolocation code is used to determine the user's position. For folks who are building a pure web based solution, you will want to use the browser's Geolocation API instead. All modern browsers support the ability to request a user's location (see the CanIUse data for a comprehensive look at browser support), but it is something that the user will have to give permission for. The Mozilla Developer Network has great documentation for the API, but here's an incredibly simple demo that gets the user's location and prints it to the screen: <html>\n<head>\n<title>Geolocation Test</title>\n</head>\n\n<body>\n<div id=\"result\"></div>\n<script>\ndocument.addEventListener('DOMContentLoaded', init, false);\nfunction init() {\n    if(!navigator.geolocation) {\n        alert(\"Your browser doesn't support geolocation.\");\n        return;\n    }\n\n    navigator.geolocation.getCurrentPosition(result => {\n        console.log(result);\n        let html = `\n<p>\nYour position is ${result.coords.latitude}, ${result.coords.longitude}.\n</p>\n        `;\n\n        document.querySelector('#result').innerHTML = html;\n    }, error => {\n        alert(error);\n    });\n}\n</script>\n</body>\n</html> The API I used here was navigategor.geolocation.getCurrentPosition . This API supports additional parameters related to how the location is determined but the defaults should be fine for most use cases. There's also an API to watch the user's location which will give you updated values as the user moves. (Which is probably something you only want to do on a mobile device!) Now, let's talk about our maps. You should begin by looking at the documentation , which covers our maps library for JavaScript, Android, and iOS. I'm primarily a web developer so I'll focus my attention on this. Using our maps require loading a few JavaScript libraries, a CSS resource, and then adding some code to your site. You'll also need a key which you can get with a free developer account . The keys used in client-side applications can be locked down to specific hosts so it's safe to use in JavaScript. Here's a template that loads up a map, enables basic interaction controls (pinch to zoom, touch or click to move, and so forth), and adds UI for zooming. <!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Test</title>\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n        <style>\n            #mapContainer {\n                width: 500px;\n                height: 500px;\n            }\n        </style>\n    </head>\n    <body>\n\n        <div id=\"mapContainer\"></div>\n\n        <script>\n        const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\n        var platform = new H.service.Platform({\n            'apikey': KEY\n        });\n\n        // Obtain the default map types from the platform object:\n        var defaultLayers = platform.createDefaultLayers();\n\n        var map = new H.Map(\n            document.getElementById('mapContainer'),\n            defaultLayers.vector.normal.map,\n            {\n                zoom: 5,\n                center: { lat: 30.22, lng: -92.02 },\n                pixelRatio: window.devicePixelRatio || 1\n            }\n        );\n\n\n        var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n        // Create the default UI:\n        var ui = H.ui.UI.createDefault(map, defaultLayers);\n\n        </script>\n    </body>\n</html> The map above is centered on my home town, but obviously you could center it anywhere, or even better, combine it with geolocation code to center the map on the user's location. <!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Test</title>\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n        <style>\n            #mapContainer {\n                width: 500px;\n                height: 500px;\n            }\n        </style>\n    </head>\n    <body>\n\n        <div id=\"mapContainer\"></div>\n\n        <script>\n        const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\n        var loc;\n\n        document.addEventListener('DOMContentLoaded', init, false);\n\n        function init() {\n            if(!navigator.geolocation) {\n                alert(\"You're browser doesn't support geolocation.\");\n                return;\n            }\n\n            navigator.geolocation.getCurrentPosition(result => {\n                loc = result.coords;\n                renderMap();\n            }, error => {\n                alert(error);\n            });\n\n        }\n\n        function renderMap() {\n            var platform = new H.service.Platform({\n                'apikey': KEY\n            });\n\n            var defaultLayers = platform.createDefaultLayers();\n\n            var map = new H.Map(\n                document.getElementById('mapContainer'),\n                defaultLayers.vector.normal.map,\n                {\n                    zoom: 12,\n                    center: { lat: loc.latitude, lng: loc.longitude },\n                    pixelRatio: window.devicePixelRatio || 1\n                }\n            );\n\n            var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n            var ui = H.ui.UI.createDefault(map, defaultLayers);\n        }\n        </script>\n    </body>\n</html> Finally, the starter applications makes use of both Routing and Geocoding . Both of these services can be used outside of our maps as well. You can use the Geocoding and Search REST APIs both in your client-side and server-side code. Search in particular could be useful as it would let you find medical-related points of interest near your user. Consider this API call as an example: https://browse.search.hereapi.com/v1/browse?apikey={{apiKey}}&at=30.22,-92.02&categories=800-8000-0000 This returns hospitals and health care facilities near the location specified in the at parameter. Here's an example result: {\n    \"title\": \"Home Care Associates\",\n    \"id\": \"here:pds:place:8403fv6k-1b0587e41e2a05c09781481bd6b94f8d\",\n    \"resultType\": \"place\",\n    \"address\": {\n        \"label\": \"Home Care Associates, 600 Jefferson St, Lafayette, LA 70501, United States\",\n        \"countryCode\": \"USA\",\n        \"countryName\": \"United States\",\n        \"state\": \"Louisiana\",\n        \"county\": \"Lafayette\",\n        \"city\": \"Lafayette\",\n        \"street\": \"Jefferson St\",\n        \"postalCode\": \"70501\",\n        \"houseNumber\": \"600\"\n    },\n    \"position\": {\n        \"lat\": 30.22339,\n        \"lng\": -92.01931\n    },\n    \"access\": [\n        {\n            \"lat\": 30.22338,\n            \"lng\": -92.01878\n        }\n    ],\n    \"distance\": 383,\n    \"categories\": [\n        {\n            \"id\": \"700-7200-0272\"\n        },\n        {\n            \"id\": \"700-7200-0277\"\n        },\n        {\n            \"id\": \"700-7400-0138\"\n        },\n        {\n            \"id\": \"800-8000-0000\"\n        }\n    ],\n    \"contacts\": [\n        {\n            \"phone\": [\n                {\n                    \"value\": \"+13375047710\"\n                }\n            ],\n            \"www\": [\n                {\n                    \"value\": \"http://www.homecareassoc.com\"\n                },\n                {\n                    \"value\": \"http://www.homecareassoc.com/\"\n                }\n            ],\n            \"email\": [\n                {\n                    \"value\": \"info@homecareassoc.com\"\n                }\n            ]\n        }\n    ],\n    \"openingHours\": [\n        {\n            \"text\": [\n                \"Mon-Sun: 00:00 - 24:00\"\n            ],\n            \"isOpen\": true,\n            \"structured\": [\n                {\n                    \"start\": \"T000000\",\n                    \"duration\": \"PT24H00M\",\n                    \"recurrence\": \"FREQ:DAILY;BYDAY:MO,TU,WE,TH,FR,SA,SU\"\n                }\n            ]\n        }\n    ]\n}, As you can see, quite a bit of information is returned. Everything from it's location to contact information about open hours. Routing also has a REST API with extensive options covering things like waypoints (stopping at certain points along the way), avoidance (avoiding locations as well as types of locations) and routes that make use of public transit. Here's a simple example of a route calculation call: https://router.hereapi.com/v8/routes?transportMode=car&origin=30.22,-92.02&destination=32.8047,-96.6782&return=summaryapikey={{apiKey}} This just returns a summary of the trip which would useful for letting the user know how long it's going to take to get to their destination. You can absolutely return much more information including complete turn by turn navigation. Lastly, the starter code project makes use of IBM Cloudant for storing resources and their location. While Cloudant is excellent, you may also want to consider using HERE's Data Hub . Data Hub lets you store data with specific APIs tailored for location related tasks. For example, returning all items within a certain radius. Data Hub is part of our freemium tier and consists of APIs, a CLI, as well as Studio , a full web-based tool for rendering maps of location-aware data. I hope this has been useful for folks accepting the Call for Code challne. If you need more help with HERE's tools, be sure to visit us on Slack or Stack Overflow . We'll also be creating more helpful content for Call for Code and will be answering real-time questions on future IBM Twitch streams.", "date": "2020-05-06"},
{"website": "Here", "title": "How to Quickly Get Started with HERE", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-to-create-a-developer-account", "abstract": "Essential for doing development with any HERE products is establishing a developer account and obtaining the proper credentials to use our SDKs or make API calls. This blog post features the steps and resources needed to quickly get started as a developer with HERE. Creating a Developer Account To create a new account, you will need a working email and a device such as a computer or tablet with internet connection. The following short video walks through the registration process for creating a Freemium account: Obtaining Developer Credentials Once a developer account is created, you will need to obtain developer credentials for access to products such as our REST APIs and JavaScript libraries. Each has a slightly different approach. Obtaining an API Key for JavaScript To access our JavaScript SDK, you will need an API Key to initialize it. The following video demonstrates how to get an API Key for JavaScript from your developer account: Obtaining an API Key for REST APIs To use our REST APIs, you will need an API Key for each request. The following video demonstrates how to get an API Key for REST from your developer account: Summary Getting started with HERE is a fast and easy process! You may also want to check out our tutorial for a step-by-step walk-through on how to get started!", "date": "2020-05-05"},
{"website": "Here", "title": "Getting Started with the IBM Call for Code Disaster Resilience Starter", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/getting-started-with-the-ibm-call-for-code-disaster-resilience-starter", "abstract": "Earlier this month I blogged about our collaboration with IBM in their Call for Code initiative as a way to encourage developers to find ways to help fight both COVID-19 and climate change. I mentioned that IBM had created two starter kits and talked about some of the APIs and suggestions for the first one involving Community Collaboration . Today I'll walk you through the second starter kit, Disaster Resiliency and Climate Change . The starter kit focuses on the problem of flooding and imagines an application that supports three unique modes. Before a flood occurs, the app provides resources to help people prepare for flooding. Once a flood occurs, the app switches to emergency mode and displays a route to an available shelter with capacity. The third stage of the app includes suggestions for rebuilding as well as serving as a platform for people to ask for and provide supplies. As with the previous blog post, I'm going to provide some information and examples related to HERE Location Services that will work well with this starter. This isn't meant to be a  finished solution, but merely a few examples of how the services work and how easy (hopefully!) they will be for you to implement. Let's begin with Routing. Routing In my last article I talked about our routing API and described how simple it was to get a path from one point to the other. While the API is flexible and can be used anywhere, what about an example on a map? Let's start with a basic map: const KEY = 'your key here';\nvar platform = new H.service.Platform({\n    'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nvar defaultLayers = platform.createDefaultLayers();\n\nvar map = new H.Map(\n    document.getElementById('mapContainer'),\n    defaultLayers.vector.normal.map,\n    {\n        zoom: 5,\n        center: { lat: 30.22, lng: -92.02 },\n        pixelRatio: window.devicePixelRatio || 1\n    }\n);\n\n\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n// Create the default UI:\nvar ui = H.ui.UI.createDefault(map, defaultLayers); To add routing, you first add an instance of the routing service: var router = platform.getRoutingService(); Then you define parameters for your route. There's a lot you can do here, but to make it simple I've just asked for the fastest route from Lafayette, Louisiana to New Orleans. var routingParameters = {\n    // The routing mode:\n    'mode': 'fastest;car',\n    // The start point of the route:\n    'waypoint0': 'geo!30.22,-92.02',\n    // The end point of the route:\n    'waypoint1': 'geo!29.95,-90.07',\n    // To retrieve the shape of the route we choose the route\n    // representation mode 'display'\n    'representation': 'display'\n}; Then you simply calculate the route, I say simply but the actual route calculation is petty simple: router.calculateRoute(routingParameters, result => {\n\n}, e => {\n\n}); Of course, working with the result takes a bit more work. The result will contain information that lets you plot the route on the map. Here's that portion: let route, routeShape, startPoint, endPoint, linestring;\nif(!result.response.route) return;\n\n// Pick the first route from the response:\nroute = result.response.route[0];\n// Pick the route's shape:\nrouteShape = route.shape;\n\n// Create a linestring to use as a point source for the route line\nlinestring = new H.geo.LineString();\n\n// Push all the points in the shape into the linestring:\nrouteShape.forEach(function(point) {\n    var parts = point.split(',');\n    linestring.pushLatLngAlt(parts[0], parts[1]);\n});\n\n// Retrieve the mapped positions of the requested waypoints:\nstartPoint = route.waypoint[0].mappedPosition;\nendPoint = route.waypoint[1].mappedPosition;\n\n// Create a polyline to display the route:\nvar routeLine = new H.map.Polyline(linestring, {\n    style: { strokeColor: 'blue', lineWidth: 3 }\n});\n\n// Create a marker for the start point:\nvar startMarker = new H.map.Marker({\n    lat: startPoint.latitude,\n    lng: startPoint.longitude\n});\n\n// Create a marker for the end point:\nvar endMarker = new H.map.Marker({\n    lat: endPoint.latitude,\n    lng: endPoint.longitude\n});\n\n// Add the route polyline and the two markers to the map:\nmap.addObjects([routeLine, startMarker, endMarker]);\n\n// Set the map's viewport to make the whole route visible:\nmap.getViewModel().setLookAtData({bounds: routeLine.getBoundingBox()}); That's quite a bit, but the comments should make it clear what's going on. We work with the first result (our service may return multiple routes) and create a \"line\" object. This line is filled with the result data from the route. Then we add markers to the beginning and end of the route to make it even more clear. This is all added to the map and then we \"reset\" the map view to ensure you can see the complete route. Here's how it looks: You can find the complete source for this demo here . Maps with Markers Another aspect that would be useful for this starter (and the previous one ) is adding markers to a map. Luckily this is incredibly simple to do. In fact, you can do it in one line of code: map.addObject(new H.map.Marker({lat:30.9087, lng:-92.1079})); Markers can be customized of course (check out out docs for examples of this), but if you're ok with the default marker style and size, it's as simple as specifying a location. Here's an example with a dynamic set of markers. (Well to be clear, the set is hard coded, but you could imagine this coming from a third party API.) let locations = [\n    { lat: 31.22, lng: -91.02 },\n    { lat: 30.22, lng: -88.02 },\n    { lat: 29.22, lng: -89.02 },\n    { lat: 28.22, lng: -88.02 },\n    { lat: 27.22, lng: -94.02 },\n\n];\n\nlocations.forEach(l => {\n    map.addObject(new H.map.Marker(l));\n}); Here's how it looks: You can find the complete source for this example here . Don't forget that if you need to store geospatial data, you should consider looking at Data Hub . It's got great APIs for working with this kind of data and our JavaScript Maps have built-in support for it! Getting the Weather The starter mentions the excellent IBM service for getting weather data, you may also want to take a look at our Destination Weather API . This API provides current conditions, forecasts, and information about any weather alerts (like flooding). You can ask for weather information using a latitude and longitude, a zip code, or a name. Here's a simple example for the current weather at my location: https://weather.ls.hereapi.com/weather/1.0/report.json?apiKey={YOUR_API_KEY}&product=observation&name=Lafayette,LA This returns an array of observations based on the name value. If you look at the first response only, you've got a lot of data: {\n  \"observation\": [\n    {\n      \"daylight\": \"D\",\n      \"description\": \"Mostly cloudy. Warm.\",\n      \"skyInfo\": \"16\",\n      \"skyDescription\": \"Mostly cloudy\",\n      \"temperature\": \"25.61\",\n      \"temperatureDesc\": \"Warm\",\n      \"comfort\": \"26.83\",\n      \"highTemperature\": \"27.90\",\n      \"lowTemperature\": \"22.70\",\n      \"humidity\": \"74\",\n      \"dewPoint\": \"20.61\",\n      \"precipitation1H\": \"*\",\n      \"precipitation3H\": \"*\",\n      \"precipitation6H\": \"*\",\n      \"precipitation12H\": \"*\",\n      \"precipitation24H\": \"*\",\n      \"precipitationDesc\": \"\",\n      \"airInfo\": \"*\",\n      \"airDescription\": \"\",\n      \"windSpeed\": \"16.68\",\n      \"windDirection\": \"170\",\n      \"windDesc\": \"South\",\n      \"windDescShort\": \"S\",\n      \"barometerPressure\": \"1014.60\",\n      \"barometerTrend\": \"\",\n      \"visibility\": \"16.09\",\n      \"snowCover\": \"*\",\n      \"icon\": \"6\",\n      \"iconName\": \"mostly_cloudy\",\n      \"iconLink\": \"https://weather.ls.hereapi.com/static/weather/icon/17.png\",\n      \"ageMinutes\": \"15\",\n      \"activeAlerts\": \"15\",\n      \"country\": \"United States\",\n      \"state\": \"Louisiana\",\n      \"city\": \"Lafayette\",\n      \"latitude\": 30.2241,\n      \"longitude\": -92.0198,\n      \"distance\": 3.74,\n      \"elevation\": 11,\n      \"utcTime\": \"2020-05-15T11:53:00.000-05:00\"\n    }\n  ],\n  \"country\": \"United States\",\n  \"state\": \"Louisiana\",\n  \"city\": \"Lafayette\",\n  \"latitude\": 30.22409,\n  \"longitude\": -92.01984,\n  \"distance\": 0,\n  \"timezone\": -6\n} Check out the docs for more information, but I'll share a quick tip for my American readers - add &metric=false to return Imperial values. (Sorry, as much as I've tried to I can't \"learn\" Celsius!) I hope this has been useful for folks considering taking up the Call for Code . On Friday, May 22nd at 12PM EST, IBM is hosting a livestream and I'll be on it. Here's more information: Join here: https://developer.ibm.com/livestream/ May 22 | 12 pm - 1:30 pm ET Title: Call for Code Live: Become more resilient to disasters Speakers: Joshua Zheng and va Barbosa, IBM; Raymond Camden, HERE Understand the connection between climate change and disasters and learn how technology can help our society become more resilient to disasters. Boost your Call for Code solution with the disaster resiliency starter kit , which includes an AI-based app that can help communities better prepare for and respond to floods. Our experts will show you how to build an application that combines IBM Data and AI offerings with HERE Technologies’ Location Services. Follow along with the tutorial .", "date": "2020-05-18"},
{"website": "Here", "title": "Solutions: Day 31-35 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-31-35-100daysofcode", "abstract": "We are back with another week of #100DaysOfCode with HERE. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. In this blog post, I will cover solutions for days 31 through 35. If you have missed the solutions for days 0-30, you can read them in my previous blogs posts or in the video format . Let's begin! Day 31/100 With Day 31, we start exploring the browse endpoints of the Geocoding and Search API . While the discover endpoint lets you do a free form search for points of interest, the browse endpoint lets you perform a more structured search. For day 31 we will do a simple search with name // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n  \n    function geocodeAndSearch(){\n  \n        let geocoderParams = {\n            name: 'museum',\n            at : '52.45722,13.38044'\n        }\n  \n        function onResult(result){\n          console.log(result);\n        }\n  \n        geocoder.browse(geocoderParams,onResult,alert);\n  \n    }\n  \n    geocodeAndSearch(); Day 32/100 The points of interests or 'Places' in the HERE database have been arranged in different categories with 3 levels of granularity. Level 1 is the logical high-level grouping with category names like 'Eat and Drink' or 'Landmark-Attraction'. Level 2 is the sub-group where 'Eat and Drink' is further divided into categories like 'Restaurants'. Level 3 further categorizes these sub-groups such as 'Eat and Drink - Restaurants - Casual Dining'. For day 32, we will use a level 2 category description to look for 'History Museums' around us. We will thus use the category 300-3100-0028 to search for 'History Museum'. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n  \n    function geocodeAndSearch(){\n  \n        let geocoderParams = {\n            name: 'museum',\n            at : '52.45722,13.38044',\n            categories: '300-3100-0028'\n        }\n  \n        function onResult(result){\n          console.log(result);\n        }\n  \n        geocoder.browse(geocoderParams,onResult,alert);\n  \n    }\n  \n    geocodeAndSearch(); Day 33/100 Along with a places category system, HERE also offers a food category system . One of the reasons I work with this company is because they take their food as seriously as I do! With the food categories, you can go as specific to search for different cuisines of places that offer food. For day 33, we will combine the food category and places category to look for places which serve 'Mexican food' and have a 'take-out service'. Thus we will use a combination of categories 100-1000-0003 for 'Eat and Drink - Restaurants - Take Out and Delivery Only' and 102-000 for 'North American - Mexican'. // Get an instance of the geocoding service:\n    var geocoder = platform.getSearchService();\n  \n    function geocodeAndSearch(){\n  \n        let geocoderParams = {\n            name: 'restaurant',\n            at : '52.45722,13.38044',\n            categories: '102-000,100-1000-0003'\n        }\n  \n        function onResult(result){\n          console.log(result);\n        }\n  \n        geocoder.browse(geocoderParams,onResult,alert);\n  \n    }\n  \n    geocodeAndSearch(); Day 34/100 While you can do a search with names and categories, you can also do a table lookup if you know the id of a place. Take a look at one of the the results from the query from day 33 or any autosuggest results. In the result returned, you will find a property called id . {…}\n    access: Array [ {…} ]\n    address: Object { label: \"Que Pasa, Zossener Straße 27, 10961 Berlin, Deutschland\", countryCode: \"DEU\", countryName: \"Deutschland\", … }\n    ​categories: Array [ {…} ]\n    ​​​contacts: Array [ {…} ]\n    ​​distance: 3683\n    ​​​foodTypes: Array [ {…}, {…} ]\n    ​​​id: \"here:pds:place:276aabd1-9fd829e3684d05b86f7ddb1f3f83924c\" \n    ​​​openingHours: Array [ {…} ]\n    ​​​position: Object { lat: 52.48935, lng: 13.39362 }\n    ​​​resultType: \"place\"\n    ​​​title: \"Que Pasa\" For day 34, we use this id with the lookup endpoint to search for the specific place. // Get an instance of the geocoding service:\nvar geocoder = platform.getSearchService();\n\nfunction geocodeAndSearch(){\n\n    let geocoderParams = {\n        id : 'here:pds:place:276aabd1-9fd829e3684d05b86f7ddb1f3f83924c'\n    }\n\n    function onResult(result){\n        console.log(result);\n    }\n\n    geocoder.lookup(geocoderParams,onResult,alert);\n\n}\n\ngeocodeAndSearch(); Day 35/100 During days 21 to 34 we performed what we call forward searches, where you search for places with names or categories and get their location in the form of a latitude and longitude. In a situation where you know the location of a place and want to know what it is called, you will have to use something called a reverse geocoder . As the name suggests, you need to pass the location of this place and in return, you get the complete address with other fields as a result. // Get an instance of the geocoding service:\nvar geocoder = platform.getSearchService();\n\nfunction geocodeAndSearch(){\n\n    let geocoderParams = {\n        at : '52.5415,13.39316'\n    }\n\n    function onResult(result){\n        console.log(result);\n    }\n\n    geocoder.reverseGeocode(geocoderParams,onResult,alert);\n\n}\n\ngeocodeAndSearch(); This week we covered the explore, lookup and reverse geocoder endpoints of the Geocoding and Search on #100DaysOfCode. Next week, we will take look at 'Geofencing' in #100DaysOfCode. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . While you're at it, why don't you take a look at Ray's recent Star Wars blog post . To get a step-by-step guide to use HERE OAuth with Python, head over to the detailed tutorial by our very own 🥑 Vidhan. Happy coding!", "date": "2020-05-07"},
{"website": "Here", "title": "What Is a WKT File and how to Create One?", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/what-is-a-wkt-file-and-how-to-create-one", "abstract": "Well-known text (WKT) is a human readable representation for spatial objects like points, lines, or enclosed areas on a map. I came across WKT files as I was getting started with a Geofencing project. With WKT, you can specify an area that’s interesting to you and then see if some geolocation information like a lat/long pair from a mobile device falls into that area. Understanding WKT point formatting WKT formats points in (long, lat) order. This was surprising to me as I had previously seen geographical points in the (lat, long) order, so I looked into why WKT formats points the other way around. The reason WKT has such order is that latitude represents north/south-ness of a point and longitude represents east/west-ness of a point. So really, WKT is trying to refer to a point by its (x,y) coordinate, and that translates to (long, lat). GeoJSON follows the same order as WKT in this case, so if you are familiar with GeoJSON, this might not be news for you. Take this following point: { lat: 37, lng: -121 } Latitudes represent the “y” value of the point, and longitudes represent the “x” value. Therefore, when we translate this point to WKT representation, it’ll look like the following: POINT (-121 37) How to create a WKT file There are many applications like QGIS that let you create WKT files. But I will assume you only have access to your laptop right now and you want to create a WKT file from scratch - which is absolutely possible! All you need to do is create a new file, and add the wkt extension to it. For example I will call mine bermuda.wkt. If you want to do this from the command line you could say: touch bermuda.wkt Bermuda Triangle is a mythical region where a number of aircrafts and ships are said to have disappeared under mysterious circumstances. The exact coordinates of it are loosely defined, but for this example I will make a guess for where this mythical triangle might be. In order to add the Bermuda Triangle to your WKT file, you can open your file in a text editor like TextEdit or Atom. You can see below that I have listed four points to describe my triangle. The reason for having four points actually has nothing to do with this triangle’s mysterious history. The last point is a duplicate of the first point in order to tell WKT that our polygon is an enclosed area. When creating a polygon, you want to have your longitudes and latitudes separated by a space and you want different points comma separated. Finally, you want to wrap your points in a pair of parentheses because WKT likes things that way. If you are looking for a visual tool that helps you create your geometric shapes, Wicket might come in useful. POLYGON ((-80 25, -65 18, -64 32, -80 25)) If you get started with HERE APIs and decide to add more attributes to your geocoordinates, you can specify them like the following. Just make sure that they are tab delimited , or your layer won’t work. So here, I’m giving my triangle a name before I upload it as a layer. NAME        WKT\nBERMUDA    POLYGON ((-80 25, -65 18, -64 32, -80 25)) You can create multiple polygons too: NAME        WKT\nTwoTriangles    MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)),\n((15 5, 10 20, 5 10, 15 5))) Polygons and Points aren’t the only things you can specify with WKT, if you are interested in learning more, please refer to Wikipedia . Have fun mapping and if you think I have incorrectly specified the Bermuda Triangle’s coordinates, feel free to reach out.", "date": "2020-05-11"},
{"website": "Here", "title": "Find your perfect apartment with HERE and BCX20", "author": ["Stefanie Schwartz, David Stürmer, Nils Jannasch, Tom Stein and Catalina Müller"], "link": "https://developer.here.com/blog/find-your-perfect-apartment-with-here-and-bcx20", "abstract": "On February 17 - 19 2020, team Place2Be participated in BCX 2020 - Europe's biggest IoT hackathon! During the hackathon we developed a prototype for a web service which helps you to find an apartment based on multiple criteria. In combination with HERE Technologies as an API provider for location services it was possible to ramp up the project in short time. What is Place2Be? \"Time is what we want most, but what we use worst.\" - William Penn Have you ever been looking for an apartment? Well, you can certainly call yourself lucky if your search took less than half a year. Finding an apartment is already a hassle, and when you have finally found an apartment big enough and within the budget, you realize: \"What? 1h 30 to work - one way? I don't want that!\" - What if... ... you would live nearby your office? ... the kindergarden would be on the way to work? ... your friends and familiy would live nearby? Place2Be: Finding the best apartment based on your daily life mobility We don't only seek to find the best apartment for you, but also to fundamentally decrease the overall need for mobility by living closer to the locations you visit regulary. We designed a web page that allows the user to search housing market platforms such as Immoscout24 and additionally provide addresses that matter in their daily life, e.g. 🏢 Their office 🏫 The school of their child 🏡 Or their parents' home Our solution calculates then a mobility rating based on the user input and ranks the appartments accordingly. How does our solution work? 🚀 In our hackathon-prototype, we gathered data from different housing market platforms via web scraping. The addresses of available appartments as well as the user inputs are the basis of our calculations. As our solution is heavily based on location data we made use of several HERE REST APIs to enrich our results. Our tech stack during this project included: Python for our backend logic and custom REST API JavaScript/React as a framework for our easy to use frontend applications AWS to deploy our service with CloudFront, Lambda & EC2 Sketch to design our UI/UX Integration of the HERE Geocoder API to find text-input-addresses First of all, we have to tansform the plaintext addresses into geocodes. This applies to both the data from the housing market platforms as well as the addresses the user visits in daily life. In order to do so, we use the HERE Geocoding and Search API . HTTP GET \n https://geocode.search.hereapi.com/v1/geocode?q=Luckenwalder+Str.+4-6%2C+10963+Berlin&apiKey={api-key} The HERE Geocoding and Search API acceptes a search string as query parameter q and returns a geocode (latitude and longitude) that can be used for further processing. Integration of the HERE Routing API to calculate fastest routes To calculate the mobility ratings, we want to find out how fast a user can reach their desired destinations from any apartment. We use the HERE Routing API to get the fastest routes between to geocoded locations. The API allows us to specify different waypoints as query parameters. HTTP GET \nhttps://route.ls.hereapi.com/routing/7.2/calculateroute.json?\nwaypoint0=geo!52.5,13.4\n&waypoint1=geo!52.5,13.45\n&mode=fastest;car;traffic:disabled\n&apiKey={api-key} Additionally, you can specify different transportation modes with the mode parameter. We were always looking for the fastest route independently of the current traffic situation (traffic:disabled). Additionally, the parameter allows to choose a means of transportation: 🚗 Car 👣 Pedestrian 🚃 Public transport 🚲 Bycicle This allows us to find fastest routes for all means of transportation available to the user of our platform. For each apartment, we retrieve the route to each desired destination with each means of transportation. This leads to quite a few API requests: Calculating the routes for three destinations e.g.: The user's office Parents School Calculating the routes for two means of transportation e.g.: Bicycle Public transport This already leads to 2 * 3 = 6 requests per apartment — this adds up pretty quickly if we want to analyze tens or hundreds of apartments at the same time. Hence, we executed the request concurrently using the Python package aiohttp - a potential caching approach is described in the outlook. The following code snippet shows our function which initializes the requests to the HERE Routing API. async def init_requests(origin, destinations, means_of_transportation, results): This function initializes the single requests and tracks their completion. param origin : geo-coordinates for the origin. param destination : a list of geo-coordinates for the destinations. param mean : a string specifying a single means of transportation. param results : The list to append the results to. async with aiohttp.ClientSession() as session:\n        await asyncio.gather(\n            *[make_request(session, origin, d, m, results[d]) for m in means_of_transportation for d in destinations] The function `init_requests` creates an `aiohttp.ClientSession()` and gathers the requests made on this session. The actual request is invoked by calling the function `make_request` which encapsulates building the request URL, executing the request and handling the response. The function looks as follows: async def make_request(session, origin, destination, mean, results): This helper funciton executes a single aiohttp request to query the here API and saves the result. param session : The session to execute the requests on. param origin : geo-coordinates for the origin. param destination : a list of geo-coordinates for the destinations. param mean : a string specifying a single means of transportation. param results : The list to append the results to. params = {\n        \"apiKey\": API_KEY,\n        \"waypoint0\": origin,\n        \"waypoint1\": destination,\n        \"mode\": f\"fastest;{mean};traffic:disabled\"\n    }\n    query = urllib.parse.urlencode(params)\n    url = BASE_PATH + \"?\" + query\n\n    async with session.get(url) as resp:\n        if resp.status == 200:\n            json = await resp.json()\n            results.append(\n                {\n                    \"time\": json[\"response\"][\"route\"][0][\"summary\"][\"travelTime\"],\n                    \"distance\": json[\"response\"][\"route\"][0][\"summary\"][\"distance\"],\n                    \"transporation\": json[\"response\"][\"route\"][0][\"mode\"][\"transportModes\"][0]\n                })\n        ... By executing the requests concurrently, we attempt to reduce the time required to wait for HTTP responses. Moreover, not only the single requests are executed like this, but also the code one layer above: The function init_requests encapsulates the requests necessary for one apartment, represented by the origin parameter. One layer above, init_requests has to be called for each apartment, and this is also handled asynchronously. For each apartment that matches the user's search requirements (i.e. the city they are looking for etc.) we calculate these routes and based on this, the mobility rating. A high rating means: the apartment's location is best suitable in order to travel to the desired locations. All this data is combined and sent backto the frontend application as an ordered list. We expose this logic to our frontend application via an REST endpoint using Starlette . Starlette allows to execute asynchronous code from the thread which handles the incoming HTTP request. This is required to include all the asynchronous code described above into the request handling. Further thoughts In our current design, we use the HERE Routing API. The calculated routes always depend on one means of transportation from start to destination. However, especially in modern city life, routes are often covered by a multitude of transportation options. For instance, a person might drive to the train station by car, take the train into the city and go the \"last mile\" to their office by e-scooter. The HERE Intermodal Routing API offers such a solution for intermodal mobility. For our use case of calculating mobility ratings for apartments, we would first have to evaluate how the need of switching between different means of transportation could be factored in to the rating. Then the usage of this API (as a replacement or in addition) could provide further benefits for accurate and modern mobility ratings. To further improve the project we thought about reducing the amout of necessery API requests by applying an intelligent caching. A promising solution is to use caching in combination of rasterization. Futhermore it would be good to preprocess data for the most common residential areas. On the frontend side we thought about integrating the HERE JavaScript Maps API to visualize our results in a more interactive manner. The BOSCH Connected Experience 2020 was a great experience to build a brand new web service with a new team in a short time, and HERE maps made it even more fun.", "date": "2020-05-08"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.15 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.15-release", "abstract": "Highlights Parallelize stream data consumption Setting a partition parallelization parameter for Stream layers is supported via the Data Client Library and the CLI, making this configuration now possible across the following Data interfaces in total (API, Portal, CLI, Data Client Library). This granular control can help you scale your stream data consumption per your use case needs by enabling more data consumers to consume your stream data in parallel. Changes, Additions and Known Issues SDKs and tools Go to the HERE platform changelog to see all detailed changes to our CLI , the SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. HERE Content Added: additions to existing layers in the HERE Map Content catalog: Added Administrative Place Profiles schema changes Added SurfaceType to Bicycle Attributes layer Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Added: You can offer a service listing that is hosted in your own environment to HERE Marketplace consumers by integrating with our External Service Gateway. Contact your account manager to learn more. Issue: There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, service will slow down across the board for all consumers who are reading from the External Service Gateway. Workaround: Contact technical support for help. Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 July 31, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after July 31, 2020. ·      Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after July 31, 2020, ·      Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before July 31, 2020 so your workflows continue to work. ·      HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after July 31, 2020. ·      Examples of old and new Catalog HRN formats: ·      Old (without OrgID/realm): hrn:here:data:::my-catalog ·      New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 OrgID added to Schema HRN (Global) 2.10 December 2019 July 31, 2020 Deprecation Summary: References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. 3 Data Client Library data compression behavior 2.10 December 2019 June 20, 2020 Deprecation Summary: As of June 30, 2020, all data streaming related workflows must be updated to use at least SDK version 2.9.  The Data Client Library behavior as it relates to compressing and decompressing streaming data will strictly adhere to stream layer configuration settings. 4 Spark-ds-connector replaced by SDK for Java and Scala Spark Connector 2.12 February 2020 August 19, 2020 Deprecation Summary: The spark-ds-connector will be deprecated (6) months from this release on August 19, 2020. Please upgrade to the latest SDK for Python version before then to get the latest SDK for Java and Scala Spark Connector. 5 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. Existing Batch pipelines that use the Batch-2.0.0 run-time environment will continue to operate normally until August 19, 2020. During this period, Batch-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-2.0.0 environment, please use OLP SDK 2.11 or older. After August 19, 2020 we will remove the Batch-2.0.0 run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. 6 Schema validation to be added 2.13 March 2020 September 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of September 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If a non-existing or non-accessible schema is associated with any layer after this date, any attempt to update any configurations of that layer will fail. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before September 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 7 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020.", "date": "2020-05-19"},
{"website": "Here", "title": "Solutions: Day 41-45 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-41-45-100daysofcode", "abstract": "We are in week 9 of #100DaysOfCode with HERE. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. In this blog post, I will cover solutions for days 41 through 45. If you have missed the solutions for days 0-40, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 41/100 With Day 41, we will start exploring the Routing API v8 . The routing API is a powerful API which, as the name suggests, calculates navigable routes between two points. Along with this, there are a number of endpoints which the routing API provides to get efficient routing and navigation. For day 41, we will simply get the route in the form of a polyline for point A to B using car as a mode of transport. You can find the documentation for routing v8 parameters in the API reference section // Get an instance of the routing service version 8:\n    var router = platform.getRoutingService(null, 8);\n    \n    // Create the parameters for the routing request:\n    var routingParameters = {\n      transportMode:'car',\n      routingMode: 'fast',\n      origin: '52.4569927,13.380545',\n      destination: '52.52407865,13.429371',\n      return:'polyline',\n      };\n      \n      // Define a callback function to process the routing response:\n    var onResult = function(result) {\n      console.log(result);\n    };\n    \n    // error callback function\n    var onError = function(error) {\n      alert(error.message);\n    };\n      \n    // Call calculateRoute() with the routing parameters,\n    // the callback and an error callback function \n\n    router.calculateRoute(routingParameters, onResult, onError); As the documents indicate, the parameters transportMode, origin, destination are required parameters. This call will give you a route id which is used to identify the route and late retrieve it. Adding the return parameter as polyline will give you a Flexible Polyline in the return object of the route. You can use this object to draw the route on the map. routes: (1) […]\n        0: {…}\n            ​​id: \"2d1ba2fb-4515-445c-ade1-8a6be6db00ad\"\n            ​​​sections: (1) […]\n                ​​​​0: { … } \n                arrival: {…}\n                    ​​​place: Object { type: \"place\", location: {…}, \n                originalLocation: {…} }\n                departure: Object { place: {…} }\n                ​​​​​id: \"4e9497fb-c18a-4094-a65d-918e3d29d05c\"\n                polyline:\"BGg03hkDig2wZjD-kBT4I8uB0K4coGjDkhBnBsOzKovDnB4IsnBsJ0KkD4XoGw8C0UkwBgKoGoBsdoG0KwCkwBoLoGoBgZoGkXsEkSoBgjBwCkNU8VoB8VU8VnB0ZnB4mBT8pBA8aUwWUkXUwMA0UU4N8BwHAgPUoLU4NTsEAoGUoGUkIoB0PA4cA8LUgPTkiDU4uC8B01CoBsEUopBUsqCwC4DAg4DkDopBoBw0BUwtC8BoGAsTAgKAoLUgoB8B8QA4XUkIAo4B7BgenB4rBoB4NoBsEUoaoB8akDkXkDouBsJ8QsE8LkD8QsEoasJsOgF0P0FgUwHoL0FgK4DoVsJoQwH4SkNgP0KkN4I8QsJ8VwM0jBgZ8QkNoakXwM0K8LkI0KsE4I8BwHAoQ7B0FnBwR_EgjBvHof3IoL7BzF0oBrEkwBnB8aA0U8BgoBoB8uBoBgPkDsd4DgtBoBwMU4I8BsTsEgPgFwR4D4N8GoQ0FwCoG8BoLUsEAkNvC8L3D4I3D0FvC4kCzoBkNjI0FjDwRzKgKzFoGvC8L3DwRrEsOA4N8B8Q0FsE8B8G4DsJ0FkIoGoGgF4IwHwW8VwWwRgUgP4zCw-BwHgFsEwCoGkD8V4NsTsO8LoLofkXgP0KwHsEsEkDoBUsEkDgKwH0FsE8L4I4X4SsTkNsEkD4SkNwR8LkDoGwCwCkNgKoG0FsEsE4DsEkIsJ4IgK8GsJ0F8GoG4IsJoL8G8GkI0FwHAkDA0KjDsOrEwCgK4D8LwCwHoBsEkDwHoLsYoL4S4IkNgFkI4D0F0F4IwC4DwC4D8GgK4NsTkSoaoV0e8Q4XgjBwvBwM8QwWwbsE0F0F8G0F8GwCkDsd0jB4DsE4IgK4N8Q0U0Z8LgPkD4D8VkckIsJgU4Xoa0egP8QgZ4csOsTsJsOsEwH8V4mBgKkNwHwMkSwlBsJsTkI4S8LgZ4DwHwHkNwHoLsE0FoVsYkIsJwb4cwbkc8L8L4IgKgF0F0Z8a8LkN0oBgtB0P4SoLoQ4I4NsJ0KwRoVgPwR0UkX8GwHkI4IwWkcwqBozBoQsT0e8kB0U4X4Sge0KsOsT0ZjD0PvC4SnBwMUoGkD4N_EwH3D8G7L0ZzFgPnLoa3I0UrOsiBjI8QnLkSrJ4NrEwH_J0PvMgUvHoLrOwWjIwM3XkmBjIwM3D0F7G8GrEwCrEoBnGT_EnBjI3D_J_E3SrJnGjDxEhC\"\n                transport: Object { mode: \"car\" }\n                type: \"vehicle\"\n            ​​​​length: 1 Day 42/100 For day 42, we will render the flexible polyline received as a result of our routing v8 call from day 41. The flexible polyline is a compressed version of a list of coordinates on the route. You can find out more about flexible polyline encoding our GitHub repository . For this task, we will use the JS wrapper for the flexible polyline and use the style option of the polyline object to change the color of the polyline to '#034F84' // Define a callback function to process the routing response:\n    var onResult = function(result) {\n      console.log(result);\n      if (result.routes.length) {\n        // result.routes.forEach(route =>{\n          result.routes[0].sections.forEach((section) => {\n            // Create a linestring to use as a point source for the route line\n           let linestring = H.geo.LineString.fromFlexiblePolyline(section.polyline);\n    \n           // Create a polyline to display the route:\n           let routeLine = new H.map.Polyline(linestring, {\n             style: { strokeColor: '#034F84', lineWidth: 3 }\n           });\n    \n           // Create a marker for the start point:\n           let startMarker = new H.map.Marker(section.departure.place.location);\n    \n           // Create a marker for the end point:\n           let endMarker = new H.map.Marker(section.arrival.place.location);\n    \n     \n           // Add the route polyline and the two markers to the map:\n           map.addObjects([routeLine, startMarker, endMarker]);\n    \n           // Set the map's viewport to make the whole route visible:\n           map.getViewModel().setLookAtData({bounds: routeLine.getBoundingBox()});\n           \n       });\n          \n      }\n    }; Day 43/100 With day 43, we tweak the day 41 call by adding the parameter alternatives to get a maximum of 4 routes between the given points. You can choose to render all four routes and let the user select the desired route. var routingParameters = {\n        transportMode:'car',\n        routingMode: 'fast',\n        origin: '52.4569927,13.380545',\n        destination: '52.52407865,13.429371',\n        alternatives:3,\n        return:'polyline',\n        }; Day 44/100 Day 44 shows us the difference between a the same route at prime time vs at a time where the traffic is less on the streets. You will see the difference on a busy street immediately where the order of the suggested routes often changes considering traffic. // Create the parameters for the routing request:\n    var routingParameters = {\n      transportMode:'car',\n      routingMode: 'fast',\n      origin: '52.4569927,13.380545',\n      destination: '52.52407865,13.429371',\n      alternatives:3,\n      departureTime:'2020-05-13T09:00:00',\n      return:'polyline',\n      }; // Create the parameters for the routing request:\n    var routingParameters = {\n      transportMode:'car',\n      routingMode: 'fast',\n      origin: '52.4569927,13.380545',\n      destination: '52.52407865,13.429371',\n      alternatives:3,\n      departureTime:'2020-05-13T15:00:00',\n      return:'polyline',\n      }; Day 45/100 For day 45, we get the total duration required and distance covered by the route by requesting a summary of the route. The return parameter summary along with the polyline gives us the summary of each route section in terms of duration in seconds and length of the route link in meters. // Create the parameters for the routing request:\n    var routingParameters = {\n      transportMode:'car',\n      routingMode: 'fast',\n      origin: '52.4569927,13.380545',\n      destination: '52.52407865,13.429371',\n      alternatives:3,\n      departureTime:'2020-05-13T09:00:00',\n      return:'polyline,summary'\n      }; This week we covered the Routing API v8 endpoints on #100DaysOfCode. Next week, we will take look at a few more endpoints of the Routing API v8. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . While you're at it, why don't you take a look at the blog post of the semifinalists of BCX2020. In the blog post, they explain how they made a apartment hunting app using HERE maps and services. Check the step-by-step tutorial to find Geo-coordinates using the Geocoding and Search API . Happy coding!", "date": "2020-05-19"},
{"website": "Here", "title": "April 2020 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/january-2020-release-notes-0-0-0-0", "abstract": "Welcome to the latest announcements for the HERE Location Services. This post covers the D116 release of HERE Location Services. This email includes release notes that describe the improvements to the services in the new release. This release includes updates of: Routing API, Maps API for JavaScript, Geocoder API, Fleet Telematics API and HERE SDK for Android and iOS . The Release highlights are: Improved “drive report” response information for Fleet Telematics API Route Matching Several new map display methods for the Explore and Navigate version of the Mobile SDK 4.x For more detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation on the Developer Portal . HERE Location Services on Platform Routing API ( Version 8.1.3) Added areas to avoid request parameter. You will find the Release Notification on the Developer Portal . HERE SDK for Android and iOS (Explore Edition) ( Version 4.3.1.0) Added methods MapMarker.getDrawOrder() and MapMarker.setDrawOrder(final long value) to get and set the draw order of MapMarkers on the map. Added MapView.OnReadyListener with the method Map.setOnReadyListener(OnReadyListener readyListener) to set the ReadyListener . The listener will notify once the map view has been initialization. Added the support for 3D MapMarkers with the classes MapMarker3D and MapMarker3DModel to represent and define a 3D shape rendered on the map. Added the methods void MapScene.addMapMarker3d(@NonNull MapMarker3D marker) and void MapScene.removeMapMarker3d(@NonNull MapMarker3D marker) to add and remove a 3D MapMarker . Added the Rectangle2D constructor that accepts type double for the origin and size parameters to represent a 2D rectangle. Added the Size2D constructor that accepts type double for the height and width parameters to represent the size of a 2D structure. Added the methods MapPolylines.getMetadata() and void setMetadata(@Nullable Metadata value) to get and set the Metadata for MapPolylines . HERE SDK for Android and iOS (Navigate Edition) ( Version 4.3.1.0) Additional features to the Explore version: Added the method Navigator.get_supported_languages_for_maneuver_notifications() to get the supported language functionality. Added the methods Navigator.getManeuverNotificationOptions() and Navigator.setManeuverNotificationOptions(options) to get and set maneuver notification options. Maps API for JavaScript ( Version 3.1.15.1) KML and GeoJSON now render the polygons with holes. The new style for the Japan map was added . Fleet Telematics API ( Version 3.0.30) New Route Match features improved driving information: Exact speed limits (date/time/vehicle dependent) for speeding detection Curve speeds (lateral force) for cornering detection Stop sign violations Accelerations / breaking for risk assessment Light conditions (horizontal and vertical sun angle towards driver) for risk assessment Weather conditions (at the time of driving) for risk assessment (depending on commercial availability of Weather Archive) Predefined \" customConsumptionDetails \" values for different vehicles types \"3.5t\", \"7.5t\", \"18t\", \"40t\" Important: Link IDs will exceed 32 bits soon, PLEASE PREPARE YOUR APPLICATIONS TO HANDLE LINK_ID VALUES > 4 BILLION! The following services had new releases with minor changes: Geocoder API version 6.2. 203 HERE SDK for Android and iOS (Lite Edition) 4.3.1.0", "date": "2020-05-14"},
{"website": "Here", "title": "Solutions: Day 36-40 #100DaysOfCode", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/solutions-day-36-40-100daysofcode", "abstract": "You have made it to the Week 8 of #100DaysOfCode with HERE! If you are new to this challenge, take a look at this blog post which will tell you everything about #100DaysOfCode with HERE. In this blog post, I will cover solutions for days 36 through 40 on the topic of Geofencing. If you have missed the previous solutions you can find them in our previous blog posts , in video format , or you can find them on our github repo . Let's begin! Day 36/100 For day 36, we are creating a WKT file to mark a location of interest for our Geofence. A WKT file is a human readable representation for spatial objects like points, lines, or enclosed areas on a map. We have a blog post that goes in depth about how you can create a WKT file. For example, you might have a physical store and you’d like to send your customers a notification when they are nearby to tell them about your latest promotions. For this example, I will create an area around SpaceNeedle. When you create your WKT file, you can add a column to specify the name of your spatial object and another column to specify the WKT representation. Make sure that your columns are tab delimited. NAME    WKT\nSPACENEEDLE    POLYGON((-122.34955611506788 47.620666853267224,-122.34930398742048 47.6208006380942,-122.34902235547392 47.62069758764966,-122.34904917756407 47.62047340703363,-122.34933080951063 47.62034323720253,-122.34958561936705 47.62044990417142,-122.34955611506788 47.620666853267224)) Day 37/100 When it comes to creating layers, you have a few options for doing so. You can create a layer using the layers dashboard , you can zip your WKT file and upload it through a curl command , or via a REST call . Regardless of how you choose to upload your layer, when you have successfully uploaded your layer, you can go to the layers dashboard to verify your submission: Day 38/100 As you make geofencing applications, you want to be able to interact with your layers and the first step is to retrieve the layers that you have uploaded! You can retrieve the layers you uploaded via a REST call . You will need to provide your API Key and you’ll get a list of layers as a response. If you have uploaded one layer so far, you’ll get one item in your list. The information you get back will refer to the name or ID of the layer you created. getLayers() {\n    let fleetURL = \"https://fleet.ls.hereapi.com/2/layers/list.json\"\n    return axios({\n      method: 'get',\n      url: fleetURL,\n      params: {\n        apiKey: config.apiKey\n      }\n    })\n    .then(response => {\n      return response.data.layers\n    })\n    .catch(error => {\n      return Promise.reject(error)\n    })\n  } Day 39/100 Alright, so here’s the exciting part! Now we are creating a function that takes a layer (the one we uploaded) a point and returns whether our point falls in our perimeter or not. There is a proximity parameter that takes a string in the format of “lat,long”. We can pass our position information to the proximity parameter. fenceRequest(layerIds, position) {\n    return new Promise((resolve, reject) => {\n      this.geofencing.request(\n        H.service.extension.geofencing.Service.EntryPoint.SEARCH_PROXIMITY,\n        {\n          'layer_ids': layerIds,\n          'proximity': position.lat + \",\" + position.lng,\n          'key_attributes': ['NAME']\n        },\n        result => {\n          resolve(result)\n        },\n        error => {\n          reject(error)\n        }\n      )\n    })\n  } Day 40/100 The above function tells us whether or not a given point is inside our layer. But what if you want to be notified when the point is within a certain distance from your layer? For example, imagine if you have a physical store and your customer happens to be nearby and you want to let them know about the sales promotions that you have today. In this case, if you set the distance to 100 meters, your customer can get notifications about your promotions when they are within 100 meters of your store. fenceRequest(layerIds, position) {\n    return new Promise((resolve, reject) => {\n      this.geofencing.request(\n        H.service.extension.geofencing.Service.EntryPoint.SEARCH_PROXIMITY,\n        {\n          'layer_ids': layerIds,\n          'proximity': position.lat + \",\" + position.lng + \",\" + 100,\n          'key_attributes': ['NAME']\n        },\n        result => {\n          resolve(result)\n        },\n        error => {\n          reject(error)\n        }\n      )\n    })\n  } We hope that you have enjoyed this challenge so far! Follow us on Twitter to get updates about future weeks of #100DaysOfCode. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you are looking for other hands on tutorials, I'd recommend reading How to Find Geo-Coordinates(GPS) using the Geocoding and Search API . If you've been with us for a while and you are looking into learning about the improvements to our services you can refer to April 2020 Release Highlights . Happy coding!", "date": "2020-05-19"},
{"website": "Here", "title": "Create an Android Map Application in Under 5 Minutes", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/create-an-android-map-application-in-under-5-minutes", "abstract": "A few weeks ago, we released our new HERE SDK for Android . Since then we've also launched a brand-new season of Waypoints on Twitch in which we are exploring this SDK in detail. However, an episode of Waypoints is an hour long and sometimes you just want to get something done quickly . So in this blog post, we're going to learn how to set up an Android Map Application in under 5 minutes. Set your stopwatches, here we go! Creating our app is five-step process. Each of these steps can be completed in a minute or less. Get your credentials and download the SDK libraries. Grab an example from GitHub. Add SDK library to your app's libs folder. Add your credentials to the manifest file. I was lying. There's no step five. It really is that quick and easy. Let's quickly(!) walk through all of these steps. Step 1: Get Your Credentials First you need to sign up on the developer portal, generate a set of credentials and download the SDK files. Just click on \" Sign up \" on the top-right of this page and follow the process. My colleague Michael has made a video in case you need help. (Which you don’t. Go ahead, you got this.) Once you've signed up, you will be taken to your project page. There, click on \"Generate App\" then on \"Create Credentials\". Store these credentials, we will need them in Step 4. Finally, click on \"Download SDK for Android (Explore Edition)\". The download contains an .aar file, which we will need in Step 3 so store it in a safe place. Fun fact: This was most complicated and time-consuming step. It’s only going to get faster from here. Step 2: Clone the Examples from GitHub This step is even faster. Just \"git clone https :// github.com/heremaps/here-sdk-examples.git\" to get the HERE SDK Examples from the HERE GitHub account . Step 3: Add the SDK Library to your Project Go into the examples folder of the SDK examples you just downloaded and find the \"HelloMap\" example for the Explore Edition. Then copy the .aar file from Step 1 into the app/libs folder of the example app. That’s it. That’s the whole step. Step 4: Add Credentials to your Project Open the \"HelloMap\" example in Android Studio. In Android Studio, go to the manifest.xml file of your project and paste your credentials (Access Key ID and Access Key Secret) from Step 1 into the appropriate tags under \"application\". Step 5: You're Done! OK, so there's technically a fifth step in that you have to build and run your app. That might also take a minute depending on what Gradle had for breakfast. Either way, you should have just created a running app with a HERE map! Congrats! (And don’t sweat it if you took like seven minutes or something. I won’t tell anybody.) Now, if this was too fast for you after all, you can check out the documentation for more details. You'll also get information on how to add a map to an existing app. Or you could just watch the first episode of the latest season of Waypoints on YouTube . Sure, that may take an hour, but it's also a lot of fun! Be sure to follow us on Twitter and Twitch to get info on future episodes! I’ll see you next time, when we will try to create an iOS app with a map in under five minutes!", "date": "2020-05-27"},
{"website": "Here", "title": "How to Secure Credentials with a Whitelist", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-to-whitelist-domain-names", "abstract": "At the end of 2019 we announced the availability of two new authentication types regarding developer access to our APIs and SDKs. These new authentication types were an improvement over the use of APP ID and APP Code. For example, our latest versions of the JavaScript APIs now use an API Key to initialize. In this post, we will cover another option to improve overall security with our APIs - add a domain to a whitelist. What is a Whitelist? A whitelist is a list of entities considered to be acceptable or trustworthy. In the context of this blog post, the entities are domains. By whitelisting one or more domain names, a developer is establishing where API calls can be trusted from . To phrase it another way, if a whitelist domain is the source of the API call, the request will be allowed. The contrast is also true - if the source of an API call comes from a domain not found in the whitelist, the call will fail. Managing a Whitelist Whitelists are managed in the developer portal where developer credentials are also managed. In the screen capture below, the area in the red rectangle is where one would get started with whitelisting: As shown above, the default setting is no whitelist is created yet. When there is no whitelist, it means any domain can freely make calls with the associated developer credentials. Once the decision is made to add a domain to the whitelist, you will see the following options: With the checkbox now enabled, domain names can be added or removed using the plus and minus buttons. To add a domain, enter domain names with the following format: example.com www.example.com app.example.com The following examples are *not* valid: http://www.example.com example.* example.com?foo=bar The first invalid example includes the HTTP protocol which is not needed. The second invalid example makes the assumption that wildcards are supported (they are not). The third invalid example contains a querystring which is not a way to uniquely identify a domain. You can add up to 20 domains in the list. Note! Once you have entered *any* domain in the list, all *other* sources making requests using your credentials will fail (which is the desired outcome). Also keep in mind it can take up to a full hour for any modifications to the list (including it's creation) to take effect. Summary For more information, please check out our tutorial or feel free to watch the brief video below!", "date": "2020-05-25"},
{"website": "Here", "title": "Solutions: Day 56-60 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-51-55-100daysofcode-0", "abstract": "We are in week 12 of #100DaysOfCode with HERE! With this week, we will deep dive into the Routing v7 API. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-55, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 56/100 Avoiding traffic jams is as easy as it gets! Just ask politely 😝. Well, almost. Just indicate the TrafficMode to enabled. You will see the returned routes have arranged themselves in such a way that the route avoiding traffic is the first route returned. // Get an instance of the routing service version 7:\nvar router = platform.getRoutingService();\n\n// Create the parameters for the routing request:\nvar routingParameters = {\n  waypoint0:\"52.4569927,13.380545\",\n  waypoint1:\"52.4805740,13.4303771\",\n  mode:\"fastest;car;traffic:enabled\",\n  alternatives:3,\n  representation: \"display\"\n}; Day 57/100 For whatever reasons, sometimes, you want to avoid certain areas while driving. With the routing API, it is possible in two simple steps. The first is to identify the area and draw a box around it. Drawing a rectangle is similar to drawing any map object that we learnt in week 3 of 100daysofcode . To draw this rectangle, we are going to use the method H.geo.Rect.fromPoints to draw the rectangle by stating the top-left and bottom-right points of the rectangle. let rectangle = new H.map.Rect( H.geo.Rect.fromPoints({\"lat\":52.47196092299903,\"lng\":13.376929060418977},{\"lat\":52.46853475142611,\"lng\":13.386257162576658}),{\n  style:{\n    strokeColor:'red',\n    fillColor:'rgba(255,0,0,0.5)'\n  }\n});\n  \nmap.addObject(rectangle); Day 58/100 To avoid the area that we drew on day 57, the second step is to use the avoidAreas parameter. Within this parameter, we will pass the bounding box we drew on day 57. The format of passing this bounding box is top-left and bottom-right geo-coordinates of the box. // Get an instance of the routing service version 7:\nvar router = platform.getRoutingService();\n\n// Create the parameters for the routing request:\nvar routingParameters = {\n  waypoint0:\"52.4569927,13.380545\",\n  waypoint1:\"52.4805740,13.4303771\",\n  mode:\"fastest;car;traffic:enabled\",\n  avoidAreas:rectangle.getBoundingBox().getTopLeft().lat+','+\n  rectangle.getBoundingBox().getTopLeft().lng+';'+\n  rectangle.getBoundingBox().getBottomRight().lat+','+\n  rectangle.getBoundingBox().getBottomRight().lng,\n  representation: \"display\"\n}; Day 59/100 A route is divided into several legs and these route legs are further divided into links. We will use these link ids to identify the patched of roads we wish to avoid. To do this, we need to use the parameter legAttributes and pass the RouteLegAttributeType as links // Get an instance of the routing service version 7:\n  var router = platform.getRoutingService();\n  \n  // Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;car;traffic:enabled\",\n    alternatives:3,\n    representation: \"display\",\n    legAttributes:'links'\n  }; Day 60/100 We will now use the linkID obtained from day 59 to avoid that portion of the road. To do this, you need to pass the linkId in the parameter avoidLinks . // Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;car;traffic:enabled\",\n    alternatives:3,\n    representation: \"display\",\n    avoidLinks:'-1258798441'\n  }; That was week 12 of #100DaysOfCode With HERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . While you're at it, why don't you take a look at the blog post - Controlling the map size by our 🥑 Michael Palermo. Happy coding!", "date": "2020-06-01"},
{"website": "Here", "title": "Solutions: Day 46-50 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-46-50-100daysofcode", "abstract": "Yay!! We are half way through with #100DaysOfCode with HERE. It's time to pat your backs and look back at how much we have learnt so far. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. In this blog post, I will cover solutions for days 46 through 50. If you have missed the solutions for days 0-45, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 46/100 Day 46, will cover adding a way point to your route. A way point as the name suggests, is a place that you wish to stop while on the way to your ultimate destination. The via parameter in the routing v8 API lets you add intermediate places to your route. Moreover, you can also add place options which you can check in API reference section . In this example, I have added a point which would normally not fall on the route from the origin to destination. var routingParameters = {\n    transportMode:'car',\n    routingMode: 'fast',\n    origin: '52.4569927,13.380545',\n    destination: '52.52407865,13.429371',\n    via:'52.505582,13.3692024',\n    alternatives:3,\n    departureTime:'2020-05-13T09:00:00',\n    return:'polyline,summary'\n    }; Day 47/100 Road trips in the pre-navigation system days looked quite different. The person riding shotgun had the responsibility of helping the driver navigate the roads or read out instructions. Later, Karlin & Collins, Inc. started providing printed navigation instruction at gas stations. As glad we are that technology has advanced since then to provide navigation systems in your car or even your phone, we still need the driving instructions in some form. You can chose to print them out on your navigation screen or use a text-to-speech converter to read out the instructions. The routing v8 API provides routing instructions as return parameters. These instructions are available within actions or in the text form within instructions var routingParameters = {\n    transportMode:'car',\n    routingMode: 'fast',\n    origin: '52.4569927,13.380545',\n    destination: '52.52407865,13.429371',\n    via:'52.505582,13.3692024',\n    alternatives:3,\n    departureTime:'2020-05-13T09:00:00',\n    return:'polyline,summary,actions,instructions'\n    };\n\n    var onResult = function(result) {\n\n      ... \n\n      section.actions.forEach(action =>{\n        document.getElementById(\"panel\").innerHTML += `<br>`+ action.instruction;\n\n      });\n\n      ...\n    } Day 48/100 The Routing v8 API has an interesting parameter called spans . This parameter helps attain addition attributes in the route response. These include length , duration , routeNumbers , speedLimit ,  etc. You can read more about these attributes in the documentation section . For Day 48, we will use the parameter spans to get the return parameter speedLimit for our route. // Create the parameters for the routing request:\n  var routingParameters = {\n    transportMode:'car',\n    routingMode: 'fast',\n    origin: '52.4569927,13.380545',\n    destination: '52.52407865,13.429371',\n    via:'52.505582,13.3692024',\n    alternatives:3,\n    departureTime:'2020-05-13T09:00:00',\n    return:'polyline,summary,actions,instructions',\n    spans:'speedLimit'\n    }; Day 49/100 To get a proper ETA on our route, it is necessary to consider the duration we will be stopping at our waypoint. Luckily, the parameter via has WaypointOptions which let you add a stopDuration to your waypoints. This duration is specified in seconds. I have added a stopover of 15 minutes to our waypoint mentioned at day 46. // Create the parameters for the routing request:\n  var routingParameters = {\n    transportMode:'car',\n    routingMode: 'fast',\n    origin: '52.4569927,13.380545',\n    destination: '52.52407865,13.429371',\n    via:'52.505582,13.3692024!stopDuration=900',\n    alternatives:3,\n    departureTime:'2020-05-13T09:00:00',\n    return:'polyline,summary,actions,instructions',\n    spans:'speedLimit'\n    }; Day 50/100 Along with cars as the mode of transport, the routing v8 API also calculated routes for trucks and pedestrian routing. For day 50, we will take a look at pedestrian routing and also look at how we can modify the look of the route we display on the map. A pedestrian route can be achieved by simply replacing the transportMode as pedestrian . When we draw a route, we are essentially using the map object polyline to render it on the map. The polyline along with other map objects has style options that can change the stroke color, fill color, thickness etc of the polyline. Along with these properties, the polyline also sports dashed lines . Dashed lines are defined with an even numbered array of numbers. These numbers alternately represent the length of the dash and the distance between two dashes. var routingParameters = {\n    transportMode:'pedestrian',\n    routingMode: 'fast',\n    origin: '52.4569927,13.380545',\n    destination: '52.52407865,13.429371',\n    via:'52.505582,13.3692024!stopDuration=900',\n    alternatives:3,\n    departureTime:'2020-05-13T09:00:00',\n    return:'polyline,summary,actions,instructions',\n    spans:'speedLimit'\n    };\n\n    var onResult = function(result) {\n    ...\n\n    // Create a polyline to display the route:\n    let routeLine = new H.map.Polyline(linestring, {\n      style: { strokeColor: '#034F84', lineWidth: 3,lineDash: [1,2] }\n    });\n\n    ...\n    } With days 41-50 we took a sneak-peak into the Routing API v8 on #100DaysOfCode. Next week onward, we will discuss the Routing v7 API in detail. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . While you're at it, why don't you take a look at the getting started with IBM Call for Code blog post using HERE maps and services. Check the step-by-step tutorial on how to clean up addresses using the Geocoding and Search API. Happy coding!", "date": "2020-05-22"},
{"website": "Here", "title": "Discovering nearby Places using Python Flask", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/discovering-nearby-places-using-python-flask", "abstract": "What is the best feature you like in a modern mobile application? There may be a lot, but my favorite is when an application shows up nearby places on a map without typing a single word. All you need to do is to enable location feature on mobile and app shows you the results on the map. This feature saves a lot of time. Consider a scenario where you need a medical service and you are looking for a hospital nearby. What will you do? Open a medical service app and search for a nearby hospital. Application will show you all the hospitals near to your location and you will select one based on the popped-up information. This is exactly what we are going to learn in this blog using Discover endpoint of Geocoding and Search API . We will create a Python Flask application to show hospitals in the vicinity of a provided location. Let us get started! Prerequisites Your machine should have Python installed (I have Python 3.8) and if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you have signed up, you can generate your free API key and get 250.000 free transactions every month. Discover Endpoint of Geocoding and Search API Discover simplifies searching for places by letting you search for a known or an unknown place. All you need is to submit a free-form text request that returns a JSON response containing places along with additional details. https://discover.search.hereapi.com/v1/discover\n?at=12.96643,77.5871\n&q=hospital\n&apikey=YOUR_API_KEY\n&limit=5 at : Latitude and longitude value separated by a comma q : A place you are looking for, we are searching for hospitals near provided latitude and longitude. apikey: From the Freemium account generated on developer portal limit : Limits the number of result, we are limiting it to 5. The REST API will return a JSON response containing nearest hospitals along with additional details. ...\n{\n  \"items\": [\n    {\n      \"title\": \"ST. Martha's Hospital\",\n      \"id\": \"here:pds:place:356tdr1v-021cdf05fe1a453a9f2124eeff3e3182\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"ST. Martha's Hospital, Sampangi Rama Nagar, Bengaluru 560027, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Sampangi Rama Nagar\",\n        \"postalCode\": \"560027\"\n      },\n      \"position\": {\n        \"lat\": 12.97076,\n        \"lng\": 77.58637\n      },\n      \"access\": [\n        {\n          \"lat\": 12.97077,\n          \"lng\": 77.58639\n        }\n      ],\n      \"distance\": 488,\n      \"categories\": [\n        {\n          \"id\": \"800-8000-0159\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Mallya Hospital\",\n      \"id\": \"here:pds:place:356tdr1v-0a1c39a1306f4046a0d76e1828afc7ba\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"Mallya Hospital, Vittal Mallya Road, Ashoka Nagar, Bengaluru 560001, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Ashoka Nagar\",\n        \"street\": \"Vittal Mallya Road\",\n        \"postalCode\": \"560001\"\n      },\n      \"position\": {\n        \"lat\": 12.96769,\n        \"lng\": 77.59493\n      },\n      \"access\": [\n        {\n          \"lat\": 12.96803,\n          \"lng\": 77.59482\n        }\n      ],\n      \"distance\": 860,\n      \"categories\": [\n        {\n          \"id\": \"800-8000-0000\"\n        },\n        {\n          \"id\": \"800-8000-0158\"\n        },\n        {\n          \"id\": \"800-8000-0159\"\n        }\n      ],\n      \"contacts\": [\n        {\n          \"phone\": [\n            {\n              \"value\": \"+918022277979\"\n            }\n          ],\n          \"mobile\": [\n            {\n              \"value\": \"+918022221564\"\n            }\n          ],\n          \"fax\": [\n            {\n              \"value\": \"+918022121282\"\n            }\n          ],\n          \"www\": [\n            {\n              \"value\": \"http://www.mallyahospital.net\"\n            }\n          ],\n          \"email\": [\n            {\n              \"value\": \"mallya@giashg01.vsnl.net.in\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"title\": \"Republic Hospital\",\n      \"id\": \"here:pds:place:356tdr1v-d742487af5274445b899852b66f64f13\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"Republic Hospital, Langford Gardens, Richmond Town, Bengaluru 560025, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Richmond Town\",\n        \"subdistrict\": \"Langford Gardens\",\n        \"postalCode\": \"560025\"\n      },\n      \"position\": {\n        \"lat\": 12.96415,\n        \"lng\": 77.59799\n      },\n      \"access\": [\n        {\n          \"lat\": 12.96416,\n          \"lng\": 77.59797\n        }\n      ],\n      \"distance\": 1207,\n      \"categories\": [\n        {\n          \"id\": \"800-8000-0000\"\n        },\n        {\n          \"id\": \"800-8000-0157\"\n        },\n        {\n          \"id\": \"800-8000-0158\"\n        },\n        {\n          \"id\": \"800-8000-0159\"\n        }\n      ],\n      \"contacts\": [\n        {\n          \"phone\": [\n            {\n              \"value\": \"+918022211762\"\n            },\n            {\n              \"value\": \"+918046808354\"\n            }\n          ],\n          \"www\": [\n            {\n              \"value\": \"HTTPS://WWW.REPUBLICHOSPITAL.IN\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"title\": \"Vanivilas Hospital\",\n      \"id\": \"here:pds:place:356tdr1t-59db4ec93a3246c5bcf4940ce26b088b\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"Vanivilas Hospital, New Tharagupet, Kalasipalyam, Bengaluru 560002, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Kalasipalyam\",\n        \"subdistrict\": \"New Tharagupet\",\n        \"postalCode\": \"560002\"\n      },\n      \"position\": {\n        \"lat\": 12.96244,\n        \"lng\": 77.57396\n      },\n      \"access\": [\n        {\n          \"lat\": 12.96246,\n          \"lng\": 77.57395\n        }\n      ],\n      \"distance\": 1491,\n      \"categories\": [\n        {\n          \"id\": \"800-8000-0000\"\n        },\n        {\n          \"id\": \"800-8000-0158\"\n        },\n        {\n          \"id\": \"800-8000-0159\"\n        }\n      ],\n      \"contacts\": [\n        {\n          \"phone\": [\n            {\n              \"value\": \"+918026708395\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"title\": \"विक्टोरिया हॉस्पिटल\",\n      \"id\": \"here:pds:place:356tdr1t-7782433d22eb4d5aaa3d5c57ed3c1df9\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"विक्टोरिया हॉस्पिटल, New Tharagupet, Kalasipalyam, Bengaluru 560002, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Kalasipalyam\",\n        \"subdistrict\": \"New Tharagupet\",\n        \"postalCode\": \"560002\"\n      },\n      \"position\": {\n        \"lat\": 12.96305,\n        \"lng\": 77.57281\n      },\n      \"access\": [\n        {\n          \"lat\": 12.96304,\n          \"lng\": 77.57279\n        }\n      ],\n      \"distance\": 1593,\n      \"categories\": [\n        {\n          \"id\": \"800-8000-0159\"\n        }\n      ],\n      \"contacts\": [\n        {\n          \"phone\": [\n            {\n              \"value\": \"+918026701150\"\n            }\n          ],\n          \"www\": [\n            {\n              \"value\": \"http://www.victoriahospitalbangalore.org\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n} The above JSON response shows details of 5 hospitals in an area of Bangalore, India. Working with Python We are using Python for making API call and parsing the response data. For this, install the requests library with ' pip install requests ' command using Python IDE (PyCharm, Spyder, etc) or terminal/command prompt depending on how you are working on Python (I am using the command prompt), and then import it in the code. import requests\n\nURL = \"https://discover.search.hereapi.com/v1/discover\"\nlatitude = 12.96643\nlongitude = 77.5871\napi_key = 'YOUR_API_KEY' # Acquire from developer.here.com\nquery = 'hospitals'\nlimit = 5\n\nPARAMS = {\n            'apikey':api_key,\n            'q':query,\n            'limit': limit,\n            'at':'{},{}'.format(latitude,longitude)\n         } \n\n# sending get request and saving the response as response object \nr = requests.get(url = URL, params = PARAMS) \ndata = r.json()\n\n\nhospitalOne = data['items'][0]['title']\nhospitalOne_address =  data['items'][0]['address']['label']\nhospitalOne_latitude = data['items'][0]['position']['lat']\nhospitalOne_longitude = data['items'][0]['position']['lng']\n\n\nhospitalTwo = data['items'][1]['title']\nhospitalTwo_address =  data['items'][1]['address']['label']\nhospitalTwo_latitude = data['items'][1]['position']['lat']\nhospitalTwo_longitude = data['items'][1]['position']['lng']\n\nhospitalThree = data['items'][2]['title']\nhospitalThree_address =  data['items'][2]['address']['label']\nhospitalThree_latitude = data['items'][2]['position']['lat']\nhospitalThree_longitude = data['items'][2]['position']['lng']\n\n\nhospitalFour = data['items'][3]['title']\nhospitalFour_address =  data['items'][3]['address']['label']\nhospitalFour_latitude = data['items'][3]['position']['lat']\nhospitalFour_longitude = data['items'][3]['position']['lng']\n\nhospitalFive = data['items'][4]['title']\nhospitalFive_address =  data['items'][4]['address']['label']\nhospitalFive_latitude = data['items'][4]['position']['lat']\nhospitalFive_longitude = data['items'][4]['position']['lng'] Introducing Flask We have acquired all the values needed (hospital name, hospital address, latitude, longitude, API key) to show on our map. This can be done easily with the help of flask. All we need to do is install a library named flask, with ' pip install flask' command. Now, let’s integrate all the values collected so far into the flask code. from flask import Flask,render_template\n\napp = Flask(__name__)\n@app.route('/')\n\ndef map_func():\n\treturn render_template('map.html',\n    \t\t\tlatitude=latitude,\n                            longitude=longitude,\n                            apikey=api_key,\n                            oneName=hospitalOne,\n                            OneAddress=hospitalOne_address,\n                            oneLatitude=hospitalOne_latitude,\n                            oneLongitude=hospitalOne_longitude,\n                            twoName=hospitalTwo,\n                            twoAddress=hospitalTwo_address,\n                            twoLatitude=hospitalTwo_latitude,\n                            twoLongitude=hospitalTwo_longitude,\n                            threeName=hospitalThree,\n                            threeAddress=hospitalThree_address,\n                            threeLatitude=hospitalThree_latitude,\n                            threeLongitude=hospitalThree_longitude,\n                            fourName=hospitalFour,\t\t\n                            fourAddress=hospitalFour_address,\n                            fourLatitude=hospitalFour_latitude,\n                            fourLongitude=hospitalFour_longitude,\n                            fiveName=hospitalFive,\t\t\n                            fiveAddress=hospitalFive_address,\n                            fiveLatitude=hospitalFive_latitude,\n                            fiveLongitude=hospitalFive_longitude)\n\nif __name__ == '__main__':\n\tapp.run(debug = False) The above code represents a simple flask template in which we have imported two sub-packages of flask, viz., Flask and render_template . Also, we have created a function called the “map_func”. This function returns a jinga2 html page and passes the API Key, latitude and longitude to our HTML code (yes, we will need HTML too). Working with HTML and JavaScript A HTML file will be required to show the Map on the browser. For this, we need to create an HTML file in a folder called “templates”, and then name the file as “map.html” <html>  \n<head>\n<meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<link rel=\"stylesheet\" type=\"text/css\"href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n</head>\n  \n<body style='margin: 0'>\n<div style=\"width: 100%; height: 100%\" id=\"mapContainer\"></div>\n\n<script>\t\n      // Initialize the platform object:\n      var platform = new H.service.Platform({\n        'apikey': '{{apikey}}'\n      });\n\t  \n\t   const lat = {{latitude}};\n\t   const lng = {{longitude}};\n\t   \n\t   const hospitalOne_lat = {{oneLatitude}}; \n\t   const hospitalOne_lng = {{oneLongitude}};\n\n\t   const hospitalTwo_lat = {{twoLatitude}}; \n\t   const hospitalTwo_lng = {{twoLongitude}};\n\n\t   const hospitalThree_lat = {{threeLatitude}}; \n\t   const hospitalThree_lng = {{threeLongitude}};\n\n\t   const hospitalFour_lat = {{fourLatitude}}; \n\t   const hospitalFour_lng = {{fourLongitude}};\n\n\t   const hospitalFive_lat = {{fiveLatitude}}; \n\t   const hospitalFive_lng = {{fiveLongitude}};\t   \n\t\n\t// Obtain the default map types from the platform object\n      var maptypes = platform.createDefaultLayers();\n\n      // Initialize a map:\n      var map = new H.Map(\n        document.getElementById('mapContainer'),\n        maptypes.raster.terrain.map,\n        {\n          zoom: 15,\n          center: { lat: lat, lng: lng }  \n        });\n\t\t\n\t// Enable the event system on the map instance:\n\t  var mapEvents = new H.mapevents.MapEvents(map);\n\t\n\t// Instantiate the default behavior, providing the mapEvents object:\n\t var behavior = new H.mapevents.Behavior(mapEvents);\n\n\tvar myLocation_marker = new H.map.Marker({ lat: lat, lng: lng });\n\tvar hospitalOne_marker = new H.map.Marker({ lat: hospitalOne_lat, lng: hospitalOne_lng });\n\tvar hospitalTwo_marker = new H.map.Marker({ lat: hospitalTwo_lat, lng: hospitalTwo_lng });\n\tvar hospitalThree_marker = new H.map.Marker({ lat: hospitalThree_lat, lng: hospitalThree_lng });\n\tvar hospitalFour_marker = new H.map.Marker({ lat: hospitalFour_lat, lng: hospitalFour_lng });\n\tvar hospitalFive_marker = new H.map.Marker({ lat: hospitalFive_lat, lng: hospitalFour_lng });\n\t\t\n\t// Add the marker to the map:\n\tmap.addObject(myLocation_marker);\n\tmap.addObject(hospitalOne_marker);\n\tmap.addObject(hospitalTwo_marker);\n\tmap.addObject(hospitalThree_marker);\n\tmap.addObject(hospitalFour_marker);\n\tmap.addObject(hospitalFive_marker);\n\t\n\t// Create the default UI:\n\tvar ui = H.ui.UI.createDefault(map, maptypes);\n\t\n\t// Add event listener to the marker:\n\tmyLocation_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: lng, lat: lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>\"Hi\"</h3><p>\"This is you!\"</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\t\n\t\nhospitalOne_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: hospitalOne_lng, lat: hospitalOne_lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>{{oneName}}</h3><p>{{oneAddress}}</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\n\t\nhospitalTwo_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: hospitalTwo_lng, lat: hospitalTwo_lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>{{twoName}}</h3><p>{{twoAddress}}</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\n\t\nhospitalThree_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: hospitalThree_lng, lat: hospitalThree_lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>{{threeName}}</h3><p>{{threeAddress}}</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\n\t\nhospitalFour_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: hospitalFour_lng, lat: hospitalFour_lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>{{fourName}}</h3><p>{{fourAddress}}</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\n\t\nhospitalFive_marker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: hospitalFive_lng, lat: hospitalFive_lat }, {\n                content: ''\n             });\n\t\tbubble.setContent('<div style=\"height: 130px; overflow: auto; width: 270px;\"><h3>{{fiveName}}</h3><p>{{fiveAddress}}</p></div>');\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\n\n</script>\n</body>\n</html> The above code plots the latitude and longitude of 5 hospitals on a map and shows a marker on the plotted location. When marker is clicked, a box pops up showing the name and address of hospitals. Complete Python Code import requests\nfrom flask import Flask,render_template\nURL = \"https://discover.search.hereapi.com/v1/discover\"\nlatitude = 12.96643\nlongitude = 77.5871\napi_key = 'YOUR_API_KEY' # Acquire from developer.here.com\nquery = 'hospital'\nlimit = 5\n\nPARAMS = {\n            'apikey':api_key,\n            'q':query,\n            'limit': limit,\n            'at':'{},{}'.format(latitude,longitude)\n         } \n\n# sending get request and saving the response as response object \nr = requests.get(url = URL, params = PARAMS) \ndata = r.json()\n\n\nhospitalOne = data['items'][0]['title']\nhospitalOne_address =  data['items'][0]['address']['label']\nhospitalOne_latitude = data['items'][0]['position']['lat']\nhospitalOne_longitude = data['items'][0]['position']['lng']\n\n\nhospitalTwo = data['items'][1]['title']\nhospitalTwo_address =  data['items'][1]['address']['label']\nhospitalTwo_latitude = data['items'][1]['position']['lat']\nhospitalTwo_longitude = data['items'][1]['position']['lng']\n\nhospitalThree = data['items'][2]['title']\nhospitalThree_address =  data['items'][2]['address']['label']\nhospitalThree_latitude = data['items'][2]['position']['lat']\nhospitalThree_longitude = data['items'][2]['position']['lng']\n\n\nhospitalFour = data['items'][3]['title']\nhospitalFour_address =  data['items'][3]['address']['label']\nhospitalFour_latitude = data['items'][3]['position']['lat']\nhospitalFour_longitude = data['items'][3]['position']['lng']\n\nhospitalFive = data['items'][4]['title']\nhospitalFive_address =  data['items'][4]['address']['label']\nhospitalFive_latitude = data['items'][4]['position']['lat']\nhospitalFive_longitude = data['items'][4]['position']['lng']\n\napp = Flask(__name__)\n@app.route('/')\n\ndef map_func():\n\treturn render_template('map.html',\n                            latitude = latitude,\n                            longitude = longitude,\n                            apikey=api_key,\n                            oneName=hospitalOne,\n                            OneAddress=hospitalOne_address,\n                            oneLatitude=hospitalOne_latitude,\n                            oneLongitude=hospitalOne_longitude,\n                            twoName=hospitalTwo,\n                            twoAddress=hospitalTwo_address,\n                            twoLatitude=hospitalTwo_latitude,\n                            twoLongitude=hospitalTwo_longitude,\n                            threeName=hospitalThree,\n                            threeAddress=hospitalThree_address,\n                            threeLatitude=hospitalThree_latitude,\n                            threeLongitude=hospitalThree_longitude,\n                            fourName=hospitalFour,\t\t\n                            fourAddress=hospitalFour_address,\n                            fourLatitude=hospitalFour_latitude,\n                            fourLongitude=hospitalFour_longitude,\n                            fiveName=hospitalFive,\t\t\n                            fiveAddress=hospitalFive_address,\n                            fiveLatitude=hospitalFive_latitude,\n                            fiveLongitude=hospitalFive_longitude\n                            )\n\nif __name__ == '__main__':\n\tapp.run(debug = False) Running the Code Run the code using any Python IDE like Spyder or PyCharm else simple use command prompt or terminal to execute the code. Copy the address http://127.0.0.1:5000 and paste it in the browser application. When clicked on the marker, the details passed in the code will pop up This concludes our blog on discovering nearby places using Python Flask. Now you have all the ingredients to build your own search application! Stay tuned for more Python tutorial. Meanwhile, keep learning!", "date": "2020-05-26"},
{"website": "Here", "title": "Solutions: Day 51-55 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-51-55-100daysofcode", "abstract": "It's week 11 of #100DaysOfCode with HERE and we have accomplished so much already. We have gone through the Interactive Maps API, the Geocoding and Search API and the Routing v8 API. With this week, we will start exploring the Routing v7 API. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-50, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 51/100 With Day 51, we have also started the avoid series where we try to avoid certain parts of the route while getting a route from point A to B. Also, we will be using the Routing v7 API. In this task, we will use the pedestrian route from day 50, but avoid parks on the way. Why avoid parks? Well because I am super allergic to pollen and walking through a park is sadly not a walk in the park 😓. So lets get the route from day 50, but with Routing v7 . The API structure is pretty much the same. The origin, destination are replaced with waypoint0, waypoint1 respectively, while transportMode, routingMode are combined as mode . Remember to call the Routing v7 API. // Get an instance of the routing service version 7:\nvar router = platform.getRoutingService();\n\n// Create the parameters for the routing request:\nvar routingParameters = {\n  waypoint0:\"52.4569927,13.380545\",\n  waypoint1:\"52.4805740,13.4303771\",\n  mode:\"fastest;pedestrian,\n  representation: \"display\"\n  }; Now, to avoid parks, the mode parameter has an attribute called RouteFeature which lists features that you can avoid on a route. These features come with weights depending on how badly you want to avoid them. For this task, we want to avoid parks, so we give the weight -1 . This way, the routing API will give penalties to routes with parks. Which means you might still get a route going through the park, but it will be later in the alternatives. You can change up the weights for softer or harder restrictions. // Get an instance of the routing service version 7:\n  var router = platform.getRoutingService();\n  \n  // Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;pedestrian;park:-1\",\n    representation: \"display\"\n    }; Day 52/100 Walking can get you only up to a certain distance. For longer distances, lets go biking. Its a good exercise and you're also controlling your carbon footprint. To do this, the routing v7 API lets you add bicycle as your routing mode . // Get an instance of the routing service version 7:\n  var router = platform.getRoutingService();\n  \n  // Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;bicycle\",\n    representation: \"display\"\n    }; Day 53/100 Again, the routing mode bicycle lets you avoid things too. This time, we are avoiding dirt roads . My bicycle is a weak little city bike and won't be able to survive dirt roads. So lets avoid them. You will find dirt roads as a RouteFeatureType under RouteFeature . This time I want to strictly avoid the dirt roads, so I will assign it a weight of -3 . // Get an instance of the routing service version 7:\n  var router = platform.getRoutingService();\n  \n  // Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;bicycle;dirtRoad:-3\",\n    representation: \"display\"\n  }; Day 54/100 So we're done walking and biking. Let's do the next best thing. Let's use public transport. Again, we're using the same schematic as day 52 and just switching up the routing mode // Get an instance of the routing service version 7:\n  var router = platform.getRoutingService();\n// Create the parameters for the routing request:\n  var routingParameters = {\n    waypoint0:\"52.4569927,13.380545\",\n    waypoint1:\"52.4805740,13.4303771\",\n    mode:\"fastest;publicTransport\",\n    representation: \"display\"\n  }; Day 55/100 As much as I love to travel, I also have motion sickness. I know what you're thinking. This girl has too many issues, right? Welcome to my life! Well, among all modes of tansport, buses make me the most sick. So... let's avoid them too. This time, there is a special parameter to avoid things for public transport. This parameter is called avoidTransportTypes . This parameter comes with a list of PublicTransportTypeType that you can avoid. We are going to avoid the public buses , coz c'mon, I can't give up on Flixbus. // Create the parameters for the routing request:\nvar routingParameters = {\n  waypoint0:\"52.4569927,13.380545\",\n  waypoint1:\"52.4805740,13.4303771\",\n  mode:\"fastest;publicTransport\",\n  avoidTransportTypes:\"busPublic\",\n  representation: \"display\"\n}; That was week 11 of #100DaysOfCode With HERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . While you're at it, why don't you take a look at the blog post - Create an android map application in under 5 minutes! by our 🥑 Richard Süselbeck. Happy coding!", "date": "2020-05-28"},
{"website": "Here", "title": "HERE with Postman", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/here-with-postman", "abstract": "RESTful APIs or REST APIs are one of the easiest ways to communicate with services to build your application. HERE provides developers with over 20 APIs through a freemium account . These APIs are available as REST APIs along with their JS wrappers. What is amazing about REST APIs is the fact that they are independent of platforms, frameworks and languages. So you can call them in many different ways. Moreover there are several tools available to test out the responses of REST APIs. One such tool is Postman . Postman is not merely a way to test REST APIs, but you can do a lot with it. You can also use it to build your own APIs and write documentation around it. Today I am going to talk about tips and tricks to  call HERE REST APIs efficiently with Postman. First, let's create a simple request with my favorite Geocoding and Search API . Creating a request If you take a look at the structure of the Postman window, there are several components to make a REST call. To make a simple call, we are going to look at the three main ones:- Request type , Request URL and Response . Now if you go to the Construct a Request section of the Geocoding and Search API, you will notice that the API call has the same structure. By following the documentation, we select GET as our request type. The next important thing is the request URL . In this case, it will be https://geocode.search.hereapi.com/v1/geocode as we want to make a simple geocoding request. This is followed by parameters to make this call. The minimum required parameter to make a geocoding request is the free form text query q for what you want to get the location for. So lets add that to our URL. The URL should look like https://geocode.search.hereapi.com/v1/geocode?q=Brandenburg gate, Berlin . The most important parameter to make any HERE API call is authentication. For this request, I will use the REST API Key from the projects page of my freemium developer account with HERE. On adding my API Key, my URL now looks like https://geocode.search.hereapi.com/v1/geocode?q=Brandenburg gate, Berlin&apiKey={MY_REST_API_KEY} . Now copy this into the request URL bar of the Postman window and click on Send . You will see the response of this API in the Response section. Parameters In the previous step, the parameters that we added to the URL after the main API resource are reflected in the params section of the Postman window. So instead of creating the request URL with all the parameters and then entering it, you can simply add the base URL of the API and then keep adding the parameters in the params section with their respective values. You can also disable or enable a parameter by toggling the check-box next to it. With the Geocoding and Search request above, I am going to add the parameter limit as I want just one result in the response. Environments You might have already noticed that you can't see my API Key in the screen grabs above. This is because I have saved them in the Postman Environment. Environments in Postman let you store your API keys or other authentication keys so you don't have to enter them every time you create a request. This is also super handy when you are using APIs from different companies and platforms. You can then have several environments for each of the API platforms. Collections After creating several requests for several different API endpoints, you may want to use them in the future. I may want to search the location of the fernsehturm this time and I don't want to construct the whole request from scratch. With Postman you can save your requests and group them as Collections . So I can save the requests for all the endpoints of the Geocoding and Search API , namely: Geocoding, Reverse geocoding, Discover, Autosuggest, Browse and Lookup in a collection called HERE Geocoding and Search and reference it whenever I want to test any of the endpoints. You can also share these collections and import other collections into your window. Bonus- Creating Bearer Tokens In the above examples, I have used an API Key to authenticate my call to the Geoocoding and Search API. HERE also provides authentication with OAuth 2.0 tokens. You can generate these bearer tokens with Postman. Head over to this tutorial to check out how. Have fun creating your HERE API Collections on Postman!", "date": "2020-06-05"},
{"website": "Here", "title": "Solutions: Day 61-65 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-61-65-100daysofcode", "abstract": "Let's get started with week 13 of #100DaysOfCode with HERE and dive further into the Routing v7 API. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-60, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 61/100 Let's say you want to limit your delivery area or want to limit your travel to 10 km around you. Can you simply draw a circle of radius 10 Km and any place Within the circle can be reached by driving for 10 Km or less? This is what we will be checking with day 61. We have already covered drawing a circle on day 14 of 100DaysOfCode . Click on any point on the circumference of this circle and get the route to that point. Also note the total distance covered by this route. var circle10Km = new H.map.Circle({lat:52.4571601,lng:13.3806395}, 10000);\n// Add the circle to the map:\nmap.addObject(circle10Km);\n\n// Get an instance of the routing service version 7:\nvar router = platform.getRoutingService();\n\n// Create the parameters for the routing request:\nvar routingParameters = {\n  waypoint0:\"52.4569927,13.380545\",\n  waypoint1:\"52.47911050,13.5236065\",// point on the circumference of the circle\n  mode:\"fastest;car;traffic:enabled\",\n  representation: \"display\",\n  routeAttributes:'summary'\n};\n  \n// Define a callback function to process the routing response:\nvar onResult = function(result) {\n  console.log(result);\n  var colors =[\"green\",\"orange\",\"yellow\",\"red\"]\n  result.response.route.forEach(route =>{\n  var lineString = new H.geo.LineString(),\n    routeShape = route.shape,\n    polyline,\n    startMarker,\n    endMarker;\n  \n  // Retrieve the mapped positions of the requested waypoints:\n  startPoint = route.waypoint[0].mappedPosition;\n  endPoint = route.waypoint[1].mappedPosition;\n\n  routeShape.forEach(function(point) {\n    var parts = point.split(',');\n    lineString.pushLatLngAlt(parts[0], parts[1]);\n  });\n\n\n  polyline = new H.map.Polyline(lineString, {\n    style: {\n      lineWidth: 4,\n      strokeColor: colors[result.response.route.indexOf(route)]\n    }\n  });\n\n  startMarker = new H.map.Marker({\n    lat:route.waypoint[0].mappedPosition.latitude,\n    lng:route.waypoint[0].mappedPosition.longitude \n  });\n\n  endMarker = new H.map.Marker({\n    lat:route.waypoint[1].mappedPosition.latitude,\n    lng:route.waypoint[1].mappedPosition.longitude \n  });\n\n  // Add the polyline to the map\n  map.addObjects([polyline,startMarker,endMarker]);\n  // And zoom to its bounding rectangle\n  document.getElementById(\"panel\").innerHTML += 'Route '+(result.response.route.indexOf(route)+1)+ ' Distance: '+ route.summary.distance/1000 +' Km'+ ` `;\n\n  map.getViewPort().setPadding(100, 0, 0, 0);\n  map.getViewModel().setLookAtData({\n    bounds: polyline.getBoundingBox()\n  });\n  map.getViewPort().setPadding(0, 0, 0, 0);\n});\n};\n\nvar onError = function(error) {\n  alert(error.message);\n};\n\nrouter.calculateRoute(routingParameters, onResult, onError); You will notice that these routes are definitely longer than 10 Km. This is even more evident if the center of your cirle is near a water-body. You definitely cannot drive across water and it takes much longer to cross it from a bridge which may or may not be near you. This leads us to the search of places reachable by driving 10 Km or less Day 62/100 Isoline routing is the answer to the problem from day 61. It returns all the places which can be reached by driving or walking a certain distance. It basically gives us the answer to - Is the road network to this place within a distance of 10 Km? The The Calculate Isoline endpoint of the Routing API needs a starting point, a range which will be 10000 meters in this case and a range type- distance. The routing engine will return a polyline that connects all the end points of all routes starting from the start and at a distance of 10 Km from it. Laying the Isoline polyline on the circle from the previous example, you will see the difference between the actually reachable radius. // Get an instance of the routing service:\n  var router = platform.getRoutingService();\n\n\n  var routingParams = {\n    'mode': 'fastest;car;',\n    'start': '52.4571601,13.3806395',\n    'range': '10000',\n    'rangetype': 'distance'\n  };\n  \n  // Define a callback function to process the isoline response.\n  var onResult = function(result) {\n    var center = new H.geo.Point(\n        result.response.center.latitude,\n        result.response.center.longitude),\n      isolineCoords = result.response.isoline[0].component[0].shape,\n      linestring = new H.geo.LineString(),\n      isolinePolygon,\n      isolineCenter;\n  \n    // Add the returned isoline coordinates to a linestring:\n    isolineCoords.forEach(function(coords) {\n    linestring.pushLatLngAlt.apply(linestring, coords.split(','));\n    });\n  \n    // Create a polygon and a marker representing the isoline:\n    isolinePolygon = new H.map.Polygon(linestring);\n    isolineCenter = new H.map.Marker(center);\n  \n    // Add the polygon and marker to the map:\n    map.addObjects([isolineCenter, isolinePolygon]);\n  \n    // Center and zoom the map so that the whole isoline polygon is\n    // in the viewport:\n    map.getViewModel().setLookAtData({bounds: isolinePolygon.getBoundingBox()});\n  };\n  \n  \n  // Call the Routing API to calculate an isoline:\n  router.calculateIsoline(\n    routingParams,\n    onResult,\n    function(error) {\n    alert(error.message);\n    }\n  ); Day 63/100 Where's the park? A mere 15 minutes drive from here. 😅 In many parts of the world, it is common to tell distances in time. Sometimes for our applications, we may have a time constraint to where we walk or drive to. Some restaurants offer delivery within a certain time. For such use cases, you want to know the places you can walk or drive to within a certain time. The Calculate Isoline endpoint has the ability to do this when you set the rangeType to time and specify the time in seconds. // Get an instance of the routing service version 7:\nvar router = platform.getRoutingService();\n\nvar routingParams = {\n  'mode': 'fastest;car;',\n  'start': '52.4571601,13.3806395',\n  'range': '900',// 15 x 60 sec\n  'rangetype': 'time'\n}; Day 64/100 When you're making a group plan to go out, you need to select a place that is convenient to all your friends. This involves finding out the route to your favourite brewery from everyone's houses. And then someone suggests another place and you calculate all the routes all over again. What if you could do this all at once? The Calculate Matrix end point of the Routing API lets you do exactly this. You can calculate the route summaries from multiple starting points to multiple destinations. function getMatrixRoute(){\n  let url = `https://matrix.route.ls.hereapi.com/routing/7.2/calculatematrix.json?`+\n            `apikey=${window.hereCreds.JS_KEY}`+\n            `&mode=fastest;car`+\n            `&start0=52.4571601,13.3806395`+\n            `&start1=52.530858,13.384744`+\n            `&start2=52.50665,13.39162`+\n            `&destination0=52.48505,13.47921`+\n            `&destination1=52.54345,13.35946`+\n            `&matrixAttributes=indices`\n\n  fetch(url)\n    .then(response => response.json())\n    .then(response => {\n      console.log(response);\n    }, error =>{\n      console.error(error);\n    });\n}\n\ngetMatrixRoute(); Day 65/100 Along with route indices, the calculate matrix endpoint also returns different properties within route summary. One of them is a route ID. Every route after calculation gets assigned a unique route ID. You can access this route later using the route ID. With day 65, we are going to use the route ID of the routes calculated by Calculate Matrix and render them using Get Route . While calculating the route summaries with Matrix Routing, include the summaryattributes=routeId . Use this route ID with the Get Route end point to get the route shape and render it on the map. function getMatrixRoute(){\n  let url = `https://matrix.route.ls.hereapi.com/routing/7.2/calculatematrix.json?`+\n            `apikey=${window.hereCreds.JS_KEY}`+\n            `&mode=fastest;car`+\n            `&start0=52.4571601,13.3806395`+\n            `&start1=52.530858,13.384744`+\n            `&start2=52.50665,13.39162`+\n            `&destination0=52.48505,13.47921`+\n            `&destination1=52.54345,13.35946`+\n            `&matrixAttributes=indices,summary`+\n            `&summaryattributes=routeId`\n\n  fetch(url)\n    .then(response => response.json())\n    .then(response => {\n      console.log(response.response.matrixEntry);\n      response.response.matrixEntry.forEach(entry=>{\n        // let routeId = entry.summary.routeId; \n        // console.log(entry.summary.routeId,entry.startIndex);\n        drawRoute(entry.summary.routeId,entry.startIndex);\n      });\n    }, error =>{\n      console.error(error);\n    });\n}\n\n\nfunction drawRoute(routeID, routeIndex){\n  let url = `https://route.ls.hereapi.com/routing/7.2/getroute.json?`+\n            `apikey=${window.hereCreds.JS_KEY}`+\n            `&routeId=${routeID}`+\n            `&representation=display`\n\n  fetch(url)\n  .then(response => response.json())\n  .then(response => {\n    drawPolyline(response,routeIndex);\n    // console.log(response);\n  }, error =>{\n    console.error(error);\n  });\n\n}\n\n\nfunction drawPolyline(response,routeIndex){\n\n  let route = response.response.route\n        var lineString = new H.geo.LineString(),\n        routeShape = route.shape,\n        polyline,\n        startMarker,\n        endMarker,\n        colors = [\"#38d9a9\",\"#cc5de8\",\"#ffa94d\"];\n      \n      // Retrieve the mapped positions of the requested waypoints:\n      startPoint = route.waypoint[0].mappedPosition;\n      endPoint = route.waypoint[1].mappedPosition;\n\n      routeShape.forEach(function(point) {\n        var parts = point.split(',');\n        lineString.pushLatLngAlt(parts[0], parts[1]);\n      });\n\n\n      polyline = new H.map.Polyline(lineString, {\n        style: {\n          lineWidth: 4,\n          strokeColor: colors[routeIndex]\n        }\n      });\n\n      startMarker = new H.map.Marker({\n        lat:route.waypoint[0].mappedPosition.latitude,\n        lng:route.waypoint[0].mappedPosition.longitude \n      },{icon:new H.map.Icon('img/start.png')});\n\n      endMarker = new H.map.Marker({\n        lat:route.waypoint[1].mappedPosition.latitude,\n        lng:route.waypoint[1].mappedPosition.longitude \n      },{icon:new H.map.Icon('img/end.png')});\n\n      // Add the polyline to the map\n      map.addObjects([polyline,startMarker,endMarker]);\n      // And zoom to its bounding rectangle\n\n      map.getViewPort().setPadding(100, 0, 0, 0);\n      map.getViewModel().setLookAtData({\n        bounds: polyline.getBoundingBox()\n      });\n      map.getViewPort().setPadding(0, 0, 0, 0);\n\n}\n\ngetMatrixRoute(); That was week 13 of #100DaysOfCode With HERE. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . While you're at it, why don't you take a look at the tutorial - Add a HERE Web Map into your React application. Happy coding!", "date": "2020-06-08"},
{"website": "Here", "title": "Finding COVID-19 Testing Sites with the HERE Geocoding and Search API", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/finding-covid-19-testing-sites", "abstract": "A few days ago we added new support for finding COVID-19 testing sites using our Geocoding and Search API. This is a crucial update to help people build solutions to connect users to testing locations. In this post I'm going to quickly describe how to access this new data. Note that you'll need a freemium HERE developer in order to use this API. This new support works with both our Dicover and Browse endpoints. If you remember, \"Discover\" is better suited for text based searches across multiple categories whereas \"Browse\" is better suited for searching within specific categories. There's definitely a bit of overlap there but you can decide which is the best for your needs. To return testing sites, you must search for the string, \"COVID\" (case does not matter). Doing so will returns results where each place name will be prefixed with \"Covid-19 Testing Site:\". Here's an example doing a search local to Lafayette, LA: https://discover.search.hereapi.com/v1/discover?apikey={{apiKey}}&q=Covid&at=30.22,-92.02&limit=10 And here's the result (reduced down to three results): {\n    \"items\": [\n        {\n            \"title\": \"Covid-19 Testing Site: Cajundome & Convention Center\",\n            \"id\": \"here:pds:place:8409vqec-b18ef0a254f64cb8843d6bd84895917d\",\n            \"resultType\": \"place\",\n            \"address\": {\n                \"label\": \"Covid-19 Testing Site: Cajundome & Convention Center, 444 Cajundome Blvd, Lafayette, LA 70506-4264, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Louisiana\",\n                \"county\": \"Lafayette\",\n                \"city\": \"Lafayette\",\n                \"street\": \"Cajundome Blvd\",\n                \"postalCode\": \"70506-4264\",\n                \"houseNumber\": \"444\"\n            },\n            \"position\": {\n                \"lat\": 30.21844,\n                \"lng\": -92.03887\n            },\n            \"access\": [\n                {\n                    \"lat\": 30.21757,\n                    \"lng\": -92.04011\n                }\n            ],\n            \"distance\": 1821,\n            \"categories\": [\n                {\n                    \"id\": \"800-8000-0400\"\n                }\n            ],\n            \"contacts\": [\n                {\n                    \"phone\": [\n                        {\n                            \"value\": \"+13372652100\"\n                        }\n                    ],\n                    \"www\": [\n                        {\n                            \"value\": \"http://ldh.la.gov/\"\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            \"title\": \"Covid-19 Testing Site: Northside Community Health Center\",\n            \"id\": \"here:pds:place:8409vqs4-661e7d098a944604bdc181f41d5dceb6\",\n            \"resultType\": \"place\",\n            \"address\": {\n                \"label\": \"Covid-19 Testing Site: Northside Community Health Center, 1800 Louisiana Ave, Lafayette, LA 70501-3702, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Louisiana\",\n                \"county\": \"Lafayette\",\n                \"city\": \"Lafayette\",\n                \"street\": \"Louisiana Ave\",\n                \"postalCode\": \"70501-3702\",\n                \"houseNumber\": \"1800\"\n            },\n            \"position\": {\n                \"lat\": 30.24118,\n                \"lng\": -92.00064\n            },\n            \"access\": [\n                {\n                    \"lat\": 30.24123,\n                    \"lng\": -92.00093\n                }\n            ],\n            \"distance\": 3001,\n            \"categories\": [\n                {\n                    \"id\": \"800-8000-0400\"\n                }\n            ],\n            \"contacts\": [\n                {\n                    \"phone\": [\n                        {\n                            \"value\": \"+13376789000\"\n                        }\n                    ],\n                    \"www\": [\n                        {\n                            \"value\": \"http://ldh.la.gov/\"\n                        }\n                    ]\n                }\n            ]\n        },\n        {\n            \"title\": \"Covid-19 Testing Site: Clark Integrated Medical Clinic\",\n            \"id\": \"here:pds:place:8409vqef-f61ea5135b314808bad8a933683273a9\",\n            \"resultType\": \"place\",\n            \"address\": {\n                \"label\": \"Covid-19 Testing Site: Clark Integrated Medical Clinic, 130 Rue Beauregard, Lafayette, LA 70508-3102, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Louisiana\",\n                \"county\": \"Lafayette\",\n                \"city\": \"Lafayette\",\n                \"street\": \"Rue Beauregard\",\n                \"postalCode\": \"70508-3102\",\n                \"houseNumber\": \"130\"\n            },\n            \"position\": {\n                \"lat\": 30.19261,\n                \"lng\": -92.01253\n            },\n            \"access\": [\n                {\n                    \"lat\": 30.19276,\n                    \"lng\": -92.01236\n                }\n            ],\n            \"distance\": 3129,\n            \"categories\": [\n                {\n                    \"id\": \"800-8000-0400\"\n                }\n            ],\n            \"contacts\": [\n                {\n                    \"phone\": [\n                        {\n                            \"value\": \"+13372323353\"\n                        }\n                    ],\n                    \"www\": [\n                        {\n                            \"value\": \"http://ldh.la.gov/\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n} This also works with the Browse endpoint, but note that at the time of this article's publication, it will not work with category filters. Be sure to leave the value off of your API calls: https://browse.search.hereapi.com/v1/browse?apiKey={{apiKey}}&at=30.22,-92.02&name=Covid&limit=10 Of course you will get category values in your results so a secondary filter operation could be performed there. (This issue will be corrected soon.) As always, we are adapting as fast as possible to changing situations. We sincerely hope this helps and if you need support, do not forget you can find us on StackOverflow and Slack .", "date": "2020-06-09"},
{"website": "Here", "title": "How to Control Map Size", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-to-control-map-size", "abstract": "There are times when a developer wants to implement a simple feature, and discovers finding the solution was not so simple. There are other times when a developer once had the solution, but with changing times, the solution is outdated. I was having one of those times recently, when trying to do what I thought was a simple thing - control the size of a map! What if I wanted my map to go full screen? What would happen if I resize the map? Despite once having the answers to these, times have changed. So let's explore the answers to these questions. Map Size When using our JavaScript APIs, you will likely notice that many of our examples include an element in HTML that looks like this: <div id=\"map\"> The div element is a container for the map. When the map is initialized in code, you will often see this approach in many of our examples: var map = new H.Map(document.getElementById('map'),\n  defaultLayers.vector.normal.map,{\n  center: {lat:50, lng:5},\n  zoom: 4,\n  pixelRatio: window.devicePixelRatio || 1\n}); In the first line of code, a map is initialized with where it will reside visually on the page - in the element with and id of 'map'. However, if no information is provided regarding the size or dimensions of the div, the map will not display. A simple fix to this to provide static dimensions to the page, such as: <div id=\"map\" style=\"width: 800px; height: 600px\" > This approach will do exactly what is expected - to load a map into an 800x600 container on the page. Simple. Now how about going full screen? Full Screen Map To make a map go \"full screen\" in the context of the browser, use the following to style the div: <div id=\"map\" style=\"width: 100vw; height: 100vh\" > The above styling instructs the div element to display 100 percent to the width and height of the browser. By the way, this is the \"simple\" feature I could not find in our documentation. Most of our examples are using fixed sized containers. I previously had another solution to this, but changing browser specifications lead to using the CSS styling used above. You may need to implement more styling to make sure the map is clean of gaps and scroll bars by making sure the body element is styled with no padding or margins like so: <body style=\"padding: 0; margin: 0;\" > Of course all the inline styling in this post can be done in a style element or in a linked stylesheet. Resizing A final word of advice on map sizing is making sure the map behaves as you would expect when a browser window is resized. Just make sure to implement the following line of code which is found in many of our examples: window.addEventListener('resize', \n\t() => map.getViewPort().resize()); The above code will capture the resize event of the browser and instruct the map to resize to the new window dimensions. Summary Maps require dimensions, whether static or based on the size of the browser screen. Make sure you have a strategy for how the map should behave if the browser resizes. For a quick demonstration of these topics, check out the video below!", "date": "2020-05-29"},
{"website": "Here", "title": "Working with GeoJSON and Visual Studio Code", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/working-with-geojson-and-visual-studio-code", "abstract": "Getting GeoJSON in your Visual Studio Code What's better than peanut butter and jelly? GeoJSON and your favorite editor! OK, maybe not as satiating, but even more useful. GeoJSON is an incredibly flexible way to work with geographic data. Need an introduction? Check out my article on it. And obviously, if you are not using Visual Studio Code , you should absolutely consider it. Visual Studio Code is a free, open source editor created by Microsoft with incredible features related to web development and programming in general. It's been my preferred editor since shortly after it was released and it's only gotten better since then. So, let's start off with a file, cats.geojson , that represents a small set of features related to cats. Here's the raw data: {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -90.0715, 29.9510 ]\n      },\n      \"properties\": {\n        \"name\": \"Fred\",\n           \"gender\": \"Male\",\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -92.7298, 30.7373 ]\n      },\n      \"properties\": {\n        \"name\": \"Martha\",\n           \"gender\": \"Female\"\n        }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [ -91.1473, 30.4711 ]\n      },\n      \"properties\": {\n        \"name\": \"Zelda\",\n        \"gender\": \"Female\"\n      }\n    }\n  ]\n} At only three features, this isn't a terribly realistic example, but it makes it easier for demonstrations. Let's see what happens when you open up this file in Code: There's two important things to notice here. First, Code is smart enough to associate certain file types with available Extensions. Extensions are plugins that add extra features to the editor. Secondly, notice that the file is treated as \"Plain Text\". This is the default behavior when Code doesn't know how to work with a file type. So while Code recognizes there's extensions out there that will help, for now it's going to treat it as just a text file. If you go ahead and click on \"Search Marketplace\", you'll find two (currently) suggested extensions: I've been using the first one, VSCode Map Preview , for a while now so I suggest installing that one. That's going to give us some nice tools to work with GeoJSON files in general that we'll look at more in a bit. Before doing that, let's first let Code know that GeoJSON files are just JSON files. If you click \"Plain Text\" in the bottom right corner, Code will give you some options: You'll want to select, \"Configure File Association for '.geojson`\" This will give you a long list of languages. Scroll down and select JSON. Once you've done that, Code will forever associate any file with the .geojson extension as JSON, giving you nice color coding and syntax checking. Now to be clear, that's JSON checking, not GeoJSON checking. So for example, this is invalid JSON that Code would immediately flag: \"type\": `FeatureCollection`, But this valid JSON isn't valid GeoJSON: \"type\": \"InvalidType\", Luckily there's a solution for that as well. There's a specification for JSON Schemas which provide validation for JSON files, specifically the shape of the JSON data and the values within. Code supports JSON Schema so all you need to enable it. While you have a few different options, the easiest is to go to your settings, search for schema, and click to edit: This will open up an editor and place your cursor in the right position to manually add the schema. By default, you will probably see this: \"json.schemas\": [\n\n] Modify it to add an association between *.geojson and the schema found at schemastore.org: {\n    \"fileMatch\": [\n        \"*.geojson\"\n    ],\n    \"url\": \"http://json.schemastore.org/geojson\"\n} As soon as you save your settings, you'll now have schema validation for your GeoJSON files. If you actually type in the InvalidValue string I used above, you'll see it highlighted: You've got two ways to address it. One is to just mouseover the yellow squiggle: You'll see the tooltip provides detailed explanations about the validation error. You can also open the \"Problems\" view. While there's a keyboard command for this, I normally open it by clicking the warning sign on the bottom left: This opens a panel with the problems in the current document: If you then fix the issue, the problems will go away (along with the yellow squiggle... evil, vile yellow squiggle!) Before we move on to the extension we installed earlier, note that sometimes JSON files will not contain any line breaks. This makes them incredibly hard to read. If you have a GeoJSON file like this open in Code, you can run the Format Document command via the F1 menu or use the shortcut (SHIFT+ALT+F on Windows). Previewing the Map Earlier you installed the VSCode Map Preview extension. Let's take a look at how it works. If you open your GeoJSON file in Code, you'll see two new icons on the upper right side: These let you open a preview view for your data. Mousing over each will give you a tooltip describing what they do. Both give map views, but the second gives you a map view with a projection. These two commands are also available via the command palette. Hit F1 and type Map Preview and you'll see them: Cool. So what does the Map Preview look like? The map is fully interactive, zoomable, scrollable, etc and automatically focuses on your data. In my case, my cats were located in Louisiana so it nicely centered the display there. You can also click a feature to see the details: This is a great tool and provides quick visualization of your data. Do note that the map does not update as you edit your data. You'll need to close and reopen the preview in order to see changes. Wrap Up As you can see, for users of Visual Studio Code you've got a lot of options for working with geojson files. Of course, other editors will have some of the same features, like JSON Schema validation, and you should check your relevant documentation.", "date": "2020-06-04"},
{"website": "Here", "title": "Get the Most Out of Bounds", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/get-the-most-out-of-bounds", "abstract": "The world is round, yet most maps are flat rectangles. When we are interested in a certain area of a map, we may narrow our focus to that region of the map. With digital maps, we can even zoom in for details. As a developer with HERE, you can create compelling user experiences surrounding these areas or regions, by using bounding boxes. In this post, you will learn the concept of a bounding box, and how to implement with a few scenarios. What is a Bounding Box? To understand a \"bounding box\" we will first consider what the \"box\" is. To understand the concept, consider the following map image: A blue rectangle is shown to help demonstrate the concept. Each corner has coordinates. The upper left corner coordinates and lower right corner coordinates (shown with bolder font) are all that is needed to create this area on the map. In the example above, the \"box\" is visible because a rectangle was drawn there, but in many uses of a bounding box, you will never see a border. You will soon see why. And what about the \"bounding\" part of the concept? In the example above, the box is bound to static coordinates provided by the developer. We will see other types of bindings later in this post. Controlling the Map with Bounds In the following code example, a map of a specific region of the Grand Canyon is bound to the viewing area of the map. // get reference to map container\nlet container = document.getElementById('map');\n\n// initialized platform\nlet platform = new H.service.Platform(\n\t{apikey: \"your-apikey\"}\n);\n\n// get reference to layers/map types \nlet layers = platform.createDefaultLayers();\n\n// initialize map with container and map type\nlet map = new H.Map(container, layers.raster.satellite.map, {\n    // No need to add coordinates or zoom level\n    pixelRatio: window.devicePixelRatio || 1\n});\n\n// To make the map static, do not add these lines...\n// let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n// let ui = H.ui.UI.createDefault(map, layers);\n\n// when screen resizes, resize map container\nwindow.addEventListener('resize', () => map.getViewPort().resize() );\n\n// initialize\n(()=>{\n    let GC_Bounds = new H.geo.Rect(36.08536, -112.14056, 36.04881, -112.13);\n    // change map bounds to rectangle coordinates at 45 degree tilt\n    map.getViewModel().setLookAtData({\n        bounds: GC_Bounds,\n        tilt: 45\n    });\n})(); The above code turns off all interactions and UI controls, so only the exact area specified in the coordinates area dominate on the screen as shown here: This is a simple starting place. We used the bounding box of a rectangle (no visible border) created with static coordinates to determine what would be shown in the map. Let's look at other uses. Bounding to an Object In the following initializing code, a circle object is added to the map. When the circle is tapped/clicked, the map view is changed to the bounding box of the circle. // initialize\n(()=>{\n    // create a circle with centered at Palermo, Sicily\n    let circle = new H.map.Circle( {lat:38.12207,lng:13.36112}, 98765);\n    // add event handler for when the circle is tapped or clicked\n    circle.addEventListener('tap', (evt) =>{\n        // get instance of circle via evt.target\n        let target = evt.target;\n        // set the map dimensions to bounding box of circle\n        map.getViewModel().setLookAtData({\n          bounds: target.getBoundingBox()\n        });\n    });\n    // add circle to map\n    map.addObject(circle);\n})(); So when the map is first displayed, the circle may appear small over Palermo, Sicily. By clicking the circle, the map view is then bound to the invisible bounding box surrounding the circle so that it will occupy most of the screen as shown here: As a developer, you did not need to calculate the region or box surrounding the circle, just calling the getBoundingBox() method did all the work for you. Lets now look at another example. Bounding to a Group In the next scenario, many circles are added to the map. This time, the circles are added to a group, then the group is added to the map. This makes it possible to get the bounding box of the group, and bind it to the view area of the map. In other words, fit the map to show all the circles. Consider the following code: // initialize\n(()=>{\n    // create a group\n    let group = new H.map.Group();\n    \n    // ...\n    // after all circle objects are added to group...\n    // ...\n    \n    // add group to map\n    map.addObject(group);\n    // change map to focus in an all circles in group\n   \tmap.getViewModel().setLookAtData({ \n    \tbounds: group.getBoundingBox()\n    });\n})(); The result of the above code is a map starting with a view containing all the circles as shown here: Each circle on the map above belongs to a group, and the bounding box of that group is what the map is now revealing. Summary In this post, we learned the concept of a bounding box, and how it is bound to coordinates, a single object, or a group of objects. Want to see these examples demonstrated? Check out our video below!", "date": "2020-06-11"},
{"website": "Here", "title": "#HackForBetterDays: Addressing COVID-19 in APAC", "author": ["Melodi Kaya"], "link": "https://developer.here.com/blog/humanitarian-technology-hackforbetterdays", "abstract": "It's in times of great challenges when our developer community truly shines. When our Asia-Pacific developer community faced the wildfires in Australia and the COVID-19 pandemic earlier this year, we knew we had to be there to help our developers find ways to solve these and similar issues that might happen in the future. While we have really been missing the personal contact with our community through in-person events, we had to provide the experience and resources for addressing COVID-19 through virtually. Enter: #HackForBetterDays #HackForBetterDays was our first virtual hackathon with the purpose to find disruptive solutions and hack the COVID-19 curve in the region. We wanted this month-long hackathon to bring partners, developers, designers, cartographers and entrepreneurs together to work on solutions to enable a more resilient and just future for all. Our month-long hacking journey was an exciting one thanks to our partners like IBM, Outsystems, Twilio, AURIN and Postman (see the full list here ) who helped participants improve their skills constantly with trainings, workshops and technical support on the event channels. We had the most amazing participants too! They stayed fully engaged with us for over four weeks and our hack’s Slack channel was constantly flooded with hundreds of messages a day. #HackForBetterDays had two main tracks; app development and visualization. In total, we received over 90 projects from 850+ people, and our prize pool included over $12,500 USD cash, merchandise and various partner category prizes. We announced the winners during at the virtual closing ceremony on June 5 th . Now, let’s have a look at the winning solutions which we believe to have the potential to create a change in their community and help the COVID-19 related struggles. App Development Track 1st Place ($5000): Hack Guam from Australia Hack Guam’s app (called PopupGuam ) connects producers and consumers of fresh produce and addresses issues related to COVID-19 including food waste, economic crisis, and social distancing. 2 nd Place ($3500): Project Moses from Philippines An All-in-One platform for Filipinos in times of calamity and crisis bridging the gap between crisis response actors. The platform brings the medical institutions, medical professionals, patients and citizens together to win the fight against COVID-19 pandemic. ​ 3 rd Place ($2000): OopsIDidItAgain​ from India COVID-Oversight is a one-stop solution for visualizing local risky areas, finding safe stores and safer routes for visiting them. It creates systematic queues for reducing delays and a case reporting mechanism for leveraging crowd-sourced data to map the crisis and protect one and all. Visualization Track Our winners on visualization track used HERE Studio and created impactful maps around COVID-19 related issues to help their local communities, SMEs and governments. 1 st place ($1000): Alex Vedernikov – Australia 2 nd place ($500): Manjunatha Venkatappa – Thailand 3 rd place ($500): Frialdhy Ketty – Indonesia 4 th place ($150): Jannieca Camba – Phillipines 5 th place ($150): Maria Kottermair – Guam HERE Technologies and some of the hack’s partners will keep on nurturing these teams and individuals by providing mentorship in the upcoming months and help with further business development. We are thankful to all of our wonderful participants who have become part of our lives for the last 6 weeks and also our enterprise partners who made this event possible and showed that when it comes to the humanitarian efforts, there is no siloed approach, we are all in this together. To see the hack page, visit here .", "date": "2020-06-10"},
{"website": "Here", "title": "Working with GeoJSON in the Browser", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/working-with-geojson-in-the-browser", "abstract": "I've been a bit enamored lately with GeoJSON and I thought it might be nice to look at how you can work with GeoJSON in the browser itself. Obviously it works well with Data Hub and you should consider storing your GeoJSON data there, but you can also work directly with GeoJSON via client-side JavaScript code. Let's consider some examples. Accessing your Data Before you begin, you obviously need your data. It's important to remember that GeoJSON is no different than JSON when it comes to usage within your browser. This means that if your data is hosted on a different server than your own, you need to ensure CORS is setup correctly before you can work with it. CORS (Cross-Origin Resource Sharing) is a fairly complex topic. At the simplest level, it's the mechanism by which your client-side code on your site can directly access data on another site. By default this is blocked for security reasons, but by using the appropriate headers, the other site can enable usage by other sites and their JavaScript code. Most APIs will have this header so that they can be used in JavaScript but it isn't guaranteed to be available. Let's consider an example. I've often used the National Parks System GeoJSON data in blog posts and presentations. You can find the URL for that data here: https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson Now let's consider a simple JavaScript request directly to it: let resp = await fetch('https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson'); If you run this in your browser, you'll get the following error: Access to fetch at 'https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson' from origin 'http://localhost:3333' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. You've got two possible solutions to this problem. Reach out to the National Parks System's web site administrators and ask if they can add this header (a long shot probably), or host the data yourself. In this case you can literally take the URL and save the result to your own web site. Don't forget you need to ensure you can do so legally. In this case it is public government data. But also note that by doing so, you won't know if and when the data ever changes. The other solution would be to use server-side code to simply proxy a request from your server to their server. Specifics of that aren't relevant to this blog post, but it's a fairly common use case for serverless functions. As I said, CORS is a rather complex topic and you can read more about it over at the excellent MDN site: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS Before moving on, one more quick mention of headers. GeoJSON has a specific content-type header. While you don't have to use it, if you do end up hosting your own GeoJSON data you should ensure it uses a content-type header of application/geo+json . Working With Your Data So assuming you've got your data and it's accessible, you can then work with it like any other JSON-related information. Let's look at a complete, simple example: <html>\n<head>\n</head>\n\n<body>\n\n<h2>National Parks</h2>\n<div id=\"results\">\n<i>Loading...</i>\n</div>\n\n<script>\ndocument.addEventListener('DOMContentLoaded', init, false);\n\nasync function init() {\n    console.log('init');\n    let resp = await fetch('./national-parks.geojson');\n    let data = await resp.json();\n    let s = '<ul>';\n    data.features.forEach(f => {\n        s += `\n        <li>${f.properties.Name} located at ${f.geometry.coordinates[1]}, ${f.geometry.coordinates[0]}</li> \n        `;\n    });\n    s += '</ul>';\n    document.querySelector('#results').innerHTML = s;\n    console.log(data);\n}\n</script>\n</body>\n</html> In this example, I wait for the page to load, use the Fetch API to load my geojson, parse it, and then iterate over it. I've described the \"structure\" of GeoJSON before, but as a refresher, remember that GeoJSON consists of: An array of features, the things you are mapping. Each feature consists of a geometry field which is it's location and properties , a generic JavaScript object of custom data. Don't forget that GeoJSON supports much more than just locations as points, but also supports polygons, lines, and multiple locations per features. Also don't forget that the values in properties are random. For the National Parks System data it consists of the name of the park and a code value for it. Don't forget that JavaScript is case-sensitive and you'll see that since my source data used Name , I have to use Name in my code. Finally, GeoJSON stores point data in an array where longitude is first, then latitude. Most people expect data in latitude,longitude form so I wrote it that way above. You can see the result below: Notice that I didn't do any kind of mapping with the information and that's ok. Geocoded data doesn't always need to be something you map, but as I feel guilty not including a map with that information, here's another version of the demo that adds markers across a map based on the same file. <!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Test</title>\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n        <style>\n            #mapContainer {\n                width: 800px;\n                height: 800px;\n            }\n        </style>\n    </head>\n    <body>\n\n        <div id=\"mapContainer\"></div>\n\n        <script>\n        document.addEventListener('DOMContentLoaded', init, false);\n\n        async function init() {\n\n            const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\n            var platform = new H.service.Platform({\n                'apikey': KEY\n            });\n\n            // Obtain the default map types from the platform object:\n            var defaultLayers = platform.createDefaultLayers();\n\n            var map = new H.Map(\n                document.getElementById('mapContainer'),\n                defaultLayers.vector.normal.map,\n                {\n                    zoom: 4,\n                    center: { lat: 30.22, lng: -92.02 },\n                    pixelRatio: window.devicePixelRatio || 1\n                }\n            );\n\n\n            var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n            // Create the default UI:\n            var ui = H.ui.UI.createDefault(map, defaultLayers);\n\n            var icon = new H.map.Icon('park.png');\n\n            let resp = await fetch('./national-parks.geojson');\n            let data = await resp.json();\n            data.features.forEach(f => {\n                map.addObject(new H.map.Marker({lat:f.geometry.coordinates[1], lng:f.geometry.coordinates[0]}, { icon:icon}));\n            });\n\n        }\n\n        </script>\n    </body>\n</html> This one makes use of our JavaScript Maps API to render a map. As before, we load in the GeoJSON file but this time as we iterate, we add markers to the map. Here's how it looks: Let's consider one more example. A browser can determine (with the user's permission of course) the user's location. Given we know where the user is, what if we could filter out the GeoJSON data to results that were nearby. Doing this requires a few modifications to our previous example. First, we make use of the Geolocation API . This is where the browser can ask the user's permission and then retrieve their position. I've added this as a function: async function getLocation() {\n    return new Promise((resolve, reject) => {\n        navigator.geolocation.getCurrentPosition(pos => {\n            resolve(pos.coords);\n        }, e => {\n            reject(e);\n        });\n    });\n} Most of the code above is syntax sugar so I can make calling it easier with the await keyword. Once you know the user's position, you could then determine the distance from them to another location with the haversine formula . I found a simple to use one on StackOverflow : function calcCrow(lat1, lon1, lat2, lon2)  {\n    var R = 6371; // km\n    var dLat = toRad(lat2-lat1);\n    var dLon = toRad(lon2-lon1);\n    var lat1 = toRad(lat1);\n    var lat2 = toRad(lat2);\n\n    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n        Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n    var d = R * c;\n    return d;\n}\n\n// Converts numeric degrees to radians\nfunction toRad(Value) {\n    return Value * Math.PI / 180;\n} As hinted at by the function name, this isn't a \"real\" distance determination because it assumes you're travelling as \"the crow flies\", or a straight line, but it's good enough for now. So now that we can figure out the distance, here's a complete implementation: <!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Test</title>\n        <meta name=\"description\" content=\"\">\n        <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n        <style>\n            #mapContainer {\n                width: 800px;\n                height: 800px;\n            }\n        </style>\n    </head>\n    <body>\n\n        <div id=\"mapContainer\"></div>\n\n        <script>\n        document.addEventListener('DOMContentLoaded', init, false);\n\n        async function init() {\n\n            let position = await getLocation();\n            console.log(position);\n\n            const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw';\n            var platform = new H.service.Platform({\n                'apikey': KEY\n            });\n\n            // Obtain the default map types from the platform object:\n            var defaultLayers = platform.createDefaultLayers();\n\n            var map = new H.Map(\n                document.getElementById('mapContainer'),\n                defaultLayers.vector.normal.map,\n                {\n                    zoom: 6,\n                    center: { lat: position.latitude, lng: position.longitude },\n                    pixelRatio: window.devicePixelRatio || 1\n                }\n            );\n\n\n            var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n            // Create the default UI:\n            var ui = H.ui.UI.createDefault(map, defaultLayers);\n\n            var icon = new H.map.Icon('park.png');\n\n            let resp = await fetch('./national-parks.geojson');\n            let data = await resp.json();\n            data.features.forEach(f => {\n                let dist = calcCrow(position.latitude, position.longitude, f.geometry.coordinates[1], f.geometry.coordinates[0]); \n                if(dist < 500) {\n                    map.addObject(new H.map.Marker({lat:f.geometry.coordinates[1], lng:f.geometry.coordinates[0]}, { icon:icon}));\n                }\n            });\n\n        }\n\n        async function getLocation() {\n            return new Promise((resolve, reject) => {\n                navigator.geolocation.getCurrentPosition(pos => {\n                    resolve(pos.coords);\n                }, e => {\n                    reject(e);\n                });\n            });\n        }\n\n        // credit: https://stackoverflow.com/a/18883819/52160\n        //This function takes in latitude and longitude of two location and returns the distance between them as the crow flies (in km)\n        function calcCrow(lat1, lon1, lat2, lon2)  {\n            var R = 6371; // km\n            var dLat = toRad(lat2-lat1);\n            var dLon = toRad(lon2-lon1);\n            var lat1 = toRad(lat1);\n            var lat2 = toRad(lat2);\n\n            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n                Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); \n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); \n            var d = R * c;\n            return d;\n        }\n\n        // Converts numeric degrees to radians\n        function toRad(Value) {\n            return Value * Math.PI / 180;\n        }\n        </script>\n    </body>\n</html> Now our demo waits for the browser to report it's location. It then centers the map on that location and zooms in closer than before. It loads up the GeoJSON and filters the markers to those within 500km (an arbitrary decision on my part). Here's the result: As a quick aside, I've already mentioned Data Hub before, but this is a place where moving your geospatial data into Data Hub would be hugely beneficiation. In the demo above, all of the data needs to be loaded even though only a small portion of the features are rendered. Data Hub's APIs would allow you to pass in a location and radial distance and then return just those features within that circle! I hope this quick introduction to using GeoJSON in the browser helps you understand how easy, and flexible, the format is. With browsers advancing at a rapid pace and JavaScript itself evolving, it's a great time to bet on the web! Check out my other GeoJSON posts here: Working with GeoJSON and Visual Studio Code , Integrating GeoJSON in Your Static Sites Great Guide to Generating Good GeoJSON", "date": "2020-06-15"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.16 release", "author": ["Jeanus Ko"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.16-release-notes", "abstract": "Highlights Reduced Stream Pipeline downtime during Upgrade and Restart The downtime experienced during a Stream pipeline's Upgrade or Restart has been reduced to under 30 seconds, delivering a 50% improvement that is important for critical stream processing. Use the improved GeoJSON plugin interface to combine and visualize data from multiple layers The GeoJSON plugin interface now enables you to retrieve, combine and visualize data from multiple layers in different catalogs. For example, the Places MetaData layer contains a lookup table to translate category IDs used in the Places layer to category names. With this feature we can now show the category names in the properties rather than just the ID . Use SBT to fetch schemas and the Data Client Library So far, you could fetch platform dependencies only with the Maven build system. Java and Scala developers that prefer the Scala Build System (SBT) may now use our new SBT resolver plugin to fetch their project dependencies from the platform. Like the previously released Maven Wagon plugin, this SBT resolver manages the access to the platform via your platform credentials. The plugin is open sourced on GitHub and also published to Maven Central so it can be fetched as part of your build process. Any contribution to both these GitHub projects is welcome. Please note, this SBT resolver is provided 'as is' and not officially part of Workspace or Marketplace. That means the official support that you may have licensed does not apply to this SBT resolver. Access additional HERE Map Content: ADAS Attributes via the Optimized Map for Location Library The following ADAS attributes from the HERE Map Content catalog are now available: Slope, BuildUpArea, LinkAccuracy and CurvatureHeading. Note: \"Elevation\" is targeted to be added to OMLL in the next platform release (v2.17). We will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library.  For more detail on the added attributes, please see: HERE Map Content- ADAS Attributes layer Changes, Additions and Known Issues SDKs and tools Go to the HERE platform changelog to see all detailed changes to our CLI , the SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Changed: Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. HERE Content Added: additions to existing layers in the HERE Map Content ( Japan ) catalog: Added Postal Code Boundaries content to Postal Area Boundaries layer Added Postal Code Points content to Postal Code Points layer Added Carto Roads content to the Cartography layer Added Truck Service Locations content to the Truck Service Locations layer Added Fueling Stations content to the Fueling Stations layer Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Issue: There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, service will slow down across the board for all consumers who are reading from the External Service Gateway. Workaround: Contact technical support for help. Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 July 31, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after July 31, 2020. ·       Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after July 31, 2020, ·       Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before July 31, 2020 so your workflows continue to work. ·       HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after July 31, 2020. ·       Examples of old and new Catalog HRN formats: ·       Old (without OrgID/realm): hrn:here:data:::my-catalogNew (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 OrgID added to Schema HRN (Global) 2.10 December 2019 July 31, 2020 Deprecation Summary: References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. 3 Data Client Library data compression behavior 2.10 December 2019 June 20, 2020 Deprecation Summary: As of June 30, 2020, all data streaming related workflows must be updated to use at least SDK version 2.9.  The Data Client Library behavior as it relates to compressing and decompressing streaming data will strictly adhere to stream layer configuration settings. 4 Spark-ds-connector replaced by SDK for Java and Scala Spark Connector 2.12 February 2020 August 19, 2020 Deprecation Summary: The spark-ds-connector will be deprecated (6) months from this release on August 19, 2020. Please upgrade to the latest SDK for Python version before then to get the latest SDK for Java and Scala Spark Connector. 5 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. Existing Batch pipelines that use the Batch-2.0.0 run-time environment will continue to operate normally until August 19, 2020. During this period, Batch-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-2.0.0 environment, please use OLP SDK 2.11 or older. After August 19, 2020 we will remove the Batch-2.0.0 run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. 6 Schema validation to be added 2.13 March 2020 September 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of September 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If a non-existing or non-accessible schema is associated with any layer after this date, any attempt to update any configurations of that layer will fail. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before September 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 7 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020.", "date": "2020-06-18"},
{"website": "Here", "title": "Solutions: Day 71-75 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-71-75-100daysofcode", "abstract": "Welcome to week 15 #100DaysOfCode with HERE. In this week, we will learn to customize the response that you get from the routing request with Routing v7. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-70, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 71/100 Looking at all the objects in the response of the routing call and selecting the ones that make sense can be overwhelming. With day 71, we will look at how to get the summary of a route per country when your route crosses countries. We have selected a route from Berlin, Germany to Warsaw, Poland for the example. The rest of the parameters are basic. What changes is what you want in the route response. The routeAttributes parameter lets you customize what you want in your route response. For this example, we will take a look at the property summaryByCountry which should give is the route summary per country that it crosses. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    routeAttributes:\"summaryByCountry\"\n  }; In the response, you will see details of the route for every country with distance traveled and time taken in each of the countries. summaryByCountry: (2) […]\n    0: {…}\n      ​​_type: \"RouteSummaryByCountryType\"\n    ​  baseTime: 5769\n    ​​​​  country: \"DEU\"\n    ​​​​​  distance: 104702\n    ​​​​​  flags: Array(4) [ \"tollroad\", \"tunnel\",   \"motorway\", … ]\n    ​​​​​​  text: \"...\"\"\n    ​​​​​​  tollRoadDistance: 103179\n    ​​​​​​  trafficTime: 6207\n    ​​​​​​  travelTime: 6207\n  ​​  1: {…}\n      ​​​​​​_type: \"RouteSummaryByCountryType\"\n      ​​​​baseTime: 14446\n      ​​​​​​country: \"POL\"\n      ​​​​​​distance: 299131\n      ​​​​​​flags: Array(4) [ \"tollroad\", \"tunnel\", \"motorway\", … ]\n      ​​​​​​text: \"...\"\n      ​​​​​​tollRoadDistance: 170174\n      ​​​​​​trafficTime: 16393\n      ​​​​​​travelTime: 16393\n      length: 2 Day 72/100 With day 72, we are going to add another parameter to the routeAttributes , namely: zones . With this parameter, you will get the list of all the routing zones that your vehicle will pass through. This is important when looking at restrictions on vehicles in specific routing zones. To add more objects to the parameter, you can simply separate them with a comma. You can also use shortened versions of the option names. So summaryByCountry can be written as sc , zones as zo , and so on. You can find out all the short versions here . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    routeAttributes:\"summaryByCountry,zones\"\n  }; Day 73/100 If you analyze the route object, you will see that the first object within it is the leg . This object gives details of every leg of the route and is often useful in analyzing different parts of the route. With the legAttributes , you can customize the information you get in the leg object of your route response. To get the maneuvers per leg of the route, we can simply add the legAttributes as maneuvers . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    routeAttributes:\"summaryByCountry,zones\",\n    legAttributes:\"maneuvers\"\n  }; Day 74/100 With maneuvers, you also want to display the direction of the maneuver. You can use this with a text-to-speech converter as an instruction to the driver. Check out all the possible maneuver attributes that you can define. For day 74, we can simply include direction as our maneuverAttributes . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    routeAttributes:\"summaryByCountry,zones\",\n    legAttributes:\"maneuvers\",\n    maneuverAttributes:\"direction\"\n  }; Day 75/100 And finally for day 75, we will take a look at cleaning up our response. As much as you can add to a response, sometimes you do not need as many objects in your response. To completely delete an object from your response, you can set the value for it's parameter as none . To selectively remove attributes, you can add a negative sign - before the attribute name and you will get a cleaner response. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    routeAttributes:\"-summary\",\n    legAttributes:'none',\n    maneuverAttributes:\"none\"\n  }; That was week 15 of #100DaysOfCode With HERE. I hope this week was helpful in understanding the responses of the Routing API v7. Let us know if you would like to know more about some of the responses of the Routing API. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . Meanwhile, learn more about BoundingBox through this blog post by our 🥑 Michael Palermo. While you're at it, learn how to work with geojson in the browser with our very own Jedi Master Raymond Camden. Happy coding!", "date": "2020-06-17"},
{"website": "Here", "title": "Our API and SDK Cheat Sheet: Maps, Geocoder and Search, Routing and more", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/a-brief-tour-of-here-developer-awesomeness", "abstract": "Like any developer-focused company, we pride ourselves with the variety and power of our APIs and SDKs. Over 40 APIs and SDKs provide easy integration with Android and iOS map applications and web services and it's not easy to get a good overview of which API you might need for your use case. That's why we created this cheat sheet of each of our services. We'll update this continuously as a quick guide for our developer community. Unless specifically noted, every service here is available under our Freemium plan. The use of HERE APIs and SDKs requires an API key. Service Description Maps API for JavaScript A fully featured mapping library for JavaScript, supporting markers, routing, traffic, and custom map styling. Vector Tiles API The HERE Vector Tile Service allows you to request tiles containing vector data using content from the HERE Platform. HERE SDK (Explore Edition) A light-weight map renderer for the mobile platforms. Supports displaying maps, geocoding, routing, and more. Available on Android , iOS , and Flutter . HERE SDK (Navigate Edition) All the features of the Explore edition, plus additional capabilities like turn-by-turn navigation. Available on Android , iOS , and Flutter . Map Image API Renders maps as static images. Map Tile API Display server-rendered, raster 2D map tiles at different zoom levels, display options, views and schemes. Map Feedback Allows reporting map errors and editing the maps using API calls or the Embedded Map Editor. Geocode API Turn a text-based address into a precise location. Reverse Geocode API Returns what can be found at a location. Discover API Text-based search for POIs (Points of Interest) at or near a location. Browse API Category-based search for POIs at or near a location. Autosuggest API POI API built to work with client-side autosuggest fields. Lookup API Returns details about one specific POI. Routing API Flexible API that returns information on how to get from one point to another, supports starting times, traffic, truck restrictions and more. Intermodal Routing API Offer different routes that include drive, park, bike, ride, bike or ride share, taxi and walk to a destination. Automatically account for real-time traffic, incidents, public transit timetables and historical information. Traffic API Help users avoid traffic and potential delays with historical traffic data at a particular place, time of day and day of the week. Public Transit API Provide the best public transit routes while highlighting walking directions to stops, pedestrian access points, station locations and transfer locations along the way. Truck Routing API Deliver the most appropriate truck routes using truck-specific attributes, while taking into account applicable physical and legal restrictions. Large-Scale Matrix Routing API Calculate the best routes through one or more locations, showing distances and/or ETAs from up to 10,000 origins and destinations. Get over 200,000 route responses per second for regions with diameters as big as 400 km. Isoline Routing API See the areas of reach from or to a given spot based on time, distance or fuel consumption. Covers both gas and electric vehicle dynamics, as well as physical restrictions such as size, weight and height. Fuel Consumption API Specify parameters (such as speed, ascent, descent and auxiliary) to calculate fuel or energy consumption for your vehicles on a given route. Fleet Telematics API Get access to advanced location algorithms for fleet management use cases like geofencing, route matching, toll costs and more. Geofencing API Monitor mobile assets entering or leaving a certain geographic area, of any size, anywhere in the world. Custom Locations API Store, manage and retrieve any custom POI or polygon, whenever and wherever needed. Custom Routes API Build custom routes considering own road restrictions and geometries including blocking of existing roads, removal of existing road blocks and adding new road geometries. Advanced Data Sets API Get additional HERE Map Content, including height and slope values, curvature, speed limits and traffic lights. Route Matching API Match the GPS traces to the HERE road network to get the most probable routes for your vehicles, and detect illegal maneuvers. Toll Costs API Calculate the toll costs for any HERE route while taking into account various vehicle profiles, or get the cost-optimized route based on toll and vehicle costs. Waypoints Sequence API Get the optimum sequence of a given set of waypoints based on time or distance traveled, or by considering the commercial value at each location. Fleet Connectivity API Enable direct communication between dispatch and fleet with HERE Premium SDKs. Live Sense Android / iOS Real-time detection of hazards, road signs and more using a camera-enabled edge device. Immediate or potential hazards on the road ahead can be identified to alert the driver, so they can take appropriate action. This service is not available under our Freemium plan. Tracking API A fast, flexible way to add real-time and historical location to your IoT product. This service is not available under our Freemium plan. Positioning Provides positioning estimates based on global Wi-Fi and Cell coverage. Venue Maps Show venue maps with floor levels, connectors, access points and Places/store information. HERE Off-Street Parking Display off-street parking facilities on the map with information about opening times, height restrictions, prices and real-time parking availability. HERE On-Street Parking A service providing dynamic information about the likelihood of finding an available parking spot on the street (unattended curb-side parking), and applicable parking restrictions with price information. Fuel Prices Show actual prices of relevant fuel types at gas stations and rank the latter based on current and statistically-modelled prices. EV Charging Stations Indicate where EV charge points are, with rich content about opening hours, connector types and real-time information on connector availability. Destination Weather Reports on weather conditions and forecasts. TPEG Traffic Service providing real-time information about traffic incidents and traffic flow in a compressed binary format, using the TISA TPEG standard. HERE OTA Connect A secure, easy-to-use SaaS platform for the automotive industry offering over-the-air updates from prototyping to production and service life. HERE Studio Online tool to build interactive map with your data. HERE Data Hub A cloud storage service specially targeted to geospatial data. For more information about these services, you can look at our main developer portal (you're already here!) and check out our extension set of documentation links for details.", "date": "2020-06-22"},
{"website": "Here", "title": "Create a Flutter Map Application in Under 5 Minutes", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/create-a-flutter-map-application-in-under-5-minutes", "abstract": "A few weeks ago, we released our new HERE SDKs for Android and iOS. However, if you’ve been eagle-eyed, you may have also noticed the simultaneously beta launch of our HERE SDK for Flutter . I’ve been Flutter-curious for a while, so last weekend I started learning Flutter. This made me wonder how long it takes to get a basic map application set up with our new Flutter SDK. As a reminder, on Android you can do that in under five minutes . Spoiler alert! It’s just as quick with Flutter. Set you stopwatches, here we go! Creating our app is five-step process. Each of these steps can be completed in a minute or less. Get your credentials and download the SDK libraries. Grab an example from GitHub. Copy the SDK files into the plugins folder of your project. Add your credentials to the manifest file and information property list file. I was lying, again. There's still no step five. It really is that quick and easy. Let's quickly(!) walk through all these steps. Step 1: Get Your Credentials First you need to sign up on the developer portal , generate a set of credentials and download the SDK files. Just click on \" Sign up \" on the top-right of this page and follow the process. My colleague Michael has made a video in case you need help. (Which you don’t. Go ahead, you got this.) Once you've signed up, you will be taken to your project page. There, click on \"Generate App\" then on \"Create Credentials\". Store these credentials, we will need them in Step 4. Finally, click on \"Download SDK for Flutter (Explore Edition)\". The download contains a .tar archive, which we will need in Step 3, so store it in a safe place. Fun fact: This was most complicated and time-consuming step. It’s only going to get faster from here. Step 2: Clone the Examples from GitHub This step is even faster. Just \"git clone https://github.com/heremaps/here-sdk-examples.git\" to get the HERE SDK Examples from the HERE GitHub account. Step 3: Add the SDK Library to your Project Go into the examples folder of the SDK examples you just downloaded and find the \"HelloMap\" example for the Flutter SDK Explore Edition. Then extract the .tar file from Step 1 into the plugins folder of the example app. Rename the folder you extracted into “here_sdk”. The result should look something like this. Step 4: Add Credentials to your Project Open the \"HelloMap\" example in Android Studio (or VS Code or whatever tickles your fancy). In your IDE, go to the manifest.xml file of your Android project and paste your credentials (Access Key ID and Access Key Secret) from Step 1 into the appropriate tags under \"application\". Then, go the plist.info file in your iOS project and set your credentials under the keys “AccessKeyId” and “AccessKeySecret”. OK, so there's technically a fifth step in that you must “flutter run” you app. And that’s really it, you should have just created a running app with a HERE map! Congrats! (And don’t sweat it if you took like seven minutes or something. I won’t tell anybody.) Now, if this was too fast for you after all, you can check out the documentation for more details. Be sure to follow us on Twitter and Twitch for more updates on the new Flutter SDK!", "date": "2020-06-18"},
{"website": "Here", "title": "Visual Recognition with IBM Watson, HERE and Python - Part 1", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/visual-recognition-with-ibm-watson-here-and-python-part-1", "abstract": "Introduction Many times, you want to search a restaurant which serves a specific dish. And you know the possibility of remembering name of that dish is bleak, but you took a picture last time you had it. In such situation a feature to search a dish by image is sorely missed. In this blog we are going to learn how to create an application to find restaurants with the help of food image you have. You will also learn how to work with IBM Watson for Visual Recognition and use HERE location services for maps and location analytics. Prerequisites To start with Image Recognition, you will need: An IBM Cloud account (you can sign up here ) Python 3.8  and pip Freemium account on HERE Developer portal From IBM Cloud, you need to access Watson and create a Visual Recognition service. From the created service, you have to acquire the API key for performing operations through the API. You will also need an API key from the HERE Developer Portal (which we will use in the code). Simply sign up for your free account and generate API key on your account page. For coding, your machine should have Python installed (I have Python 3.8). In this part, you will learn to run image recognition code on your machine and extract the required result from the JSON response. (We will cover the location element in next blog post). Lets get started then! Creating Visual Recognition Service and Acquiring API key After logging into your IBM Cloud account, you will be on the dashboard page. You need to create a service by clicking on 'Create resource' (as shown in the image below). This will take you to the IBM Product Catalog page. There, search for 'visual recognition' (as shown below) and select the first option. The Visual Recognition service uses deep learning algorithms to analyze images for scenes, objects and other content. And it also has a set of built-in models for ease of use. You will reach a page where you have to select the region and configure resources. It can be edited as per your wish or can be left unaltered (see the below image). Then click on 'Create' to move to the next step. Finally, you will be on the page from where you need to copy the API key and URL. Keep both the values for further coding (represented as IBM API KEY and IBM URL later in the code). Writing Python Code for Visual Recognition Once you have acquired an API key associated with the Visual Recognition service, the next step is to install Watson Developer Cloud using pip: pip install --upgrade \"ibm-watson>=4.0.1\" The library can be installed using the command prompt, terminal or a Python IDE (PyCharm, Spyder, etc), depending on how you are working with Python. Watson's Visual Recognition comes with a number of default classification models. We will use the Food Model for recognizing images of food item. import json\nfrom ibm_watson import VisualRecognitionV3\nfrom ibm_cloud_sdk_core.authenticators import IAMAuthenticator\n\nauthenticator = IAMAuthenticator('IBM API KEY')\n\nvisual_recognition = VisualRecognitionV3(\n    version='2018-03-19',\n    authenticator=authenticator)\n\nvisual_recognition.set_service_url('IBM URL') \n\nwith open('./test.jpg', 'rb') as images_file: \n    classes = visual_recognition.classify(images_file=images_file,threshold='0.6',classifier_ids='food').get_result()\n\nprint(json.dumps(classes, indent=2)) First, you need to instantiate VisualRecognitionV3 with the version value and API key (acquired from IBM Cloud) 'test.jpg' is the image to be recognized with the help of classify() , this method accepts a JPG/PNG image. Following image is provided to test the code. The output for the image after passing it through the food classifier: {\n  \"images\": [\n    {\n      \"classifiers\": [\n        {\n          \"classifier_id\": \"food\",\n          \"name\": \"food\",\n          \"classes\": [\n            {\n              \"class\": \"pepperoni pizza\",\n              \"score\": 0.809,\n              \"type_hierarchy\": \"/pizza/pepperoni pizza\"\n            },\n            {\n              \"class\": \"pizza\",\n              \"score\": 0.918\n            }\n          ]\n        }\n      ],\n      \"image\": \"test.jpg\"\n    }\n  ],\n  \"images_processed\": 1,\n  \"custom_classes\": 0\n} The above result shows the accuracy of the built-in model and is able to give us an exact match, i.e. pizza . Conclusion The world is moving more and more toward automation and visual recognition is one of the best example of automation. The real question is how to use the output of Machine Learning and AI based model. We will explore the answer in the next part where we will take the name (pizza) and pass it to the HERE Location Services and Map to built an amazing recipe. A recipe to showcase the true potential of Machine Learning and AI with location services. Till then, happy learning!", "date": "2020-06-29"},
{"website": "Here", "title": "Solutions: Day 76-80 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-76-80-100daysofcode", "abstract": "Welcome to week 16 of #100DaysOfCode with HERE. This week we are going to concentrate on the different costs involved in a journey and the ways to get cost optimized routes. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-75, you can find them in the previous blogs posts or on our YouTube channel . Let's begin! Day 76/100 When you are operating a fleet of commercial vehicles, it is necessary to consider the cost paid to drivers and the cost of the vehicle for the journey. With this information, you need to calculate the cost of different routes you can take to your destination and choose the one which is the most cost effective. This has to be done before planning your delivery schedules, and can take a lot of time. With the Fleet Telematics API , this has been simplified for developers. While getting a route for the vehicle, you can simply mention the driver_cost and the vehicle_cost in your target currency and get two things: The total cost of the journey considering the driver cost and vehicle cost Route options arranged to optimize cost and routing type var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    alternatives:3,\n    driver_cost:10, // cost per hour\n    vehicle_cost:0.5, //cost per kilometer\n    currency:\"EUR\"\n  }; In the response, you will get an object called cost which will hold the information of the total cost for all the route options. {\n    \"response\": {\n        \"route\": [\n            {\n              ...,\n                \"cost\": {\n                    \"totalCost\": \"251.16\",\n                    \"currency\": \"EUR\",\n                    \"details\": {\n                        \"driverCost\": \"48.98\",\n                        \"vehicleCost\": \"202.18\",\n                        \"optionalValue\": \"0.0\"\n                    }\n                }\n            },\n            {\n              ...,\n                \"cost\": {\n                    \"totalCost\": \"271.7\",\n                    \"currency\": \"EUR\",\n                    \"details\": {\n                        \"driverCost\": \"66.55\",\n                        \"vehicleCost\": \"205.15\",\n                        \"optionalValue\": \"0.0\"\n                    }\n                }\n            }\n        ],\n    }\n} Day 77/100 The cost calculated from day 76 is far from complete. There are more costs involved with the journey from point A to B. One of the obvious ones is the cost of fuel. To add that to the mix, the Fleet Telematics API lets you add fuel related details to the routing call. With day 77, we are adding the rate of consumption of fuel for this vehicle. This detail can help you get specific costs for all your vehicles. It is interesting to note that the parameter customConsumptionDetails lets you describe the speed profile of your vehicle along with the consumption profile. Say your truck consumes 7€ worth of fuel per 100 km at a speed of 60 km/hr and a different amount at reduced speed, different on a slope, urban areas etc. You can specify all this information in your consumption profile. To make it easier, there are also some preset values for consumption profiles for trucks based on their weight. For this example, we will use the preset values for a 40 tonne truck. You will get this cost as energyCost under the cost object. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    alternatives:3,\n    driver_cost:10, // cost per hour\n    vehicle_cost:0.5, //cost per kilometer\n    currency:\"EUR\",\n    maxSpeed:\"90\",\n    customConsumptionDetails:\"40t\"\n  }; Day 78/100 While we are talking about the fuel consumption profile, we should also consider the fuel type and the fuel cost. This is something that varies widely. Specifying this can get you the detailed cost for the journey. With the Fleet Telematics API , you can specify the fuel type and the fuel rate with parameters fuelType and costPerConsumptionUnit respectively. The truck I am considering runs on diesel and the current rate in Berlin, Germany, is about 1.225€/liter. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    alternatives:3,\n    driver_cost:10, // cost per hour\n    vehicle_cost:0.5, //cost per kilometer\n    currency:\"EUR\",\n    maxSpeed:\"90\",\n    customConsumptionDetails:\"40t\",\n    fuelType:\"Diesel\",\n    costPerConsumptionUnit:\"1.225\"\n  }; Day 79/100 A major part of long-haul journeys is toll costs. Toll costs vary from country to country, region to region and are a reason for cumulative costs during the journey. With the Toll Cost API , you can make the routing engine consider toll costs. The Toll Cost API is part of the Fleet Telematics API and can give you toll summaries for the  route. For getting this cost, you need to mention certain details of your vehicle. Firstly, you need to specify the tollVehicleType as the toll cost is different for different vehicles. If your truck has trailers, mention the number of trailers. The warnings object in the response will tell you all toll-related parameters that you can mention to help the routing engine calculate the exact toll cost for your vehicle. After adding the details necessary to calculate the toll, you can specify the format in which you want to see the toll cost. This is done with the parameter rollups which is a necessary parameter for toll cost calculation. For this example, I have selected a total summary for the tolls involved. The toll cost of the journey is reflected in the cost object in the routing response as well as in a separate object called tollCost . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    alternatives:3,\n    driver_cost:10, // cost per hour\n    vehicle_cost:0.5, //cost per kilometer\n    currency:\"EUR\",\n    maxSpeed:\"90\",\n    customConsumptionDetails:\"40t\",\n    fuelType:\"Diesel\",\n    costPerConsumptionUnit:\"1.225\",\n    tollVehicleType:3,\n    trailersCount:1,\n    weightPerAxle:10,\n    rollups:\"total\"\n  }; Day 80/100 From day 79, we saw that the parameter rollups can give us the total toll costs involved in the journey. This same parameter gives us other options to display the toll cost in the tollCost object of the response. The rollups parameter has options to display the total toll cost, costs per toll system, per country and per link. You can use the options in combinations separated with a comma to display different summaries for the toll costs. You can also use hybrid combinations like costs by country and toll systems by using a semicolon as the separator country;tollsys . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",// Berlin, Germany\n    waypoint1:\"53.13256,17.98909\",// Warsaw, Poland\n    mode:\"fastest;truck;traffic:enabled\",\n    representation: \"display\",\n    alternatives:3,\n    driver_cost:10, // cost per hour\n    vehicle_cost:0.5, //cost per kilometer\n    currency:\"EUR\",\n    maxSpeed:\"90\",\n    customConsumptionDetails:\"40t\",\n    fuelType:\"Diesel\",\n    costPerConsumptionUnit:\"1.225\",\n    tollVehicleType:3,\n    trailersCount:1,\n    weightPerAxle:10,\n    rollups:\"total,tollsys\"\n  }; That was week 16 of #100DaysOfCode with HERE. This week was all about calculating journey related costs. Let us know if you would like to know more about journey costs with the Fleet Telematics API. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . Meanwhile, learn how to create a Flutter Map Application in under 5 minutes with this blog post by our 🥑 Richard Süselbeck. Happy coding!", "date": "2020-06-23"},
{"website": "Here", "title": "At HERE, Pride is More than a Month, it's a Movement", "author": ["Christo Mitov"], "link": "https://developer.here.com/blog/at-here-pride-is-more-than-a-month-its-a-movement", "abstract": "At HERE, we’re proud to foster a talented and diverse group of employees who bring their unique perspectives and experiences to be a key part in developing solutions that a homogeneous culture never could. And while Pride Month may be ending soon, our commitment to celebrating and empowering our LGBT+ team members remains a daily constant. In that spirit, we’d like to introduce you to three of our most passionate employees: Lene Preuss is a Senior Developer in our Public Transit and Intermodal Routing team. The routing engine she worked on powers any non-car-only routes in the HERE WeGo app, as well as many of our B2B products. Over her 15-year long career, Lene has witnessed acceptance for LGBT+ people in the workplace progress from an impossibility to an ideal that is encouraged and protected. And while she sees and values the diversity she finds at HERE, she continues to challenge us to reach fairer gender and race equity among our developer population. For Lene, it is a huge relief to be free from discrimination in the workplace. Besides making it possible for her to work at HERE at all, being allowed to be herself at work helps her fully engage in her assignments, and freely contribute her unique viewpoints to our products, giving them an edge over products produced by teams of one shared background. Outside of HERE, Lene is a participant in LGBT in Tech communities, finding them to be an important resource for community building, learning and networking, as well as an incubation space for new and innovative ideas. She feels that such constant learning and openness to new tech and experiences is invaluable as a developer at any stage of their career, and in order to become a well-rounded person in general. When not working, which she admits is a hobby unto itself in some respects, Lene is an aspiring science-fiction novelist, and enjoys riding her bike, good food and drink, and dancing with friends. She wants everyone to remember that Pride started as a riot, and the struggle for equality continues in the current Black Lives Matter movement. Patrick Vacek is a Lead Software Engineer in our OTA Connect team, working as both a developer and manager of the embedded development and security aspects of HERE products. During their time at HERE, they worked on aktualizr, our embedded, client-side software that enables OTA (over-the-air) software updates. Patrick’s been with that team since the project’s start, and is proud to have seen it grow into a powerful tool with real open-source community input and customer adoption. One difference that Patrick notes about working at HERE is that, while they’ve never worked at an outright discriminatory company, HERE feels like the first workplace that encourages them to be open about being non-binary and queer. Being able to be open about themself at work helps Patrick feel more invested in what they do at HERE, compared to a disengagement that stems from having to act “normal” they’ve felt at previous jobs. However, like Lene, while Patrick feels comfortable at HERE, they challenge us to continue to hire more diverse developers. While surrounded by supportive and sympathetic friends and family, Patrick is still pretty new to being active in the LGBT+ tech community. Since joining those spaces, Patrick’s found them to be a great resource for realizing that they weren’t alone, and that other people have faced similar issues and have had similar questions about their workplaces. Patrick believes that technology requires creativity, humanity, and compassion; and encourages the next generation of tech workers to never deny or hide who they are, or close themselves off to the experience of others. In their free time, Patrick loves playing music, and cooking. Hervé Utheza is our Chief of Data Strategy, leading the Media, Advertising & Telco teams for the Americas. As HERE expands into new markets, Hervé works with his segment lead peers to find out how to best connect Location intelligence to the problems faced by various industries. As a team leader, Hervé is most proud of creating a safe space for his team to innovate and think differently in order to solve problems. He believes that fostering this culture of openness has been key to building the foundations necessary to enter new markets and industries. With over 30 years in Silicon Valley, Hervé recognizes and respects that all progress towards the inclusion of the LGBT+ community into workspaces represents and validates decades of activism and work between individuals, and takes none of that struggle for granted. He’s glad to have had a part in that, helping HERE become recognized by the Human Rights Campaign foundation with a perfect score in LGBT+ inclusion for many years in a row. Hervé believes his own experience as a queer man helped him recognize the importance of innovation and empathy in the workspace - that having to come out to dissenting parents after growing up in the closet taught him how to approach problems from different angles, and put oneself in his audiences’ shoes. This experience helped him realize that empathy is required to overcome the fear that comes with most types of change, and to find the allies necessary to construct better things and spaces for all. As we continue to go forward, Hervé recommends that we don’t forget where we’ve come from:  that so much progress for LGBT+ rights have been built on the shoulders of black queer people who turned their generational frustration into action during Stonewall; and as we continue to progress into a more equal future, it’s our responsibility to carry the torch of the innovators who came before. In his downtime, Hervé enjoys writing, cooking with and for his friends, and supporting his husband’s career in fashion design. We hope that reading these short profiles of some of our LGBTQI+ colleagues encourages you to continue pushing for more inclusive workspaces, whatever your position, company, or industry. We know that, as a company, we still have a long way to go, but as we continue to reach towards the diversity and inclusion expectations our employees hold us to, we’ll celebrate the hard-won progress made by all that have already fought for us. Happy Pride!", "date": "2020-06-26"},
{"website": "Here", "title": "Solutions: Day 66-70 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-66-70-100daysofcode", "abstract": "Welcome to week 14 #100DaysOfCode with HERE. With this week, we are kicking off with truck routing and will take a look at routing features specific to logistics with Routing v7. If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-65, you can read them in the previous blogs posts or on our YouTube channel . Let's begin! Day 66/100 Day 66 is pretty straightforward as we just need to change the routing mode. We have already seen that the Routing v7 API has several transport modes , one of them being a truck . Moreover, the API lets us control the restriction penalty associated with truck routing. What does this mean you say? Well, if you were to find a route for a car and a truck between the same two points, the route will often vary. This is due to the fact that different kinds of roads all over the world have different restrictions on the kind of vehicle that can be driven on them. In some places, trucks aren't allowed in the city centers at all. While in others, they are allowed only at night or after peak evening hours. Whatever the restrictions might be, they are considered when you get a route for a truck. Although you can adjust how strictly you want to follow that while getting a route. All you need to to is set the truckRestrictionPenalty to soft or strict var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",\n    waypoint1:\"52.1370754,11.6326044\",\n    mode:\"fastest;truck;traffic:enabled\",\n    truckRestrictionPenalty:'strict',\n    alternatives:3,\n    representation: \"display\",\n  }; Day 67/100 While we talked about restrictions on trucks simply by the virtue of being trucks, restrictions also exist depending on what they carry. For day 67, we are looking at a truck which carries radioactive material. How do you tell this to a routing engine. As I mentioned before, we are going to concentrate on logistics related routing here and so we have this covered. The parameter shippedHazardousGoods lets you mention a few types of goods that trucks may carry which can affect the route assigned to them. Feel free to check out the different Hazardous Good Types . var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",\n    waypoint1:\"52.1370754,11.6326044\",\n    mode:\"fastest;truck;traffic:enabled\",\n    truckRestrictionPenalty:'strict',\n    shippedHazardousGoods:'radioActive',\n    alternatives:3,\n    representation: \"display\",\n  }; Day 68/100 Another thing you need to consider while driving a truck is the height of the truck. You need to make sure the route you've taken does not have tunnels, bridges or any other construction that may not allow your truck to easily pass through it. Roads have signs on them to indicate that, but you don't want to know about a restriction only when you reach there. To be prepared, we can create a Truck Profile and get a route accordingly. One of the most basic parameters of the truck profile is the height which can be specified in meters. var routingParameters = {\n    waypoint0:\"52.518543744,13.37906420\",\n    waypoint1:\"52.14837255,11.617700516\",\n    mode:\"fastest;truck;traffic:enabled\",\n    truckRestrictionPenalty:'strict',\n    height:3,\n    alternatives:3,\n    representation: \"display\",\n  }; Day 69/100 After specifying the height, you naturally would want to specify the length of the truck. This often includes specifying the number of trailers attached to the main body of the truck. For this we are going to use parameters trailersCount , axleCount and length . And like height, length is also specified in meters. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",\n    waypoint1:\"52.1370754,11.6326044\",\n    mode:\"fastest;truck;traffic:enabled\",\n    truckRestrictionPenalty:'strict',\n    trailersCount:1,\n    axleCount:4,\n    length:20,\n    alternatives:3,\n    representation: \"display\", \n  }; Day 70/100 .And finally for smaller roads, bridges, mountain roads, it is important to know the weight limit. Roads also have a limit of load per axle that a truck can carry. These are again parameters within the truck profile that you can easily set with limitedWeight and weightPerAxle where both the weights are specified in tonnes. var routingParameters = {\n    waypoint0:\"52.53086235,13.38475371\",\n    waypoint1:\"52.1370754,11.6326044\",\n    mode:\"fastest;truck;traffic:enabled\",\n    truckRestrictionPenalty:'strict',\n    trailersCount:1,\n    axleCount:4,\n    length:20,\n    limitedWeight:40,\n    weightPerAxle:10,\n    alternatives:3,\n    representation: \"display\",\n  }; That was week 14 of #100DaysOfCode With HERE. We are going to continue with routing for logistics in the coming weeks so keep watching this space. Keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . Meanwhile, read this blog post to know more about what a success #HackForBetterDays was. While you're at it, check out how to use HERE APIs easily with POSTMAN . Happy coding!", "date": "2020-06-12"},
{"website": "Here", "title": "Solutions: Day 86-90 #100DaysOfCode", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/solutions-day-86-90-100daysofcode", "abstract": "Welcome to week 18 of #100DaysOfCode with HERE. This week we are going to look at the Map Image API . This API generates static map images (literally PNGs, JPEGs, etc.) for use in contexts where interactive maps don’t work. Think sending a map with a route in a receipt email for a ride-sharing service or displaying a morning commute in an Alexa skill card. If you want to know more about 100DaysOfCode with HERE, take a look at this blog post which will tell you everything about it. If you have missed the solutions for days 0-85, you can find them in the previous blogs posts or on our YouTube channel . Let's begin! Let's begin! Day 86/100 Our task here was to generate a map image using the Map Image API. The map was supposed to be centered on Manhattan, with a size of 1280 by 720 pixels and in PNG format. Let’s check out the API Reference for Map Image API and take each of these requirements in turn. First, we need to choose the correct resource. In our case we want a simple map view, so we select the mapview resource: https://image.maps.ls.hereapi.com/mia/1.6/mapview To center the map image on Manhattan, we need to use the ctr (for center) parameter and set it to a latitude and longitude in Manhattan, e.g. 40.71451,-74.00602. To set the size of the map we use the w and h parameters (for width and height). We set w to 1280 and h to 720. Finally, to select the image format we use the f parameter (for format). The default value is 1 (for JPEG). We need to set it to 0 (for PNG). Our API call now looks like this. https://image.maps.ls.hereapi.com/mia/1.6/mapview\n?apiKey=YOUR_API_KEY\n&ctr=40.71451,-74.00602\n&w=1280\n&h=720\n&f=1 Our resulting map image looks like this. Day 87/100 The task for this day was to create a satellite image map of Easter Island. We also needed to change the map zoom, so that the entire island was visible in as much detail as possible. First, we need to move the map center by setting ctr to the center of Easter Island: -27.11789,-109.35955 To change the default map scheme type, we need to use the parameter t (for type) and set it to 1, which stand for “satellite.day”. (Feel free to experiment with some other map scheme types!) We also introduce the parameter z (for zoom) and need to experiment with its value, to find a good zoom level. 12 looks like a good choice. We can leave all other parameters the same. Our API call now looks like this. https://image.maps.ls.hereapi.com/mia/1.6/mapview\n?apiKey=YOUR_API_KEY\n&ctr=-27.11789,-109.35955\n&w=1280\n&h=720\n&f=0\n&t=1\n&z=12 Our resulting map image looks like this. Day 88/100 On day 88 we were asked to generate a map image of Disneyland and put a map marker on the castle. The map marker should be green and use the theme “pin”. Once again we need to change our ctr parameter, in this case to 33.8121,-117.91899. To add a marker, we use the poi (for point of interest) parameter. The value of this parameter is the location of the marker, so: 33.81278,-117.91899 To change the color of the marker, we use the poifc (for point of interest fill color) parameter and set it to green using a hex value as AARRGGBB (alpha, red, green, blue): FFFF0000 Finally, to change the marker’s theme, we use the poithm (for point of interest theme) parameter and set this to 1 for “pin”. There are many other poi related parameters, so feel free to experiment! We can leave all the other parameters the same. Our API call now looks like this. https://image.maps.ls.hereapi.com/mia/1.6/mapview\n?apiKey=YOUR_API_KEY\n&ctr=33.8121,-117.91899\n&w=1280\n&h=720\n&f=1\n&z=16\n&poi=33.81278,-117.91899\n&poifc=FF00FF00\n&poithm=1 Our resulting map image looks like this. Day 89/100 Here we were asked to create a map of the Bermuda Triangle. We had to draw the triangle on the map, with a transparent blue fill color and a white outline. To draw polygons on the map, we need to use a different resource called region , so our new endpoint looks like this: https://image.maps.ls.hereapi.com/mia/1.6/region To draw our triangle on the map we use the parameter a (for area) and set it to a list latitude,longitude pairs. These represent the vertices of the triangle: 32.29362,-64.78414,25.77481,-80.19773,18.46634,-66.10474 To set the fill color, we use the parameter fc (for fill color) and use the same color format as previously: 880000FF Similarly, for the line color we use the parameter lc (for line color): FFFFFFFF Finally, when drawing regions (or polygons), the map will automatically center and zoom so that everything we’ve drawn on the map is visible. We can therefore remove the ctr and z parameters. Our API call now looks like this. https://image.maps.ls.hereapi.com/mia/1.6/region\n?apiKey=YOUR_API_KEY\n&w=1280\n&h=720\n&f=1\n&a=32.29362,-64.78414,25.77481,-80.19773,18.46634,-66.10474\n&fc=880000FF\n&lc=FFFFFFFF Our resulting map image looks like this. Day 90/100 Our final task using the Map Image API was to draw a route across the island of Crete, from the town of Kissamos to the town of Sitia. We were also asked to switch the map labels to Greek. First, the Map Image API actually has a Routing feature built in, so there is no need for a separate call to the Routing API! To use this feature, we once again need to select a different resource, unsurprisingly called routing : https://image.maps.ls.hereapi.com/mia/1.6/routing To trigger the route calculation and display, all we need to do is provide two parameters, waypoint0 and waypoint1 and set them to appropriate Geo-coordinates, respectively 35.49393,23.65603 and 35.20657,26.10085. Note that the Map Image API will once again auto center and auto zoom for you! Finally, to set the map labels to Greek we use the parameter ml (for map label language) and use the three letter MARC code for Greek: gre Our API call now looks like this. https://image.maps.ls.hereapi.com/mia/1.6/routing\n?apiKey=YOUR_API_KEY\n&f=1\n&w=1280\n&h=720\n&waypoint0=35.49393,23.65603\n&waypoint1=35.20657,26.10085\n&ml Our resulting map image now looks like this. That’s all for our excursion into the Map Image API. Meanwhile, keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . Learn to improve ambiguous location data with this hands-on blog post by our 🥑 Saina P. See you next week and Happy Coding!", "date": "2020-07-03"},
{"website": "Here", "title": "HERE developer workshops powered by NASSCOM", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/here-developer-workshops-powered-by-nasscom", "abstract": "HERE developer evangelists are teaming up with the startup ecosystem NASSCOM to share their knowledge about location technology. Startups that join will learn more about how location data can help create solutions for problems as a result of the ongoing pandemic.In the next few months, we will be conducting a series of workshops for all the developers and entrepreneurs who are a part of the NASSCOM Industrial Partnership Program (NIPP). The workshops will be hands-on and will give developers a deep dive into the several APIs provided by HERE Technologies. We will cover several use-cases and explain the HERE map services that are the backbone of these apps. What are the workshops about? The first two workshops are called Learn How To Build an Online Delivery Ecosystem . Part 1 - by yours truly Shruti Kuber . In lieu of the current situation, more and more businesses are going online and making online delivery possible. In this workshop, participants will learn about: Different services under location technology that can be used to build delivery services for small corporations. Setting up a basic map using the HERE JS API as the customer facing app Using the Geocoding and Search API to order take out. Dates and Registration Register for Learn How To Build an Online Delivery Ecosystem - Part 1 . Date: 15 July 2020 Time: 3-4 pm IST Part 2 - by Vidhan Bhonsle . The online delivery market is growing at an astounding rate in almost all the sectors. This is an opportunity being recognized by Tech Entrepreneurs, resulting in a momentous rise of startups in the delivery ecosystem. Location is a key ingredient that defines the success of online delivery platform. In this Workshop you will learn: How to leverage location data to create a Delivery Agent application using Android as a platform and HERE as a location service platform. Dates and Registration Register for Learn How To Build an Online Delivery Ecosystem - Part 2 . Date: 30 July 2020 Time: 4-5 pm IST See you there!", "date": "2020-07-02"},
{"website": "Here", "title": "Improve Your Address Data with HERE Geocoding: Part 1", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/improve-your-address-data-with-here-geocoding-part-1", "abstract": "[Writer’s note: This is a blog series that’s all about modern data management. You’ll learn how to improve existing ambiguous or incomplete location data as well as new data you collect.] From collecting and understanding customer insights to developing a successful product strategy, data is a core pillar of a successful business. When it comes to data, the not-so-old adage applies: “garbage-in, garbage-out”.  After all, your decisions can only be as good as your data, so it is vital to ensure your data is high quality. It’s not always that you can improve your data quality without a compromise, but location data is a lucky exception. “You may only get one chance to make a first impression,” but you get two shots at improving your location data. Humans are responsible for inputting incomplete, or ambiguous location data, and sometimes humans make mistakes. So the first step to improving your data is to provide autosuggest (aka autocomplete) to help your users with choosing a valid address. With autosuggest, your users will also benefit from not having to type the entire address. Even after you have collected your data, you can retroactively improve it and we’ll talk more about how you can do that later in this series. What won’t cover in these blogs are getting noisy GPS data and filtering bot-generated data. Using Autosuggest to collect high-quality data If you are on a journey to collect better data, Autosuggest is a great tool to get started. You have most likely experienced using some form of Autosuggest when searching for a place or an address and see predictions appear as you type. HERE Autosuggest API is a web service that allows you to bring this experience to your users. It works by taking a string with over an HTTP call and it returns place suggestions in response to that request. Even if you have a custom form with separate input areas for state, zip code, and city and still use Autocomplete to help your user fill the form faster by automatically populating the form after your user chooses a suggested address. You can tailor the suggestions to return predictions that are closer to your user and you can even customize the language that the results appear in. Let’s look at a specific example. I chose Seattle as my central location here, so the results have a bias towards places in Seattle. The live demo for Autosuggest is also available on jsFiddle . This is what a call to Autosuggest API looks like: https://autosuggest.search.hereapi.com/v1/autosuggest?at=38.71014896078624,-98.60787954719035&limit=5&q=Pike&apiKey=YOUR_API_KEY Here's the API response. You can see that it returns the suggestions along with the highlight information, that allows you to display the character match of the query and the prediction by adding custom styles such as underlining, or highlighting the string match. {\n    \"items\": [\n        {\n            \"title\": \"E Pike Dr, Sylvan Grove, KS 67481, United States\",\n            \"id\": \"here:af:street:n02pLKALuDwKAsduJ7nMPB\",\n            \"resultType\": \"street\",\n            \"address\": {\n                \"label\": \"E Pike Dr, Sylvan Grove, KS 67481, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Kansas\",\n                \"county\": \"Lincoln\",\n                \"city\": \"Sylvan Grove\",\n                \"street\": \"E Pike Dr\",\n                \"postalCode\": \"67481\"\n            },\n            \"position\": {\n                \"lat\": 39.08835,\n                \"lng\": -98.38702\n            },\n            \"distance\": 46193,\n            \"mapView\": {\n                \"west\": -98.48442,\n                \"south\": 39.08824,\n                \"east\": -98.28957,\n                \"north\": 39.09129\n            },\n            \"highlights\": {\n                \"title\": [\n                    {\n                        \"start\": 2,\n                        \"end\": 6\n                    }\n                ],\n                \"address\": {\n                    \"label\": [\n                        {\n                            \"start\": 2,\n                            \"end\": 6\n                        }\n                    ],\n                    \"street\": [\n                        {\n                            \"start\": 2,\n                            \"end\": 6\n                        }\n                    ]\n                }\n            }\n        },\n        ...additional results ...\n} Now let’s try setting the language to German for fun, here's our API call: https://autosuggest.search.hereapi.com/v1/autosuggest?at=38.71014896078624,-98.60787954719035&limit=3&q=Pike&lang=de&apiKey=YOUR_API_KEY And the results are: {\n    \"items\": [\n        {\n            \"title\": \"Pike Place Markt\",\n            \"id\": \"here:pds:place:840c23nb-80862ee36c5c4df3b946a71a6606e447\",\n            \"resultType\": \"place\",\n            \"address\": {\n                \"label\": \"Pike Place Markt, 85 Pike St, Seattle, WA 98101-2024, Vereinigte Staaten\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"Vereinigte Staaten\",\n                \"state\": \"Washington\",\n                \"county\": \"King\",\n                \"city\": \"Seattle\",\n                \"district\": \"Pike Market\",\n                \"street\": \"Pike St\",\n                \"postalCode\": \"98101-2024\",\n                \"houseNumber\": \"85\"\n            },\n            \"position\": {\n                \"lat\": 47.60832,\n                \"lng\": -122.34081\n            },\n            \"access\": [\n                {\n                    \"lat\": 47.6087,\n                    \"lng\": -122.34055\n                }\n            ],\n            \"distance\": 5960,\n            \"categories\": [\n                {\n                    \"id\": \"300-3000-0023\",\n                    \"name\": \"Touristenattraktion\",\n                    \"primary\": true\n                },\n                {\n                    \"id\": \"300-3000-0000\",\n                    \"name\": \"Sehenswürdigkeit\"\n                },\n                {\n                    \"id\": \"500-5000-0000\",\n                    \"name\": \"Hotel oder Motel\"\n                },\n                {\n                    \"id\": \"550-5510-0204\",\n                    \"name\": \"Gartenanlage\"\n                },\n                {\n                    \"id\": \"600-6300-0067\",\n                    \"name\": \"Delikatessengeschäft\"\n                },\n                {\n                    \"id\": \"600-6900-0000\",\n                    \"name\": \"Konsumgüter\"\n                },\n                {\n                    \"id\": \"600-6900-0096\",\n                    \"name\": \"Fachgeschäft\"\n                },\n                {\n                    \"id\": \"600-6900-0247\",\n                    \"name\": \"Markt\"\n                },\n                {\n                    \"id\": \"800-8200-0295\",\n                    \"name\": \"Einrichtung für Bildung/Fortbildung\"\n                }\n            ],\n            \"references\": [\n                {\n                    \"supplier\": {\n                        \"id\": \"core\"\n                    },\n                    \"id\": \"1212101839\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"core\"\n                    },\n                    \"id\": \"17202733\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"core\"\n                    },\n                    \"id\": \"998713833\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"tripadvisor\"\n                    },\n                    \"id\": \"103584\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"tripadvisor\"\n                    },\n                    \"id\": \"16932579\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"44Hk9LbRS4WDgZ2fwivvpA\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"5bVJayfycRZYVOajtR2pQA\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"5pU9Ahv7ow4XRyhjeE754A\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"BJo5lD9IaZYKgoxGimmaSw\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"JsvxX0ja8GS5tJx13C8JBA\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"egwmnmyGZ7clzCkRS2uZTg\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"ktQ2J90Mk3aUvBb5P5a6wQ\"\n                },\n                {\n                    \"supplier\": {\n                        \"id\": \"yelp\"\n                    },\n                    \"id\": \"s-9BYsAd4fl06Yq9u_OO7Q\"\n                }\n            ],\n            \"highlights\": {\n                \"title\": [\n                    {\n                        \"start\": 0,\n                        \"end\": 4\n                    }\n                ],\n                \"address\": {\n                    \"label\": [\n                        {\n                            \"start\": 0,\n                            \"end\": 4\n                        }\n                    ]\n                }\n            }\n        },\n        ...additional results ... Let’s revisit the core lessons from this blog: we covered how to use Autosuggest to help customers input better data in order to improve the overall address quality in your system. And as a side benefit, your customers will be able to save some time by typing less. Next time, we’ll be covering standardizing location data so stay tuned!", "date": "2020-07-01"},
{"website": "Here", "title": "A Tour of the Developer Usage Dashboard", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/tour-of-developer-usage-dashboard", "abstract": "Once a developer is up and running using HERE location services, the question may come up - How much of my plan have I used so far? For most new developers, our Freemium plan is what they start with. This post will take you on a tour of the developer usage dashboard, which provides an easy way to track the usage of a project associated with your developer account. How to access the developer usage dashboard To access the developer usage dashboard, you will need to log in and select the project associated with the account. Once in the project details page, look at the panel on the left side. First, it will identify what plan is being used (hovering over info icon will display what is allowed), display a summary of usage, and finally provide access to more details by clicking on \"View Usage Details\" as seen here: After clicking the link, you will see a screen similar to the one shown here: Now let's examine how to read these details. Viewing transaction or request data By default, the data first shown will be the number transactions for the current billing period. To toggle the data to show the total number of requests, just select what you want from the upper left corner of the report panel. The report is interactive! Just hover over the data you are interested in to get more details. You can also download a CSV of the usage data by selecting the menu item in the upper right hand corner as shown above circled in red. If you are using HERE Studio/Hub , you will also see that available as seen here: Filtering usage data At the top of the dashboard there is a panel that allows you to filter the data as shown here: On the left side, you can toggle which apps you want included in the usage report. In the middle, the environments filter is provided for legacy users of the platform. The right side allows you to select the time frame you want to see the usage from. If you would like to see this in action, please watch our brief video: Summary In this post we took a brief tour of the developer usage dashboard. We covered how to access it, how to understand and download the report data, and how to filter to with your own custom criteria.", "date": "2020-07-03"},
{"website": "Here", "title": "Solutions: Day 91-95 #100DaysOfCode", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/solutions-day-91-95-100daysofcode", "abstract": "Welcome to week 19 of #100DaysOfCode with HERE. This week we are going to look at the Transit API. This API is similar to the Routing API, which we have used in previous weeks, except that it is focused on generating routes using public transport. It also comes with some neat additional features, such as the ability to search for public transit stations (think bus stops and subway stations). You can even get the departure boards of transit stations, including live information on delays! If you want to know more about 100DaysOfCode with HERE, take a look at this blog post which will tell you everything about it. If you have missed the solutions for days 0-90, you can find them in the previous blogs posts or on our YouTube channel . Let's begin! Day 91 Our task for this day was to generate and display a public transit route between the Singapore Zoo and the Singapore Merlion. First, we should probably take a look at the API Reference for the Transit API . As we can see, the Transit API uses the same parameters for the origin and destination of the route as the Routing API. It also uses a similar return parameter to let us determine which information we want about the route. Since we want to draw it on a map, we should at least request a polyline to be returned. Our Transit API call now looks like this: https://transit.router.hereapi.com/v8/routes\n?apiKey=YOUR_API_KEY\n&origin=1.40464,103.79009\n&destination=1.25414,103.81883\n&return=polyline To draw the returned route on a map, we can use the HERE JavaScript API and the Fetch API, as we’ve done in previous weeks. Note that as with the Routing API we are getting a list of routes, which each contains a list of sections. When using the Routing API, the sections were the part of the route in between the individual waypoints. When using the Transit API, each section represents a different mode of transport. For example, you might start on foot and walk to a bus station (section 1), then take the bus for a while (section 2), once again walk from the bus station to a subway station (section 3), and so on. To draw the complete route on the map, we thus need to iterate through all sections in the route. function getTransitRoute() {\n\n    let url = \"https://transit.router.hereapi.com/v8/routes\" +\n        \"?apiKey=YOUR_API_KEY\" +\n        \"&origin=1.40464,103.79009\" +\n        \"&destination=1.28675,103.85441\" +\n        \"&return=polyline\";\n\n    fetch(url)\n        .then(response => response.json())\n        .then(response => {\n\n            let routeGroup = new H.map.Group();\n\n            response.routes[0].sections.forEach(section => {\n\n                let lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);\n                var polyline = new H.map.Polyline(lineString, { style: { lineWidth: 10 } });\n                routeGroup.addObject(polyline);\n\n            });\n\n            map.addObject(routeGroup);\n            map.getViewModel().setLookAtData({\n                bounds: routeGroup.getBoundingBox()\n            });\n\n        }, error => {\n            console.log.error(error);\n        });\n\n} The resulting map should look something like this. Day 92 On this day we were asked to create a public transit route once again (between Alexanderplatz and Checkpoint Charlie in Berlin), but to ensure that we arrive before at 9am in the morning. We also needed to request at least one alternative route. This means we need to use two additional parameters. arrivalTime : This parameter lets you define an arrival time for your route. Oftentimes when we have an appointment, the most important information any type of mobility API can provide us with, is when we must leave to arrive on time. alternatives : This parameter lets you request alternative routes, that is you can ask for more than one option to get from your origin to your destination. For example, if we set this to 3 , we will get up to four different routes returned. Assuming that today is July 8th, 2020, our API call now looks like this: https://transit.router.hereapi.com/v8/routes\n?apiKey=YOUR_API_KEY\n&origin=52.5214,13.41555\n&destination=52.50715,13.39061\n&return=polyline\n&arrivalTime=2020-07-09T09:00:00\n&alternatives=1 Once again, we use the JavaScript API to draw our two routes on the map. Note that since we now have multiple routes we need to iterate over the routes as well as the sections. function getTransitRoute() {\n\n    let url = \"https://transit.router.hereapi.com/v8/routes\" +\n        \"?apiKey=YOUR_API_KEY\" +\n        \"&origin=52.5214,13.41555\" +\n        \"&destination=52.50715,13.39061\" +\n        \"&return=polyline\" +\n        \"&arrivalTime=2020-07-08T09:00:00\" +\n        \"&alternatives=1\";\n\n    fetch(url)\n        .then(response => response.json())\n        .then(response => {\n\n            let routeGroup = new H.map.Group();\n\n            response.routes.forEach(route => {\n                route.sections.forEach(section => {\n\n                    let lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);\n                    var polyline = new H.map.Polyline(lineString, { style: { lineWidth: 10 } });\n                    routeGroup.addObject(polyline);\n\n                });\n            });\n\n            map.addObject(routeGroup);\n            map.getViewModel().setLookAtData({\n                bounds: routeGroup.getBoundingBox()\n            });\n\n        }, error => {\n            console.log.error(error);\n        });\n} Day 93 For today’s transit route (between the Empire State Building and the American Museum of Natural History in New York) we were asked to avoid the subway and display fare prices for the rides. To avoid the subway, we need to start using the modes parameter. Whereas the similar mode parameter in the Routing API lets us define a single mode of transport to be used, the modes parameter lets us define exactly which types of transit modes we want to be considered for our route. For example, if we only wanted the use the bus, ferry, and subway we could set modes to \" bus, ferry, subway ”. By default, all modes are considered. We can then use a minus sign in front of a mode to exclude it from consideration. This is what we are going to do with the subway mode. To include fare prices in the response (where supported), we can simply add the value fares to our return parameter. Our API call now looks like this: https://transit.router.hereapi.com/v8/routes\n?apiKey=YOUR_API_KEY\n&origin=40.74843,-73.98567\n&destination=40.78193,-73.97239\n&modes=-subway\n&changes=2\n&return=polyline,fares When drawn on a map, our route looks like this. (Note that depending on the time of day and any possible delays or cancellations, your routes for all the tasks in this week may of course look somewhat different.) If we look in the response of our API call, we can also see that fare price information is included for every relevant section of the route. \"fares\": [\n    {\n        \"id\": \"fare-R00215d-C0-S1-T0-F0\",\n        \"name\": \"MetroCard single ride\",\n        \"price\": {\n            \"type\": \"value\",\n            \"currency\": \"USD\",\n            \"value\": 2.75\n        },\n        \"reason\": \"ride\"\n    }\n] Day 94 Switching gears (or tracks as it were), today’s task was not to find a public transit route, but a list of public transit stations (near the Tower of London). If we once again look at the Transit API Reference , we can see that there is a dedicated “Station Search “ end point we can use for this. For our task, we can provide a location to the in parameter and we will get a list of stations in return. Note that the response provides a unique station id for each transit station. Remember this, as it will be useful for day 95. You could also use the modesInPlace parameter to search only for stations of a certain type (e.g., subway) or exclude certain types of station. It works exactly like the modes parameter from day 93! Here’s our API call and the corresponding response: https://transit.hereapi.com/v8/stations\n?apiKey=YOUR_API_KEY\n&in=51.50808,-0.07587 {\n    \"stations\": [\n        {\n            \"place\": {\n                \"name\": \"The Tower of London (Stop TA)\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": 51.509621,\n                    \"lng\": -0.075411\n                },\n                \"id\": \"420321352\"\n            }\n        },\n        {\n            \"place\": {\n                \"name\": \"The Tower of London (Stop TB)\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": 51.509689,\n                    \"lng\": -0.075883\n                },\n                \"id\": \"420321351\"\n            }\n        },\n        {\n            \"place\": {\n                \"name\": \"Tower Hill\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": 51.509715,\n                    \"lng\": -0.077015\n                },\n                \"id\": \"420326491\"\n            }\n        },\n        {\n            \"place\": {\n                \"name\": \"Tower Pier\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": 51.507339,\n                    \"lng\": -0.078937\n                },\n                \"id\": \"420325926\"\n            }\n        },\n        {\n            \"place\": {\n                \"name\": \"Tower Gateway (Stop TC)\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": 51.510281,\n                    \"lng\": -0.075051\n                },\n                \"id\": \"420308069\"\n            }\n        }\n    ]\n} We can also use this information to draw some markers on our map. Our code for this is as follows. function getTransitRoute() {\n\n    let url = \"https://transit.router.hereapi.com/v8/stations\" +\n        \"?apiKey=YOUR_API_KEY\" +\n        \"&in=51.50808,-0.07587\";\n\n    fetch(url)\n        .then(response => response.json())\n        .then(response => {\n\n            console.log(response);\n\n            let markerGroup = new H.map.Group();\n\n            response.stations.forEach(station => {\n                let marker = new H.map.Marker(station.place.location);\n                markerGroup.addObject(marker);\n            });\n\n            map.addObject(markerGroup);\n            map.getViewModel().setLookAtData({\n                bounds: markerGroup.getBoundingBox()\n            });\n\n        }, error => {\n            console.log.error(error);\n        });\n\n} Day 95 We’ve almost made it! Less than a week to go in #100DaysOfCode and this is also the last task using the Transit API. Let’s get to it! Today we want to display the departure board for a very specific tram station (the Cavill Avenue Station in Cold Coast, Australia to be precise). Once again, the Transit API has a dedicated endpoint for this, called “ Next Departures ”. There are two ways we can tell the Next Departures endpoint, which station we want to see departures for. First, we can simply provide a geo-coordinate. The API when then pick the closest station. However, this can be imprecise, especially when there are multiple transit stations close to each other. This is why I told you to remember the station id provided by the Station Search endpoint! This id uniquely identifies a given station. Let’s use our Station Search endpoint again, to get the station id of Cavill Avenue station. In addition to the in parameter, we will also use the name parameter to further narrow down our search. https://transit.hereapi.com/v8/stations\n?apiKey={{apiKey}}\n&in=-28.00185,153.42859\n&name=cavill From the response we can see that the station id we are looking for is 425315170 . Let’s plug this id into the Next Departures endpoint, using the ids parameter. We were also asked to just provide the departures in the next 30 minutes. For this we use the timespan parameter. Our API call and response now look like this: https://transit.hereapi.com/v8/departures\n?apiKey=YOUR_API_KEY\n&ids=425315170\n×pan=30 {\n    \"boards\": [\n        {\n            \"place\": {\n                \"name\": \"Cavill Avenue station\",\n                \"type\": \"station\",\n                \"location\": {\n                    \"lat\": -28.001711,\n                    \"lng\": 153.428413\n                },\n                \"id\": \"425315170\",\n                \"platform\": \"2\"\n            },\n            \"departures\": [\n                {\n                    \"time\": \"2020-07-08T17:18:00+10:00\",\n                    \"transport\": {\n                        \"mode\": \"lightRail\",\n                        \"name\": \"GLKS\",\n                        \"category\": \"Tram\",\n                        \"color\": \"#FFD400\",\n                        \"textColor\": \"#000000\",\n                        \"headsign\": \"Broadbeach South\"\n                    },\n                    \"agency\": {\n                        \"id\": \"fUe61100\",\n                        \"name\": \"TransLink\",\n                        \"website\": \"http://translink.com.au\"\n                    }\n                },\n                {\n                    \"time\": \"2020-07-08T17:26:00+10:00\",\n                    \"delay\": 0,\n                    \"transport\": {\n                        \"mode\": \"lightRail\",\n                        \"name\": \"GLKS\",\n                        \"category\": \"Tram\",\n                        \"color\": \"#FFD400\",\n                        \"textColor\": \"#000000\",\n                        \"headsign\": \"Broadbeach South\"\n                    },\n                    \"agency\": {\n                        \"id\": \"fUe61100\",\n                        \"name\": \"TransLink\",\n                        \"website\": \"http://translink.com.au\"\n                    }\n                },\n                {\n                    \"time\": \"2020-07-08T17:33:00+10:00\",\n                    \"transport\": {\n                        \"mode\": \"lightRail\",\n                        \"name\": \"GLKS\",\n                        \"category\": \"Tram\",\n                        \"color\": \"#FFD400\",\n                        \"textColor\": \"#000000\",\n                        \"headsign\": \"Broadbeach South\"\n                    },\n                    \"agency\": {\n                        \"id\": \"fUe61100\",\n                        \"name\": \"TransLink\",\n                        \"website\": \"http://translink.com.au\"\n                    }\n                },\n                {\n                    \"time\": \"2020-07-08T17:41:00+10:00\",\n                    \"delay\": 0,\n                    \"transport\": {\n                        \"mode\": \"lightRail\",\n                        \"name\": \"GLKS\",\n                        \"category\": \"Tram\",\n                        \"color\": \"#FFD400\",\n                        \"textColor\": \"#000000\",\n                        \"headsign\": \"Broadbeach South\"\n                    },\n                    \"agency\": {\n                        \"id\": \"fUe61100\",\n                        \"name\": \"TransLink\",\n                        \"website\": \"http://translink.com.au\"\n                    }\n                }\n            ]\n        }\n    ]\n} Note that depending on the tram schedule, there may not be any departures in the next 30 minutes! Feel free to play around with the timespan and time parameters until you get a result. That’s all for our excursion into the Transit API. Meanwhile, keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . Also, why not let HERE 🥑 Michael Palermo take you on a tour of our developer usage dashboard and see how many API calls you’ve made in the last 95 days! Only five days to go! Happy Coding!", "date": "2020-07-08"},
{"website": "Here", "title": "HERE Studio introduces Hexbins and Geocoding", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-studio-introduces-hexbins-and-geocoding", "abstract": "This week we've introduced a pretty big update to HERE Studio . Along with bug fixes and performance updates we introduced two really cool new features. I'll walk you through them below and show some examples, but remember that you can sign up now yourself and play with Studio on our generous free tier - no credit card required! Let's get started by talking about hexbins. Now - don't be afraid if you've never heard the term \"hexbin\" before. I certainly had not. At a high level, a hexbin is a way to represent multiple values into a more summarized form, shaped in the form of a hexbin. Ok, that probably didn't help much, but I think a picture may help a lot more. Consider this map of national parks in the United States. There's quite a few points there, and while it isn't too much, it may be difficult to get an idea of where parks are distributed at a more high level view. Now consider the same view with hexbins enabled: In the map above, the data has been grouped together into hexs where the darker the color means more features, or in our case, more parks. I really didn't \"get\" the concentration in DC before enabling this feature. As you zoom in, the hexbin display will intelligently redraw to represent information currently in view. Here's a closer look at the DC area. Hexbins can be enabled in the project editor and give you control over both the color range, numeric labels, and more: Hexbins are a \"Add On\" feature so if you've not upgraded yet, you'll be prompted to on working with them in the editor. Updating to \"Add On\" gives you other cool features as well so if you haven't yet checked it out, read our blog post on what \"Add On\" offers and why you should consider upgrading. The next big update is more \"behind the scenes\" but just as useful - geocoding. Geocoding is the act of translating a text based address, like \"New Orleans, LA\", to a precise location with a latitude and longitude. We've got a nice REST-based API to do this for developers, but what about map makers using Studio? Now you've got a solution. Imagine a data set that includes address in text form, like this simple CSV file. Name,Address\nfii,\"Lafayette, LA\"\ngoo,\"New Orleans, LA\"\nzoo,\"Baton Rouge, LA\" Previously this wouldn't work with Studio because it needed a precise address. Now though Studio will recognize that the location isn't defined and prompt you: If you say yes, a new screen will pop up asking you for help figuring out how to geocode your data: In my case I know that the Address column has my addresses, so I can select it. As soon as I do, Studio shows me a sample of one of the values and let's my continue: Hit Apply and you get one more confirmation before uploading: And just to confirm that it worked, here's a map with my three rows of data properly geocoded: Right now this is limited to CSV files but try it yourself and see. One of the things I've learned as I become more familiar with maps and mapping technology is that data cleanup/preparation can be a chore. This will go a long way to helping! That's it for this update. Don't forget there's a \"Support\" link on the Studio site that leads to a feedback form where you can tell us what you would like to see in the future. Please let us know what would make life easier for you! (Well, in terms of making maps. ;)", "date": "2020-07-10"},
{"website": "Here", "title": "SafeQueue Takes Lines Online for Social Distancing", "author": ["David Chura"], "link": "https://developer.here.com/blog/safequeue-takes-lines-online-for-social-distancing", "abstract": "I wasn’t even planning on entering IBM’s Call for Code contest until Lady Gaga asked me to. Not that she asked me, personally, but something about seeing her video about the contest on my local news station pushed the idea for SafeQueue from a “someone should do something about this” kind of problem into a “ I should do something about this” kind of problem. That problem were the lines outside of restaurants and other establishments that were doing their best to stay open in spite of laws limiting their capacity in response to COVID-19. The pandemic had already affected me in other ways - forcing me to put the launch of an entirely separate company on hold - and I felt that Call for Code would provide an opportunity for me to stay productive in the meantime. I knew I could come up with a technology-based solution for these lines, there was an urgent need for it, and I had the time to work on it. What SafeQueue actually does is quite simple. If you’re within 1000 feet of a business, as determined by GPS, the app invites you to join a virtual line called a SafeQueue. There’s no need to call ahead to make a reservation, sign-up, or volunteer personal information. All that’s needed is proximity - and it allows people to “line up” for goods or services while maintaining safe social distancing. You can see how it works for yourself in the  web-app version of Safe Queue – just go to: www.safequeueweb.com > select “MANAGER” > select “Add” in the upper-right (you’ll have to agree to share your GPS location), and you’ll see an address field that is filled in from the reverse geocode result. The result appears really fast—I don’t think I’ve ever seen a lag in filling in the result! There are times when it gives only a partial result, but that is expected – that is why I give the option to edit the address. It’s not too fancy, but here is the javascript function from our web-app that does this: (the callback fills in the form) export const addressOfLocation = (loc, callback) => {\n\n  var hereurl = \"https://reverse.geocoder.ls.hereapi.com/6.2/reversegeocode.json?apiKey=xxxxxxxxxxxxxxxxxxxxxxxxx&mode=retrieveAddresses&prox=\";\n  var finalurl = `${hereurl}${loc}`;\n\n  fetch(finalurl)\n    .then(response => response.json())\n    .then((jsonData) => {\n      // jsonData is parsed json object received from url\n      if (jsonData === undefined) {\n        callback('');\n        return;\n      }\n\n      var o = jsonData.Response.View[0].Result[0].Location.Address;\n      var number = (o.HouseNumber == null) ? '' : o.HouseNumber;\n      var street = (o.Street == null) ? '' : o.Street;\n      var city = (o.City == null) ? '' : o.City;\n      var state = (o.State == null) ? '' : o.State;\n      var zip = (o.PostalCode == null) ? '' : o.PostalCode;\n\n      callback(number + \" \" + street + \"\\n\" + city + \", \" + state + ' ' + zip);\n    })\n    .catch((error) => {\n      // handle your errors here\n      console.log(finalurl);\n      console.error(error)\n      callback(''); // no known address\n    })\n} SafeQueue took about three weeks to develop in prototype, and another three weeks to develop to production quality for submission to Apple and Google App stores. And I developed a web-app version in another two weeks, so that anybody can use SafeQueue on essentially any device. That fast production schedule was only possible because of HERE. Obviously, GPS location is critical for the app’s function, and HERE’s technology made integrating GPS locations for reverse-geolocation incredibly simple. It also makes it simple for businesses to start their SafeQueues by automatically determining a business’ GPS location and address for the business owner. SafeQueue’s production wasn’t the only fast part about it though! I received an email very shortly after the Call for Code deadline with a request for more information about the app and a call with IBM staff. After the call, I was informed via email that I was in the top three, and would be interviewed by Bob Lord and Chelsea Clinton at IBM Think 2020! And then I was interviewed by Doug Kolk of KTLA - the same local news station that I saw the Lady Gaga video on! While I originally just imagined SafeQueue as a response to the pandemic, the backing of IBM helped me envision uses for it even after things “return to normal.” I envision adding a more map-centric user experience to help customers find businesses, and help businesses know exactly where their customers are, and their place in the virtual line. Furthermore, mapping will help businesses that operate without single, fixed-addresses - like ski resorts - better operate and keep track of their guests. SafeQueue Takes Lines Online for Social Distancing But for now, SafeQueue is still in Beta with early adopter businesses - many of whom discovered us at IBM Think 2020 . All I can hope right now is that the solution proves to have more staying power than the problem it was built to solve.", "date": "2020-07-06"},
{"website": "Here", "title": "Solutions: Day 81-85 #100DaysOfCode", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/solutions-day-81-85-100daysofcode", "abstract": "Welcome to week 17 of #100DaysOfCode with HERE. This week we are going to look at a few powerful endpoints of the Fleet Telematics API If you have no idea what I'm talking about, take a look at this blog post which will tell you everything about #100DaysOfCode. If you have missed the solutions for days 0-80, you can find them in the previous blogs posts or on our YouTube channel . Let's begin! Day 81/100 Nicely tucked into the Fleet Telematics API , is the option for getting a route for Electronic Vehicles (EVs). Now, how is a route for an EV any different than a route for a diesel guzzling car? 🙄 Well, for one, the environmental zone restrictions on vehicles depending on the emission type is different. Secondly, you would want to get a route where you can find plenty of electric charging stations. With this end-point, we will go a little deeper. If you specify the consumption details of your EV and give the battery parameters like initial charge, max charge, etc. the Fleet Telematics API gives you a route with suggestions on where you can stop to charge your EV. That's quite neat eh? So, how do we do it. Two parameters: customConsumptionDetails and batteryParameters . The customConsumptionDetails parameter is similar to the one we used for our diesel truck back on day 77 of #100DaysOfCode. Although here you need to write down the specifics of the charge consumed at different speed levels. This is again in cost/Km where the cost is in the currency you specify. With batteryParameters , you can write down the current charge of the vehicle , in kWh at the beginning of the journey, battery capacity,charge level at which you want to recharge and the maximum charge you want the battery to be at. This is followed by the charging curve which answers the question - How much power(kW) does your battery spend when it is at a charge level X ? let url = `https://fleet.ls.hereapi.com/2/calculateroute.json`+\n    `?apikey=${window.hereCreds.JS_KEY}`+\n    `&waypoint0=52.53086235,13.38475371`+//Berlin\n    `&waypoint1=53.13256,17.98909`+// Warsaw\n    `&mode=fastest;car;traffic:disabled`+\n    `&departure=2020-06-22T15:01:41`+\n    `&customConsumptionDetails=speed,0,0.102,10,0.084,30,0.066,50,0.06,70,0.066,100,0.072,120,0.084,140,0.108;ascent,0.4;descent,0.1`+\n    `&batteryParameters=initialCharge:15;maxCharge:33;minChargeAtStop:7;chargingStopDepartureCharge:27;chargingCurve:0,45,20,48,23,50,27,40,28,27,30,15,32,5,33,1`+\n    `&routeAttributes=shape`+ \n    `&linkAttributes=-shape`;\n\n\n  fetch(url)\n  .then(response => response.json())\n  .then(response => {\n    console.log(response);\n  }, error =>{\n      console.error(error);\n  }); The waypoint object in the route response comes with a few extra objects with this routing type. Here the object type gives you the type of the waypoint, whether it is a normal stop over or a charging stop over. The object power under the object chargingStationInfo gives the charge of the battery when it reached that point. \"waypoint\": [\n          {\n              \"linkId\": \"+563894215\",\n              \"mappedPosition\": {\n                  \"latitude\": 48.76963,\n                  \"longitude\": 9.1747\n              },\n              \"originalPosition\": {\n                  \"latitude\": 48.769606,\n                  \"longitude\": 9.174678\n              },\n              \"spot\": 0.0,\n              \"sideOfStreet\": \"right\",\n              \"seqNrOnRoute\": 0,\n              \"globalWayPointSeqNr\": 0,\n              \"type\": \"stopOver\",\n              \"mappedRoadName\": \"Hauptstätter Straße\",\n              \"shapeIndex\": 0\n          },\n          {\n              \"linkId\": \"-749456569\",\n              \"mappedPosition\": {\n                  \"latitude\": 49.23369,\n                  \"longitude\": 9.35457\n              },\n              \"originalPosition\": {\n                  \"latitude\": 49.23369,\n                  \"longitude\": 9.35462\n              },\n              \"spot\": 0.33507,\n              \"sideOfStreet\": \"left\",\n              \"seqNrOnRoute\": 1,\n              \"waypointType\": \"chargingStopOver\",\n              \"type\": \"stopOver\",\n              \"mappedRoadName\": \"Wilhelm-Maybach-Straße\",\n              \"chargingStationInfo\": {\n                  \"power\": 22.08\n              },\n              \"shapeIndex\": 1686\n          }, Day 82/100 A classic travelling salesperson problem is what many fleet management companies or even individual drivers face. I have 10 packets to deliver to 10 different locations in the city, In what sequence do I deliver them to obtain efficiency? For this very problem, the Waypoint Sequence API is the perfect and easy solution. As the name suggests, you can give it a starting point and a number of destinations. The API will give you the optimal sequence of the destinations. You can specify if you want to optimize the sequence for time or distance with the parameter improveFor . The sequence gives you the sequence number of the destination in the route. The Waypoint Sequence has another endpoint called findpickups which gives you the sequence of picking up passengers in a ride-pooling situation. let url = `https://wse.ls.hereapi.com/2/findsequence.json`+\n    `?apiKey=${window.hereCreds.JS_KEY}`+\n    `&start=52.53086235,13.38475371`+//Berlin\n    `&destination0=52.457213,13.3806209`+// Warsaw\n    `&destination1=52.518229,13.315388`+\n    `&destination2=52.54830288,13.3634539`+\n    `&mode=fastest;car;traffic:disabled`+\n    `&improveFor=time`; \n\n    fetch(url)\n    .then(response => response.json())\n    .then(response => {\n      console.log(response);\n    }, error =>{\n        console.error(error);\n    }); Day 83/100 For day 83 and 84, we are going to explore custom routes. Certain roads, bridges, or private roads do not permit certain types of vehicles. The routing engine will not route through that road geometry. In some situations, you want a route through those restricted roads assuming you have taken appropriate permissions. It could also be the case that your delivery vehicle needs to come further into the building/ warehouse on a private road. For day 83, we are going to upload a private route in the custom route layer . This layer is connected to your API KEY . So, only the apps using this API Key can use this route. You can add this route by adding multiple points along the route. You can store multiple route like this given that they all have unique names. The names of these layers should start with the word OVERLAY . Along with the points in the route, you need to include the name of the layer in which this route will be included as well as the data associated with it. You can get more details about the format here . With this Custom Routes API, you can also get rid of restrictions on existing roads as well as add restrictions on roads. let url = `https://fleet.ls.hereapi.com/2/overlays/upload.json`+\n    `?apikey=${window.hereCreds.JS_KEY}`+\n    `&map_name=OVERLAYIKEA`+\n    `&overlay_spec=[{\n      \"op\":\"create\",\n      \"shape\":[\n        [52.46959,13.36809],\n          [52.46959,13.36801],\n          [52.46960,13.36792],\n          [52.46960,13.36781],\n          [52.46960,13.36771],\n          [52.46961,13.36761],\n          [52.46961,13.36751],\n          [52.46962,13.36741],\n          [52.46962,13.36732]],\n      \"data\":{\"NAMES\":\"IKEA loading Road\",\"TRAVEL_DIRECTION\":\"B\"}\n    }]`+\n    `&storage=readonly`;\n\n  fetch(url)\n  .then(response => response.json())\n  .then(response => {\n    console.log(response);\n  }, error =>{\n      console.error(error);\n  }); Day 84/100 With day 84, we will calculate a route which includes the custom route from day 83. The call is pretty similar to a regular routing call . What is important is the name of the added layer. This name should be the same as the layer you updated on your API Key. By including this, you will now get a route which includes the added layer. You can take a look at this blog post for another example with custom routes. let url = `https://fleet.ls.hereapi.com/2/calculateroute.json`+\n    `?apikey=${window.hereCreds.JS_KEY}`+\n    `&overlays=OVERLAYIKEA`+// your overlay name\n    `&mode=fastest;truck`+\n    `&waypoint0=52.45710,13.38058`+\n    `&waypoint1=52.46961,13.36730`+\n    `&routeAttributes=shape`;\n\n  fetch(url)\n  .then(response => response.json())\n  .then(response => {\n    console.log(response);\n  }, error =>{\n      console.error(error);\n  }); Day 85/100 With day 85, we are going to get a sneak peak into the massive Advanced Data Sets . This gem is, as the name suggests, a huge dataset of advanced map layers that stores information from census data, to building geometries, to POIs to sign posts etc. in the map layer. There are many ways to use this data depending on what your application requires. One of the ways is to request data along a route/ corridor . For day 85, we are going to pass the route from day 81, and get all EV Charging Stations along this route. The corridor here is the route shape while the radius is the distance from the route where the EV charging stations can be. The layer Id specifies the data layer you want to search through. In this case, the layer name is EVCHARGING_POI . The key_attributes here states what properties of this data you want. To know about more layers, and their properties, the Advanced Data Sets lists all data layers, its properties and attributes in the Guide section. For this example, I am using just a part of the route to use the GET call. For longer routes, you need to you the POST call. function getEVChargingRoute(){\n    let url = `https://fleet.ls.hereapi.com/2/calculateroute.json`+\n    `?apikey=${window.hereCreds.JS_KEY}`+\n    `&waypoint0=52.53086235,13.38475371`+//HERE Berlin\n    `&waypoint1=52.45709,13.38059`+//my Location\n    `&mode=fastest;car;traffic:disabled`+ \n    `&routeAttributes=shape`;\n\n    fetch(url)\n    .then(response => response.json())\n    .then(response => {\n    ...\n    // pass the route shape of the route from day 81 \n    let route = response.response.route[0];\n    let routeShape = route.shape;\n    searchCorridor(routeShape);\n    ... \n    }\n\n  }\n\n  function searchCorridor(corridor){\n    let searchUrl = `https://fleet.ls.hereapi.com/1//search/corridor.json`+\n      `?apiKey=${window.hereCreds.JS_KEY}`+\n      `&corridor=${corridor}`+//\n      `&radius=500`+// in meters\n      `&layer_ids=EVCHARGING_POI`+\n      `&key_attributes=POI_ID`;\n  \n    fetch(searchUrl)\n    .then(result => result.json())\n    .then(result => {\n      displayEV(result);\n    }, err =>{\n      console.error(err);\n    });\n  \n  } That was week 17 of #100DaysOfCode with HERE. This week, we looked at EV routing, Waypoint sequencing, Custom routes and Advanced Data Sets from the Fleet Telematics API. This was just the tip of the iceberg with Fleet Telematics. Feel free to try your hand at more Fleet Telematics endpoints and let us know the ones you found interesting. Meanwhile, keep following us on Twitter for more tasks and complete all 100 days. If you want to watch the video version of these solutions, take a look at our playlist for #100DaysOfCode on YouTube . If you want the code snippets of the APIs covered with #100DaysOfCode, head over to the 100daysofcode GitHub repository . If you are a fan of IBM Watson, machine learning, location data, python and pizza not particularly in that order, jump to the blog post by our 🥑 Vidhan Bhonsle. Happy coding!", "date": "2020-06-30"},
{"website": "Here", "title": "Built with HERE: Climate Change Performance Index 2020 Map", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/built-with-here-climate-change-performance-index-2020-map", "abstract": "Interactive map visualizations are a great way to tell a data-driven story when it comes to cross-country comparisons. Upon the release of the Climate Change Performance Index (CCPI) for 2020 , we wanted to showcase the report data with an interactive map . We received many requests about how we built our interactive map, so in this post, we would like to share that with you. The following is a list of the major technologies and/or services used: Web client HERE Maps API for JavaScript HERE Data Hub API and Data Hub Command Line Interface (CLI) Other relevant technologies will be highlighted throughout the post. Preparing the data The map visualizations are based on how each country ranked in the CCPI report . The report data contains a numerical score for each participating country. A higher score reflected greater achievements in climate protection, also resulting in a lower rank (1 being the best). Each country is categorized depending on what range the score fell in as shown here: Note: No country scored high enough to be placed in the top 3 rankings. The first task was to make the data usable with the map. We manually converted the data to a csv file with only the country name, score value,  and an additional column to include the ISO 3166 Country Code (Alpha 3) . Using a conversion utility , the data was then converted to a JSON format. The result of these modifications are partially shown here: [\n   { name: 'Sweden', value: 75.77, code: 'SWE' },\n   { name: 'Denmark', value: 71.14, code: 'DNK' },\n   { name: 'Morocco', value: 70.63, code: 'MAR' },\n   { name: 'United Kingdom', value: 69.8, code: 'GBR' },\n   // ...\n   { name: 'Taiwan', value: 23.33, code: 'TWN' },\n   { name: 'Saudi Arabia', value: 22.03, code: 'SAU' },\n   { name: 'United States', value: 18.6, code: 'USA' },\n]; Using the HERE Data Hub CLI , we uploaded the boundaries of every country already associated with an ISO Alpha 3 code sourced from Natural Earth Data . Once uploaded into our data hub, this provided quick access to each country's boundary by simply using the 3-character alpha code. This way we can use this data for future projects as well The remaining task with the data is to join the data (value) in the JSON file above with each country visually on the map. That process is done in code, as we will see next. Creating the map The map was created using the HERE Maps API for JavaScript . When the map is loaded, it loads all the boundaries of each country (previously loaded with CLI ) using the HERE Data Hub API as shown here: async function fetchBoundaries(countryCodes) {\n   const base = `https://xyz.api.here.com/hub/spaces/${credentials.id}/search?access_token=${credentials.token}`;\n   const url = base + countryCodes.map((code) => `&tags=ADM0_A3@${code}`).join(',');\n   const data = await jsonFetcher(url);\n   return data;\n} The JSON file containing the data from the CCPI report is a resource to the web site hosting the map. It is loaded and merged with the boundaries. By merging we mean by assigning the JSON data for each country to the properties of the corresponding country in the boundaries object as shown here: import data from './data/data.js';\n   \n   // fetchBoundaries defined above\n   const boundaries = await fetchBoundaries(countryCodes);\n\n   const [min, max] = [Math.min(...vals), Math.max(...vals)];\n   vizManager.setRange({ min, max });\n   boundaries.features\n      .map((x) => {\n         x.properties = data.find((z) => x.properties.ADM0_A3 === z.code);\n         return x;\n      })\n      .forEach((country) => {\n         map.addObject(country);\n      }); The result of this code connects all the data together: country with code, country boundary, and value of CCPI score. Each country object is then added to the map. Styling We styled the map with a custom YAML file as described in our documentation . Features of the page such as tool-tips and info box were styled with CSS. We consulted with this online utility for color choices. We also added a feature to make the map more interactive - when hovering over any country you will not only see the CCPI score, you will get an image of the country's flag too! We accomplished this by using this REST Countries API where the endpoint is the country code, such as https://restcountries.eu/data/usa.svg Here is what the map looks like when hovering over the United Kingdom: So with some simple styling touch-ups, the map is pleasantly engaging! Summary In this post we discussed how we built the CCPI 2020 map . We covered how we converted the data from the report and joined it with map data. We also addressed how we styled the map and made it interactive. If you are interested in building your map solutions with HERE, get started today !", "date": "2020-07-09"},
{"website": "Here", "title": "June 2020 Release Highlights", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/june-2020-release-notes", "abstract": "Welcome to the latest announcements for the HERE Location Services. This post covers the D118 release of HERE Location Services. This release includes updates of: Routing API, Maps API for JavaScript, Geocoder & Search API, Fleet Telematics API and HERE SDK for Android and iOS . The Release highlights are: Routing - Added support for routing over Express/High-Occupancy Vehicle Geocoding & Search -Search along the route and filtering of results by radius or bounding box Mobile SDK - New map schemes have been introduced to support satellite images together with vector-based street labels Mobile SDK and Maps API for JS - Support for interactive private venues For more detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation and release notes on the Developer Portal . IMPORTANT INFORMATION: Usage of CIT (Customer Integration and Testing) CIT is not anymore intended to be used by developers . All evaluation developers are entitled to use production. CIT was planned to be ramped down by end of Q2/2020, this will be extended until end of July! As we still see numerous developers still using CIT with an amount of transactions that indicate commercial usage we extended the runtime by one month and will now redirect requests to the Production environment until we observe a significant drop in number of requests coming into those CIT end-points. Affected developers should move to Production as only there we can guarantee fully scalability and availability of the services and ensure they are billed accordingly. On the Licensing Dashboard is a Customer Dashboard you can check if you are still using CIT. To switch to production developer s only have to take out the .. cit .. from the service URL. E.g. http://geocoder.api.here.com/ instead of http://geocoder. cit .api.here.com Important: Link IDs will exceed 32 bits soon, PLEASE PREPARE YOUR APPLICATIONS TO HANDLE LINK_ID VALUES > 4 BILLION! HERE Location Services on Platform Routing  (Version 8.3.1) Added support for routing over Express/High-Occupancy Vehicle (HOV) lanes. See vehicle [ ] parameter Added wait action generated for waypoints with waiting time (e.g. when stopDuration is set or charging is needed) Geocoding & Search (Version 7.0.50) Geocoder Autocomplete Beta released (GA expected in July) Geocoder now supports high precision postal code queries in Singapore and Ireland Geocoder quality improved in Hong Kong and Macau with new data set Search Autosuggest, Discover and Browse endpoints now support search along the route Search Autosuggest, Discover and Browse endpoints now support filtering of results by radius or bounding box HERE SDK for Android and iOS (Lite Edition) ( Version 4.4.02) Search for places along a route Search for places by category along a route. This feature is in BETA state. Added to the Details class the method: List<PlaceCategory> getPrimaryCategories() to get a place category from the result of a search query. Added a new font with Chinese, Japanese and Korean characters. The font occupies 1.7MB and can be optionally removed to save space. HERE SDK for Android and iOS (Explore Edition) (Version 4.4.0.2) New map schemes have been introduced to support satellite images together with vector-based street labels: HYBRID_DAY and HYBRID_NIGHT. Added to the MapCamera class the method: void setTargetOrientation (@NonNull MapCamera.OrientationUpdate orientation) to set only the target orientation in relation to the camera. By default, polylines are rendered in the order as they have been added to the map. This can now be changed at runtime by setting the draw order. It's now also possible to change the width and outline width at runtime. Search for places along a route Search for places by category along a route. This feature is in BETA state. Added to the Details class the method: List<PlaceCategory> getPrimaryCategories() to get a place category from the result of a search query. HERE SDK for Android and iOS (Navigate Edition) (Version 4.4.0.2) Additional features to the Explore version: Support for interactive private venues has been introduced. This feature is available for private venues owners upon request. HERE SDK for Android and iOS (Premium Edition) Version 3.16 (Last release of the 3.x SDK with new features before it gets into maintenance!) Improved 2D footprints coverage for Russia. Added HERE Hazard Warnings service support as beta feature with North America and Europe coverage. Extended routing options with the possibility to set balanced route type for truck routing. Added Picture-In-Picture(PIP) mode support for MapFragment. Added Navigation and Tracking mode support for buses on public transport roads. Added ability to set lane assistance mode while Routing/Guidance. Added Route Match service support which allows to get the most probable route for a small set of GPS traces. Added ability to show traffic on more than one Map instance. Provided API to control alternative routes number. Improved routing and navigation based on custom map data (Fleet Telematics Custom Route feature). Added maneuver action, direction and lane information to the routing response. Maps API for JavaScript (Version 3.1.17.0) Added the new module (mapsjs-venues.js) responsible for the rendering and interaction with the HERE (private) Venues service. Fleet Telematics API (Version 3.0.31) New Route Match feature: Report Illegal Environmental Zone Access Route Match can now also return warnings where vehicles illegally drove inside environmental zones.", "date": "2020-07-15"},
{"website": "Here", "title": "Create an iOS Map Application in Under 5 Minutes", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/create-an-ios-map-application-in-under-5-minutes", "abstract": "A few weeks ago, we released our new HERE SDKs for Android, iOS and Flutter. We’ve already published blog posts on how to get started in under five minutes with both Android and Flutter , so today we’ll try and see if we can also get an iOS project going that quickly. (Spoiler alert: yes, we can!) Set you stopwatches, here we go! Creating our app is a five-step process. Each of these steps can be completed in a minute or less. Get your credentials and download the SDK libraries. Grab an example from GitHub. Copy the SDK folder into the root folder of your project. Add your credentials to your information property list file. Yeah. Here’s thing. There’s no step five. It really is that quick and easy. Let's quickly(!) walk through all these steps. Step 1: Get Your Credentials First you need to sign up on the developer portal , generate a set of credentials and download the SDK files. Just click on \" Sign up \" on the top-right of this page and follow the process. My colleague Michael has made a video in case you need help. (Which you don’t. Go ahead, you got this.) Once you've signed up, you will be taken to your project page. There, under “HERE SDK for Android or iOS” click on \"Generate App\" and then on \"Create Credentials\". Store these credentials, we will need them in Step 4. Finally, click on \"Download SDK for iOS (Explore Edition)\". The download contains a .tar archive, which we will need in Step 3, so store it in a safe place. Fun fact: This was the most complicated and time-consuming step. It’s only going to get faster from here. Step 2: Clone the Examples from GitHub This step is even faster. Just \"git clone https://github.com/heremaps/here-sdk-examples.git\" to get the HERE SDK Examples from the HERE GitHub account. Step 3: Add the SDK Library to your Project Go into the examples folder of the SDK examples you just downloaded and find the \"HelloMap\" example for the iOS SDK Explore Edition. Then extract the .tar file from Step 1 until you have the heresdk.xcframework folder. Then copy this folder into the root folder of your project. The result should look something like this. Step 4: Add Credentials to your Project Open the \"HelloMap\" example in xCode. Go to the plist.info file in your project and set your credentials from Step 1 under the keys “AccessKeyId” and “AccessKeySecret”. OK, so there's technically a fifth step in that you must build and run you app. And that’s really it, you should have just created a running app with a HERE map! Congrats! Now, if this was too fast for you after all, you can check out the documentation for more details. Be sure to follow us on Twitter and Twitch for more updates on the new SDKs!", "date": "2020-07-13"},
{"website": "Here", "title": "Solutions: Day 96-100 #100DaysOfCode", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/solutions-day-96-100-100daysofcode", "abstract": "Welcome to the 20th, and final, week of #100DaysOfCode with HERE. It's my honor to bring this to a wrap with a look at Data Hub . Data Hub is a cloud service focused on working with geospatial data. It allows developers to upload their data and then provides incredibly rich APIs that work with that data in a location-focused manner. The final week of #100DaysOfCode focused on working with Data Hub including how to integrate it with our Maps. If you want to know more about 100DaysOfCode with HERE, take a look at this blog post which will tell you everything about it. If you have missed the solutions for the previous days, you can find them in our earlier blog posts or on our YouTube channel . Day 96 Day 96 started off rather easy. Your task was to simply get the Data Hub CLI installed. This required the use of npm, or Node Package Manager, which if you already have Node installed than you're ready to go. If not, you can install Node at Nodejs.org . To be clear, you do not have to be a Node developer to work with Data Hub. As a tool, npm is widely used to install utilities for developers. I'll use Node in later days but that's completely optional. You can use any programming language with Data Hub! Assuming you do have Node and npm installed, you can install the Data Hub CLI like so: npm install -g @here/cli When done, you can confirm you've got it running by typing here -V After you've got the CLI installed, you then need to login. These are the same credentials you can get by signing up for a free developer account at https://developer.here.com . This is done with here configure . You'll be prompted to enter your email address and password. This is a one time operation and the CLI will remember your credentials going forward. You can read more about the CLI at the docs . Day 97 On this day you were asked to download GeoJSON data and add it to a new Data Hub space. A \"space\" is simply a bucket for your data. In fact, you can think of it as a database. While you can use any GeoJSON data (or CSV, and more), I suggest the National Parks Service GeoJSON data found here: https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson . Download this file. Next, create a new Data Hub space with the CLI: here xyz create -t \"NPS Data\" THe -t option gives a title to the space. You can also use -d to provide a description. When you do this, an ID value will be displayed: Next, we need to upload it. This is done via: here xyz upload X -f filename Where X is the ID of the space you created and filename is your filename. You'll get a nice summary when done: The final action was to confirm your data was uploaded by looking at the contents. Technically the result of the last operation was more than enough to confirm it, but let's cross our Is and dot our Ts as I like to say. You can do this by using the show command: here xyz show X Again, X should be replaced by your space ID. This will output all of the contents: Day 98 In the previous two days you've used the CLI to work with and manage spaces. You created a new space and uploaded data from the National Parks Service. Today's challenge was to use the REST APIs to retrieve features from the space. Our REST APIs do everything the CLI does and more. In our case, we want to display contents from a space using the Iterate end point. It looks like so: https://xyz.api.here.com/hub/spaces/${SPACE_ID}/iterate?access_token=${ACCESS_TOKEN} Where ${SPACE_ID} is the ID of the space and ${ACCESS_TOKEN} is your security token. You can get your token at the Space Manangement utility. Login at that location and click the \"Access Management\" link on top. Then click \"Generate Token\". In the UI that pops up, click \"readFeatures\" in the first row (\"ALL\") to create a read only token for all your spaces. Click Next in the next two screens (Features and Details) and click Submit. The new token will be displayed on top of the page: With that token, and your space ID, you can get your data with a few lines in most any programming language. Here's a Node script that does it. It makes use of the DotEnv project to store both values in a .env file. const fetch = require('node-fetch');\n\nrequire('dotenv').config();\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\nconst SPACE_ID = process.env.SPACE_ID;\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/iterate?access_token=${ACCESS_TOKEN}`)\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    console.log(res);\n})\n.catch(e => {\n    console.error(e);    \n}); Here's the result in my terminal: Day 99 In yesterday's challenge, you used Data Hub's REST API to ask for data (features) from a space. I mentioned earlier that one of Data Hub's strengths is that it provides features specifically related to location. One simple but cool example of this is asking for data near a location. Your challenge for this day was to just that - ask for features near a location. Data Hub can find items within a radius, within a bounding box, in a polygon, and along a line. To search within a radius is fairly simple. Find a center location and figure out how big you want your circle. The endpoint looks like so: https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&lat=${LAT}&lon=${LON}&radius=${RAD} Here's a complete script written in Node.js (and again, remember that it's just a REST API, you can use any language): const fetch = require('node-fetch');\n\nrequire('dotenv').config();\nconst ACCESS_TOKEN = process.env.ACCESS_TOKEN;\nconst SPACE_ID = process.env.SPACE_ID;\n\n// City of New Orleans, LA\nconst LAT = 29.95;\nconst LON = -90.07;\n// How big of a circle to search (meters)\nconst RAD = 5000;\n\nfetch(`https://xyz.api.here.com/hub/spaces/${SPACE_ID}/spatial?access_token=${ACCESS_TOKEN}&lat=${LAT}&lon=${LON}&radius=${RAD}`)\n.then(res => {\n    return res.json();\n})\n.then(res => {\n    console.log(res);\n})\n.catch(e => {\n    console.error(e);    \n}); Day 100 For the final challenge we're going to add the features from the Data Hub space to a map. For this we will use our interactive JavaScript maps . To start, we can create a map, centered on America (since our data is American parks): <!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Test XYZ</title>\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n    <style>\n    body {\n        margin: 0;\n    }\n\n    #mapContainer {\n    width: 100vw;\n    height: 100vh;\n    }\n    </style>\n  </head>\n  <body>\n\n    <div id=\"mapContainer\"></div>\n\n    <script>\n    // Get this at developer.here.com, it's a JavaScript key\n    const HERE_MAPS_KEY = \"change to your key\";\n\n    var platform = new H.service.Platform({\n        apikey: HERE_MAPS_KEY\n    });\n\n    // Obtain the default map types from the platform object:\n    var defaultLayers = platform.createDefaultLayers();\n\n    var map = new H.Map(\n        document.getElementById('mapContainer'),\n        defaultLayers.vector.normal.map,\n        {\n            zoom: 4,\n            center: { lat: 38.7984, lng: -96.3944 },\n            pixelRatio: window.devicePixelRatio || 1\n        }\n    );\n\n    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n    // Create the default UI:\n    var ui = H.ui.UI.createDefault(map, defaultLayers);\n\n    </script>\n  </body>\n</html> This renders a nice map: For more on basic MapsJS usage, see the blog post for days 0-5. Now to add in Data Hub, we only need a few lines. First, we'll create a few variables for our keys and the space. // This is a read only key you can get in our token manager\nconst DATA_HUB_ACCESS_TOKEN = \"AMuu6pamTieLe38Ybun60gA\";\n// Your space ID\nconst SPACE_ID = \"uK3E2YoX\"; Next, we create an instance of the service. You'll see XYZ a few times as this was the previous name of the product. const service = platform.getXYZService({\n    token: DATA_HUB_ACCESS_TOKEN,\n}); Then we create a \"provider\" object: const mySpaceProvider = new H.service.xyz.Provider(service, SPACE_ID, {}); Notice that the space ID is passed to it. Then we can tie this to a map layer: const mySpaceLayer = new H.map.layer.TileLayer(mySpaceProvider); And the final bit is to add it to the map: map.addLayer(mySpaceLayer); And that's it! Here's the result: This map simply renders the locations but doesn't provide any functionality. It would absolutely be possible to add touch events that show data about the parks being rendered. Conclusion I hope you enjoyed this quick look at Data Hub. There is a heck of a lot more to Data Hub than I showed today, so be sure to check it out and see for yourself. Follow us on Twitter to see what we're up to, check out the Youtube playlist for this series, and finally, check the repository for all the solutions for #100DaysOfCode with HERE.", "date": "2020-07-14"},
{"website": "Here", "title": "Improve Your Address Data with HERE Geocoding - Part 2", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/improve-your-address-data-with-here-geocoding", "abstract": "[Writer’s note: This post is part of a series on data management. You’ll learn how to improve existing ambiguous or incomplete location data as well as new data you collect.] Delivering packages efficiently and reducing the number of undeliverable mail has become even more important as more people turn to online shopping to avoid public places in the fight against COVID-19. In part one of this blog series , we laid the groundwork to start with collecting better data using Autosuggest . Now, we’ll learn how to improve the quality of address data by validating and standardizing addresses. Address Standardization We all use addresses to navigate our way through the city and find our way to our destination (theoretically even without a map). For example, in San Francisco and Vancouver, BC, streets are numbered sequentially across the grid. In other places, streets are named after famous people, historically important dates, and even bird and flower species. Navigating the city using flowers may not be as intuitive as following sequential numbers, but at least it’s memorable for the locals. As much as addresses help us get around, they can also result in undeliverable mail, inefficient routes, or even cluttered databases and poor user experience when the input address is displayed on a page. For example, say you are meeting a friend for coffee. You text your friend saying “What’s the address of the Starbucks we’re meeting?” They could respond by saying “2200 NW Market St, Seattle, WA 98107,” or “2200 NorthWest Market St, Seattle, WA 98107,” or even “2200 north west market street, Seattle.” These are all different sides of the same coin - if you plug any of them into a map, you’ll be led to the right location. With HERE Geocoder, you can validate and standardize both US and international addresses. Try it here with JSFiddle : Here’s what an example call to HERE Geocoder looks like: https://geocode.search.hereapi.com/v1/geocode?q=2200 north west market street, Seattle&apiKey=YOUR_API_KEY&limit=1 You can see below how returned address is broken down into country, state, city,... and you can use this information to customize how the address is displayed, save the individual components in the database, or fill a custom form: { \"items\": [ { \"title\": \"2200 NW Market St, Seattle, WA 98107-4024, United States\", \"id\": \"here:af:streetsection:m8pFYU9PQ3F2fV-WhPo14C:CgcIBCDJlbUKEAEaBDIyMDAoZA\", \"resultType\": \"houseNumber\", \"houseNumberType\": \"PA\", \"address\": { \"label\": \"2200 NW Market St, Seattle, WA 98107-4024, United States\", \"countryCode\": \"USA\", \"countryName\": \"United States\", \"state\": \"Washington\", \"county\": \"King\", \"city\": \"Seattle\", \"district\": \"Ballard\", \"street\": \"NW Market St\", \"postalCode\": \"98107-4024\", \"houseNumber\": \"2200\" }, \"position\": { \"lat\": 47.66884, \"lng\": -122.38491 }, \"access\": [ { \"lat\": 47.66867, \"lng\": -122.38491 } ], \"mapView\": { \"west\": -122.38625, \"south\": 47.66794, \"east\": -122.38357, \"north\": 47.66974 }, \"scoring\": { \"queryScore\": 1.0, \"fieldScore\": { \"city\": 1.0, \"streets\": [ 1.0 ], \"houseNumber\": 1.0 } } } ] } With this, you can ask your user to confirm the standardized address to make sure that the recommended standardized address matches their intended location. Asking a customer to validate input address (Photo from Backerkit ) If you have large amounts of data that you need to process asynchronously, Batch Geocoder is a great option for processing hundreds of thousands of addresses at a time. If you are interested in using Batch Geocoder to update data that you have in your database and save the standardized results, you can contact us for a plan that supports storing results from geocodes. Next steps So far in this series we’ve learned how to collect better data and standardize existing data. One problem that we haven’t covered yet though, is the case of ambiguous or incomplete address data. For example, an address may contain a typo or it could be incomplete and therefore have multiple possible locations it could be representing. We want to help you identify the address that you need. If that’s what you are looking for, stay tuned for the last part in this series! You can sign up for a free account and try geocoding today. We hope you have enjoyed this series. and we look forward to hearing about what you build with HERE. Follow us on Twitter @heredev for team updates, and share what you’re working on with us. We can’t wait to see what you build!", "date": "2020-07-15"},
{"website": "Here", "title": "Using HERE Studio to Map National Parks", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/using-here-studio-to-map-national-parks", "abstract": "I've been an avid HERE Studio user since I joined HERE, and my \"go to\" data set for a while has been a list of American parks provided by the NPS (National Parks Service).In this blog post, I will share how I built maps with this data and what I did to improve the data and get better visualization. The process I went through (taking data and improving it for the map) is somewhat common so I hope this example will help guide others. The Original Data Let's start by talking about the original set of data. I began by searching for \"national parks service geojson\" which led me here: https://www.nps.gov/maps/tools/npmap.js/examples/geojson-layer/ . This page shows a simple JavaScript demo rendering a map using a GeoJSON layer. While not exactly called out, if you actually read the JavaScript, you can find this URL: https://www.nps.gov/lib/npmap.js/4.0.0/examples/data/national-parks.geojson If you open this in your browser, you get a list of every single park in the service. Here's a small subset: {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"id\": 0,\n      \"properties\": {\n        \"Code\": \"FRLA\",\n        \"Name\": \"Frederick Law Olmsted National Historic Site\"\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -71.131129569256473,\n          42.325508673715092\n        ]\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"id\": 1,\n      \"properties\": {\n        \"Code\": \"GLDE\",\n        \"Name\": \"Gloria Dei Church National Historic Site\"\n      },\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -75.143583605984745,\n          39.934377409572079\n        ]\n      }\n    }, One thing you'll notice is that there really isn't a lot of data. Each park has a Code value (which appears to be an internal way of identifying the park) and a Name . But we can still work with this and create a map from it! I downloaded this file to my computer, went to HERE Studio and created a new project. After making my project, I added the data layer by uploading it via the browser. We've got a CLI as well that I'll use later, but for now the browser-based tools are enough. Once uploaded and added to my project, I get this: Cool. Studio picks some default colors for your data but we can change that easily enough. I went with a green color and an icon (\"nature\") which feels more appropriate for mapping parks: The last step (for this version) is to publish it and share it with the world. You can see this map here: https://studio.here.com/viewer/?project_id=bec76599-1715-42bd-b46c-9b5c4837b735 We Can Do Better! So to recap, we got a GeoJSON file containing all the parks in the National Park Service, uploaded it to HERE Studio, and built a beautiful, if simple, map. The National Park Service though has a lot more information about their parks. Luckily for us, this is all available via a free to use National Parks Service API . The API covers a lot of different use cases but the one we're most interested in is the parks endpoint. This returns detailed information about one or more parks. The API looks like so: https://developer.nps.gov/api/v1/parks?parkCode=avia&api_key=YOURKEY And returns a huge amount of information on the park: {\n  \"total\": \"1\",\n  \"data\": [\n    {\n      \"contacts\": {\n        \"phoneNumbers\": [\n          {\n            \"phoneNumber\": \"9372257705\",\n            \"description\": \"\",\n            \"extension\": \"\",\n            \"type\": \"Voice\"\n          }\n        ],\n        \"emailAddresses\": [\n          {\n            \"description\": \"\",\n            \"emailAddress\": \"tom_engberg@nps.gov\"\n          }\n        ]\n      },\n      \"states\": \"OH\",\n      \"longitude\": \"-84.0711364746094\",\n      \"activities\": [\n        {\n          \"id\": \"B33DC9B6-0B7D-4322-BAD7-A13A34C584A3\",\n          \"name\": \"Guided Tours\"\n        }\n      ],\n      \"entranceFees\": [\n        {\n          \"cost\": \"1.0000\",\n          \"description\": \"The National Aviation Heritage Area is comprised of many sites. While some sites are free of charge to the public, others may have entrance fees and/or event or participation fees. Please check on the specific National Aviation Heritage Area site prior to your visit.\",\n          \"title\": \"Entrance Fees Vary\"\n        }\n      ],\n      \"directionsInfo\": \"The National Aviation Heritage Area has multiple sites located throughout eight counties in the Dayton, Ohio and western Ohio area. Please be sure to visit a specific National Aviation Heritage Area website for directions and/or maps to each location.\",\n      \"entrancePasses\": [\n        {\n          \"cost\": \"1.0000\",\n          \"description\": \"The National Aviation Heritage Area is comprised of many sites. While some sites are free of charge to the public, others may have entrance fees and/or event or participation fees. Please check on the specific National Aviation Heritage Area site prior to your visit.\",\n          \"title\": \"Fee Pass Costs Vary\"\n        }\n      ],\n      \"directionsUrl\": \"http://www.aviationheritagearea.org/\",\n      \"url\": \"https://www.nps.gov/avia/index.htm\",\n      \"weatherInfo\": \"The National Aviation Heritage Area lies in a humid continental zone with a generally temperate climate. Winters are mildly cold with average temperatures around 39 degrees (F). Summers are hot and humid with an average temperature around 74 degrees (F). Average annual total rainfall is just above 41\\\". Snowfall in the winter is generally light with an average total snowfall of about 25\\\".\",\n      \"name\": \"National Aviation\",\n      \"operatingHours\": [\n        {\n          \"exceptions\": [],\n          \"description\": \"While this website is not meant to be an exhaustive resource for all of the National Aviation Heritage Area partners and organizations, there is an official partner organization (National Aviation Heritage Alliance) which operates a separate and full-functioning website with a plethora of site information. Visit National Aviation Heritage Alliances' webpage for up-to-date information, directions and breaking news for all of the historical sites and member organizations.\",\n          \"standardHours\": {\n            \"wednesday\": \"All Day\",\n            \"monday\": \"All Day\",\n            \"thursday\": \"All Day\",\n            \"sunday\": \"All Day\",\n            \"tuesday\": \"All Day\",\n            \"friday\": \"All Day\",\n            \"saturday\": \"All Day\"\n          },\n          \"name\": \"Various Heritage Area Sites\"\n        }\n      ],\n      \"topics\": [\n        {\n          \"id\": \"B912363F-771C-4098-BA3A-938DF38A9D7E\",\n          \"name\": \"Aviation\"\n        }\n      ],\n      \"latLong\": \"lat:39.9818229675293, long:-84.0711364746094\",\n      \"description\": \"Aviation is chock-full of tradition & history and nowhere will you find a richer collection of aviation than here, the birthplace of aviation.  From the straightforward bicycle shops that fostered the Wright brothers' flying ambitions to the complex spacecraft that carried man to the moon, the National Aviation Heritage Area has everything you need to learn about this country’s aviation legacy.\",\n      \"images\": [\n        {\n          \"credit\": \"NPS Photo / Tom Engberg\",\n          \"altText\": \"Visitor center building in background with plaza in foreground\",\n          \"title\": \"Dayton's National Park\",\n          \"caption\": \"The Wright-Dunbar Interpretive Center located just west of downtown Dayton\",\n          \"url\": \"https://www.nps.gov/common/uploads/structured_data/DCB2628F-1DD8-B71B-0BD78D1063069C70.jpg\"\n        }\n      ],\n      \"designation\": \"Heritage Area\",\n      \"parkCode\": \"avia\",\n      \"addresses\": [\n        {\n          \"postalCode\": \"45402\",\n          \"city\": \"Dayton\",\n          \"stateCode\": \"OH\",\n          \"line1\": \"16 South Williams St.\",\n          \"type\": \"Physical\",\n          \"line3\": \"\",\n          \"line2\": \"\"\n        },\n        {\n          \"postalCode\": \"45402\",\n          \"city\": \"Dayton\",\n          \"stateCode\": \"OH\",\n          \"line1\": \"16 South Williams St.\",\n          \"type\": \"Mailing\",\n          \"line3\": \"\",\n          \"line2\": \"\"\n        }\n      ],\n      \"id\": \"C8C207D8-49C4-4891-9915-0007205A0284\",\n      \"fullName\": \"National Aviation Heritage Area\",\n      \"latitude\": \"39.9818229675293\"\n    }\n  ],\n  \"limit\": \"1\",\n  \"start\": \"0\"\n} This is an awesome set of data and would be a great addition to our map, so how do we get it? Remember that HERE Studio needs GeoJSON. We've got a GeoJSON file of parks. What if we take that original source file, get the codes from them, and then make requests to the API to fill in the gaps? Here's my initial solution using Node.js. It failed so don't copy this as is! const fs = require('fs');\nconst fetch = require('node-fetch');\nrequire('dotenv').config();\n\nconst NPS_KEY = process.env.NPS_KEY;\n\nconst BUCKET_SIZE = 25;\n\nlet rawData = fs.readFileSync('./national-parks.geojson','utf8');\nlet data = JSON.parse(rawData);\nconsole.log(`Read in my file and I have ${data.features.length} features to parse.`);\n\nlet buckets = [];\nlet idx = 0;\nbuckets[idx] = [];\nfor(let i=0;i<data.features.length;i++) {\n    let code = data.features[i].properties.Code;\n    buckets[idx].push(code);\n    if(buckets[idx].length === BUCKET_SIZE) {\n        idx++;\n        buckets[idx] = [];\n    }\n}\n\nconsole.log(`Please stand by, I'm requesting a lot of data.`);\nlet requestQueue = [];\nfor(let i=0;i<buckets.length;i++) {\n    requestQueue.push(getParkData(buckets[i]));\n}\n\nPromise.all(requestQueue).then(results => {\n    console.log(`Fetched a LOT of data. Now I need to get this into my JSON.`);\n    //its an array of array, so let's make one big one\n    let result = [];\n    for(let i=0;i<results.length;i++) {\n        for(let k=0;k<results[i].length;k++) {\n            result.push(results[i][k]);\n        }\n    }\n\n    /*\n        Now we need to connect ths data to the original data. Going to use a\n        lot of looping which is slow but meh. Also note the API returns codes in lowercase, \n        the original data was uppercase. Also know we will be storing stuff in properties we don't need, \n        like latlong, longitude, and latitude. I'm ok with the extra though. I will remove .parkCode though so as to not conflict with .Code\n        Actually scratch that, I'm going to replace the orig properties w/ the new props cuz woot woot\n    */\n    for(let i=0;i<result.length;i++) {\n        let park = result[i];\n        let origIndex = data.features.findIndex(p => {\n            return p.properties.Code === park.parkCode.toUpperCase();\n        });\n        if(origIndex >= 0) {\n            data.features[origIndex].properties = park;\n        }\n\n    }\n\n    fs.writeFileSync('./nationl-parks-full.geojson', JSON.stringify(data));\n    console.log('All done, yo!');\n});\n\nfunction getParkData(list) {\n    return new Promise((resolve, reject) => {\n        let url = `https://developer.nps.gov/api/v1/parks?api_key=${NPS_KEY}&parkCode=${list}`;\n\n        fetch(url)\n        .then(res => res.json())\n        .then(res => {\n            resolve(res.data);\n        })\n        .catch(e => {\n            console.error(e);\n            reject(e);\n        });\n    });\n} When requesting details about a park, the API lets you send a list of park codes. Given that I've got a list of nearly 400, I decided to create a list of lists, or what I called a bucket array. Each item in the bucket array is another array of 25 park codes. Once I have my \"list of lists\", I then fire off calls to the API for all of them at once and wait for them to finish before I start processing. If you're a bit concerned about this approach you should be. Once done, I loop over my result data and for each park, find the corresponding original park in my geojson file and update it with the result from the API. So this seemed like a good idea, but in my testing, the API would randomly spit out server errors. This is to be expected as I was basically creating a minor DDOS on the API. Luckily I realized this rather quickly and stopped using the script. Version two was modified to only do a few entries at a time, keeping track of \"processed\" parks by adding a _processed flag. Here's the updated file, minus the getParkData() function which didn't change. const fs = require('fs');\nconst fetch = require('node-fetch');\nrequire('dotenv').config();\n\nconst NPS_KEY = process.env.NPS_KEY;\n\nconst BUCKET_SIZE = 20;\n\nlet rawData = fs.readFileSync('./national-parks-full.geojson','utf8');\nlet data = JSON.parse(rawData);\nconsole.log(`Read in my file and I have ${data.features.length} features to parse.`);\n\nlet bucket = [];\nfor(let i=0;i<data.features.length;i++) {\n    if(!data.features[i].properties._processed) {\n        let code = data.features[i].properties.Code;\n        bucket.push(code);\n    } else {\n        console.log(`Skipping ${data.features[i].properties.parkCode} as it has been done.`);\n    }\n}\n\nconsole.log(`I've got ${bucket.length} parks to process.`);\n\n//Our bucket may be too big\nbucket = bucket.slice(0, BUCKET_SIZE);\n\nconsole.log(`Please stand by, I'm requesting a lot of data (specifically, ${bucket.length} items).`);\n\ngetParkData(bucket)\n.then(result => {\n    /*\n        Now we need to connect this data to the original data. Going to use a\n        lot of looping which is slow but meh. Also note the API returns codes in lowercase, \n        the original data was uppercase. Also know we will be storing stuff in properties we don't need, \n        like latlong, longitude, and latitude. I'm ok with the extra though. I will remove .parkCode though so as to not conflict with .Code\n        Actually scratch that, I'm going to replace the orig properties w/ the new props cuz woot woot\n    */\n    for(let i=0;i<result.length;i++) {\n        let park = result[i];\n        let origIndex = data.features.findIndex(p => {\n            return p.properties.Code === park.parkCode.toUpperCase();\n        });\n\n        if(origIndex >= 0) {\n            data.features[origIndex].properties = park;\n            data.features[origIndex].properties._processed=1;\n        }\n\n    }\n\n    fs.writeFileSync('./national-parks-full.geojson', JSON.stringify(data));\n    console.log('All done, yo!');\n\n})\n.catch(e => {\n    console.error(e);\n}); This script will read in a geojson file, find the parks without _processed , and then process BUCKET_SIZE items. It may sound lame, but I ran this, waited a while, ran it again, and so forth, over an hour or two until the entire set of parks was done. To be clear, this was an ugly fix, but probably indicative of the kinds of things folks have to deal with in getting their data in the best form to map. The final result looked a bit like this (I'm including just the top of the geojson file and the first result): {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"id\": 0,\n            \"properties\": {\n                \"contacts\": {\n                    \"phoneNumbers\": [\n                        {\n                            \"phoneNumber\": \"6175661689\",\n                            \"description\": \"\",\n                            \"extension\": \"\",\n                            \"type\": \"Voice\"\n                        }\n                    ],\n                    \"emailAddresses\": [\n                        {\n                            \"description\": \"\",\n                            \"emailAddress\": \"frla_interpretation@nps.gov\"\n                        }\n                    ]\n                },\n                \"states\": \"MA\",\n                \"longitude\": \"-71.13202567\",\n                \"activities\": [\n                    {\n                        \"id\": \"B33DC9B6-0B7D-4322-BAD7-A13A34C584A3\",\n                        \"name\": \"Guided Tours\"\n                    },\n                    {\n                        \"id\": \"DF4A35E0-7983-4A3E-BC47-F37B872B0F25\",\n                        \"name\": \"Junior Ranger Program\"\n                    },\n                    {\n                        \"id\": \"C8F98B28-3C10-41AE-AA99-092B3B398C43\",\n                        \"name\": \"Museum Exhibits\"\n                    },\n                    {\n                        \"id\": \"A0631906-9672-4583-91DE-113B93DB6B6E\",\n                        \"name\": \"Self-Guided Tours - Walking\"\n                    }\n                ],\n                \"entranceFees\": [\n                    {\n                        \"cost\": \"0.0000\",\n                        \"description\": \"No entrance fee required.\",\n                        \"title\": \"No Entrance Fee\"\n                    }\n                ],\n                \"directionsInfo\": \"Site is located on the southwest corner of Warren and Dudley Streets in Brookline, south of Route 9, near the Brookline Reservoir.\\n\\nSite is 0.7 miles from the Brookline Hills MBTA stop on the Green Line, D Branch.\",\n                \"entrancePasses\": [\n                    {\n                        \"cost\": \"0.0000\",\n                        \"description\": \"No entrance passes required.\",\n                        \"title\": \"No Entrance Pass\"\n                    }\n                ],\n                \"directionsUrl\": \"http://www.nps.gov/frla/planyourvisit/directions.htm\",\n                \"url\": \"https://www.nps.gov/frla/index.htm\",\n                \"weatherInfo\": \"Summer: Warm temperatures, average high temperature around 80 degrees Fahrenheit, often with humidity. July and August bring the hottest temperatures.\\nFall: Cooler temperatures, mean temperatures between 45 and 65 degrees Fahrenheit, sometimes rainy. Peak fall foliage is in mid-October.\\nWinter: Cold, with snow, average low temperature around 25 degrees Fahrenheit. \\nSpring: Cold to cool temperatures, average mean temperatures between 40 and 60 degrees Fahrenheit.\",\n                \"name\": \"Frederick Law Olmsted\",\n                \"operatingHours\": [],\n                \"topics\": [\n                    {\n                        \"id\": \"A8E54356-20CD-490E-B34D-AC6A430E6F47\",\n                        \"name\": \"Civil War\"\n                    },\n                    {\n                        \"id\": \"AF4F1CDF-E6C4-4886-BA91-8BC887DC2793\",\n                        \"name\": \"Landscape Design\"\n                    },\n                    {\n                        \"id\": \"3CDB67A9-1EAC-408D-88EC-F26FA35E90AF\",\n                        \"name\": \"Schools and Education\"\n                    },\n                    {\n                        \"id\": \"27BF8807-54EA-4A3D-B073-AA7AA361CD7E\",\n                        \"name\": \"Wars and Conflicts\"\n                    }\n                ],\n                \"latLong\": \"lat:42.32424266, long:-71.13202567\",\n                \"description\": \"Frederick Law Olmsted (1822-1903) is recognized as the founder of American landscape architecture and the nation's foremost parkmaker. Olmsted moved his home to suburban Boston in 1883 and established the world's first full-scale professional office for the practice of landscape design. During the next century, his sons and successors perpetuated Olmsted's design ideals, philosophy, and influence.\",\n                \"images\": [\n                    {\n                        \"credit\": \"NPS Photo\",\n                        \"altText\": \"Fairsted\",\n                        \"title\": \"Frederick Law Olmsted National Historic Site\",\n                        \"id\": \"4085\",\n                        \"caption\": \"Frederick Law Olmsted National Historic Site\",\n                        \"url\": \"https://www.nps.gov/common/uploads/structured_data/3C853BE9-1DD8-B71B-0B625B6B8B89F1A0.jpg\"\n                    }\n                ],\n                \"designation\": \"National Historic Site\",\n                \"parkCode\": \"frla\",\n                \"addresses\": [\n                    {\n                        \"postalCode\": \"02445\",\n                        \"city\": \"Brookline\",\n                        \"stateCode\": \"MA\",\n                        \"line1\": \"99 Warren Street\",\n                        \"type\": \"Physical\",\n                        \"line3\": \"\",\n                        \"line2\": \"\"\n                    },\n                    {\n                        \"postalCode\": \"02445\",\n                        \"city\": \"Brookline\",\n                        \"stateCode\": \"MA\",\n                        \"line1\": \"99 Warren Street\",\n                        \"type\": \"Mailing\",\n                        \"line3\": \"\",\n                        \"line2\": \"\"\n                    }\n                ],\n                \"id\": \"CDC0FE7F-C249-466C-88B2-B81FC5279B91\",\n                \"fullName\": \"Frederick Law Olmsted National Historic Site\",\n                \"latitude\": \"42.32424266\",\n                \"_processed\": 1\n            },\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -71.13112956925647,\n                    42.32550867371509\n                ]\n            }\n        }, At this point it's probably a good idea to recap. First, we got the GeoJSON file from the NPS website. It included every park in the service, but just the name and code. We used the NPS API to \"gradually\" improve the data by fetching detailed information about each park. That information was then stored back in the original GeoJSON data (but saved to a new file) The next step would be to upload the new data, but we can make it better for Studio by \"flattening\" and simplifying the data a bit. To do this, I wrote a new script that flattened the data for me. It also made some changes that made sense to me, but may not to you. So for example, I thought topics were important, but not the information on entrance passes. That was an arbitrary decision based on the hypothetical map I imagined building. Since I still have my original data I can always change my mind later, but I wanted you, my esteemed reader, to understand what I did. Here's the script: const fs = require('fs');\n\nlet data = JSON.parse(fs.readFileSync('./national-parks-full.geojson'));\n\ndata.features = data.features.map(f => {\n\n    let newProps = {};\n\n    if(f.properties.contacts) {\n        if(f.properties.contacts.phoneNumbers && f.properties.contacts.phoneNumbers[0].type === 'Voice') {\n            newProps.phoneNumber = f.properties.contacts.phoneNumbers[0].phoneNumber;\n        } \n\n        if(f.properties.contacts.emailAddresses) {\n            newProps.emailAddress = f.properties.contacts.emailAddresses[0].emailAddress;\n        } \n    }\n\n    if(f.properties.activities) {\n        newProps.activities = f.properties.activities.reduce((list, activity) => {\n            if(list != '') list += ',';\n            return list += activity.name;\n        },'');\n    }\n\n    newProps.directionsInfo = f.properties.directionsInfo;\n    newProps.directionsUrl = f.properties.directionsUrl;\n    newProps.url = f.properties.url;\n    newProps.weatherInfo = f.properties.weatherInfo;\n    newProps.name = f.properties.name;\n\n    if(f.properties.topics) {\n        newProps.topics = f.properties.topics.reduce((list, topic) => {\n            if(list != '') list += ',';\n            return list += topic.name;\n        },'');\n    }\n\n    newProps.description = f.properties.description;\n\n    if(f.properties.images && f.properties.images.length >= 1) {\n        newProps.image = f.properties.images[0].url;\n    }\n\n    newProps.designation = f.properties.designation;\n    newProps.parkCode = f.properties.parkCode;\n    newProps.fullName = f.properties.fullName;\n\n    //console.log(newProps);\n    f.properties = newProps;\n    return f;\n});\n\nfs.writeFileSync('./national-parks-studio.geojson', JSON.stringify(data)); The script is basically one big map call where I flatten and remove stuff I didn't care about. Notice how both activities and topics are converted from a complex array of objects into a comma-delimited list. Here's an example of how the properties look after this conversion: \"properties\": {\n  \"phoneNumber\": \"6175661689\",\n  \"emailAddress\": \"frla_interpretation@nps.gov\",\n  \"activities\": \"Guided Tours,Junior Ranger Program,Museum Exhibits,Self-Guided Tours - Walking\",\n  \"directionsInfo\": \"Site is located on the southwest corner of Warren and Dudley Streets in Brookline, south of Route 9, near the Brookline Reservoir.\\n\\nSite is 0.7 miles from the Brookline Hills MBTA stop on the Green Line, D Branch.\",\n  \"directionsUrl\": \"http://www.nps.gov/frla/planyourvisit/directions.htm\",\n  \"url\": \"https://www.nps.gov/frla/index.htm\",\n  \"weatherInfo\": \"Summer: Warm temperatures, average high temperature around 80 degrees Fahrenheit, often with humidity. July and August bring the hottest temperatures.\\nFall: Cooler temperatures, mean temperatures between 45 and 65 degrees Fahrenheit, sometimes rainy. Peak fall foliage is in mid-October.\\nWinter: Cold, with snow, average low temperature around 25 degrees Fahrenheit. \\nSpring: Cold to cool temperatures, average mean temperatures between 40 and 60 degrees Fahrenheit.\",\n  \"name\": \"Frederick Law Olmsted\",\n  \"topics\": \"Civil War,Landscape Design,Schools and Education,Wars and Conflicts\",\n  \"description\": \"Frederick Law Olmsted (1822-1903) is recognized as the founder of American landscape architecture and the nation's foremost parkmaker. Olmsted moved his home to suburban Boston in 1883 and established the world's first full-scale professional office for the practice of landscape design. During the next century, his sons and successors perpetuated Olmsted's design ideals, philosophy, and influence.\",\n  \"image\": \"https://www.nps.gov/common/uploads/structured_data/3C853BE9-1DD8-B71B-0B625B6B8B89F1A0.jpg\",\n  \"designation\": \"National Historic Site\",\n  \"parkCode\": \"frla\",\n  \"fullName\": \"Frederick Law Olmsted National Historic Site\"\n}, Alright, so to test this, I made a new project in Studio, uploaded my data into a new space, and did the same changes to the icons. Next, I opened up the Card editing UI. Here's the default order Studio used: I modified this order like so: Again, this was arbitrary, but it made sense to me. Having the name, image, description and phone number visible first seemed sensible. Also, Studio does awesome things when it discovers a URL value, like our image. Beautiful! You can view this map project here: https://studio.here.com/viewer/?project_id=4df1f2de-df48-4300-98ee-0576f629c3c2 What's Next? I hope this exploration into data, and the work you have to, is useful. While you may get lucky and have data \"perfectly\" ready for display, most likely you're going to have to do some manipulation before it's ready for a map. I highly recommend documenting your process (so you don't forget steps) and take snapshots of your data along the way so you can compare and contrast what works for you. You can start using Studio today at https://studio.here.com . Everything I've demonstrated is available on our free tier!", "date": "2020-07-21"},
{"website": "Here", "title": "Thank you for making us number one, again!", "author": ["Mithun T. Dhar"], "link": "https://developer.here.com/blog/thank-you-for-making-us-number-one-again", "abstract": "HERE has once again raised the bar and pulled ahead of Apple, Google, Mapbox and TomTom taking the top spot in the OMDIA location platform index. The independent experts voted us the world’s best location platform – we have, you, our developer community, to thank for this great achievement. OMDIA, formerly known as Ovum , is an industry analyst firm that has more than thirty years' experience in technology and communications. Its location platform index assesses the major players in the location platform market, with a particular focus on mapping and navigation. We are the highest-ranking vendor in the report with an overall score of 7.49 out of a possible 10. Omdia describes the strengths of HERE that include our developer reach and partner network, particularly in Asia with Mitsubushi Corp. and Japan’s largest telecom provider, NTT, now as equity investors in HERE. “HERE is known for its strong position in the automotive industry and its prowess in HD mapping and ADAS. But what is perhaps less conspicuous is the progress HERE is making in other verticals including logistics, telecommunications, retail and media,” said Eden Zoller, Omdia Chief Analyst. For more information and to download a copy of the OMDIA Location Platform Index, June 2020, go to: http://here.com/omdia-2020-platform-report Join our best in class platform – all you need is your freemium account . We can’t wait to see what you create!", "date": "2020-07-16"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.19 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.19-release", "abstract": "Highlights Manage framework agnostic Machine Learning life-cycles on the HERE platform An MLflow plugin is now available which allows data scientists to manage their Machine Learning (ML) life-cycle on the HERE platform. Users can manage their ML experiments and share that with other users of the platform, or make it available on the Marketplace. Data scientists can use any ML framework on any ML cloud platform for training and can choose to manage the ML artifacts on the platform. The MLflow plugin can be used while training the ML model or users can upload an already trained model to the platform. ML Flow plugin features include: Tracking experiments to record and compare parameters and results Packaging ML code in a reusable, reproducible form in order to share with other data scientists Providing a central model store to collaboratively managing the full life-cycle of an MLflow model including model versioning, stage transitions, and annotations through a catalog HRN. Build a docker locally for exposing the model as a service for inference. Please note, this feature is available only for testing the inference service locally in this release. Please, refer to the MLflow plugin section of the HERE Data SDK for Python Setup Guide for installation instructions. Easily serialize Location Library geometry objects to GeoJSON The new FeatureCollection class in the Location Library lets you create GeoJSON files from your geometry objects. Simply create GeoJSON point markers, line strings, arrows to highlight direction, line strings and point markers to represent point and range based attributes and custom markers. GeoJSON is a standard format for geo-spatial data and can be displayed with many open source and commercial tools. You may also want to publish the result in partitions of a versioned layer and inspect your data in the platform via the Data Inspector. Set granular Stream layer throughput configurations to optimize performance and cost Set more granular stream layer throughput configurations so that you can better optimize your stream layer storage based on your use case and budget needs.  When creating a Stream layer, you are only charged for the \"In\" throughput.  With this release, you can create new Stream layers with \"In\" throughput in 100 KB/s increments.  Please see more specific details about this change here . Note: G oing forward and in order to maintain backward compatibility with older Data Client Library versions, you will see Stream throughput numbers in MB/s and rounded down when requesting layer configuration information using older clients.  Example:  If you are using a Data Client Library version less than the latest version released with this HERE Workspace release AND you request Stream layer throughput configuration AND you set your Stream layer \"In\" throughput to 100 KB/s, you will see a response of \"0\".  This response is explained in HERE Workspace documentation here .  Conversely, If you are using the latest SDK version available with this release, you will see the accurate \"In\" throughput of 100 KB/s for this example. Please, take note of the corresponding deprecation announcement at the end of these release notes. Improved control for editing of Grafana monitoring dashboards To provide better control for editing monitoring dashboards and alerts, users in your Org can be granted the \"edit monitoring dashboards\" role by their Org Admin. Only Org Admins and users with this role have the right to make changes to the dashboards and view alerts. Analyze Flink metrics to monitor your data archive stream processing The Data Archiving Library now enables you to define and expose Flink processing metrics in Grafana dashboards so that you can monitor the health and activity of your data archive stream processing. Have a look at our documentation to learn which metrics are available. Changes, Additions and Known Issues SDKs and tools Go to the HERE platform changelog to see details of all changes to our CLI , the Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library . Web & Portal Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: A finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Added: You can upload data directly from your local machine onto a data layer using the \"upload data\" button located in the data layer user interface. Issue: The \"Upload data\" button is hidden when the layer has the \"Content encoding\" field set to \"gzip\". Workaround: Files (including zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"uncompressed\". Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a group, user or app has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until October 30, 2020 . Referencing old Schema HRNs is not broken and will work in perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Deprecation Reminder: Batch-2.0.0 environment deprecation period is now over and it will be removed soon. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue : Pipelines can still be activated after a catalog is deleted. Workaround : The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same group (pipeline permissions are managed via a group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround : Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new group for each pipeline/application, each with its own Application ID. Marketplace (Not available in China) Issue: There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, service will slow down across the board for all consumers who are reading from the External Service Gateway. Workaround: Contact HERE technical support for help. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 October 30, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after October 30, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after October 30, 2020. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before October 30, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after October 30, 2020. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 4 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Deprecation period is now over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 5 Schema validation to be added 2.13 March 2020 November 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of November 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, any attempt to update any configurations of that layer will fail until the schema association or permissions are corrected. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before November 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 6 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020. 7 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing Stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this period, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, please use Platform SDK 2.16 or older. After February 1, 2021 the Stream-2.0.0 run-time environment will be removed and the pipelines still using it will be canceled. We recommend that you migrate your Stream Pipelines to the new Stream-3.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For more details about our general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 8 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 Deprecation Summary: ‘pipeline_jobs_canceled’ metric used within the Pipeline Status Dashboard is now deprecated because it was tied to the Pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. After that date, the metric will be removed. 9 Stream throughput configuration changes from MB/s to KB/s 2.19 September 2020 March 31, 2021 Deprecation Summary: Support for Stream layers with configurations in MB/s will be deprecated in (6) months or by March 31, 2021. After March 31, 2021 only KB/s throughput configurations are supported. This means also that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers after this date because these versions do not support configuring stream layers in KB/s.", "date": "2020-09-22"},
{"website": "Here", "title": "Improve Your Address Data with HERE Geocoding - Part 3", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/improve-your-address-data-with-here-geocoding-part-3", "abstract": "[Writer’s note: This is the final part in our series about modern data management. Our first blog post focuses on how you can collect better location data using Autosuggest and our second blog post focuses on how you can validate and standardize addresses . In this part, you’ll learn how to improve existing ambiguous or incomplete location data.] Let’s say you want to send packages to your customers, and you’ve just found out that some of the addresses cannot be mapped to a location because of problems as innocent as typos. Some addresses don’t map to any location, others represent multiple places, and there are many others with spelling or formatting problems. If you proceed with the current data, some customers won’t receive their packages, some packages will be returned and you’ll face unhappy customers and increased shipping costs for resending packages. How should you proceed? As your business gains more traction and you collect more data, maintaining perfect data becomes harder and that’s okay. At HERE, we’re ready to help you improve your address data and ultimately improve your customer satisfaction. Enriching existing location data When people are responsible for manually inputting data (for example when shopping online and typing the delivery address), it’s generally safe to assume that the data won’t be perfect. We've all had the experience of typing an address on our phone where it’s easy to make a typo or select an incorrect address suggestion. I have accidentally purchased a few things for my address doppelgänger in Wisconsin, but it is safe to say that they were never sent back. There’s little that can be done to salvage valid but incorrect addresses (like gifts I sent to my doppelgänger), but we learned that with Autosuggest, we can introduce a preference or bias for results that are closer to the user, and ultimately increase the likelihood that the user would pick the right suggestion. So, how can we use geocoding to improve incorrect or incomplete addresses? Geocoding empowers you to do more than formatting and standardizing; you can also fix incomplete or incorrect addresses. If you specify a central location for your search, you can introduce a preference for results that are closer to your central location. Most often, you’ll want to set the center to where your user is, or the city where you might expect your users to live. For example, if you know that the incomplete addresses are from users who live in Seattle, you can specify Seattle as the center so you will get results that are most likely what your users intended as their home address. Let’s take Seattle Volunteer Park Conservatory as an example. Their complete address is “1400 E Galer St, Seattle, WA 98112,” but let’s say we called them to ask about their address. However, the connection wasn’t great so we only heard something that could be: “1400 galer st,” or “1400 e gamer st seattle.” You can try these examples below and see the predictions from HERE Geocoder: Here’s what an example call to HERE Geocoder looks like: https://geocode.search.hereapi.com/v1/geocode?apiKey=API_KEY&q=1400 galer st seattle You can see below how returned address is broken down into country, state, city,... and you can use this information to customize how the address is displayed, save the individual components in the database, or fill a custom form: {\n    \"items\": [\n        {\n            \"title\": \"1400 W Galer St, Seattle, WA 98119, United States\",\n            \"id\": \"here:af:streetsection:rYa8kC3gTMNOq8atovDWvC:EAIaBDE0MDAoZA\",\n            \"resultType\": \"houseNumber\",\n            \"houseNumberType\": \"interpolated\",\n            \"address\": {\n                \"label\": \"1400 W Galer St, Seattle, WA 98119, United States\",\n                \"countryCode\": \"USA\",\n                \"countryName\": \"United States\",\n                \"state\": \"Washington\",\n                \"county\": \"King\",\n                \"city\": \"Seattle\",\n                \"district\": \"Interbay\",\n                \"street\": \"W Galer St\",\n                \"postalCode\": \"98119\",\n                \"houseNumber\": \"1400\"\n            },\n            \"position\": {\n                \"lat\": 47.63225,\n                \"lng\": -122.37591\n            },\n            \"access\": [\n                {\n                    \"lat\": 47.63215,\n                    \"lng\": -122.37578\n                }\n            ],\n            \"mapView\": {\n                \"west\": -122.37724,\n                \"south\": 47.63135,\n                \"east\": -122.37458,\n                \"north\": 47.63315\n            },\n            \"scoring\": {\n                \"queryScore\": 0.99,\n                \"fieldScore\": {\n                    \"city\": 1.0,\n                    \"streets\": [\n                        0.87\n                    ],\n                    \"houseNumber\": 1.0\n                }\n            }\n        },\n        ... If an address maps to multiple results, they will all be standardized and formatted. The queryScore and fieldScore show how closely the results match the input and you can use these values to select the closest match. We are actively working on improving the scoring mechanism so stay tuned for the updates! Tip : For improving address data in larger datasets we recommend using batch geocoding so you can make fewer queries. If you are interested in using HERE Batch Geocoder, contact us for a plan that supports storing results from geocodes. Ready to get started? You can sign up for a free account and try geocoding today. Follow us on Twitter @heredev for more updates and share what you’re working on with us.", "date": "2020-08-03"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.17 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.17-release", "abstract": "Highlights Usage Dashboard Changes Usage reporting in the platform is now shown based on currency rather than on HERE Credit Units which have been retired. This enables a more transparent and granular approach to pricing. We are also shifting the billing periods from “anniversary billing” to “calendar monthly billing”. Please note, that on the Usage Dashboard and Rate History pages, the rates and amounts are now shown as list price for the platform in dollars or euros, depending on the billing currency in your contract. In summary, the following changes on the platform usage dashboards: The platform usage dashboard is replaced with a direct conversion of your usage per resource to an actual $/EUR value. Usage is reported in calendar month instead of anniversary billing. A custom range view is still possible via the drop-down on the platform usage dashboard . The historical rates in the rate history dashboard have been converted to Dollars / Euros based on a $/EUR 65 list rate. For existing customers, contract and pricing terms already in place supersede rates published in the platform portal. The list rates are published as an aid for customers to compare relative usage between services billed based on dissimilar usage metrics (for example, the list rates normalize the comparative cost generation of service transactions  vs. GB of data transfer). Develop Stream Pipelines with Apache Flink 1.10.1 for better control over the memory configuration of Workers A new Stream-3.0.0 run-time environment with Apache Flink 1.10.1 is now available for creating Stream pipelines. With Stream-3.0.0, the Memory Model of Task Managers has changed in order to provide more control over the memory configuration of the Workers of a Stream pipeline. Include version 2.17 of the HERE Data SDK for Java & Scala in your pipeline project to start developing with this new environment and choose Stream-3.0.0 as the run-time environment while creating a pipeline version. Deprecated: The Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. The impact on existing Stream pipelines and the process of migrating to the Stream-3.0.0 run-time environment is available in the deprecation table at the bottom of this page. Use Direct Kafka metrics to better monitor and debug streaming data workflows Underlying Kafka Producer, Kafka Consumer \"Fetch\" and Direct Kafka connectivity related metrics are now accessible via the Data Client Library for data workflows with Flink and when using the Direct Kafka connector type (only). These metrics can be used to create custom dashboards in Grafana. Underlying Kafka Consumer metrics are also available for programmatic retrieval. With these metrics, you have more information to help you monitor and debug any of your streaming data workflows using Direct Kafka. Learn more here . Add Stream layers to multi-region configured catalogs as an additional data loss mitigation strategy This release supports adding Stream layers to multi-region catalogs. With this addition, it is possible to include Versioned, Volatile and Stream storage layers to multi-region catalogs. Catalogs can be configured to be multi-region upon initial catalog configuration/creation. Data stored in multi-region catalogs is replicated to a second region mitigating data loss in the event the primary region experiences a downtime event. Note: Additional charges apply: Storage charges double when storing data in a second region. Data I/O charges increase 2.5 to 4 times, depending on the size of the objects you’re uploading: less for fewer large objects, more for many small objects. This is due to the validation HERE performs to ensure successful replication. Learn more about multi-region catalogs and associated costs here . Access additional HERE map attributes via the Location Library for fast random access Additional attributes have been compiled to Optimized Map for Location Library so they can be accessed much faster in random access scenarios via the Location Library: GradeCategory and Scenic from the Advanced Navigation Attributes layer and Elevation from the ADAS Attributes layer . Note: Elevation is currently restricted by Chinese authorities. Hence, it is not available in the HERE Map Content China catalog nor via the Location Library using its Optimized Map. We will continue to iteratively compile HERE Map Content attributes into the Optimized Map for Location Library enabling fast and simplified direct access to these attributes via the Location Library. Documentation with updated terminology following our new branding To move closer to one integrated HERE platform, we have continued the previously announced rebranding efforts. You’ll now see that documentation and most supporting materials reflect the rebranding changes we started several months ago as we seek to ensure a more seamless user experience. Examples of changes include: Former name New name Open Location Platform (OLP) HERE Workspace and HERE Marketplace OLP SDK for Java & Scala HERE Data SDK for Java & Scala OLP SDK for Python HERE Data SDK for Python OLP SDK for C++ HERE Data SDK for C++ OLP SDK for TypeScript HERE Data SDK for TypeScript Changes, Additions and Known Issues SDKs and tools Go to the HERE platform changelog to see all detailed changes to our CLI , the Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library . Web & Portal Issue: The custom run-time configuration for a Pipeline Version has a limit of 64 characters for the property name and 255 characters for the value. Workaround: For the property name, you can define a shorter name in the configuration and map that to the actual, longer name within the pipeline code. For the property value, you must stay within the limitation. Issue: Pipeline Templates can't be deleted from the Portal UI. Workaround: Use the CLI or API to delete Pipeline Templates. Issue: In the Portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version while the list is open for viewing. Workaround: Refresh the Jobs and Operations pages to see the latest job or operation in the list. Projects & Access Management Issue: A finite number of access tokens (~ 250) are available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Issue: Only a finite number of permissions are allowed for each app or user in the system across all services. It will be reduced depending on the inclusion of resources and types of permissions. Issue: All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There is no support for users or apps with limited permissions. For example, you cannot have a reduced role that can only view pipeline status, but not start and stop a pipeline. Workaround: Limit the users in a pipeline's group to only those users who should have full control over the pipeline. Issue: When updating permissions, it can take up to an hour for changes to take effect. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in both Workspace and Marketplace. Data Fixed: Issues with Metadata Storage billing were resolved where Metadata Storage tied to the use of Versioned and Index layers was not being charged / appearing on customer invoices. This fix will result in those charges now correctly appearing on invoices. Note that no storage costs have increased; associated increases in invoices are simply due to these charges now getting billed correctly. Issue: The changes released with 2.9 (RoW) and with 2.10 (China) to add OrgID to Catalog HRNs and with 2.10 (Global) to add OrgID to Schema HRNs could impact any use case (CI/CD or other) where comparisons are performed between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using vs what a Group, User or App has permissions to will  result in errors if the comparison is expecting results to match the old HRN construct.  With this change, Data APIs will return only the new HRN construct which includes the OrgID (e.g. olp-here…) so a comparison between the old HRN and the new HRN will be unsuccessful. Reading from and writing to Catalogs using old HRNs is not broken and will continue to work until July 31, 2020 . Referencing old Schema HRNs is not broken and will work into perpetuity. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including OrgID. Iss ue: Versions of the Data Client Library prior to 2.9 did not compress or decompress data correctly per configurations set in Stream layers. We changed this behavior in 2.9 to strictly adhere to the compression setting in the Stream layer configuration but when doing so, we broke backward compatibility wherein data ingested and consumed via different Data Client Library versions will likely fail. The Data Client LIbrary will throw an exception and, depending upon how your application handles this exception, could lead to an application crash or downstream processing failure. This adverse behavior is due to inconsistent compression and decompression of the data driven by the different Data Client Library versions. 2.10 introduces more tolerant behavior which correctly detects if stream data is compressed and handles it correctly. Workaround: In the case where you are using compressed Stream layers and streaming messages smaller than 2MB, use the 2.8 SDK until you have confirmed that all of your customers are using at least the 2.10 SDK where this Data Client Library issue is resolved, then upgrade to the 2.10 version for the writing aspects of your workflow. Issue: Searching for a schema in the Portal using the old HRN construct will return only the latest version of the schema.  The Portal will not show older versions tied to the old HRN. Workaround: Search for schemas using the new HRN construct OR lookup older versions of schemas by old HRN construct using the OLP CLI. Issue: Visualization of Index layer data is not yet supported Pipelines Deprecated: pipeline_jobs_canceled metric used within the Pipeline Status Dashboard is now deprecated. See the details in the Deprecation table at the bottom of this page. Issue: A pipeline failure or exception can sometimes take several minutes to respond. Issue: Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and will show an error message about the missing catalog. Re-check the missing catalog or use a different catalog. Issue: If several pipelines are consuming data from the same Stream layer and belong to the same Group (pipeline permissions are managed via a Group), then each of those pipelines will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same Application ID. Workaround: Use the Data Client Library to configure your pipelines to consume from a single stream: If your pipelines/applications use the Direct Kafka connector, you can specify a Kafka Consumer Group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/applications will be able to consume all the messages from the stream. If your pipelines use the HTTP connector, we recommend you to create a new Group for each pipeline/application, each with its own Application ID. Issue: The Pipeline Status Dashboard in Grafana can be edited by users. Any changes made by the user will be lost when updates are published in future releases because users will not be able to edit the dashboard in a future release. Workaround: Duplicate the dashboard or create a new dashboard. Issue: For Stream pipeline versions running with the high-availability mode, in a rare scenario, the selection of the primary Job Manager fails. Workaround: Restart the stream pipeline. Map Content Added: additions to existing layers in the HERE Map Content catalog Added HighOccupancyVehicleLaneCondition to Lane Attributes partition Added DependentAccessType to AccessPermission Location Services Issue: Lack of usage reporting for Location Services released in version 2.10 (Routing, Search, Transit, and Vector Tiles Service) Workaround : Usage is being tracked at the service level.  Following the 2.12 release wherein usage reporting is expected to be in place, customers may request usage summaries for usage incurred between the 2.10 release and 2.12. Marketplace (Not available in China) Issue: There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, service will slow down across the board for all consumers who are reading from the External Service Gateway. Workaround: Contact technical support for help. Issue: Users do not receive stream data usage metrics when reading or writing data from Kafka Direct. Workaround: When writing data into a Stream layer, you must use the Ingest API to receive usage metrics. When reading data, you must use the Data Client Library, configured to use the HTTP connector type, to receive usage metrics and read data from a Stream layer. Issue: When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you are losing usage metrics, contact HERE technical support for assistance rerunning queries and validating data. Issue: Projects and all resources in a Project are designed for use only in Workspace and are unavailable for use in Marketplace. For example, a catalog created in a Platform Project can only be used in that Project. It cannot be marked as \"Marketplace ready\" and cannot be listed in the Marketplace. Workaround: Do not create catalogs in a Project when they are intended for use in the Marketplace. Summary of active deprecation notices across all components No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 July 31, 2020 Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after July 31, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after July 31, 2020. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before July 31, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after July 31, 2020. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 OrgID added to Schema HRN (Global) 2.10 December 2019 July 31, 2020 Deprecation Summary: References to pre-existing schemas created before this feature release will work with either new or old HRNs so those references are not impacted. New schemas created as of this feature release will support both HRN constructs for a period of (6) months or until June 30, 2020. After this time, only the new HRN construct will be supported. 3 Spark-ds-connector replaced by SDK for Java and Scala Spark Connector 2.12 February 2020 August 19, 2020 Deprecation Summary: The spark-ds-connector will be deprecated (6) months from this release on August 19, 2020. Please upgrade to the latest SDK for Python version before then to get the latest SDK for Java and Scala Spark Connector. 4 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 Deprecation Summary: Batch-2.0.0 run-time environment for Batch pipelines is now deprecated. Existing Batch pipelines that use the Batch-2.0.0 run-time environment will continue to operate normally until August 19, 2020. During this period, Batch-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Batch-2.0.0 environment, please use OLP SDK 2.11 or older. After August 19, 2020 we will remove the Batch-2.0.0 run-time environment and the pipelines still using it will be canceled. We recommend that you migrate your Batch Pipelines to the Batch-2.1.0 run-time environment to utilize the latest functionality and improvements. 5 Schema validation to be added 2.13 March 2020 September 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of September 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change indeed has at least read access to the existing schema associated with that layer (i.e. a user or application cannot reference or use a schema they do not have access to). If a non-existing or non-accessible schema is associated with any layer after this date, any attempt to update any configurations of that layer will fail. Please ensure all layers refer only to real, existing schemas, or contain no schema reference at all before September 30, 2020. It is possible to use the Config API to remove or altogether change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existing or non-accessible schemas will need to be updated by this date or they will fail. 6 Customizable Volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation Summary: The Volatile layer configuration option to set storage capacity as a \"Package Type\" will be deprecated within (6) months or by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations within (6) months of this feature release or by October 30, 2020. 7 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing Stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this period, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, please use Platform SDK 2.16 or older. After February 1, 2021 the Stream-2.0.0 run-time environment will be removed and the pipelines still using it will be canceled. We recommend that you migrate your Stream Pipelines to the new Stream-3.0.0 run-time environment to utilize the latest functionality and improvements. For more details about migrating an existing Stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For more details about our general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 8 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 Deprecation Summary: ‘pipeline_jobs_canceled’ metric used within the Pipeline Status Dashboard is now deprecated because it was tied to the Pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. After that date, the metric will be removed.", "date": "2020-07-28"},
{"website": "Here", "title": "Exploring Four Tools for Visualizing Map Data", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/exploring-four-tools-for-visualizing-map-data", "abstract": "HERE Technologies recently announced the release of Data Layers where they provide GeoJSON map data you can download and explore and I wanted to use this chance to try a few different tools to visualize this data. In this blog post, I’ll use HERE data layers and visualize that data using HERE Studio, ArcGIS, Tableau, and Kepler.gl and I’ll share my experience with the different features and limitations of each platform and how quickly I was able to get started with each of them. I'll use the traffic signs near Rosario, Argentina. HERE Studio I created a free HERE Account to use HERE Studio. I like how simple it was to get started, and that I was able to easily upload multiple data sets and visualize and compare them. HERE Studio allows for customizing the base map and marker shapes and colors. It also allows publishing your map and sharing it publicly with a link or embedding it to other web pages. One last fun feature that I liked was customizing the labels where I could display the labels based on different attributes in my data. For this example, I'm selecting the label based on the signType, but I could also select things like category of the sign and I'd have labels displaying: warning, regulating, or informing. Time to get started: ~5 minutes Account Registration: Free Account with 90 day trial Fun features: customizing the icon, uploading your own icon, publishing map and embedding in other websites, customizing label ArcGIS All I needed to do to get started with ArcGIS was incredibly easy and quick to get started besides the immediate step that was confusing: It wasn’t clear that I had to first click “modify map” to be able to add a layer. It did, however, provide an easy drag and drop option for CSV, TXT, and GPX files but my data was in GeoJSON format so I had to upload it as a layer. It, unfortunately, didn’t support larger datasets that I was able to visualize with HERE Studio and the functionalities were relatively limited. You could customize the pointer to some extent, but not much more than that. Time to get started: ~3 minutes Account Registration: No account required Fun features: Drag and drop option for some file types Kepler.gl I learned about Kepler.gl in a talk by Shan He, an ex Uber Engineer. Working with Kepler.gl was easy and fun. What stood out to me most was how easy it was to upload multiple datasets and visualize them together quickly on the map to find correlations. Time to get started: ~1 minute Account Registration: No account required Fun features: Beautiful visualizations for multiple datasets Tableau Working with Tableau took me the longest of all, but Tableau is quite powerful so we can forgive the delayed start. The part that I had the most difficulty with was choosing the latitude and longitude from the calculated data and it didn’t feel very intuitive but when I got things to work, I was able to get pretty exciting visualizations that I, unfortunately, can’t share here because I was busy with a few other projects after I first tried Tableau and my trial ended before I got a chance to take a screenshot. Time to get started: ~20 minutes Account Registration: Account required with 14 day trial Fun features: Powerful visualization capabilities Thanks for joining me today on exploring different visualization tools! Do you have any favorite tools for visualizing mapping data? Share y our thoughts with us on twitter .", "date": "2020-09-22"},
{"website": "Here", "title": "Five Popular Scenarios for Integrating Location Services with AWS", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/five-popular-scenarios-for-integrating-location-services-with-aws", "abstract": "If you are a developer working with Amazon Web Services (AWS) and looking to integrate maps and location data, I'll show you in this post five popular scenarios you can integrate HERE Location Services with the AWS platform. At the end of this post, you will find an on-demand video discussing these in more detail. Let's go! 1. Web Sites Amazon has many options for developers to create/host a website as shown in this screen capture: Perhaps the most common use of location services is with a visual, interactive map seen on a web page. This is possible with our Maps API for JavaScript . Alternatively, web applications could also retrieve map images via API , as well as other location services . 2. Serverless Hosting and maintaining business logic with a serverless architecture is possible with AWS Lambdas . You could write your own serverless process from scratch, use a \"blueprint\", or select from one of many in the AWS Serverless Repository . If you want to create your own custom location services API wrapper, you could choose from what HERE offers in the repository as shown here: 3. AWS IoT With so many IoT devices out there, this has become a very popular scenario for using location services. AWS IoT provides the means to managing all those devices supporting your solution. HERE contributes with the integration of location services to help you track devices, create routes, and discover location information. HERE also provides integration for the various client types with our SDKs . 4. AWS Lex If automation with chat bots intrigues you, AWS Lex makes it easy to create one! And if you need to integrate location data in your conversational UX, simply use our APIs in the Lambda function which fulfills the processing of the chat bot. The screen capture below shows a simple chat bot configured to use a Lambda containing the needed API call to determine if an asset is in an area (geofencing). If you want to learn more, check out our blog and video ! 5. Alexa Voice interaction is more popular than ever before. Developers can target Alexa by creating skills that allow voice commands. When such skills require location services, this can be accomplished once again with simple API calls. Summary In this post, we briefly covered five popular scenarios where AWS developers could integrate HERE Location Services. You can learn more about this in our video below!", "date": "2020-07-30"},
{"website": "Here", "title": "Displaying Public Transport Stations in the Entire World", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/displaying-public-transport-stations-in-the-entire-world", "abstract": "In the previous blog post about HERE Advanced Map Data Sets, we talked about what they are and where to find them. In this post, let's explore how to use them. One of the easiest ways to start using these data sets is to display the data on your map. The JS API 3.1 has a wrapper which can help you do just that. But where do you start? Select a layer As a refresher from the last blog post, we will now get a list of all the layers that are available through the Advanced Map Data Sets API. GET  https://s.fleet.ls.hereapi.com/1/doc/layers.json?apiKey={{YOUR APIKEY}} On sending this call, we will get a long list of available layers and their attributes. What you want to look at are the objects name , type and featureMapping . ...\n    {\n        \"name\": \"PUBLIC_TRANSPORT_POI\",\n        \"type\": \"geom\",\n        \"tileLevel\": 13,\n        \"attributes\": [\n            \"PLACE_ID\",\n            \"NAMES\",\n            \"LINK_ID\",\n            \"CAT_ID\",\n            \"CAT_NAME\",\n            \"DISPLAY_LAT\",\n            \"DISPLAY_LON\",\n            \"SIDE_OF_STREET\",\n            \"PERCENT_FROM_REFNODE\",\n            \"POI_ID\",\n            \"LAT\",\n            \"LON\"\n        ],\n        \"featureMapping\": \"PDE-Base\"\n    },\n    {\n        \"name\": \"LOADING_ZONE_POI\",\n        \"type\": \"geom\",\n        \"tileLevel\": 13,\n        \"attributes\": [\n            \"POI_ID\",\n            \"CAT_ID\",\n            \"NAME\",\n            \"CHAIN_ID\",\n            \"LINK_ID\",\n            \"SIDE\",\n            \"LAT\",\n            \"LON\"\n        ],\n        \"featureMapping\": \"PDE-Premium-Truck-POI\"\n    },\n    {\n        \"name\": \"ROAD_NAME_FC1\",\n        \"type\": \"attr\",\n        \"tileLevel\": 9,\n        \"attributes\": [\n            \"LINK_ID\",\n            \"NAMES\"\n        ],\n        \"featureMapping\": \"PDE-Base\"\n    },\n    ... The name will give you the layer name to use in the next step. The type will either be geom - Geometry or attr - Attributes. With the JS wrapper, you should use the geometry layers. The featureMapping object tells you if the layer is available with the freemium account . I have selected the PUBLIC_TRANSPORT_POI layer for this example. Get layer details This and the previous step should be implemented only once. You won't need them in your main application, however I wanted to give you an idea of what information these datasets can give you. Once you have selected your layer, you need to get a few more details about it. To get this information, we will query the layer with the layer name. GET https://s.fleet.ls.hereapi.com/1/doc/layer.json?layer=PUBLIC_TRANSPORT_POI&apiKey={{YOUR APIKEY}} What you get is the description of the attributes in this layer, tileRequestsLevel , tileX and tileY . The tile system is a way to divide the location data in the world into chunks. The lower the level, fewer the number of chunks, larger the area these chunks cover. To make it simple, the tileRequestsLevel will give you the minimum zoom level of the map at which the data is available. The tileX and tileY values are the extent of the data tile. You can read about this in detail here . Meanwhile, let's use these values to display the data set. {\"description\":\"Layer contains Public Tranport POIs.\",\"attributes\":{\"PLACE_ID\":\"The Place ID is an identifier for a Place record. For published (blended) records, the Place ID is a unique identifier. For source records, the Place ID may or may not be unique as it can be provided by various suppliers. The Place ID contains a number of alphanumeric characters and hyphens.\nNULLABLE in case the POI has POI_ID\",\"NAMES\":\"List of all names for this object, in all languages, latin1/pinyin/phonetic transliterations.\nFor convenience, non-exonym base names are listed first.\nFormat:\nNAMES = NAME1 \\u001D NAME2 \\u001D NAME3 ...\nNAME = NAME_TEXT \\u001E TRANSLIT1 ; TRANSLIT2 ; ... \\u001E PHONEME1 ; PHONEME2 ; ...\nNAME_TEXT = LANGUAGE_CODE NAME_TYPE IS_EXONYM text\nTRANSLIT = LANGUAGE_CODE text\nPHONEME = LANGUAGE_CODE IS_PREFERRED text\nLANGUAGE_CODE is a 3 character string\nNAME_TYPE is one letter (A = abbreviation, B = base name, E = exonym, K = shortened name, S = synonym)\nIS_EXONYM = Y if the name is a translation into another language\nIS_PREFERRED = Y if this is the preferred phoneme.\n\nPlease note, the delimiters are:\n\\u001D between languages (NAMES level)\n\\u001E between name text, transliterations, and phonemes\n';' between different transliterations and phonemes of the same name.\nLanguage codes:\nALB : ALBANIAN\nAMT : ARMENIAN TRANSCRIBED\n...\nWEL : WELSH\nWEN : WORLD ENGLISH\n\nLanguage codes of transliterations:\nARX : ARMENIAN TRANSLITERATION\nASX : ASSAMESE TRANSLITERATION\nAZX : Azeri Transliteration\n...\nUKX : UKRAINIAN TRANSLITERATION\nVIX : VIETNAMESE TRANSLITERATION\n\",\"LINK_ID\":\"Permanent link ID. Positive 64 bit Integer that globally identifies the road, carto or building footprint link, also across map releases. Link IDs are never reused.\",\"CAT_ID\":\"Category ID of POI. Values:\n4013 - Train Station\n400-4000-4581 - Airport\n...\n400-4100-0348 - Bicycle Parking\n800-8500-0179 - Park and Ride\",\"CAT_NAME\":\"Category Name\",\"DISPLAY_LAT\":\"Latitude of the display position for the POI. Only published if it is different to LAT.\nNULLABLE.\",\"DISPLAY_LON\":\"Longitude of the display position for the POI. Only published if it is different to LON.\nNULLABLE.\",\"SIDE_OF_STREET\":\"Identifies the side of the street on which the POI is located.\nNULLABLE\nValues:\nL - LEFT\nR - RIGHT\nN - NEITHER\",\"PERCENT_FROM_REFNODE\":\"The location of a POI on a link (in terms of percentage from the reference node). -1 indicates that a Percent From Reference Node is unavailable for the POI\nNULLABLE\",\"POI_ID\":\"A permanent identifier that is unique across all published Core POIs.\nNULLABLE in case the POI has a PLACE_ID\",\"LAT\":\"Latitude coordinates [10^-5 degree WGS84] for the POI Coordinate of the location.\",\"LON\":\"Longitude coordinates [10^-5 degree WGS84] for the POI Coordinate of the location.\"},\"referencedStaticContents\":[],\"tileRequestsLevel\":13,\"tileX\":7481,\"tileY\":5358,\"isStaticContent\":false} Render the basic map To display the data layer on the map, we first need to render the map. Let's use the boilerplate JS code for rendering a web map. Do not forget to add your 'APIKEY'. Once we have the map set up, let's get our datasets fired up. Displaying datasets First things first. To use any of these layers, you need to get an instance of the HERE Platform Data Extension service. Next, we are going to create a Fleet Telematics Advanced Data Sets provider with the 'PUBLIC_TRANSPORT_POI' thematic layer, and render markers to display the layer. For doing this, we are going to use the layer name and the level which we noted in step 2. var service = platform.getPlatformDataService();\n\n    const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"21px\" height=\"21px\" viewBox=\"-0.5 -0.5 21 21\"><defs/><g><ellipse cx=\"10\" cy=\"10\" rx=\"5\" ry=\"5\" fill=\"#FAB800\" stroke=\"#000000\" pointer-events=\"none\"/></g></svg>`;\n    const icon = new H.map.Icon(svg);\n\n    \n    // create tile provider and layer that displays all public transport station POIs \n\n    var poiProvider = new H.service.extension.platformData.TileProvider(service,\n    {\n        layer: 'PUBLIC_TRANSPORT_POI', \n        level: 13\n    }, \n    {\n        resultType: \n            H.service.extension.platformData.TileProvider.ResultType.MARKER,\n            styleCallback(data) {\n                return icon;\n            }\n    });\n    var poiPoints = new H.map.layer.MarkerTileLayer(poiProvider);\n    map.addLayer(poiPoints); Now, we will add a tap event on these markers to display useful information. For this, I have selected the NAMES and CAT_NAME attributes of the layer as seen in step 2. // add events listener, that outputs data provided by the Platform Data Extension and\n    // associated with the H.map.Marker\n    poiProvider.addEventListener('tap', function(ev) {\n        if(ev.target instanceof H.map.Marker){\n            var markerData = ev.target.getData();\n            // Create an info bubble object at a specific geographic location:\n            // console.log(markerData)\n\n            let names = markerData.getCell('NAMES').split('DEUBN');\n\n            var bubble = new H.ui.InfoBubble(ev.target.getGeometry(), {\n                content: \n                    `<div><h3>Name: </h3></div>`+\n                    names[1]+\n                    `<div><h3>Category: </h3></div>`+\n                    markerData.getCell('CAT_NAME')\n            });\n\n            // Add info bubble to the UI:\n            ui.addBubble(bubble);\n        }\n    }); In this way, you will have displayed ALL the public transport points of interest in the WORLD instead of querying 100 at a time with the HERE Geocoding and Search API . Of course, I wouldn't recommend displaying geometries for the entire map in every application. The recommended way to use the HERE Fleet Telematics Advanced Data Sets API is the tile interface, with caching on the client side. In the next post about Advanced Maps Data Sets, I will talk about selectively displaying datasets for certain areas. In the meantime, check out Sayna's post about improving your address data with HERE Geocoding .", "date": "2020-07-29"},
{"website": "Here", "title": "Integrating Location Data into Pipedream Workflows", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/integrating-here-in-pipedream-workflows", "abstract": "Over the past few months, I've become somewhat enamored with a new service called Pipedream . Pipedream is yet another serverless solution with a bit of a twist. It makes it easy to build workflows by piecing together various actions like LEGO bricks. These actions are small pieces of programming logic that cover a wide variety of different services. You can connect these actions together along with the ability to write Node code for your own logic. For example, maybe you want to read in a Google Sheet, do sentiment analysis on the text, and then email a summary to a product team? Or perhaps monitor a RSS feed for new items and send a SMS message with an alert? Pipedream has an incredibly powerful, easy to use website that makes it easy to setup these workflows, share them with others, and modify when you find the need. I've been playing with Pipedream and have built many different workflows for my own needs. This week I created something that I think could be really powerful for people who take a lot of pictures - automatic geographic sorting. Before I go into the code for this, let me demonstrate how this works. In my Documents directory, I've got a folder called Photos: I can then upload an image (or use the integrated operating system client): In a few seconds, the image automatically disappears... and reappears in a new folder, GeoSortedPhotos/Louisiana/Lafayette: And if I were to go back in time and find a photo from my visit to Galaxy's Edge, I see it sorted in Florida/Orlando: How did I create this incredible work of programming wizardry? By connecting a few Pipedream actions with a bit of integration of the HERE Reverse Geocoding service. All in all the process took roughly thirty minutes. Let me walk you through the steps. Every workflow begins with a trigger, basically a way to define how the workflow starts. Pipedream supports many different types of triggers with a simple \"here is a URL to hit\" HTTP trigger being the simplest. On the more powerful side, Pipedream supports what are known as \"event sources\", these are triggers that act as responses to various services. One of them is the Dropbox source. I began by selecting this source, logging in to my Dropbox account, and then specifying the folder to check. Note the link to edit the code and configuration. Every Pipedream action, trigger, or event source you work with is 100% editable, letting you make tweaks if you need something custom. When I had this event source trigger selected, I could immediately begin testing. Pipedream provides a way to look at all invocations of the workflow and inspect the data at each step. So, with just this one part in place, I was able to upload a photo and see how the data looked. See that \"media_info\" block in there? If we expand it, and keep expanding, we get to the location data: That's what I need! For my next step, I added a Node.js step. This is a generic \"write the code you need\" step. (As an aside, I plan on contributing HERE steps to Pipedream to make it even easier to use HERE APIs in Pipedream!) All I needed in my step was a bit of code to hit the Reverse Geocode endpoint. async (event, steps) => {\n    const fetch = require('node-fetch');\n    const key = process.env.HERE_API_KEY;\n\n    if(steps.trigger.event['.tag'] !== 'file') $end('wrong type = ' + steps.trigger.event['.tag']);\n    let loc = steps.trigger.event.media_info.metadata.location.latitude + ',' + \n            steps.trigger.event.media_info.metadata.location.longitude;\n\n    let url = `https://revgeocode.search.hereapi.com/v1/revgeocode?apikey=${key}&at=${loc}`;\n\n    let resp = await fetch(url);\n    let data = await resp.json();\n    return data.items[0];\n} For the most part this is pretty simple usage of the API but pay special attention to steps.trigger.event['.tag] . One of the things I discovered was that the event source triggered for any file change in the folder, including deletes. When a file was added, the value was file so if the value is anything but that, I use a special Pipedream utility available $end to stop the workflow from continuing. I then fire off the call to reverse geocode the longitude and latitude. When done, I return the result. Now, my intent is to take the location and move my pictures to a folder named /STATE/CITY/ . I need a bit more Node.js code for that and instead of just adding code here, I built another step. While Pipedream doesn't care how you organize your workflows, I like to each function does just one task. So I made another step where the sole purpose was to figure out the destination folder: async (event, steps) => {\n    let destPath = `/documents/geosortedphotos/${steps.reversegeocode.$return_value.address.state}/${steps.reversegeocode.$return_value.address.city}/`;\n    let filename =  steps.trigger.event.path_lower.split('/').pop();\n    destPath += filename;\n    return destPath;\n} Notice how I have access to the previous step using the variable steps . All your steps and their outputs are available to later steps. I also have access to the first trigger and use the path_lower value to get the original filename. The end result is a new path based on the state and city. The last step was simple. There's a Dropbox action for moving files. I added that and literally just supplied two values: It may be terribly obvious, but the 'white box' after the values is meant to give you an idea of what the input will look like. As you use a Pipedream workflow, it learns what kind of data flows through it and begins to intelligently offer help to you in a way that's almost creepy in its accuracy. And that's it! My workflow is incredibly brittle, but that's my fault, not Pipedream's. For example, I noticed what I assume has to be a security setting on my work laptop that images I downloaded had the location data stripped. The same photo downloaded on my personal machine didn't have this issue. I could easily add support for noticing this and ending the workflow early. Also, it obviously expects an American state and city. It wouldn't be hard to make this use a country/state (or province)/city approach. I could also support cases where a photo couldn't be located and move it into another bucket. I could then use another Pipedream workflow to notice changes to that folder and email a human to do organization manually. One of the coolest aspects of Pipedream though is how easy it is to share workflows with others. You can see the entirety of my workflow here - https://pipedream.com/@raymondcamden/geosortphotos-p_8rCPgn/ . None of my credentials will be exposed and even better, in one click you can copy this to your Pipedream account and start playing it. Pipedream is currently free, and of course we offer a generous free tier if you sign up on our portal.", "date": "2020-07-23"},
{"website": "Here", "title": "Deep Dive Into HERE Data Layers -Part 1", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/deep-dive-into-here-data-layers-part-1", "abstract": "HERE Data Layers launched last week and I can't wait to tell you all about it. In this blog post, we will talk about the layers in detail focusing on Administrative Divisions, Buildings, Destination Signs, Hydrography and Land Cover. As Ray explained in his introduction blog post , this product gives you access to core map GIS data directly in the GeoJSON format. Now let’s get into the details of what data is included in each layer in terms of geometry and properties. Administrative Divisions The administrative division layer gives the hierarchical administrative subdivisions such as Country, State, Province, District, County, etc. This is useful to resolve addresses into their district, city, county names. This layer also gives you the geographic boundaries of the administrative areas. As the layer is in the GeoJSON format, the areas are provided in the geometry object with type Polygon or MultiPolygon . This layer includes properties: names country adminLevel objectType featureType governmentCode isoCountryCode countryMetadata This layer can be used to clean up address data, highlight certain areas to display statistics and can be used with other layers to generate customized map solutions. Below is a sneak peek into the GeoJSON file of the Berlin Administrative layer. {\n                  \"id\": \"20187403\",\n                  \"type\": \"Feature\",\n                  \"properties\": {\n                    \"names\": [\n                      {\n                        \"name\": \"베를린\",\n                        \"nameType\": \"EXONYM\",\n                        \"languageCode\": \"KOR\",\n                        \"transliterations\": [\n                          {\n                            \"name\": \"Be Reul Rin\",\n                            \"transliterationType\": \"KOX\"\n                          }\n                        ]\n                      },\n                      {\n                        \"name\": \"柏林\",\n                        \"nameType\": \"EXONYM\",\n                        \"languageCode\": \"CHI\",\n                        \"transliterations\": [\n                          {\n                            \"name\": \"Bo Lin\",\n                            \"transliterationType\": \"PYN\"\n                          }\n                        ]\n                      },\n                      {\n                        \"name\": \"Берлін\",\n                        \"nameType\": \"EXONYM\",\n                        \"languageCode\": \"UKR\",\n                        \"transliterations\": [\n                          {\n                            \"name\": \"Berlin\",\n                            \"transliterationType\": \"UKX\"\n                          }\n                        ]\n                      },\n                      \n                    ],\n                    \"country\": \"20147700\",\n                    \"adminLevel\": 50,\n                    \"objectType\": \"AdministrativeArea\",\n                    \"childPlaces\": [\n                      \"20187415\",\n                      \"20328178\",\n                      \"20328165\",\n                      ...\n                      \"28145324\",\n                      \"28146052\",\n                      \"28148777\"\n                    ],\n                    \"featureType\": \"Admin\",\n                    \"parentplaces\": [\n                      \"20187402\"\n                    ],\n                    \"governmentCode\": \"0\",\n                    \"isoCountryCode\": \"DEU\",\n                    \"countryMetadata\": {\n                      \"ebuCode\": \"D\",\n                      \"timeZone\": {\n                        \"dstEndTime\": 300,\n                        \"dstObserved\": \"YES\",\n                        \"dstStartTime\": 200,\n                        \"timeZoneOffset\": \"010\"\n                      },\n                      \"drivingSide\": \"RIGHT\",\n                      \"currencyType\": \"EUR\",\n                      \"maxAdminLevel\": 5,\n                      \"unitOfMeasure\": \"METRIC\",\n                      \"speedLimitUnit\": \"KMH\",\n                      \"countryCode2Char\": \"DE\",\n                      \"phoneCountryCode\": [\n                        \"49\"\n                      ],\n                      \"currencyPrecision\": 2,\n                      \"houseNumberPlacement\": \"AFTER\",\n                      \"adminLevelDescriptions\": [\n                        {\n                          \"adminType\": \"COUNTRY\",\n                          \"adminLevel\": 10,\n                          \"adminTypeNames\": [\n                            {\n                              \"name\": \"Country\",\n                              \"languageCode\": \"GER\"\n                            }\n                          ]\n                        },\n                        {\n                          \"adminType\": \"STATE/PROVINCE\",\n                          \"adminLevel\": 20,\n                          \"adminTypeNames\": [\n                            {\n                              \"name\": \"Bundesland\",\n                              \"languageCode\": \"GER\"\n                            }\n                          ]\n                        },\n                        {\n                          \"adminType\": \"COUNTY/REGION\",\n                          \"adminLevel\": 30,\n                          \"adminTypeNames\": [\n                            {\n                              \"name\": \"Kreis\",\n                              \"languageCode\": \"GER\"\n                            }\n                          ]\n                        },\n                        {\n                          \"adminType\": \"MUNICIPALITY\",\n                          \"adminLevel\": 50,\n                          \"adminTypeNames\": [\n                            {\n                              \"name\": \"Gemeinde\",\n                              \"languageCode\": \"GER\"\n                            }\n                          ]\n                        },\n                        {\n                          \"adminType\": \"CITY/TOWN\",\n                          \"adminLevel\": 60,\n                          \"adminTypeNames\": [\n                            {\n                              \"name\": \"Settlement\",\n                              \"languageCode\": \"GER\"\n                            }\n                          ]\n                        }\n                      ]\n                    },\n                    \"@ns:com:here:xyz\": {\n                      \"tags\": [],\n                      \"space\": \"P0UcTK5b\",\n                      \"createdAt\": 1599633826840,\n                      \"updatedAt\": 1599633826840\n                    },\n                    \"defaultLanguageCode\": \"GER\",\n                    \"@ns:com:here:mom:meta\": {\n                      \"layerId\": \"admin-divisions\",\n                      \"sourceId\": \"here-product-primitives-admin-regions-GeoJSON-ext-v1\",\n                      \"modelVersion\": \"1.0.0\",\n                      \"catalogVersion\": 34\n                    }\n                  },\n                  \"geometry\": {\n                    \"type\": \"MultiPolygon\",\n                    \"coordinates\": [\n                      [\n                        [\n                          [\n                            13.41812,\n                            52.37615,\n                            0\n                          ],\n                          [\n                            13.41792,\n                            52.37616,\n                            0\n                          ],\n                          [\n                            13.41286,\n                            52.37645,\n                            0\n                          ],\n                          ...\n                          [\n                            13.18345,\n                            52.47647,\n                            0\n                          ],\n                          [\n                            13.18364,\n                            52.47608,\n                            0\n                          ],\n                          [\n                            13.18412,\n                            52.47579,\n                            0\n                          ]\n                        ]\n                      ]\n                  ]\n                  } \n              } Buildings The buildings layer contains the 2-D footprint of the buildings along with attributes like height and building type. You can find the areas describe as Polygon and MultiPolygon in the geometry. You can use this layer for planning where to open a new store, combine it with the Traffic Signs Layer to find out if a place needs a traffic sign or even print a 3D model of the city skyline. {\n              \"id\": \"72512103\",\n              \"type\": \"Feature\",\n              \"properties\": {\n                \"names\": [\n                  {\n                    \"name\": \"Bundesministerium für Verteidigung\",\n                    \"nameType\": \"UNCLASSIFIED\",\n                    \"languageCode\": \"GER\"\n                  }\n                ],\n                \"footprints\": [\n                  {\n                    \"id\": 1,\n                    \"height\": 20.657285479457638\n                  },\n                  {\n                    \"id\": 2,\n                    \"height\": 12.121442065272825\n                  },\n                  {\n                    \"id\": 3,\n                    \"height\": 12.121442065272825\n                  }\n                ],\n                \"featureType\": \"Building\",\n                \"buildingType\": [\n                  {\n                    \"type\": 2005250,\n                    \"typeDescription\": \"Government Building/Landmark\"\n                  }\n                ],\n                \"isoCountryCode\": \"DEU\",\n                \"@ns:com:here:xyz\": {\n                  \"tags\": [],\n                  \"space\": \"nxZ7CcI3\",\n                  \"createdAt\": 1599633822514,\n                  \"updatedAt\": 1599633822514\n                },\n                \"@ns:com:here:mom:meta\": {\n                  \"layerId\": \"buildings\",\n                  \"sourceId\": \"here-product-primitives-buildings-GeoJSON-ext-v1\",\n                  \"modelVersion\": \"1.0.0\",\n                  \"catalogVersion\": 37\n                }\n              },\n              \"geometry\": {\n                \"type\": \"MultiPolygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      [\n                        13.36106321,\n                        52.50623019,\n                        0\n                      ],\n                      [\n                        13.3874349,\n                        52.52640831,\n                        0\n                      ]....\n                    ]\n                  ]\n                ]\n                }\n              }, Destination Signs The destination signs layer as the name suggests, gives information about the destination signs along the road. Okay, I understand this sounds like \" destination signs has destination signs\" but hear me out. The boards that you see along the road which indicate that the road goes towards a certain district, or that this road branches out to highway no A11, these are destination signs. The Destination Signs Map Data Layer lists the various destinations visible on a sign shield and relates such destinations to a specific path in the road network. These are handy to use in the in-car navigation on a bad weather day. You don't have to then depend on visibility to see the actual sign. You can see the digital version of the sign instead. The geometry of this layer contains MultiLineString data. Below is a sneak peek into the Berlin Destination Signs layer. {\n              \"id\": \"701265911\",\n              \"type\": \"Feature\",\n              \"properties\": {\n                \"category\": \"GUIDING\",\n                \"sourceLink\": \"1198583726\",\n                \"featureType\": \"DirectionSign\",\n                \"destinations\": [\n                  {\n                    \"signEntries\": [\n                      {\n                        \"entryType\": \"TOWARD\",\n                        \"signTexts\": [\n                          {\n                            \"text\": \"Reichstag\",\n                            \"languageCode\": \"GER\"\n                          }\n                        ]\n                      }\n                    ],\n                    \"destinationLink\": \"733098873\"\n                  },\n                  ...\n                    {\n                      \"entryType\": \"BRANCH\",\n                      \"signRoutes\": [\n                        {\n                          \"routeText\": {\n                            \"text\": \"B96\",\n                            \"languageCode\": \"GER\"\n                          }\n                        }\n                      ]\n                    }\n                    ],\n                    \"destinationLink\": \"1242355280\"\n                  },\n                  {\n                    \"signEntries\": [\n                      {\n                        \"entryType\": \"TOWARD\",\n                        \"signTexts\": [\n                          {\n                            \"text\": \"Charlottenburg\",\n                            \"languageCode\": \"GER\"\n                          }\n                        ]\n                      },\n                    ]\n                    \"destinationLink\": \"770381354\"\n                  }\n                ],\n                \"isoCountryCode\": \"DEU\",\n                \"@ns:com:here:xyz\": {\n                  \"tags\": [],\n                  \"space\": \"SLXiaUjG\",\n                  \"createdAt\": 1599633817990,\n                  \"updatedAt\": 1599633817990\n                },\n                \"@ns:com:here:mom:meta\": {\n                  \"layerId\": \"destination-signs\",\n                  \"sourceId\": \"here-product-primitives-destination-signs-GeoJSON-ext-v1\",\n                  \"modelVersion\": \"1.0.0\",\n                  \"catalogVersion\": 34\n                }\n              },\n              \"geometry\": {\n                \"type\": \"MultiLineString\",\n                \"coordinates\": [\n                  [\n                    [\n                      13.37136,\n                      52.51078,\n                      0\n                    ],\n                    [\n                      13.37123,\n                      52.51114,\n                      0\n                    ]\n                  ],\n                  [\n                    [\n                      13.37123,\n                      52.51114,\n                      0\n                    ],\n                    [\n                      13.37128,\n                      52.51115,\n                      0\n                    ],... \n                  ]\n                ]\n              }\n            }... Hydrography The hydrography layer contains the water bodies in the area. This includes geometry objects for oceans, rivers, bays, lakes etc. This layer is a mixture of geometry types MultiPolygon and MultiLineString . Apart from visualization, you can use this layer applications like nautical routing, flood management, city planning and many more. This is what the layer looks like. {\n              \"id\": \"56276170\",\n              \"type\": \"Feature\",\n              \"properties\": {\n                \"cartoName\": [\n                  {\n                    \"name\": \"Spreekanal\",\n                    \"nameType\": \"OFFICIAL\",\n                    \"languageCode\": \"GER\"\n                  }\n                ],\n                \"cartoType\": 500414,\n                \"featureType\": \"Carto\",\n                \"displayClass\": 4,\n                \"cartoTypeName\": \"Canal/Water Channel\",\n                \"@ns:com:here:xyz\": {\n                  \"tags\": [],\n                  \"space\": \"AwttqR0Y\",\n                  \"createdAt\": 1599633816880,\n                  \"updatedAt\": 1599633816880\n                },\n                \"@ns:com:here:mom:meta\": {\n                  \"layerId\": \"hydrography\",\n                  \"sourceId\": \"here-product-primitives-cartography-GeoJSON-ext-v1\",\n                  \"modelVersion\": \"1.0.0\",\n                  \"catalogVersion\": 38\n                }\n              },\n              \"geometry\": {\n                \"type\": \"MultiPolygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      [\n                        13.4058,\n                        52.51151,\n                        0\n                      ],\n                      [\n                        13.40484,\n                        52.51139,\n                        0\n                      ],..\n                    ]\n                  ]\n                ]\n              }\n            }... Land Cover The Land Cover layer tells you about where the woodlands, grasslands, deserts and glaciers are. It also gives you polygons representing the coverage of this topography. You can use this layer for mapping hiking trails and in applications like agricultural planning, wildlife preservation and many more. {\n              \"id\": \"1549217291\",\n              \"type\": \"Feature\",\n              \"properties\": {\n                \"cartoType\": 300100000,\n                \"featureType\": \"Carto\",\n                \"cartoTypeName\": \"Woodland\",\n                \"isoCountryCode\": \"GBR\",\n                \"@ns:com:here:xyz\": {\n                  \"tags\": [],\n                  \"space\": \"B29ugFXr\",\n                  \"createdAt\": 1599634129918,\n                  \"updatedAt\": 1599634129918\n                },\n                \"@ns:com:here:mom:meta\": {\n                  \"layerId\": \"land-cover\",\n                  \"sourceId\": \"here-product-primitives-cartography-geojson-ext-v1\",\n                  \"modelVersion\": \"1.0.0\",\n                  \"catalogVersion\": 38\n                }\n              },\n              \"geometry\": {\n                \"type\": \"MultiPolygon\",\n                \"coordinates\": [\n                  [\n                    [\n                      [\n                        -2.279181,\n                        53.514931,\n                        0\n                      ],...\n                      [\n                        -2.282083,\n                        53.515417,\n                        0\n                      ],\n                      [\n                        -2.281525,\n                        53.515831,\n                        0\n                      ],\n                      [\n                        -2.279181,\n                        53.514931,\n                        0\n                      ]\n                    ]\n                  ]\n                ]\n              }\n            }, These were just 5 of the 10 layers available under the freemium plan . Stay tuned for the blog post from Sayna to know more about the rest of the HERE Data Layers. If you want to start using them already, head over to the documentation and give them a whirl.", "date": "2020-09-23"},
{"website": "Here", "title": "Using JavaScript to Simulate Transport in Supply Chain Scenario", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/using-javascript-to-simulate-transport-in-supply-chain-scenario", "abstract": "In a recen t post, we announced the AWS Connections – Supply Chain series . In this post, we are going to exp lore how we built the transportation component of the supply chain scen ario. Each delivery oper ator logs in, and movement is captured via drag-n-drop. Each time the icon/marker representing the transportation vehicle is ‘dropped’ on the map, it’s coordinates are communicated via MQTT to AWS IoT and on to any subscribed to the topic . Let’s examine each feature one at a time. Building a Web Page per Deliver y Operator The base HTML for transportation is as follows: <html> <head> <title>Transportation</title> <meta name=\"viewport\" content=\"width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=yes\"> <meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\"> <!-- HERE JS V3.1 --> <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" /> <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script> <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script> <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script> <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> <!-- Resources for AWS IoT --> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core-min.js\" type=\"text/javascript\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/hmac-min.js\" type=\"text/javascript\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/sha256-min.js\" type=\"text/javascript\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js\" type=\"text/javascript\"></script> <style> body {padding: 0; margin: 0;} #transportId {z-index: 99;position: absolute; top: 10px;left:10px;} #mapContainer {width: 100vw; height: 100vh; display:none;} </style> </head> <body> <select id=\"transportId\"> <option value=\"00\">Select Transport Vehicle...</option> <option value=\"delivery01\">Transport Vehicle 01</option> <option value=\"delivery02\">Transport Vehicle 02</option> <option value=\"delivery03\">Transport Vehicle 03</option> </select> <div id=\"mapContainer\"></div> <script type=\"module\" src=\"./appTransport.js\"></script> </body> </html> Notice the initial style of the map is set in style as display:none , which prevents the map from initially being viewed. A drop down select element prompts the user to choose between three delivery operator options. When a selection is made, the following code is invoked: let deliveryOp = \"\";\nconst tranSelect = document.getElementById(\"transportId\");\ntranSelect.addEventListener('change', () => {\n    deliveryOp = tranSelect.value;\n    const iconTransport = new H.map.Icon(`./${deliveryOp}.png`);\n    const dragMarker = new H.map.Marker(initPoint,{icon:iconTransport}, {volatility:true}); \n    dragMarker.draggable = true;\n    map.addObject(dragMarker);\n    container.style.display = \"initial\";\n    map.getViewPort().resize();\n    console.log(\"end change\");\n}); Once a selection is made, the map is now visible by resetting it's style to \"initial\". Also, each delivery operator has a unique icon used to represent it on the map, which is determined by the user selection. Here are the names/images of the icons which are loaded into the marker: delivery01.png delivery02.png delivery03.png Note when the marker is added to the map, it is enabled for drag-n-drop behavior. However, more code is needed to make it work. Let’s see how this is implemented. Adding Drag -n-Drop Behavior Three methods need to be added to the code to successfully drag-n-drop the marker arou nd. The first method handles the initial “pick up” of the marker as seen here: map.addEventListener('dragstart', function(ev) {\n        var target = ev.target,\n            pointer = ev.currentPointer;\n        if (target instanceof H.map.Marker) {\n        var targetPosition = map.geoToScreen(target.getGeometry());\n        target['offset'] = new H.math.Point(pointer.viewportX - targetPosition.x, pointer.viewportY - targetPosition.y);\n        behavior.disable();\n        }\n    }, false); The next method is called for every movement made by the user while the marker is being dragged as seen here: map.addEventListener('drag', function(ev) {\n    var target = ev.target,\n        pointer = ev.currentPointer;\n    if (target instanceof H.map.Marker) {\n        target.setGeometry(map.screenToGeo(pointer.viewportX - target['offset'].x, pointer.viewportY - target['offset'].y));\n    }\n}, false); The final method is called when the user “let’s go” of the marker, thus dropping it on map as seen here : map.addEventListener('dragend', function(ev) {\n    let target = ev.target;\n    if (target instanceof H.map.Marker) {\n        processMarker(target);\n    }\n}, false); As shown above, when the marker is dropped, it calls another method to process the information . Let’s explore that in more detail. Processing Marker Location Data Here is the code for the processMarker method: function processMarker(marker) {\n    behavior.enable();\n    const markerPoint = marker.getGeometry();\n    let message = getGeoLabel(markerPoint)}\n    const bubble =  new H.ui.InfoBubble(markerPoint,{content: message});\n    ui.addBubble(bubble);\n    client.publish(`sc/transport/${deliveryOp}`, \n    {operator: deliveryOp, geo: markerPoint});\n    map.setCenter(markerPoint,true);\n} Because the code validates the event target to be an instance of a marker, we can now call the getGeometry method to receive the geolocation as a Point object. Another helper function is called to create a friendly viewing of the coordinates . Here is the code for that method: function getGeoLabel(point) {\n    return \"\" + Math.abs(point.lat.toFixed(4)) +\n    ((point.lat > 0) ? 'N' : 'S') +\n    ' ' + Math.abs(point.lng.toFixed(4)) +\n    ((point.lng > 0) ? 'E' : 'W');\n} A nother aspect of the processMarker method is publishing the data via MQTT to the topic \" sc/transpo rt/delivery##\" where the ## is the number of the delivery operator who has logged i n . What is list ening to or subscribed to that data? Find out in an upcoming blog post! To see the code above in action, don’t miss our episode on this to pic below!", "date": "2020-09-28"},
{"website": "Here", "title": "Using MQTT in JavaScript with AWS IoT", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/using-mqtt-in-javascript-with-aws-iot", "abstract": "This post is the third in a series dealing with supply chain solutions using HERE Location Services and AWS IoT Core . Need caught up? Here are the links to the first two posts: Getting Started with AWS and HERE in the Supply Chain Using JavaScript to Simulate Transport in Supply Chain Scenario Although the series has made mention of AWS IoT, this post will dig deeper into how it is all connected. Lets consider all the steps needed to make it work, starting with required sources. Add Scripts to HTML It is important to note - this post demonstrates how to get MQTT working in the browser client-side JavaScript , not a server-side approach. If you want information on doing something similar for server-side, please visit the AWS developer documentation . For our needs, you will need the following scripts added to the head section of your HTML page: <script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core-min.js\" type=\"text/javascript\"></script> \n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/hmac-min.js\" type=\"text/javascript\"></script> \n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/sha256-min.js\" type=\"text/javascript\"></script> \n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js\" type=\"text/javascript\"></script> The first three scripts contain cryptography functions we will need to help build our AWS IoT endpoint . The last script brings in the Paho.MQTT.Client object that will manage our MQTT communications. It is also noteworthy that it is not required to add a script to reference the AWS SDK . Initialize the MQTT Client In the client-side JavaScript attached to the HTML file with scripts above, create a function to initialize the MQTT client object as shown here: // gets MQTT client \nfunction initClient() {    \n    const clientId = Math.random().toString(36).substring(7); \n    const _client = new Paho.MQTT.Client(getEndpoint(), clientId);\n \n    // publish method added to simplify messaging \n    _client.publish = function(topic, payload) { \n        let payloadText = JSON.stringify(payload); \n        let message = new Paho.MQTT.Message(payloadText); \n        message.destinationName = topic; \n        message.qos = 0; \n        _client.send(message); \n    } \n    return _client; \n} The first line of code creates a unique client ID for communications. The next line creates an instance of the Paho.MQTT.Client object, passing in the endpoint (discussed next) and the unique ID created in the first line of code. The remainder of the code attaches a publish function to the client object to simplify use elsewhere in the code. The last line of code returns the adjusted instance to the calling code. Configure the Endpoint In the previous code snippet, a method called getEndpoint() was passed into the constructor of the Paho.MQTT.Client object. This is where the major work is done to properly configure and connect to AWS IoT. Here is the complete code for the method: function getEndpoint() { \n// WARNING!!! It is not recommended to expose \n// sensitive credential information in code. \n// Consider setting the following AWS values \n// from a secure source. \n\n    // example: us-east-1 \n    const REGION = \"your-aws-region\";   \n\n    // example: blahblahblah-ats.iot.your-region.amazonaws.com \n    const IOT_ENDPOINT = \"your-iot-endpoint\";  \n\n    // your AWS access key ID \n    const KEY_ID = \"your-key-id\"; \n\n    // your AWS secret access key \n    const SECRET_KEY = \"your-secret-key\"; \n\n    // date & time \n    const dt = (new Date()).toISOString().replace(/[^0-9]/g, \"\"); \n    const ymd = dt.slice(0,8); \n    const fdt = `${ymd}T${dt.slice(8,14)}Z` \n    \n  const scope = `${ymd}/${REGION}/iotdevicegateway/aws4_request`; \n    const ks = encodeURIComponent(`${KEY_ID}/${scope}`); \n    let qs = `X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=${ks}&X-Amz-Date=${fdt}&X-Amz-SignedHeaders=host`; \n    const req = `GET\\n/mqtt\\n${qs}\\nhost:${IOT_ENDPOINT}\\n\\nhost\\n${p4.sha256('')}`; \n    qs += '&X-Amz-Signature=' + p4.sign( \n        p4.getSignatureKey( SECRET_KEY, ymd, REGION, 'iotdevicegateway'), \n        `AWS4-HMAC-SHA256\\n${fdt}\\n${scope}\\n${p4.sha256(req)}`\n    ); \n    return `wss://${IOT_ENDPOINT}/mqtt?${qs}`; \n} Take a moment to ponder each line of code. Note right away the warning regarding placing your AWS credential information directly in the code. Consider using options that either allow “hiding” the values in files/storage not directly accessible, or by obtaining via a secured serverless API call. The code shown above is for demonstration purposes. The entire function results in the complete AWS IoT Endpoint needed for MQTT communications. Each occurrence of a p4 object is a wrapper to the cryptography scripts added to the HTML. Here is the p4 object defined: function p4(){} \np4.sign = function(key, msg) { \n    const hash = CryptoJS.HmacSHA256(msg, key); \n    return hash.toString(CryptoJS.enc.Hex); \n}; \np4.sha256 = function(msg) { \n    const hash = CryptoJS.SHA256(msg); \n    return hash.toString(CryptoJS.enc.Hex); \n}; \np4.getSignatureKey = function(key, dateStamp, regionName, serviceName) { \n    const kDate = CryptoJS.HmacSHA256(dateStamp, 'AWS4' + key); \n    const kRegion = CryptoJS.HmacSHA256(regionName, kDate); \n    const kService = CryptoJS.HmacSHA256(serviceName, kRegion); \n    const kSigning = CryptoJS.HmacSHA256('aws4_request', kService); \n    return kSigning; \n}; Creating the Client to Connect To use the code created so far, elsewhere it is recommended to create another function to prepare for connection. The following does just that: function getClient(success) { \n    if (!success) success = ()=> console.log(\"connected\"); \n    const _client = initClient(); \n    const connectOptions = { \n      useSSL: true, \n      timeout: 3, \n      mqttVersion: 4, \n      onSuccess: success \n    }; \n    _client.connect(connectOptions); \n    return _client;  \n} The getClient function takes in an optional parameter (named success ) which is another function to call if the connection succeeded. If no function is provided, an arrow function is created to exhibit a default behavior to log “connected” to console. The _client object is initialized from the initClient function defined earlier in this post. The connection options are defined in JSON and passed into the connect function. The client is then returned to the calling code. Let’s see how it is used! Using the MQTT Client The following init function sets the global client object to the return value of the getClient function: let client = {}; \nfunction init() { \n    client = getClient(); \n    client.onMessageArrived = processMessage; \n    client.onConnectionLost = function(e) { \n        console.log(e); \n    }  \n} The client is also configured to call on the processMessage function if it receives any communications. This will only happen if the client subscribes to a topic somewhere else in code, like this: client.subscribe(“sc/orders/”); The above line of code subscribes to any messages published to the “sc/orders” topic.Let’s now look a possible use of the processMessage function when it receives a message: function processMessage(message) { \n    let info = JSON.parse(message.payloadString); \n    const publishData = { \n        retailer: retailData, \n        order: info.order \n    }; \n    client.publish(\"sc/delivery\", publishData); \n} If a message is published to the “sc/orders” topic, it is parsed, and used with other information to now publish to the “sc/delivery” topic. In other words, once an order is received, it is now forwarded to the delivery company with all the details needed to get a product to the requesting consumer. This scenario is explained in much more detail in the video below!", "date": "2020-10-02"},
{"website": "Here", "title": "Mashing Up Data Hub and Points of Interest Search", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/mashing-up-data-hub-and-points-of-interest-search", "abstract": "Data Hub provides a powerful API for storing and working with geospatial data, but one of the best ways to make use of Data Hub is to mash it up with one of our other services. Today, I'm sharing an example of using data stored in Data Hub and integrating results from the powerful HERE Geocoding and Search API. We'll be paying special attention to the Browse endpoint. The Browse API lets you search for POIs (Points of Interest) filtered by one or more categories. The Category system is truly incredible, with a very long list of \"regular\" categories as well as a unique system just for types of food . As an example of how detailed the food system gets, let’s take Asian cuisine. You can filter by over twenty different types of Asian food, and in those twenty plus categorizations, there's even more fine-grained specific categories such Northeastern Chinese.) For our demo, we're going to take an existing application using Data Hub data and enhance it with use of the Browse API. Our existing application will be using data from the National Parks Service list of parks in the United States of America. Yes, I'm using that again, because what can I say, when I find good data, I like to keep playing with it! In case you haven't seen any of my previous blog posts or online talks, the data consists of list of features that includes things like the park's name, open hours, URLs, and more. As geospatial data it obviously includes information about the location of the park as well. Here's one feature: { \n\"id\": \"0\", \n\"type\": \"Feature\", \n\"properties\": { \n    \"url\": \"https://www.nps.gov/frla/index.htm\", \n    \"name\": \"Frederick Law Olmsted\", \n    \"image\": \"https://www.nps.gov/common/uploads/structured_data/3C853BE9-1DD8-B71B-0B625B6B8B89F1A0.jpg\", \n    \"topics\": \"Civil War,Landscape Design,Schools and Education,Wars and Conflicts\", \n    \"fullName\": \"Frederick Law Olmsted National Historic Site\", \n    \"parkCode\": \"frla\", \n    \"activities\": \"Guided Tours,Junior Ranger Program,Museum Exhibits,Self-Guided Tours - Walking\", \n    \"description\": \"Frederick Law Olmsted (1822-1903) is recognized as the founder of American landscape architecture and the nation's foremost parkmaker. Olmsted moved his home to suburban Boston in 1883 and established the world's first full-scale professional office for the practice of landscape design. During the next century, his sons and successors perpetuated Olmsted's design ideals, philosophy, and influence.\", \n    \"designation\": \"National Historic Site\", \n    \"phoneNumber\": \"6175661689\", \n    \"weatherInfo\": \"Summer: Warm temperatures, average high temperature around 80 degrees Fahrenheit, often with humidity. July and August bring the hottest temperatures.\\nFall: Cooler temperatures, mean temperatures between 45 and 65 degrees Fahrenheit, sometimes rainy. Peak fall foliage is in mid-October.\\nWinter: Cold, with snow, average low temperature around 25 degrees Fahrenheit. \\nSpring: Cold to cool temperatures, average mean temperatures between 40 and 60 degrees Fahrenheit.\", \n    \"emailAddress\": \"frla_interpretation@nps.gov\", \n    \"directionsUrl\": \"http://www.nps.gov/frla/planyourvisit/directions.htm\", \n    \"directionsInfo\": \"Site is located on the southwest corner of Warren and Dudley Streets in Brookline, south of Route 9, near the Brookline Reservoir.\\n\\nSite is 0.7 miles from the Brookline Hills MBTA stop on the Green Line, D Branch.\", \n    \"@ns:com:here:xyz\": { \n        \"tags\": [ \n        \"national-parks-studio\" \n        ], \n        \"space\": \"yi9C54LG\", \n        \"version\": 0, \n        \"createdAt\": 1594238710406, \n        \"updatedAt\": 1594238710406 \n    } \n}, \n\"geometry\": { \n    \"type\": \"Point\", \n    \"coordinates\": [ \n        -71.13112957, \n        42.32550867, \n        0 \n    ] \n    } \n}, For my demo, I began by adding a simple map. const KEY = 'c1LJuR0Bl2y02PefaQ2d8PvPnBKEN8KdhAOFYR_Bgmw'; \nvar platform = new H.service.Platform({ \n    'apikey': KEY \n}); \n\n// Obtain the default map types from the platform object: \nvar defaultLayers = platform.createDefaultLayers(); \n\nvar map = new H.Map( \n    document.getElementById('mapContainer'), \n    defaultLayers.vector.normal.map, \n    { \n        zoom: 3, \n        center: { lat: 38.7984, lng: -96.3944 }, \n        pixelRatio: window.devicePixelRatio || 1 \n    } \n); \n\nvar behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map)); \n\n// Create the default UI: \nvar ui = H.ui.UI.createDefault(map, defaultLayers); From the top, I create an instance of our mapping platform, add default layers, select where in the DOM I want to render my map, and then create a map object. For my center position I just picked something that centered the map well for my American-centric data. Finally I add in some default behavior and UI elements. To add data from Data Hub, you only need a few lines of code: const XYZ_TOKEN = 'AHDIOVe6R6y1ry3kSAjeRQA'; \nconst service = platform.getXYZService({ \n    token: XYZ_TOKEN, \n}); \n\nconst XYZ_SPACE = 'yi9C54LG'; \nconst mySpaceProvider = new H.service.xyz.Provider(service, XYZ_SPACE, { \n}); \n\nconst mySpaceLayer = new H.map.layer.TileLayer(mySpaceProvider); \n\n// add a layer to the map \nmap.addLayer(mySpaceLayer); \n\nmySpaceProvider.getStyle().setInteractive(['xyz'], true); This sets up an instance of the XYZ service (the older name of Data Hub) using a token that provides read-only access to the data. I specify my space and create a provider object tied to it. I then make a new layer tied to the provider and finally add it to my map. The last line prepares the provider for interactivity. What interactivity? When you click, I want to create an \"info bubble\" (think a small popup) that will display information about the park. Let's look at that code: let bubble; \n\n// Add 'tap' event listener, that opens info bubble \nmySpaceProvider.addEventListener('tap', function (evt) { \n    let position = map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY), \n        data = evt.target.getData(); \n\n    if (!bubble) { \n        bubble = new H.ui.InfoBubble(position, { content: '' }) \n        ui.addBubble(bubble); \n    } \n\n    bubble.setContent(` \n    <div style=\"height:320px; overflow:auto;width: 320px;\"> \n    <h2>${data.properties['properties.name']}</h2> \n    <p>${data.properties['properties.description']}</p> \n    <img class=\"park\" src=\"${data.properties['properties.image']}\" title=\"Photo of Park\"> \n    </div>`); \n\n    bubble.setPosition(position); \n    bubble.open(); \n    map.setCenter(position, true);   \n\n}); I add a tap event to the provider. This event gets the location of the tap event as well as the data from the feature. Specifically the getData() call returns that information. If an info bubble hasn't been built yet, I initialize it with some blank text and add it to the UI. Next I set the content based on the park data. As you saw above, there's quite a bit there, but to keep it simple I displayed the name, description, and image. Here's an example of the map before anything is clicked. And here's how the info bubble looks. For a complete listing of this code, see the repository file here and you can play with an online version here . Alright, let's kick it up a notch! As I mentioned, the Search service and Browse API has a powerful category system. One of those categories is \"600-6900-0395\", which has a label of \"Camping-Hiking Shop\" and is described as \"A business that sells camping/hiking-related items, such as tents, sleeping bags and other accessories.\" If you wanted to find shops like this at a particular location, you would issue a GET request to: https://browse.search.hereapi.com/v1/browse?apiKey=${KEY}&at=${lat},${lng}&categories=600-6900-0395 Where KEY, lat, and lng, would be replaced with real values. This returns a list of possible matches near the location. Here's one example: { \n    \"title\": \"Keweenaw Base Camp\", \n    \"id\": \"here:pds:place:840f02uj-f0274bac17234621a132c54fed3e5ea2\", \n    \"resultType\": \"place\", \n    \"address\": { \n        \"label\": \"Keweenaw Base Camp, 14603 Love Lake Rd, Atlantic Mine, MI 49905, United States\", \n        \"countryCode\": \"USA\", \n        \"countryName\": \"United States\", \n        \"stateCode\": \"MI\", \n        \"state\": \"Michigan\", \n        \"county\": \"Houghton\", \n        \"city\": \"Atlantic Mine\", \n        \"street\": \"Love Lake Rd\", \n        \"postalCode\": \"49905\", \n        \"houseNumber\": \"14603\" \n    }, \n    \"position\": { \n        \"lat\": 47.1431, \n        \"lng\": -88.68881 \n    }, \n    \"access\": [ \n        { \n            \"lat\": 47.14336, \n            \"lng\": -88.68915 \n        } \n    ], \n    \"distance\": 124537, \n    \"categories\": [ \n        { \n            \"id\": \"800-8600-0000\", \n            \"name\": \"Sports Facility/Venue\", \n            \"primary\": true \n        }, \n        { \n            \"id\": \"550-5510-0378\", \n            \"name\": \"Campsite\" \n        }, \n        { \n            \"id\": \"600-6900-0395\", \n            \"name\": \"Camping/Hiking Shop\" \n        } \n    ], \n    \"references\": [ \n        { \n            \"supplier\": { \n                \"id\": \"core\" \n            }, \n            \"id\": \"1194049011\" \n        } \n    ], \n    \"contacts\": [ \n        { \n            \"mobile\": [ \n                { \n                    \"value\": \"+19062507219\" \n                }, \n                { \n                    \"value\": \"+19062810614\" \n                }, \n                { \n                    \"value\": \"+19064825240\" \n                } \n            ], \n            \"www\": [ \n                { \n                    \"value\": \"http://www.keweenaw.org\" \n                }, \n                { \n                    \"value\": \"https://campluther.com/kbc\" \n                } \n            ], \n            \"email\": [ \n                { \n                    \"value\": \"info@keweenaw.org\" \n                }, \n                { \n                    \"value\": \"marcus@campluther.com\" \n                } \n            ] \n        } \n    ] \n} As you can see, it's quite detailed. For our updated demo, let's see if we can enhance the park info bubbles to display nearby camping stores. First I created a simple constant for the category ID: const CAMP_STORE = '600-6900-0395'; The next change was to the tap handler. Here's the entirety of it and I'll explain the major changes: mySpaceProvider.addEventListener('tap', async evt => { \n    let position = map.screenToGeo(evt.currentPointer.viewportX, evt.currentPointer.viewportY), \n        data = evt.target.getData(); \n\n    if (!bubble) { \n        bubble = new H.ui.InfoBubble(position, { content: '' }) \n        ui.addBubble(bubble); \n    } \n\n    bubble.setContent(` \n    <div style=\"height:320px; overflow:auto;width: 320px;\"> \n    <h2>${data.properties['properties.name']}</h2> \n    <p>${data.properties['properties.description']}</p> \n    <img class=\"park\" src=\"${data.properties['properties.image']}\" title=\"Photo of Park\"> \n    <div id=\"storeInfo\"></div> \n    </div>`); \n\n    bubble.setPosition(position); \n    bubble.open(); \n    map.setCenter(position, true); \n\n    let stores = await loadStoreInfo(position); \n\n    let storeHTML = ` \n<h2>Nearby Camping Stores</h2> \n    `; \n\n    if(stores.length > 0) { \n        storeHTML += '<ul>'; \n        stores.forEach(s => { \n            storeHTML += `<li>${s.title} at ${s.address.label}</li>`; \n        }); \n\n        storeHTML += '</ul>'; \n\n    } else { \n        storeHTML += 'Unfortunately, there are no camping stores nearby.'; \n    } \n\n    document.querySelector('#storeInfo').innerHTML = storeHTML; \n}); The first real change is in the content of the bubble. There's a new empty div using the id storeInfo . After the bubble is opened, I then call out to a new function, loadStoreInfo , that returns camping stores by the park's location. I then generate new HTML to render those stores. What I displayed here was rather arbitrary, but I felt like the title and address label were enough. This new information is then injected into the bubble. The function to get stores merely wraps a call to the API: async function loadStoreInfo(pos) { \n    let url = `https://browse.search.hereapi.com/v1/browse?apiKey=${KEY}&at=${pos.lat},${pos.lng}&categories=${CAMP_STORE}&limit=10`; \n    let resp = await fetch(url); \n    let data = await resp.json(); \n    return data.items; \n} I should note that the JavaScript Maps library from HERE also has a search service wrapper built into it. This hides some of the details of using the search services and includes support for browse . Personally I just prefer using the fetch call as I know it better, but you've got options and can use what makes sense for you! Here's a quick example of how it looks: We could also take this a step further and provide navigation to those stores and even display those routes on the map. Feel free to fork my code and play with it. The source for this version may be found here and the online version is here .", "date": "2020-09-30"},
{"website": "Here", "title": "The HERE Knowledge Base is live!", "author": ["Laura Callahan"], "link": "https://developer.here.com/blog/the-here-knowledge-base-is-live", "abstract": "Finding the answers to your questions about HERE products or services is now easier with the HERE Knowledge Base . The Knowledge Base contains a library of articles to help improve your experience when you build with HERE. The team has looked at commonly asked questions from the community and curated the initial set of articles to help you get started or unstuck quickly. As more questions are posed on Stack Overflow or to our Technical Support team, we’ll expand the Knowledge Base to make sure that everyone in our developer community can get access to more answers in an easy to find way. We would love to hear your thoughts about what’s working and what you’d like to see next from the Knowledge Base and the HERE Team. You can drop us a line on Twitter , join our Developer Community on Slack , ask a question during our livestreams on Twitch , or fill out this form to share your thoughts with the HERE Team. Thanks in advance for your feedback on the new Knowledge Base, and for choosing HERE as your Location Platform. We can’t wait to see what you build next!", "date": "2020-09-30"},
{"website": "Here", "title": "Deep Dive Into HERE Data Layers - Part 2", "author": ["Sayna Parsi"], "link": "https://developer.here.com/blog/deep-dive-into-here-data-layers-part-2", "abstract": "At HERE, we want to enable our users to have control over their map data. To support this, HERE released Data Layers for you to easily visualize and download mapping data for over 60 locations around the world. Let's explore Data layers and take a peek at the data that powers many of our services. HERE Map Data Layers, as the name suggests, contains multiple layers and each layer contains different types of mapping data . In the first part of this two-part series , you can find information about hydrography, destination signs, bu ildings and more. In this blog post, we’ll cover the following layers: Land Use Navigable Roads Places Traffic Restrictions Traffic Signs Land use The Land Use Map Data Layer contains cartographic content related to the functional usage of the land; it classifies areas of land for use by people. This can include anything from parks, shopping centers, and even airports. Land use data can be used for displaying the map at high zoom levels and to show the spatial extent of places. The geometry of land use is mostly represented as polygons but there may be some instances of polylines for special land uses as well . Navigable roads The navigable roads layer contains cartographic content related to roads and their attributes such as the name of the road, functional class, characteristics of it like whether it is paved, public or private, and even speed limit information. You can use this layer to render road networks, complete your map data, track fleet positioning against roads, and more. Places The p laces layer represents business entities and attributes about them. For example , you can find places like restaurants, banks, and hotels and you can find attributes like their hours of operation, phone number, website, and more. You can use this layer to enrich your map and display a complete list of places, or to add more attributes such as opening hours to your existing points of interests . Traffic restrictions The traffic restrictions layer contains multi-link conditions that show restrictions for specific types of vehicles at certain times. This layer can be used alongside with the navigable roads layer to help with navigation . Here’s what data from traffic restrictions can look like: { \n\n      \"id\": \"16885880\", \n\n      \"type\": \"Feature\", \n\n      \"properties\": { \n\n        \"ordered\": true, \n\n        \"category\": \"RoadRelation\", \n\n        \"endOfLink\": \"WHOLE_LINK\", \n\n        \"references\": [ \n\n          { \n\n            \"ids\": [ \n\n              \"17927697\", \n\n              \"17927696\" \n\n            ], \n\n            \"layerId\": \"navigable-roads\" \n\n          } \n\n        ], \n\n        \"featureType\": \"Relation\", \n\n        \"isoCountryCode\": \"USA\", \n\n        \"@ns:com:here:xyz\": { \n\n          \"tags\": [], \n\n          \"space\": \"ds0kZq6e\", \n\n          \"createdAt\": 1600704135681, \n\n          \"updatedAt\": 1600704135681 \n\n        }, \n\n        \"conditionalAttribute\": { \n\n          \"rdmType\": \"LOGICAL\", \n\n          \"constraints\": [ \n\n            { \n\n              \"timeConstant\": \"NOT_APPLICABLE\", \n\n              \"vehicleTypes\": { \n\n                \"bus\": true, \n\n                \"auto\": true, \n\n                \"taxi\": true, \n\n                \"truck\": true, \n\n                \"carpool\": true, \n\n                \"delivery\": true, \n\n                \"motorcycle\": true, \n\n                \"throughTraffic\": true, \n\n                \"emergencyVehicle\": true \n\n              } \n\n            } \n\n          ], \n\n          \"attributeType\": \"RESTRICTED_DRIVING_MANOEUVRE\" \n\n        }, \n\n        \"@ns:com:here:mom:meta\": { \n\n          \"layerId\": \"traffic-restrictions\", \n\n          \"sourceId\": \"here-product-primitives-road-network-geojson-ext-v1\", \n\n          \"modelVersion\": \"1.0.0\", \n\n          \"catalogVersion\": 42 \n\n        } \n\n      }, \n\n      \"geometry\": { \n\n        \"type\": \"MultiLineString\", \n\n        \"coordinates\": [ \n\n          [ \n\n            [ \n\n              -95.37179, \n\n              29.75528, \n\n              0 \n\n            ], \n\n            [ \n\n              -95.37128, \n\n              29.75532, \n\n              0 \n\n            ] \n\n          ], \n\n          [ \n\n            [ \n\n              -95.37154, \n\n              29.75501, \n\n              0 \n\n            ], \n\n            [ \n\n              -95.37179, \n\n              29.75528, \n\n              0 \n\n            ] \n\n          ] \n\n        ] \n\n      } \n\n    } Traffic signs The traffic signs layer contains data about signs alongside the road that give instructions to drivers, cyclists, and pedestrians. In this layer, you can find road signs such as stop signs, curves, winding roads, and more. These signs are represented with latitude and longitude coordinates and they come in three different categories that you can choose to display: regulatory, warning, and informing. You can access these layers for 60+ locations under the freemium plan . Jump into the documentation to have a quick walk-through for downloading and visualizing the layers and as always feel free to reach out on Twitter @heredev to share your work with us!", "date": "2020-09-25"},
{"website": "Here", "title": "Render HERE Map in IBM Node RED - Part 2", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/render-here-map-in-ibm-node-red-part-2", "abstract": "This is the second blog post about rendering a map in IBM Node RED. In part one , we created a Node RED application on IBM Cloud. Now lets learn how to integrate a HERE Map in a few simple steps. Prerequisites The requirement is same as for part 1: An IBM Cloud account(you can sign up here ) Freemium account on HERE Developer portal Creating a Flow To show a map we need to create a flow containing three nodes connected to each other. A node is a basic building block of a flow. A node can be triggered by previous node in a flow or by an external event (like an incoming HTTP request). You can find nodes on the left of your Node RED editor on the browser, called as Node palette. The three nodes required are: template http in http response You can get more information here on the nodes used. Next, you need to drag and drop all three nodes on the main workspace. And connect them to create a flow. Editing Nodes Once the flow is complete, next thing is to edit the nodes as per our requirement. And what we require is to show a map in a new URL. First, we will edit the \"http in\" node. Double click on the node to open the node editor. Under properties in the URL edit box, write \"/map\" After you have made the changes, click on \"Done\". This will result in a change in your nodes. Similarly, we need to edit the template node and paste the following code into it <!DOCTYPE html>\n<html> \n    <head> \n        <title>HERE Map</title> <meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" /> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> \n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/> \n    </head> \n    <body> \n        <div id=\"mapContainer\" style=\"width: 95vw; height: 80vh; display: block; margin: 0 auto; border: solid 2px black; margin-top: 10px;\"> </div> \n    </body> \n    <script> \n        var platform = new H.service.Platform({ \n            apikey: \"JS_API_KEY\"    \n        }); \n\n\t\tconst lat = 12.95677; \n\t\tconst lng = 77.73164; \n\n\t\t// Obtain the default map types from the platform object: \n        var defaultLayers = platform.createDefaultLayers(); \n\n        // Your current position \n        var myPosition = {lat: lat, lng: lng}; \n\n        // Instantiate (and display) a map object: \n        var map = new H.Map( \n            document.getElementById('mapContainer'), \n            defaultLayers.vector.normal.map, \n            { \n                zoom: 14, \n                center: myPosition \n            }); \n\n        var ui = H.ui.UI.createDefault(map, defaultLayers, 'en-US'); \n        var mapEvents = new H.mapevents.MapEvents(map); \n        var behavior = new H.mapevents.Behavior(mapEvents); \n\n\t\tconst marker = new H.map.Marker({lat: lat, lng: lng}); \n\n\t\tmap.addObject(marker); \n\n\t\tmarker.addEventListener('tap', function(evt) { \n\t\t\n\t\t// Create an info bubble object at a specific geographic location: \n\t\tvar bubble = new H.ui.InfoBubble({ lng: lng, lat: lat }, { \n                content: '<p> \"Hi!!\"</p>' \n             }); \n\n\t\t// Add info bubble to the UI: \n\t\tui.addBubble(bubble); \n\t\t}); \n\n\t</script> \n\n</html> In the above code, you will  need to replace \"JS_API_KEY\" with the API key you acquired from HERE Developer portal . To know how to acquire the API key, check this video out. You must be wondering, what does this code do! It shows a location in Bangalore India( 12.95677 , 77.73164 ) on a map as a marker. The marker is clickable, when you click, it pops open a information bubble which says 'Hi!!'. You can change the location of the marker and test value of the information bubble according to your requirement. Next, replace \" This is the payload: {{payload} } ! \" with our new code and click on \"Done\" button Showing the Map To show the map, you first need to deploy the app on the server. This can be done by clicking on \"Deploy\" button on the top right of your node RED editor. After few seconds, on clicking \"Deploy\", it should show a \"Successfully Deployed\" message in the middle top of the node RED editor. Congratulations! You have successfully deployed the application on server. To see the map, copy the address from the browser, it would look something like this: https://APP_NAME.eu-gb.mybluemix.net/red/#flow/2fdf220b.fee59e Copy the following part: https://APP_NAME.eu-gb.mybluemix.net/ and add 'map' at the end of it(because we mentioned '/map' in 'http in' node earlier) https://APP_NAME.eu-gb.mybluemix.net/map Open the URL in a new browser window, and you will have your map! The marker on the map is clickable Conclusion The node RED is a powerful prototyping tool used a lot in Internet of Things and combining it with location capabilities of HERE Technologies opens a new dimension. We learned how to show a map in a browser using node RED in few simple steps. You can build different use cases combining the node RED and HERE Maps. We will dive deeper into it. Meanwhile, keep learning!", "date": "2020-09-25"},
{"website": "Here", "title": "Enter the HERE Map Data Hackathon", "author": ["Christo Mitov"], "link": "https://developer.here.com/blog/enter-the-here-map-data-hackathon", "abstract": "While most people probably think of maps as a reference, we at HERE think of them as tools, and are always working to develop new ways to make maps and location data more helpful to everybody who might need them. But we can’t do that alone, and have empowered our developer ecosystem to build specific solutions for the issues and communities they care most about. This is why we’re proud to host the HERE Map Data Hackathon, which will reward developers who find impactful, sophisticated, and novel ways to use our latest tool: HERE Data Layers. HERE Data Layers helps developers create map-based solutions without all the excess noise present in so many maps. Instead of a single cluttered expensive map, we’re offering an a-la-carte type system that lets you purchase only what your map requires, whether that’s just navigable roads, land-use information, or building footprints. Available for nearly seventy cities around the world, Data Layers splits map information into 10 categories that cover over 500 different attributes per city. The map data is provided as GeoJSON format layers which can be used individually or combined for multiple use cases ranging from map display, spatial analytics, business intelligence, and machine learning. We’re inviting developers to build software solutions using HERE Data Layers and HERE Location Services that help the public, local communities, and businesses to overcome challenges from health and social care, to education, and infrastructure. The hackathon will provide a platform for developers to ideate, experiment, and collaborate. Register for the hackathon at the following link: https://herehackathon.devpost.com/ The submission period begins today, October 14th at 10:00am EDT, and ends on December 1st at 5:00pm EST. Our judges: Sayna Parsi, Raymond Camden, Shruti Kuber, Eric von Rooij, and Ashutosh Badwe will assess and evaluate the entries from December 7th at 10:00am EST to December 11th at 2:00pm EST based on the following criteria: Impact: Reachability of solution among communities and its impact in different sectors (like businesses, organizations, communities, etc.) Technical intricacy: Sophistication of the software, state of the art use of technology stack. Novelty: Uniqueness of idea/solution. Winners will be announced on December 18th at 2:00pm EST, and receive the following prizes: First Place: $5,000 USD Second Place: $2,500 USD Third Place: $1,000 USD For more information about HERE Data Layers, please feel free to use the following resources: Blog Post: HERE Data Layers at a Glance Blog Post: Deep Dive into HERE Data Layers - Part 1 Blog Post: Deep Dive into HERE Data Layers - Part 2 Documentation: HERE Data Layers Video: How to Download Free GIS Data for Analysis- HERE Data Layers I can’t wait to see what you build with HERE Data Layers. Happy coding!", "date": "2020-10-14"},
{"website": "Here", "title": "How to Create Floating Map Markers", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/how-to-create-floating-map-markers", "abstract": "This blog post is quick tutorial on how to create map markers to hover over the map. We will be creating map markers whose height and color will indicate the incline of a road up a mountain to demonstrate this. Let’s get started! Step 0: Spoiler Alert If you just like to see some code, you can check out the complete code for this post on GitHub . If you want to see what the end result looks like before you get started, you can see the code running here . Also, if you came here just to quickly find out how to add an altitude to a marker, check out the code snippet below. It’s as simple as adding an altitude value (in meters) when creating a marker. However, keep reading if you want to learn how to use this feature in a neat looking project. let altitudeMarker = new H.map.Marker({lat: 47.1, lng: 39.81, alt: 200 }); Step 1: Create a basic map To add markers to a map, you first need a map. There’s a variety of ways you can set one up. For example, you can use another one of my blog posts called “ How to Create a Web Map Application in Under Six Minutes ”. You can also follow our getting started guide , open an example in JSFiddle or simply fork our JavaScript examples . Personally, I have created my own clean full-screen map project in GitHub , which I use as a basis for projects like this. Forking that is probably the easiest way to get going. Remember that you will need an API Key for this, so sign up for your Freemium account to grab one. Note that for this project we want to default to a satellite image view, so be sure to set the correct map layer during map initialization. var map = new H.Map(document.getElementById('map'),\n  defaultLayers.raster.satellite.map, {\n  pixelRatio: window.devicePixelRatio || 1\n}); Step 2: Getting a Route Next, we need to get a route with altitude information as a basis for our markers. I have chosen the Mauna Kea Access Road on Hawaii. The waypoints below reflect the start of the road and the top of Mauna Kea. Since this isn’t a tutorial on the Routing API, I will just point out that we need the route shape returned to get locations for the markers. We also need to explicitly request altitude values, as the Routing API does not return these by default. function calculateRouteFromAtoB(platform) {\n  let router = platform.getRoutingService();\n  let routeRequestParams = {\n    mode: 'shortest;car',\n    representation: 'display',\n    routeattributes: 'shape',\n    waypoint0: '19.68976,-155.46648',\n    waypoint1: '19.82185,-155.47435',\n    // request altitudes for positions\n    returnElevation: true\n  };\n\n  router.calculateRoute(\n    routeRequestParams,\n    onSuccess,\n    onError\n  );\n} Step 3: Determining minimum and maximum altitude We want to color code our markers based on relative altitude. The lowest marker should be colored green, the highest red. This mean we need to determine the minimum and maximum altitudes of any points in the shape of the route. We can do this by simply iterating over all the points in the route shape, which gets returned on the onSuccess callback of our Routing API call. let minAltitude = 9999;\nlet maxAltitude = -9999;\n\nrouteShape.forEach(function (point) {\n  let splits = point.split(',');\n  if (splits[2] < minAltitude) minAltitude = splits[2];\n  if (splits[2] > maxAltitude) maxAltitude = splits[2];\n}); Step 4: Create SVG for the marker icon To create our color-coded markers, we set up an SVG icon and then replace the color in the SVG string based on the relative altitude of each point. Once again, we iterate over the route shape. First, we create a scaling factor for the marker color, based on the minimum and maximum altitude we determined in the previous step. Then we use this factor to create and RGB color screen, which we finally convert to the hex value needed in our SVG string. Finally, we create the SVG as a small circle and replace the color in the string. Note that we also create a lineString using the points in the route shape. We do this so we can later add a polygon with the route on the map. This allows us to compare our markers with altitude to the route on the map. routeShape.forEach(function (point) {\n\n    let splits = point.split(','); // lat, long, altitude\n    routeLineString.pushLatLngAlt(splits[0], splits[1]);\n\n    // Step 4: create RGB color in hex for SVG\n    var scale = (splits[2] - minAltitude) / (maxAltitude - minAltitude);\n    var red = Math.round(255 * scale);\n    var red = red.toString(16);\n    if (red.length == 1) {\n      red = '0' + red;\n    }\n\n    var green = Math.round(255 - 255 * scale);\n    var green = green.toString(16);\n    if (green.length == 1) {\n      green = '0' + green;\n    }\n    let blue = \"00\";\n    let color = '#' + red + green + blue;\n\n    let svg = ' ';\n    svg = svg.replace('{$COLOR}', color); Step 5: Create the markers With our SVG image for the marker all set up, we can finally create a marker icon using the SVG string and then create the marker itself, passing not only the usual latitude and longitude, but also an altitude (as described in Step 0). We also create our Polyline object for comparison and add both to the map. let altitudeIcon = new H.map.Icon(svg);\n    let altitudeMarker = new H.map.Marker(\n      {\n        lat: splits[0],\n        lng: splits[1],\n        alt: splits[2]\n      },\n      { icon: altitudeIcon }\n    );\n    group.addObject(altitudeMarker);\n  });\n\n  polyline = new H.map.Polyline(routeLineString, {\n    style: {\n      lineWidth: 5,\n      strokeColor: '#00AFAA'\n    }\n  });\n\n  // Add the polyline to the map\n  map.addObject(polyline);\n  // Add markers to the map\n  map.addObject(group);\n  // Zoom to its bounding rectangle\n  map.getViewModel().setLookAtData({\n    bounds: polyline.getBoundingBox(),\n    tilt: 50\n  }); The final result should look something like the image below. However, this is best viewed in action, so check out the running example here . Be sure to hold down the ALT key and rotate/tilt the camera for the full effect. Before you leave, don’t forget to have a look at the complete project code on GitHub !", "date": "2020-10-12"},
{"website": "Here", "title": "Create a WKT File Using HERE Data Layers and Geopandas", "author": ["Shruti Kuber"], "link": "https://developer.here.com/blog/create-a-wkt-file-using-here-data-layers-and-geopandas", "abstract": "A few weeks ago, I was working on a demo where I drew geofences around brick and mortar stores. When my user is near this geofence, they get a notification about the offers in the store. Sounds cool doesn't it? Step 1 of this demo is to create a geofence in the WKT format. Normally a geofence is created by manually drawing polygons around a place and extracting them as WKTs. I was looking for a better method to automate this. This is when I came across Geopandas. Geopandas is a Python library that works specifically with geospatial data. Couple this with the Buildings HERE Data Layer and you can get geofences for different buildings in a city within minutes. I am assuming you already have downloaded the Buildings layer of your favorite city in your Data Hub . If not, take a quick look at Ray's blog post and then come back. Now you can download this file directly from the Data Hub, although if it is too big a file, you will need to use the Data Hub CLI . So open your terminal and install the CLI. The prerequisites for this installation are Node.js and npm . npm install -g @here/cli Configure the Data Hub CLI with the same login and password that you used to create the Data Layers. here configure account You can list all the layers you have in your Data Hub using here xyz list . id title description 7Vzz48SR Berlin-Buildings-v60 Space for Berlin city, version 60 of Buildings layer You will see that every layer has an id. You can now download the Buildings layer using its id. here xyz show -r YOUR_SPACE_ID --all >Berlin-Buildings.geojson Once you have the layer, the real fun begins. As I mentioned, we are going to use Python to process this file. With it, we are going to use the geopandas , and shapely libraries. Be sure to have them installed in your environment. The first step now is to read the Buildings file and see what the structure of the objects within is. I used a Jupyter notebook for this example. You can also simply open a file called toWKT.py and start typing the code below. import geopandas as gpd\nimport json\nimport shapely.ops as shp\n\nbuildings = gpd.read_file('MapData_GeoJSON/Houston-Buildings.geojson')\n\nprint(buildings.head(n=5)) You will see that the Geopandas library converts the GeoJSON file into a GeoDataFrame and the objects within it, into DataSeries . Visually it is tabular where every column is a feature within the feature collection. In this table you will see a column named 'geometry' which has the polygons of the footprints of these buildings. Another GeoSeries or column that we are interested in is the one named 'buildingType'. If you expand the buildingType object, it looks something like this. [ { \"type\": 2005450, \"typeDescription\": \"Residential Building\\\\/Landmark\" } ] . Let's see the unique building types available in this dataset. unq = buildings.drop_duplicates(subset=[\"buildingType\"])\nfor index, row in unq.iterrows():\n    typedes = row[\"buildingType\"]\n    o = json.loads(typedes)\n    if(row[\"names\"] != None):\n        print(o[0][\"typeDescription\"]) Business/Commerce Building/Landmark\nCultural Building/Landmark\nGovernment Building/Landmark\nEducation Building/Landmark\nTourist Building/Landmark\nRetail Building/Landmark\nHistorical Building/Landmark\nPark/Leisure Building/Landmark\nPlace of Worship Building/Landmark\nMedical Building/Landmark\nConvention/Exhibition Building/Landmark\nTransportation Building/Landmark\nSports Building/Landmark\nEmergency Service Building/Landmark\nParking Building/Landmark\nUnclassified Building/Landmark For the demo I was working on, I selected the 'Retail Building/Landmark' for my geofences. And now I want to store them in the WKT format. If you want to read more about what the Well-Known Text format is, head over to this blog post about WKT files . In a nutshell, it is a format to store spatial geometries or geometries which have a latitude and longitude to them. It can store POINTS, POLYGONS or LINESTRING. The elements in the file are tab delimited. The header should always have the column named WKT along with other columns like name, id or any other form of data that you would like to append to this geometry. Let us create the file with its headers. geofence_file = open(r\"retail.wkt\",\"w\")\nheader_str = \"NAME\"+\"\\t\"+\"WKT\"+\"\\n\"\ngeofence_file.write(header_str) The rows after the header then have the property of the shape and the shape itself. The way the shape is defined is with the shape-name followed by a list of coordinates. So a polygon with 5 points will be defined as POLYGON ((POINT1_Longitude POINT1_Latitude,POINT2_Longitude POINT2_Latitude,POINT3_Longitude POINT3_Latitude,POINT4_Longitude POINT4_Latitude,POINT5_Longitude POINT5_Latitude,POINT1_Longitude POINT1_Latitude,)) . Notice how the first point is repeated in the end to signify the closing of the shape. So, let's extract the shapes and names of all the buildings of the type 'Retail Building/Landmark'. for index, row in buildings.iterrows():\n    typedes = row[\"buildingType\"]\n    o = json.loads(typedes)\n    if(row[\"names\"] != None):\n        n = json.loads(row[\"names\"])\n        if(o[0][\"typeDescription\"]==\"Retail Building/Landmark\"): Before we write these geometries to the WKT file, we need to talk about the format of the geometries in this GeoDataFrame. If you look closely, these are MultiPolygons. Although they are a perfectly acceptable format, the geofence HERE API accepts only Points, LineStrings or Polygons. Also, the shapes are preceded by a 'Z' which indicate that they are 3D shapes which include the altitude of the point as well. But if you look closely, the altitude in the shapes is always 0. E.g. MULTIPOLYGON Z(((13.37712 52.52824 0.00000,....))) . Also, the multi-polygon shape has only 1 polygon within it. So, it will be easy to extract it and put it down as a single polygon. Let's go ahead and do that and then print the shapes and store names in the WKT file. geo = row[\"geometry\"]\n            geo2d = shp.transform(lambda x,y, z=None:(x,y),geo)\n            format_str = n[0][\"name\"]+\"\\t\"+str(geo2d[0])+\"\\n\"\n            print(format_str)\n            geofence_file.write(format_str) NAME\tWKT\nKarstadt\tPOLYGON ((13.42405043 52.48666395, 13.42498651 52.4877888, 13.42432063 52.48804738, 13.42430857 52.4880349, 13.42494224 52.48778501, 13.42472176 52.48752075, 13.42467775 52.487468, 13.42429992 52.48701514, 13.42425763 52.48696446, 13.42402932 52.4866908, 13.42335958 52.48688215, 13.42334699 52.48686501, 13.42405043 52.48666395))\nGaleria Kaufhof\tPOLYGON ((13.43495276 52.51209543, 13.43544543 52.51271736, 13.43436342 52.51303453, 13.43387612 52.51241562, 13.43495276 52.51209543))\nMall of Berlin\tPOLYGON ((13.37691817 52.5099596, 13.37693541 52.50983801, 13.37714271 52.50985053, 13.37713587 52.50990756, 13.37713136 52.50993514, 13.37770245 52.51036879, 13.37894697 52.51044039, 13.37961304 52.51012148, 13.37965741 52.50985681, 13.37983327 52.50986654, 13.37977171 52.5101922, 13.37902568 52.51056459, 13.37848268 52.51053098, 13.3776097 52.51047693, 13.37694178 52.50996276, 13.37691817 52.5099596))\nZARA\tPOLYGON ((13.38120961 52.51095166, 13.38120392 52.51097859, 13.38120539 52.51096468, 13.38114562 52.5109643, 13.38131619 52.50991878, 13.38270233 52.51000422, 13.38264228 52.51040018, 13.38230362 52.51049331, 13.3821384 52.5109229, 13.38204952 52.51090149, 13.38193293 52.51106168, 13.38171063 52.51101843, 13.38146826 52.51099937, 13.38147395 52.51097244, 13.38152091 52.51075014, 13.38125656 52.51072935, 13.38120961 52.51095166)) Conclusion We used the Geopandas library to easily parse GeoJSON files and create a geospatial layer in the WKT format. Oh, and you can find the demo I mentioned on our GitHub . Let me know how you have been using the Geopandas library in the comments section below.", "date": "2020-10-26"},
{"website": "Here", "title": "How to Create an Image Overlay on a Map", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/how-to-create-an-image-overlay-on-a-map", "abstract": "Today’s blog post is a quick tutorial on how to add an image overlay to a map with the HERE Maps API for JavaScript. This is a quick three step process, so let’s get started! Step 0: Spoiler Alert If you just like to see some code, you can check out the complete code for this post on GitHub . If you want to see what the end result looks like before you get started, you can see the code running here . Step 1: Create a basic map In order to add an overlay to a map, you first need a map. There’s a variety of ways you can set one up. For example, you can use another one of my blog posts called “ How to Create a Web Map Application in Under Six Minutes ”. You can also follow our getting started guide , open an example in JSFiddle or simply fork our JavaScript examples . Personally, I have created my own clean full-screen map project in GitHub , which I use as a basis for projects like this. Forking that is probably the easiest way to get going. Remember that you will need an API Key for this, so sign up for your Freemium account to grab one. Once you’ve set up your map, we’re ready for Step 2. Step 2: Get an overlay image In order to add an overlay to a map, you also need an image to overlay. I’ve found the following 1885 map of the southern tip of Manhattan in the digital collection of the New York Public Library . I’m not 100% sure what it actually depicts (maybe electoral districts for state senators?), but it looks neat and it’s in the public domain, so it suits us just fine. The idea here is to overlay this image on the modern-day map of New York with a dash of opacity. To use this image in our overlay, we need to create a JavaScript Image object as follows. // Step 2: get an overlay image\n  let overlayImage = new Image();\n  overlayImage.src = '/overlay.png'; Step 3: Create an overlay object Now that we have a map and an image, we need to create an Overlay object . To do so, we need three things. A location for the overlay, expressed as an H.geo.Rect using latitude and longitude The image (see Step 2) Options for the overlay, for example the level of opacity we want (optional) // Step 3: create an overlay object and add it to the map\n  let overlay = new H.map.Overlay(\n    new H.geo.Rect(\n      40.73822, -74.03192,\n      40.69484, -73.96696\n    ),\n    overlayImage,\n    {\n      volatility: true,\n      opacity: 0.7\n    }\n  ); Most of these should be self-explanatory, but the volatility flag probably needs some explanation. Whenever we set a map object such as a marker (or in this case an overlay) to be volatile, we are letting the system know that the position and/or style of this object is expected to change frequently. This results in smoother updates for these changes because the rendering engine will treat these objects differently. That’s pretty much it! Don’t forget to add the overlay to the map, so it becomes visible. The end result should look something like the image below. (A quick note: the top of the 1885 map wasn’t quite pointing north, so I rotated it in an image editor beforehand.) You can see the finished code running here . Be sure to zoom and rotate the map (hold down the ALT key), to see how the overlay scales and rotates with the map. I’ll leave you with a quick tip. If you have larger overlays, you can also split these into tiles and create a custom tile overlay. Check out the Custom Tile Overlay example for more details! Also, don’t forget to have a look at the complete code in GitHub .", "date": "2020-10-19"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.21 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.21-release", "abstract": "Highlights Speed up development with Customizable Pipeline Templates We are happy to announce our brand new Customizable Pipeline Templates . Develop faster by using these scalable, configurable processing blocks that you can deploy as part of your own Workspace workflow without needing to write any code. Each pipeline template is designed to perform a specific task and can be customized to accommodate your particular use case. To download and learn more about the various pipeline templates, visit the new Customizable Pipeline Templates page in the portal launcher. Current pipeline templates include Archiver, Change Stats Calculator, Data Injector, Data Pooling, Filter-Forward Message Router, HERE Map Content Attribute Retriever, CSV to SDII-Sensoris Converter, and Vehicle Road Coverage Extractor. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue: In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the uses in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Known issue : The \"Upload data\" button in your Layer UI under \"More\" is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue: The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of index-layer data isn't supported yet. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Marketplace (Not available in China) Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices.) No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 February 26, 2021 (extended) Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way after February 26, 2021. · Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after February 26, 2021. · Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before February 26, 2021 so your workflows continue to work. · HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after February 26, 2021. · Examples of old and new Catalog HRN formats: · Old (without OrgID/realm): hrn:here:data:::my-catalog · New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation Summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 November 30, 2020 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of November 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before November 30, 2020. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 Deprecation Summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Stream throughput configuration changes from MB/s to KB/s 2.19 September 2020 March 31, 2021 Deprecation Summary: Support for stream layers with configurations in MBps will be deprecated in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 7 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation Summary: The \" kubernetes_namespace \" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \" namespace \" metric. The label_values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label_values(metric, label) The datasource \" <Realm>-master-prometheus-datasource \" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource.", "date": "2020-11-20"},
{"website": "Here", "title": "How to Get from Here to There (and There and There...)", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/how-to-get-from-here-to-there-and-there-and-there", "abstract": "How to Get from Here to There (and There and There...) One of the best things about being a developer (outside of code reviews of course) is knowing that you can use your development skills to help solve problems. There isn't a tool for what you need? Build your own! Of course, that assumes an infinite amount of time and actual ability, but let's just assume that isn't an issue. Today's demo is a perfect example of that in action. I recently had a problem that wasn't immediately solvable by an existing tool, so I used our platform to get it done. So what was the problem? I wanted to vote early, something many people across the country are already doing. In my area, I had three different polling places available to me for early voting. However, I wasn't sure which one was best. What I wanted to do was go to a map, plot my house, and then plot all three locations so I could figure out what was going to work best for me. Not just in terms of location but how long the drive is, what else is around them in case I could knock out a few more errands, and so forth. From what I could see though, no mapping tool really fit that need. Most mapping tools making it easy to map from point A to B, but I couldn't find one that would let me map from A to B1, A to B2, and so forth. (And I swear, I looked for a long time too. Maybe even up to five minutes of intense Internet searching.) I thought it would be fun to try to build a demo of this using our Maps product. I'd use our JavaScript Maps for rendering and our Geocoding and Routing to work with my input. I decided for a simple interface. I prompt for your starting location and then have fields for one to four destinations. You can enter each field using \"regular\" addresses which then get geocoded into a precise location. Here's an example (and no, this isn't my home): Each of the destinations has a marker that you can click for more information. For my initial demo, just the total driving time: You can play with this demo yourself ( https://cfjedimaster.github.io/heredemos/mapsjs/multilocations/ ) and the complete source may be found here: https://github.com/cfjedimaster/heredemos/tree/master/mapsjs/multilocations I won't go over every line of code, but let's take a look at how it was built. For my layout I used a CSS grid to create the left \"panel\" and a place for the map. .container {\n    display: grid;\n    grid-template-columns: 20% 80%;\n}\n\n#panel {\n    background-color: bisque;\n    padding: 8px;\n}\n\n#map {\n    height: 100vh;\n    width: 100%;\n} The panel itself is simple HTML tied to JavaScript to handle when values change. <div id=\"panel\">\n    <h2>Multi Router</h2>\n\n    <p>\n    Enter a starting address and then enter your muliple addresses. The tool \n    will tell you routing information from your starting position to each of them.\n    </p>\n\n    <p>\n    <label for=\"startingAddress\">Starting Address:</label><br/>\n    <input type=\"text\" id=\"startingAddress\">\n    </p>\n\n    <p>\n    <label for=\"dest1\">Destination 1</label><br/>\n    <input type=\"text\" id=\"dest1\" class=\"destField\" disabled>\n    </p>\n    <p>\n    <label for=\"dest2\">Destination 2</label><br/>\n    <input type=\"text\" id=\"dest2\" class=\"destField\" disabled>\n    </p>\n    <p>\n    <label for=\"dest3\">Destination 3</label><br/>\n    <input type=\"text\" id=\"dest3\" class=\"destField\" disabled>\n    </p>\n    <p>\n    <label for=\"dest4\">Destination 4</label><br/>\n    <input type=\"text\" id=\"dest4\" class=\"destField\" disabled>\n    </p>\n\n    <p id=\"credit\">\n    Icons made by <a href=\"https://www.flaticon.com/authors/freepik\" title=\"Freepik\">Freepik</a> from\n    <a href=\"https://www.flaticon.com/\" title=\"Flaticon\"> www.flaticon.com</a>\n    </p>\n\n</div> Notice that the destination fields are all disabled. They will get enabled once a starting address is added. Now let's tackle the JavaScript. I'm going to assume some familiarity with our JavaScript maps, but here's boilerplate code that simply drops a map on a web page: platform = new H.service.Platform({\n    'apikey': KEY\n});\n\n// Obtain the default map types from the platform object:\nlet defaultLayers = platform.createDefaultLayers();\n\nmap = new H.Map(\n    document.getElementById('map'),\n    defaultLayers.vector.normal.map,\n    {\n        zoom: 5,\n        center: { lat: 39.83, lng: -98.58 },\n        pixelRatio: window.devicePixelRatio || 1,\n        padding: {top: 50, left: 50, bottom: 50, right: 50}\n    }\n);\n\n\nlet behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));\n\n// Create the default UI:\nui = H.ui.UI.createDefault(map, defaultLayers); The only thing I'll call out here is my center which came from me Googling for the center of America. The padding value is interesting. It doesn't actually add a padding around the map itself, ie a white or transparent border. Rather, it provides some padding when working with UI items. So for example, later we're going to center the map around a set of markers and this padding will ensure that all the markers are visible and not on the \"edge\" of the view port. Along with setting up the map, there's some additional prep work we do. First, I create a group that will store our markers and set up some custom icons: markerGroup = new H.map.Group();\nmap.addObject(markerGroup);\n\nhomeIcon = new H.map.Icon('home.png');\ndestIcon = new H.map.Icon('marker.png'); Next, I create an instance of the routing and geocoding service: router = platform.getRoutingService(null,8);\ngeocoder = platform.getSearchService(); These objects provide wrappers to our services and make it a bit easier to use in JavaScript applications. Finally, I do a bit of DOM work - getting handles to my form fields and adding some event listeners: startingAddress = document.querySelector('#startingAddress');\nstartingAddress.addEventListener('change', doStartingLocation);\n\ndestFields = document.querySelectorAll('.destField');\ndestFields.forEach(d => {\n    d.addEventListener('change', doDestination);\n}); The first thing I built was handling input in the starting address field. We have to take the input, geocode it, and then add a marker. First, here's the code handling changes to the text field: async function doStartingLocation() {\n    console.log('address change', startingAddress.value);\n    if(!startingAddress.value) {\n        disableDestinationFields();\n        return;\n    } else enableDestinationFields();\n    homePos = await geocode(startingAddress.value);\n    if(homePos) addHomeMarker(homePos);\n} I do a few basic things here. I have logic to either disable or enable the destination fields based on an input. I'm not going to share that function as it just does the DOM changes. If you did have a value, I then geocode it: async function geocode(s) {\n    let params = {\n        q:s\n    };\n\n    return new Promise((resolve, reject) => {\n        geocoder.geocode(\n            params,\n            r => {\n                resolve(r.items[0].position);\n            },\n            e => reject(e)\n        );\n    });\n} This is an example of using the \"service helpers\" in the MapsJS library. The last bit handles adding the home marker: function addHomeMarker(pos) {\n    if(homeMarker) markerGroup.removeObject(homeMarker);\n    homeMarker = new H.map.Marker({lat:pos.lat, lng:pos.lng}, {icon:homeIcon});\n    homeMarker.setData(\"You are HERE\")\n    markerGroup.addObject(homeMarker);\n    map.setCenter(homeMarker.getGeometry());\n} This function handles removing any previous marker if it exists. It then adds the marker and centers the map. The next set of functionality handles destinations. I've got one event handler for all the destination fields. The handler is responsible for geocoding the input, adding a marker, and then drawing a route. Here's the main handler: async function doDestination(e) {\n    let id = e.target.id;\n    if(!e.target.value) return;\n    let pos = await geocode(e.target.value);\n\n    let routeRequestParams = {\n        routingMode: 'fast',\n        transportMode: 'car',\n        origin: homePos.lat+','+homePos.lng, \n        destination: pos.lat+','+pos.lng,  \n        return: 'polyline,turnByTurnActions,actions,instructions,travelSummary'\n    };\n\n    let route = await getRoute(routeRequestParams);\n    let totalTime = formatTime(route.sections[0].travelSummary.duration);\n\n    addDestMarker(pos, id, `\n<p>\n    <strong>Destination:</strong> ${e.target.value}<br/>\n    <strong>Driving Time:</strong> ${totalTime}\n</p>`);\n\n    addRouteShapeToMap(route, id);\n} It's using the same geocode wrapper I had before. It then calls out to a routing wrapper: async function getRoute(p) { \n\n    let params = {\n        origin:p.origin, \n        destination:p.destination,\n        transportMode:p.transportMode,\n        routingMode:p.routingMode,\n        return:p.return,\n    }\n\n    return new Promise((resolve, reject) => {\n        router.calculateRoute(\n            params, \n            r => {\n                resolve(r.routes[0]);\n            }, \n            e => reject(e)\n        );\n    });\n\n} We get the total driving time from the route result and use it to create a marker. I abstracted that part out into addDestMarker : function addDestMarker(pos, id, label) {\n    if(destMarkers[id]) markerGroup.removeObject(destMarkers[id]);\n    destMarkers[id] = new H.map.Marker({lat:pos.lat, lng:pos.lng}, {icon:destIcon});\n    destMarkers[id].setData(`<div class=\"bubble\">${label}</div>`);\n\n    destMarkers[id].addEventListener('tap', e => {\n        if(bubble) ui.removeBubble(bubble);\n        bubble = new H.ui.InfoBubble(e.target.getGeometry(), {\n            content:e.target.getData()\n        });\n        ui.addBubble(bubble);\n    });\n    markerGroup.addObject(destMarkers[id]);\n} This function uses a window level object, destMarkers , as a way to remember a marker and it's associated destination field. This is what let's us remove the marker made for the second destination, for example, when it changes while leaving the rest alone. An event listener is added that shows the text data passed to it. The final bit, addRouteShapeToMap , is code I got right from our docs that add the route API polygon shape to a map: function addRouteShapeToMap(route,id) {\n\n    // remove existing route\n    if(destRoutes[id]) {\n        destRoutes[id].removeAll();\n        markerGroup.removeObject(destRoutes[id]);\n    }\n\n    destRoutes[id] = new H.map.Group();\n\n    route.sections.forEach((section) => {\n        // decode LineString from the flexible polyline\n        let linestring = H.geo.LineString.fromFlexiblePolyline(section.polyline);\n\n        // Create a polyline to display the route:\n        let polyline = new H.map.Polyline(linestring, {\n            style: {\n                lineWidth: 4,\n                strokeColor: 'rgba(0, 128, 255, 0.7)'\n            }\n        });\n\n        destRoutes[id].addObject(polyline);\n\n      });\n\n    markerGroup.addObject(destRoutes[id]);\n    map.getViewModel().setLookAtData({bounds: markerGroup.getBoundingBox()});\n\n} There's only two modifications here. First, recognizing and removing a previous route for that particular field and then updating the map viewport. (That improvement, amongst others, came from my amazing teammate, Shruti!) And that's it. Again, you can check out the repository and demo to take it for a spin.", "date": "2020-11-05"},
{"website": "Here", "title": "Data Hub CLI 1.6 Release Notes", "author": ["John Oram"], "link": "https://developer.here.com/blog/data-hub-cli-1.6-release-notes", "abstract": "Version 1.6 of the Data Hub CLI makes it even easier to upload your data, with support for zipped shapefiles and xls/xlsx files, as well as batch uploads! It also has enhancements to the groupby option, and here xyz join has a new property search feature that makes virtual spaces even easier to use. Also, tokens we generate for show are now temporary by default. Upload enhancements More filetypes, batch uploads, and better error detection and correction! you can now upload zipped shapefiles and Excel spreadsheets (.xls,.xlsx) have 100 GeoJSON files sitting in a folder? batch uploads are now possible! upload -f /directory/path/ --batch filetype you can also upload multiple files or URLs at once using comma separated paths + filenames -- here xyz upload -f file1,file2,/path1/file3,/path2/file4 or here xyz upload -f \"url1\",\"url2\",\"url3\" if a streaming upload is failing because a chunk is too large for the API gateway, we automatically reduce the size of the chunk until it successfully uploads, or we determine that the feature on its own is too large, in which case we notify you and move along to the next chunk we notify you if coordinates in a feature are > 180 or < -180 and it cannot be uploaded changes in how we assign the Feature ID: We've changed the default behavior of the CLI during upload to respect a GeoJSON feature ID if it is present. (Previously we made it a property hash by default, but we've seen an evolution in user behavior where more of you have unique and meaningful IDs.) As before, if there is no feature ID, the CLI will generate a hash of the feature properties and use that as the feature ID. This means if there are duplicate features, only one will be uploaded. -o now overrides an existing feature ID and generate a hash of the properties to use as the ID, or you can choose an existing property/properties as the feature ID with -i -- these options are useful when you are uploading multiple datasets with unique features but where the feature IDs overlap, especially from public data portals. --groupby enhancements --flatten: instead of a nested object, create a string delimited by : to reflect the logical hierarchy --promote: hoists a list of properties that don't need to be repeated in each grouped feature (e.g. the name of a region in electoral riding results, grouped by party) you can learn more about the power of groupby join enhancements use Data Hub's property search to create a Virtual Space based on the feature ID in one space and a property in another space. (If a property is not found, we add a no_match tag) use --filter to restrict the property search by yet another property (e.g. only look for counties in a particular state in a national dataset where county names are not unique) set a space to read-only here xyz config --readOnly true useful in preventing unintended modifications to an upstream virtual space space specific tokens show -w and show -v now generate a token just for that space. By default, a temporary token lasting 48 hours is generated. You can generate a permanent token for that space using --permanent or –x To learn more about the CLI, take a look at our documentation and give it a spin yourself!", "date": "2020-10-20"},
{"website": "Here", "title": "How to Find Out Whether a Location is on Land or Water", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/how-to-find-out-whether-a-location-is-on-land-or-water", "abstract": "I was recently working on a different project and thought it might be useful to know whether a given location (latitude and longitude) is either on land or in water. Finding out how to do this was a little bit tricky, so I thought I’d share how to do this in a blog post. What we’ll be building is a simple web app, which allows you to click on a map. When you do this, an info bubble will pop up to tell you whether you clicked on land or water! If you’re in water, the info bubble will also tell you what the name of the body of water is. Before we get started, you can check out the final project on land-or-water.com. (Yes, I bought a domain for a side project. Sigh. I blame my colleague Ray who “encouraged” me.) You can also check out the full code for the project on GitHub. With that out of the way, let’s get started! Step 1: Introducing the Advanced Data Sets API One of our more hidden and also more powerful APIs is the Advanced Data Sets API. This allows you to access a lot of our detailed map data directly, without going through any of our other APIs. Essentially the API offers map attributes as key/value pairs, which are grouped in layers. This is a big API with a lot of endpoints, so I will only cover the parts that are relevant for this use case. Please read the documentation for the full details. Step 2: Searching for the Right Layers Now my first thought was that there might a layer that contains information on water bodies. To find out whether that was the case, I used the layers endpoint of the API to get a list of all the layers currently available in the Advanced Data Sets API. https://s.fleet.ls.hereapi.com/1/doc/layers.json?apikey={apiKey} As you can see this API call doesn’t need any parameters, except for an API Key. If you don’t have one yet, just sign up for your own Freemium account . It only takes a minute. This call returns a long(!) list of layers. Here’s the very first one in the list: [\n    {\n        \"name\": \"ADAS_ATTRIB_FC1\",\n        \"type\": \"geom\",\n        \"tileLevel\": 9,\n        \"attributes\": [\n            \"LINK_ID\",\n            \"HPX\",\n            \"HPY\",\n            \"HPZ\",\n            \"SLOPES\",\n            \"HEADINGS\",\n            \"CURVATURES\",\n            \"VERTICAL_FLAGS\",\n            \"REFNODE_LINKCURVHEADS\",\n            \"NREFNODE_LINKCURVHEADS\",\n            \"BUA_ROAD\",\n            \"BUA_ROAD_VERIFIED\"\n        ],\n        \"featureMapping\": \"PDE-Premium-Adas\"\n    }, You can see the layer name (ADAS_ATTRIB_FC1) and the list of attributes in the layer. Please note the featureMapping value. This indicates whether the specific layer is part of your Freemium plan. Since this layer is “Premium” it is not, but the layers marked as “Base” are. ADAS stands for Advanced Driver Assistance Systems, and this layer contains high definition map data for autonomous driving. That’s pretty cool, actually, but not what I was looking for. So, I went for a scroll in the list and looked for layer names that seemed helpful. The most obvious candidates were called CARTO_POLY_OCEAN, CARTO_POLY_RIVER_DOx (with x being 1,2,3 and 4). However, just because the name sounds right doesn’t mean it is right. Also, rivers and oceans aren’t the only bodies of water in the world. What about lakes and bays and harbors and so on? I needed to dig deeper and started to use the layer endpoint (note the lack of a trailing s) to get more details about other layers that seemed interesting. This endpoint provides a description of a given layer. Here’s how to check what the layer CARTO_POLY_DO2 contains. https://s.fleet.ls.hereapi.com/1/doc/layer.json\n?apikey={{apiKey}}\n&layer=CARTO_POLY_RIVER_DO2 You’ll note that the response contains a textual description as well as a list of FEATURE_TYPE. One of these is “Lake” and another is “Bay/Harbour”, which is exactly what we are looking for! {\n    \"description\": \"Cartographic area polygons, except for administrative areas. Polygons are cut at tile boundaries, so that a polygon is decomposed into smaller pieces. Coordinate values with a leading zero indicate that the line to the next coordinate is artificially introduced by tiling or removal of inner rings.\",\n    \"attributes\": {\n        \"CARTO_ID\": \"Permanent carto ID.\",\n        \"FACE_ID\": \"Permanent face ID. A carto can consist of multiple faces. Each polygon is a \\\"face\\\". Hence, one CARTO_ID can comprise multiple faces.\",\n        \"FEATURE_TYPE\": \"Feature type that describes the carto type: 500412 : River 500413 : Intermittent River 500414 : Canal/Water Channel \",\n        \"NAMES\": \"The names of this carto. Cartos can have multiple names, in the same or in multiple languages, transliterations of these names and phonemes. This field contains all of them.\",\n        \"LAT\": \"Latitude coordinates [10^-5 degree WGS84] along the carto polygon. Comma separated. Clockwise orientation. Each value is relative to the previous.\",\n        \"LON\": \"Longitude coordinates [10^-5 degree WGS84] along the carto polygon. Comma separated. Clockwise orientation. Each value is relative to the previous.\",\n        \"INNER_LAT\": \"Latitude coordinates [10^-5 degree WGS84] of the inner rings of LAT/LON polygon. Coordinates are comma separated. Each value is relative to the previous. Inner rings are semicolon seperated\",\n        \"INNER_LON\": \"Longitude coordinates [10^-5 degree WGS84] of the inner rings of LAT/LON polygon. Coordinates are comma separated. Each value is relative to the previous. Inner rings are semicolon seperated\"\n    },\n    \"referencedStaticContents\": [],\n    \"tileRequestsLevel\": 11,\n    \"tileX\": 1870,\n    \"tileY\": 1339,\n    \"isStaticContent\": false\n} Using my detective skills and the layer endpoint, I was able to build a list of all layers and all feature types inside these layers that are relevant to our question. let layers =\n    \"CARTO_POLY_OCEAN,\" +\n    \"CARTO_POLY_RIVER_DO1,\" +\n    \"CARTO_POLY_RIVER_DO2,\" +\n    \"CARTO_POLY_RIVER_DO3,\" +\n    \"CARTO_POLY_RIVER_DO4,\" +\n    \"CARTO_POLY_DO2,\" +\n    \"CARTO_POLY_DO3,\" +\n    \"CARTO_POLY_DO4\";\n\nlet features = [\n    \"500116\", //Ocean\n    \"500421\", //Lake\n    \"500412\", //River\n    \"507116\", //Bay/Harbour\n    \"9997008\", //Seaport/Harbour\n]; Step 3: Checking Proximity To answer our question (land or water?) we now need to find out whether a given location is inside one of these features. That’s where the proximity endpoint comes into play. This endpoint returns all content in a given map layer or layers that are within a radius of a given location. Here’s how we can check whether we are in the ocean: https://fleet.ls.hereapi.com/1/search/proximity.json\n?layer_ids=CARTO_POLY_OCEAN\n&apiKey={{apiKey}}\n&proximity=41.771312,-26.542969\n&key_attributes=NAMES Note that we are providing a proximity location as latitude and longitude. This parameter also supports a radius, but only want to know about our specific location, so we are omitting this for an effective radius of 0. We also provide a list of layers, in this case only CARTO_POLY_OCEAN. Finally, we need to provide a key attribute from the layer, which we can get using the layer endpoint. In this case we have chosen NAMES. The response looks like this. We can see that the returned attributes contain the names of the ocean feature we are in, as well as a feature type. So, if the response contains any geometries with a feature type from our list from Step 2, we are in water. Let’s quickly expand this API call to include all relevant layers. Note that we need to provide a key attribute for every single layer. https://fleet.ls.hereapi.com/1/search/proximity.json\n?layer_ids=CARTO_POLY_OCEAN,CARTO_POLY_RIVER_DO1,CARTO_POLY_RIVER_DO2,CARTO_POLY_RIVER_DO3,CARTO_POLY_RIVER_DO4,CARTO_POLY_DO2,CARTO_POLY_DO3,CARTO_POLY_DO4\n&apiKey={{apiKey}}\n&proximity=41.771312,-26.542969\n&key_attributes=NAMES,NAMES,NAMES,NAMES,NAMES,NAMES,NAMES,NAMES Step 4: Building the web app Now we are ready to build the web app. Since this isn’t really a tutorial on how to use the JavaScript API, I will mostly refer you to the finished GitHub project and the documentation for the JavaScript API . Some quick notes, however. This project uses Fetch to make the exact API call from above. It then checks whether the geometries are empty. If so, we are on land. If they are not empty, it makes sure that feature type returned is one from the list we built above. If so, we are on water. Not so tricky in the end. let feature;\n    if (response.geometries.length > 0) {\n        feature = response.geometries[0].attributes.FEATURE_TYPE;\n\n        if (features.includes(feature)) {\n            isWater = true;\n            let featureNames = response.geometries[0].attributes.NAMES;\n            featureName = featureNames.substring(5, featureNames.length);\n            let separator = '\\u001E';\n            let index = featureName.indexOf(separator);\n\n            if (index != -1) {\n                featureName = featureName.substring(0, index);\n            }\n\n        } else {\n            isWater = false;\n        }\n\n    } else {\n        isWater = false;\n    } Finally, it grabs the first name from the list of names from the response and drops an InfoBubble on the map. let html;\n\n    if (isWater) {\n        html = '<div align=\"center\">🌊 Water! 🌊</div><div align=\"center\" style=\"width:250px\">In fact, this is the <em>${FEATURE}!</em></div>';\n        html = html.replace('${FEATURE}', featureName);\n    } else {\n        html = '<div align=\"center\">🌲 Land! 🌲';\n    }\n\n    if (lastBubble != null) {\n        lastBubble.close();\n    }\n\n    let bubble = new H.ui.InfoBubble({ lat: lat, lng: lng }, { content: html });\n    lastBubble = bubble;\n    ui.addBubble(bubble); That’s it! Now that you know how it works, why not try this exercise: Can you build and app that determines whether something is a golf course or not? I think golf-course-or-not.com is probably still available!", "date": "2020-10-27"},
{"website": "Here", "title": "Workspace & Marketplace 2.20 release notes", "author": ["Jeanus Ko"], "link": "https://developer.here.com/blog/workspace-marketplace-2.20-release-notes", "abstract": "Highlights New Location Services We are happy to announce the availability of new services on platform.here.com. These are ready to use, but do note that charges will apply. All new HERE Location services are billed at a rate of $/€0.0005 per transaction except for Japan API transactions which are priced at $/€0.00065. See the transaction definition for each service in the chart below. Please see the entire services suite at https://platform.here.com/services/ Service Transaction Definition Map Tile 1 Transaction is counted for every 15 Requests. Traffic Tile 1 Transaction is counted for every 15 Requests. Aerial Tile 1 Transaction is counted for every 15 Requests. Map Image 1 Transaction is counted for each Request. Weather 1 Transaction is counted for each Request. Traffic Flow and Incident 1 Transaction is counted for each Request. Positioning 1 Transaction is counted for each Request. Route Matching 1 Transaction is counted for each Request. Fleet Telematics 1 Transaction is counted for each Request with exceptions* Exceptions: Fleet Telematics: 1 Transaction is counted for each individual Service feature included in a Request. Fleet Telematics Custom Routes: 1 Transaction is counted for each routing Request. Fleet Telematics ETA Tracking: 2 Transactions are counted for each ETA update Request. Fleet Telematics Custom Locations: One Transaction is counted for each location, points of interest, polygon or finding a POI along a route in a Request. New SDKs We are happy to announce the availability of new SDKs on platform.here.com . These are ready to use, but do note that charges will apply. These HERE SDKs services are billed based on transactions at a rate of $/€0.0005 per transaction except for Japan API transactions which are priced at $/€0.00065. Please see the entire services suite at https://platform.here.com/sdk SDK Billed on HERE SDK Lite Edition for Android Transactions HERE SDK Lite Edition for iOS Transactions HERE SDK Explore Edition for Android Transactions HERE SDK Explore Edition for iOS Transactions HERE SDK Explore Edition for Flutter Transactions Improved Platform Portal login Org ID is no longer required when logging into the platform portal, except in cases where a users belongs to more than one organization. It's also now possible for a pending user to request a new invitation in the login flow, eliminating the need for and org admin to re-invite users. For users in multiple organizations, we've added \"forgot your Org ID\" functionality which emails users a list of the organizations to which they belong. Change layer configurations after a layer is created to correct mistakes without needing to delete and recreate the layer It is now possible to edit certain layer configurations after a layer has been created and even after the parent catalog as been marked as \"Marketplace Ready\". This change was made to ease certain changes, mostly to the advantage of developers when making configuration mistakes during layer creation or who want to change the configuration during CI/CD testing. It is important to note that making certain layer configuration changes after data is stored in the layer and/or after the parent catalog is available in Marketplace is very risky and can lead to irrecoverable impacts on data. Such changes should be made with great caution and understanding of the ramifications. Learn more here . The following configurations are now mutable via API, Data Client Library and CLI after a layer has been created: Stream layer configurations: Throughput, retention (TTL), content type, content encoding (compression) and schema association. Index layer configurations: Retention (TTL) and schema association Versioned layer configurations: Schema association Volatile layer configuration changes as well as support for this functionality via the Portal will be delivered in a future release. Decode and encode protobuf partitions with the CLI for more convenience during debugging and testing You can now use the get and put commands for partitioned layers and for stream layers with a flag to have your JSON data encoded to protobuf prior to uploading it or decoded to JSON after downloading it. Popular testing frameworks integrated in a new data validation module The Data Validation Library (DVL) has the purpose to enable scalable and efficient testing and validation of versioned catalogs on HERE Platform. In particular, testing of optimized maps and other generated versioned content should be implemented using DVL. Based on the Data Processing Library (DPL), DVL is supposed to abstract the underlying distributed processing on SPARK and Data API in order to facilitate quick creation of large-scale validation pipelines. However, to write tests, knowledge of DPL is required. To lower the entrance barrier for new platform developers, we now follow a more lightweight approach by means of a new data validation module which integrates popular testing frameworks such as Cucumber, Junit or ScalaTest, allowing test engineers to write the tests without any previous knowledge of the DPL, concepts of partitioning or map compilation. This is achieved by separation of the test-data extraction phase from the test scenarios which are executed in parallel on each self-contained test-data partition. Only the test-extraction phase requires knowledge of DPL features and underlying catalog structure. Once created, it can be used by test engineers without platform experience for implementation of numerous tests. The new module pragmatically computes metrics inside the test scenarios and does the assessment based on a predicate on the aggregated metrics satisfying the vast majority of all testing use cases. Please note that the above means that we are deprecating the DVL from the SDK for Java & Scala. The new data validation module in the DPL covers the functionality of the DVL. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue: In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the uses in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Known issue: The \"Upload data\" button in your Layer UI under \"More\" is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue: The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of index-layer data isn't supported yet. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Marketplace (Not available in China) Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices across all components No. Feature summary Deprecation period announced (platform release) Deprecation period announced (month) Deprecation period end 1 OrgID added to catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 February 26, 2021 (extended) Deprecation summary: Catalog HRNs without OrgID will no longer be supported after October 30, 2020. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID or by CatalogID won't work after October 30, 2020. Make sure all HRN references in your code are updated to use Catalog HRNs with OrgID before October 30, 2020 so your workflows continue to work. HRN duplication to ensure backward compatibility of catalog version dependencies resolution will no longer be supported after October 30, 2020. Examples of old and new catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 4 Batch-2.0.0 run-time environment for pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 5 Schema validation to be added 2.13 March 2020 November 30, 2020 Deprecation summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of November 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before November 30, 2020. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 6 Customizable volatile layer storage capacity and redundancy configurations 2.14 April 2020 October 30, 2020 Deprecation summary: The volatile layer configuration option to set storage capacity as a \"Package type\" will be deprecated by October 30, 2020. All customers should deprecate their existing volatile layers and create new volatile layers with these new configurations by October 30, 2020. 7 Stream-2.0.0 run-time environment for pipelines 2.17 July 2020 February 1, 2021 Deprecation summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 8 pipeline_jobs_canceled metric in pipeline status dashboard 2.17 July 2020 February 1, 2021 Deprecation summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 9 Stream throughput configuration changes from MBps to kBps 2.19 September 2020 March 31, 2021 Deprecation summary: Support for stream layers with configurations in MBps will be deprecated in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 10 Monitoring Stability improvements 2.20 Oct 2020 April 30 2021 Deprecation summary: The \"kubernetes_namespace\" metric has been deprecated and will be supported until April 30 2021. Update all Grafana dashboard queries using this metric to use the \"namespace\" metric. The label _ values(label) function has been deprecated and will be supported until April 30 2021. Update all Grafana dashboard queries using this function to use label _ values(metric, label) The datasource \"<Realm>-master-prometheus-datasource\" has been deprecated and will be supported until April 30 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 11 Data Validation Library 2.20 Oct 2020 April 30 2021 Deprecation summary: This is the first announcement of the deprecation of the Data Validation Library (DVL) from the SDK for Java & Scala. The new data validation module in the SDK's Data Processing Library covers the functionality of the DVL.", "date": "2020-10-28"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.22 release", "author": ["Jeanus Ko"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.22-release", "abstract": "Highlights A new Object Store layer type is available to store objects without requiring HERE partitions HERE Workspace now supports Object Storage as a new layer type . Read, write, update, delete and list objects stored in Object Store layers via any of the Data interfaces with exception of the Portal. Portal support, including a file system view and data inspection/visualization, will be delivered at a later time. A Hadoop File System interface-based connector is also provided with this solution in the form of a new component of the Data Client Library. This library enables you to access data stored in this layer via any tooling which supports HDFS. The combined solution of storage + library enables you to store objects in HERE Workspace without requiring HERE partitions and reduces custom code necessary to access your stored data from outside HERE Workspace. Note: The rollout of this new storage type introduces a new version of the Blob API (data-blob-v2). In order to leverage Object Storage directly via API, you must use this new version. The preexisting API (data-blob-v1) will continue to exist. See more information here . Share catalogs between projects This release introduces the capability to share catalogs between projects within the same organization, facilitating collaboration between teams who want to reuse resources. The capability consists of two interactions: First, users with manage access to a catalog in a project can now make that catalog available to other projects in their organization with read and/or write permissions. They may choose to make the catalog(s) available to specific projects or all projects in their organization. They may also subsequently revoke availability of the catalog as needed. Second, once a catalog has been made available to a project, users in that project can link to it choosing from the available permissions if more than read access has been granted. Users can also subsequently de-link the linked catalog from their project as needed. This functionality is accessed through the portal in the Projects Manager and the catalogs section of Data , as well as through the CLI . With the addition of this feature, projects become a more flexible way to work with your resources, and we encourage platform users to only create new catalogs in the context of/scoped to a project. Data Inspector Improvements The Data Inspector in Workspace is available as a standalone online tool to load and inspect your locally developed partition files. You can access it through your platform portal launcher, or visit https://platform.here.com/data-inspector . When visiting the Inspect tab of a versioned layer, you can inspect the data freshness as a heat map on higher zoom levels, just like you would on data density. To activate the freshness heat map, find the Heatmap section on the left control panel of your Inspect tab and set type to Freshness. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Changed: The Data Inspector has been available for you to inspect data locally and run a small web server locally during your local development, and now you can also use it as an online tool to load and inspect your locally developed partition files. You may access it through the platform portal launcher, or simply visit https://platform.here.com/data-inspector . Changed: When visiting the Inspect tab of a versioned layer, you may now inspect the data freshness as a heat map on higher zoom levels, just like you would on data density. To activate the freshness heat map, find the Heat map section on the left control panel of your Inspect tab, and set type to Freshness. Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue: In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limitation. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the uses in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Changed: The Data Stream API and the Data Client Library are now integrated with OAUTH2. OAUTH2 mitigates the need for Kafka data producers and consumers to restart whenever authentication tokens are refreshed, which was the case with the prior version of authentication. Such restarts can drive data duplication in streaming data workflows, therefore this update is intended to address that issue. Known issue: In support of the new Object Store layer type, a newer version of the Blob API (blob v2) is also now available in production. The availability of this new Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Given multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you are intending to work with. To support existing workflows until you are able to correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months only, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue: When using spark-sql to read a single file from an Object Store layer using the blobfs library, blobfs returns an empty result because it will only list directories, not files. Workaround: When using spark-sql to read a single file from an Object Store layer using the blobfs library, include the respective directory path in the request. Known issue: The \"Upload data\" button in your Layer UI under \"More\" is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue: The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of index-layer data isn't supported yet. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Map Content Changed: A dditions to existing layers in the HERE Map Content catalog: A dded ConnectorTypeId to Port in \"Places\" layer Marketplace (Not available in China) Known issue: When adding an Object Store layer to a Marketplace catalog and offer with an subscription option, the subscription reporting currently does not generate usage metrics. Workaround: Subscription reporting will support Object Store layer type in the next release. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices.) No. Feature summary Deprecation period announced (platform release) Deprecation period announced (month) Deprecation period end 1 OrgID added to catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 February 26, 2021 (extended) Deprecation summary: Catalog HRNs without OrgID will no longer be supported in any way after February 26, 2021. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after February 26, 2021. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before February 26, 2021 so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after February 26, 2021. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 June 30, 2021 Deprecation summary: For security reasons, the platform will start validating schema reference changes in layer configurations as of November 30, 2020. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before November 30, 2020. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for pipelines 2.17 July 2020 February 1, 2021 Deprecation summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 pipeline_jobs_canceled metric in pipeline status dashboard 2.17 July 2020 February 1, 2021 Deprecation summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Stream throughput configuration changes from MBps to kBps 2.19 September 2020 March 31, 2021 Deprecation summary: Support for stream layers with configurations in MBps is deprecated and will no longer be supported in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 7 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation summary: The \"kubernetes_namespace\" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \"namespace\" metric. The label _ values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label _ values(metric, label) The datasource \"<Realm>-master-prometheus-datasource\" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 8 Additional support to help distinguish Blob API versions in Lookup API responses 2.22 December 2020 June 30, 2021 Deprecation summary: Given multiple versions of different Data APIs exist, it is important that your automated workflows requesting service endpoints from Lookup API are updated to select the right baseUrls per the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions within the responses for the next 6 months only, starting January 2021. In order to prevent downtime, please update your workflow automation within this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version.", "date": "2020-12-17"},
{"website": "Here", "title": "Building the COVID City Map", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/building-the-covid-city-map", "abstract": "Building the COVID City Map COVID-19 has rapidly changed how the world does, well, everything. Small businesses, in particular, have to rapidly change how they do things in order to stay afloat. As cities rapidly change lockdown rules in different directions, it can be hard to know what businesses are open and what services (delivery, curbside pick, etc.) are available. HERE Technologies, with our partners, have built an application that demonstrates how this information can be both gathered and then shared with the public. We have two examples of this now, one for Liverpool, England and one for Lyon, France . In the screen shot above, you can see the Lyon, France map with businesses that are sharing information prominently displayed. Selecting one zooms in and gives you details: If your French isn't quite up to snuff, the detail under Services specify that this bakery offers takeaway service, but not delivery or contactless delivery. (I cheated and just checked the Liverpool map.) This map was built with user submissions in mind. By clicking the Submit your Business/Ajoutez votre entreprise button, any business can enter their details. These details will be reviewed, tweaked if necessary, and then published. Let's talk a bit more about how that process works. I worked on the initial version of this demo (the current version was done by our partners and looks far nicer than mine) and initially created a solution using Google Forms and Sheets. It's possible to have a public Google Form write to a public Google Sheet that only has public read access. We tied the Google Form submissions to the Sheet and added additional columns to mark which entries were valid (in case of spam) as well as adding latitude and longitude values. We ended up moving away from this approach, but if this interests you, please read my blog post on how you can do the same. At HERE we are big users of Sharepoint so we quickly realized that it would be better to switch to Microsoft Forms. The form was built using Microsoft's form builder: For the most part, this worked just as easily as Google's, to the point where I almost wondered if one or the other was sharing tech. The only issue came in when we wanted to send the resources to an Excel form. Google makes this incredibly easy - you can send form submissions to Sheets with a quick setting change. Microsoft Forms did not. After some searching, I came across an excellent blog post that discussed how to handle this: How to sync Microsoft Excel with Microsoft Forms responses (using Power Automate) Basically - you end up using another Sharepoint product, Power Automate. I had never heard of this before, but the blog post walked me through the relatively painless process. You do need to be careful if you make any changes to the form itself. Editing questions seemed harmless enough but adding or removing questions may require going back to Power Automate and updating the connection. Unfortunately, there was no way (well, no way we felt comfortable with) to share Excel data via a public URL. Since the process required human intervention anyway (again, to check for spam as well as figuring out latitude and longitude for a business), we decided to keep it manual and simply export the results as a CSV file that ends up in the same location as the rest of the application. Initially PapaParse was used for CSV processing but that changed D3 . Personally this was rather surprising to me as I had only heard of D3 being used for fancy graphics! That covers how the data is gathered and produced - the end result is made beautiful with our JavaScript maps API. As I said, our partners made the final product look so good, but even before them I was able to build an interactive map with our data that was - ok - it wasn't beautiful but it was a good enough to be taken and improved upon! I think that's a great thing about our Maps API, even someone like myself with little to no design skills can build fully interactive data-driven maps quickly. Be sure to check out the end result - Liverpool and Lyon .", "date": "2021-01-05"},
{"website": "Here", "title": "December 2020 Release Notes", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/dec-2020-release-notes-0-0-0", "abstract": "Welcome to the latest release notes for the HERE Location Services. These notes are a bit late and for that we humbly apologize. Personally I blame too much Turkey on Thanksgiving. But let's move on! These releases include updates of: Routing API, Geocoding and Search API, Map API for Java Script, Transit API, Intermodal API and HERE SDK for Android, iOS and Flutter. For more detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation and release notes on the Developer Portal . REMINDER! IMPORTANT INFORMATION regarding new license terms for Location Services on Platform*: For some of our new Location Services made available on Platform , we have changed the Transaction definitions in your current contract with HERE. This will impact all existing Location Services customers that have a contract with a license term based on Transactions such as Location Mapping when they start using Location Services on Platform. By continuing to use the Location Services on Platform, you accept the new terms. The changes are the following: Category Feature Definition Previous Geocoder Autocomplete or Places Autosuggest No Charge New Geocoding and Search Autosuggest or Autocomplete One Transaction is counted for every 10 Requests Previous Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal max parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal alternative ’ parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Vector Tiles One Transaction is counted for every 5 Requests Previous Isoline Routing One Transaction means one Request New Isoline Routing One Transaction equals each individual Isoline within an Isoline Request Large Scale Matrix Routing and Matrix Routing included in Routing API will be merged into Matrix Routing API V8 Previous Large Scale Matrix Routing One Transaction is counted for every 20 Elements in a Large-scale Matrix Routing API Request. The number of Elements equals the number of start points times the number of destination points. Large-Scale Matrix Routing Requests generating less than 100,000 individual elements are always counted as 5,000 Transactions New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more , the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 Previous Matrix Routing One Transaction is counted for each start point Request New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 *Location Services on Platform are the latest major releases such as Geocoding and Search API V7, Routing, Matrix Routing, Isoline Routing, Transit and Intermodal API´s V8 and Vector Tile API V2 HERE Location Services on Platform Routing ( Version 8. 9.1) allowHighway option for scooters Guidance in routing: toward attribute to RoadInfo used for turnByTurnActions Machine Learning based ETAs in 5 cities Bicycle mode in matrix routing Charge aware EV Routing - alternative routes supported Geocoding and Search ( Version 7.0.57) Autosuggest, Discover, and Geocode endpoints support intersection search. Intersection queries contain two street names, for example, \"5th Ave @ E 82nd St New York\". Results are of new r esultType \" intersection \". Results provide the street names in the \" streets \" list. Autosuggest and Discover endpoints support the search for 7-digit UK postal codes These UK postal codes are high precision postal code points assigned to a single or small number of addresses. Results are of new resultType \" postalCodePoin t\". Autosuggest and Discover endpoints support geo-coordinate queries in sexagesimal degrees (degrees, minutes, seconds, for example, \"48°51'29.7\"N 2°17'40.2\"E\") or decimal degrees (\"48.8582,2.2945\"). Autosuggest and Discover endpoints support German \"Sparkasse\" chain queries. Autosuggest, Browse, Discover, and Lookup endpoints provide Parkopedia references in place results where applicable. Increased geocoding accuracy for Canada queries by recognizing and parsing out secondary unit information. All endpoints support X-Request-ID header. This ID is useful for customers who want to track their queries. Transit ( Version 8.0) Fares and Price description attribute updated Intermodal Routing ( Version 8.01) Bike + Transit Intermodal routing expanded, now supporting PrivateBike routing in combination with Transit (in addition to SharedBike already available) Maps API for Java Script ( Version 3.1.19.2) Further improvements to the Japan map style Performance improvement: the tile caching strategy was significantly changed HERE SDK for Android , iOS and Flutter Lite Edition ( Version 4.5.2) Added Scooter routing HERE SDK for Android, iOS and Flutter Explore Edition ( Version 5.5.2) Added Scooter routing Dedicated variant for Japan available (please contact you HERE Account Executive for access) Dedicated backends with Japan content Japan-specific map styles HERE SDK for Android and iOS and Flutter Navigate Edition ( Version 4.5.2) Added Lane Assistance Added Scooter routing This notification will be issued monthly summarizing the HERE Location Services releases in the previous month.", "date": "2021-01-04"},
{"website": "Here", "title": "Introducing Electric Vehicle Routing to the HERE Developer Portfolio", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/introducing-electric-vehicle-routing-to-the-here-developer-portfolio", "abstract": "We have an exciting update to our Routing API with the addition of powerful and versatile electric vehicle (EV) routing. This new feature provides rich support for EV fleet management. This support goes way beyond just mapping charging points: it can be configured with your individual EV properties to meet the requirements of your service or app. It can also take into account time to charge as well as optimal times and suggest routes best suited for your particular EV needs. To get started using this new feature, begin by taking a look at our developer guide introduction to EV routing. At a high level, you'll need the following arguments to use EV routing. First, to calculate energy consumption, you'll need: freeFlowSpeedTable : A function curve that specifies energy consumption at a particular speed. ascent : The rate of energy consumed per meter rise in elevation. descent : The rate of energy consumed per meter fall in elevation. On top of these, to calculate reachable routes, you'll need: initialCharge : Charge level of the vehicle's battery at the start of the route. maxCharge : Total capacity of the vehicle's battery. connectorTypes : Comma-separated list of connector types that are compatible with the vehicle. The API docs define supported types. chargingCurve : Function curve describing the maximum battery charging rate at a given charge level. maxChargeAfterChargingStation : Maximum charge to which the battery should be charged at a charging station. makeReachable : This must be set to true. There are additional EV related attributes as well, and as said above, the API docs are your best friend. It can get pretty complex. Let's consider an example with hard coded values using Node.js: const fetch = require('node-fetch');\n\nrequire('dotenv').config();\nconst API_KEY = process.env.HERE_API_KEY;\n\n(async () => {\n\n    // New York (lat, long)\n    let p1 = '40.712,-74.059413';\n    // Boston\n    let p2 = '42.360,-71.0588801';\n\n    let props = {\n        transportMode:'car',\n        origin:p1,\n        destination:p2,\n        'ev[freeFlowSpeedTable]':'0,0.239,27,0.239,45,0.259,60,0.196,75,0.207,90,0.238,100,0.26,110,0.296,120,0.337,130,0.351,250,0.351',\n        'ev[trafficSpeedTable]':'0,0.349,27,0.319,45,0.329,60,0.266,75,0.287,90,0.318,100,0.33,110,0.335,120,0.35,130,0.36,250,0.36',\n        'ev[auxiliaryConsumption]':1.8,\n        'ev[ascent]':9,\n        'ev[descent]':4.3,\n        'ev[initialCharge]':48,\n        'ev[maxCharge]':80,\n        'ev[makeReachable]':true,\n        'ev[connectorTypes]':'iec62196Type1Combo,iec62196Type2Combo,Chademo,Tesla',\n        'ev[chargingCurve]':'0,239,32,199,56,167,60,130,64,111,68,83,72,55,76,33,78,17,80,1',\n        'ev[maxChargeAfterChargingStation]':72,\n        return:'summary,actions,polyline'\n    };\n\n    let route = await getRoute(props);\n    // polyline is huge and noisy\n    for(let i=0;i<route.sections.length;i++) {\n        if(route.sections[i].polyline) route.sections[i].polyline = 'Deleted to make output easier to read.';\n    }\n    console.log(JSON.stringify(route, null,'\\t'));\n\n})();\n\nasync function getRoute(props) {\n    let url = `https://router.hereapi.com/v8/routes?apikey=${API_KEY}`\n    for(let key in props) {\n        url += `&${key}=${props[key]}`;\n    }\n    let resp = await fetch(url);\n    let data = await resp.json();\n    if(!data.routes) console.log(data);\n    return data.routes[0];\n\n} This script simulates an EV route from New York City to Boston. It includes multiple different ev arguments that specifies the nature of how the vehicle operates, charges, and so forth. In your REST calls, all ev arguments will be of the form ev[something] which can help visually differentiate it from the rest of the call. All of these arguments are passed to a little utility function I wrote that then hits the API and parses the result, returning just the first route (if it exists - like many of the scripts I write to test things out the error handling could be nicer!). Executing this script will return, as usual, quite a lot of information in regards to the trip, but let me share some interesting portions from the result. Route results come in \"sections\" that make up the route, and with EV routing enabled, you are presenting with information related to charging done at the end of the section, including estimated charge and time to complete the charge: \"postActions\": [\n    {\n        \"action\": \"charging\",\n        \"duration\": 568,\n        \"consumablePower\": 350,\n        \"arrivalCharge\": 3.8865,\n        \"targetCharge\": 40\n    }\n], Arrival information also includes EV data: \"arrival\": {\n    \"time\": \"2021-01-15T13:13:32-05:00\",\n    \"place\": {\n        \"type\": \"chargingStation\",\n        \"location\": {\n            \"lat\": 41.1980673,\n            \"lng\": -73.1222808\n        },\n        \"id\": \"2927\",\n        \"name\": \"Stratford Square\",\n        \"attributes\": {\n            \"power\": 350,\n            \"current\": 350,\n            \"voltage\": 1000,\n            \"supplyType\": \"dc\",\n            \"connectorType\": \"iec62196Type1Combo\"\n        }\n    },\n    \"charge\": 3.8865\n}, Summary data will also include charging related information: \"summary\": {\n    \"duration\": 5860,\n    \"length\": 150224,\n    \"consumption\": 54.0499,\n    \"baseDuration\": 5734\n}, All in all, it's a fairly complex new feature. There's a few resources I'd suggest for additional help: Calculating energy consumption - An excellent use case example from the developer's guide. Calculating a route with charging along the way - Another use case example from the developer's guide. Consumption model - Another resource from our developer's guide, this one will provide more information about EV characteristics in particular in regards to how to use them with the API. And finally, the HERE Routing API Reference Client , a web-based tool that helps you visualize our API and it's results. It's especially useful if you need sample EV attribute values. As an example, here's how the Reference Client renders my NYC to Boston route, with notable charging stops.", "date": "2021-01-25"},
{"website": "Here", "title": "Announcing the Winners of the HERE Map Data Hackathon", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/announcing-the-winners-of-the-here-map-data-hackathon", "abstract": "In October of 2020, HERE announced the launch of the HERE Map Data Hackathon . This was to help developer discover our latest offering, Data Layers which gives you access to our geographic data. Covering ten different layers of data for nearly seventy different cities around the world, Data Layers lets developers use their own tools to examine and build upon an incredible amount of map data. (See our introductory blog post for more information.) The hackathon ran for about six weeks and we had a large number of fascinating entries from around the world. Today we're happy to announce the winners and their project, Gefahrradtour. Comprised of three individuals from Germany, Gefahrradtour is a fascinating look at combining map data with safety data. Gefahrradtour is a web application built to enable bicyclists to safely get from one place to another. In many cases, a route from one place to another may be quickest for a vehicle but inherently dangerous for a person on a bicycle. In 2019, Berlin recorded over five thousand accidents involving bicyclists of which thirty four were fatal. The Gefahrradtour team took public data on these accidents and HERE Data Layers information for Berlin and made use of R to create a method of determining not just the shortest route between two points but also the safest. The web application lets you move a slider from quicker (and potentially most dangerous) to most safe. For example, here's a sample route that starts off with the quickest but dangerous route: In the image above, you can see two portions of the route highlighted in red. Clicking on them provides more information: Compare this to the very safe route: While there's still dangerous areas, overall it should be a safer route for the potential trip. The team behind the submission included: Emelie Hofland: Emelie has a background in sociology, but took part-time jobs and online courses to learn both Python and R. She got into hackathons via her partner and enjoys creating these types of projects. Most importantly - she's learning to play the banjo. Jasmin Classen: Jasmin is currently working on her Master's degree in Social and Economic Data Science. She originally got into coding and data analysis after being exposed to statistics and R while earning her Bachelors. After completing her Bachelors she decided to continue with a more technical degree and has since learned Python and more computer science topics. Jordan Skubic: Jordan works together with Jasmin and Emelie at Flixbus and has a background in philosophy and economics. He credits his time at college as having exposed him to the importance of using a bike in an urban center. Like his team mates, he learned R and Python and used them to help further his interest in urban mobility. To learn more about the winning submission, you can see their post at the Hackathon as well as check out their GitHub repo: https://github.com/Emelieh21/Gefahrradtour And finally, they've got the application up and running here: https://emelieh21.shinyapps.io/Gefahrradtour/ Thanks to Emelie, Jasmin, and Jordan for a fascinating submission and congrats again on your win!", "date": "2021-01-19"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.23 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.23-release", "abstract": "Highlights A new Interactive Map layer type is available to store and manipulate data on a feature level (not available in China with this release) For those of you familiar with HERE Data Hub as a storage/service solution available via the HERE Developer Portal , this new interactive map layer introduces that same storage concept to HERE Workspace where you can work with data at a more granular feature level, modifying individual geofeatures or even feature properties instead of full partitions. You can also request different tiling schemas at the time of request, including quadkey/Virtual Earth, Web Mercator, OSGEO Tile Map Service and HEREtile. This release includes integration support via API only with integrated visualization capabilities forthcoming. This feature is not yet available in China. Learn more about this interactive map layer storage solution here Create a layer . Speed up development with additional customizable pipeline templates New pipeline templates have been added to the Customizable Pipeline Templates portal page . Develop faster with these configurable and scalable processing blocks that you can deploy as part of your own workflow without needing to write any code. Map Matcher Aggregates messages and sorts by timestamp, then map-matches per message. HERE Map Content (HMC) to Optimized Map for Location Library (OMLL) Converter This converter lets you produce an optimized map for the location library from any catalog that follows the schemas of HERE Map Content. You can then apply the location library with this map to perform efficient map matching, fast random attribute access and road network traversal. Map Object Model (MOM) to HERE Map Content Converter Takes a MOM-based input road topology layer with GeoJSON Line Strings from HERE Map Creator. Checks are performed on the data, then road intersections are built from the GeoJSON Line Strings and a HERE Map Content topology-geometry layer is produced. HERE Map Content (HMC) Cartography Filter Filter cartography data from HERE Map Content by categories. HERE Map Content (HMC) Topology Filter Filter topology segments and their related attributes from the HERE Map Content based on their attribute. Optimal Alert Locater Finds locations on a roadwork that can be used as triggerpoints to send an alert about an issue on the road ahead. Real-Time Anonymizer This new Stream Pipeline enables probe data anonymization of SENSORIS formatted data in a streaming layer. The location data anonymization technique provides cutting edge support for multi-criteria start cutting, randomized anonymization parameter values and cross-trajectory chunk processing. Users can configure a custom anonymization strategy to create fully GDPR-compliant probe data achieve balance between user anonymity and data utility. Consent Management User Dashboard HERE Consent Manager introduces a single point of access ( https://platform.here.com/consent/ ) for car drivers to manage all consents given for sharing their vehicle data through a Neutral Server. With HERE Consent Manager, your consumers can use their dashboards to review, manage or revoke consents to multiple, integrated partners . Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue : In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limit. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the uses in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Fixed: The blobfs library has been updated to correctly list both directories and files. You can now successfully read a single file from an Object Store layer using the blobfs library without including the respective directory path in the request. Known issue: In support of the Object Store layer type, a newer version of the Blob API (blob v2) is available in production. The availability of this newer Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Because multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you intend to work with. To support existing workflows until you can correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue : The \"Upload data\" button in your Layer UI under \"More\" is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue : The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of index-layer data isn't supported yet. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Marketplace (Not available in China) Known issue: When adding an Interactive Map layer to a Marketplace catalog and offer with a subscription option, the subscription reporting doesn't generate usage metrics. Workaround: Subscription reporting will support Interactive Map layer type in the next release. Known issue: When adding an Object Store layer to a Marketplace catalog and offer with a subscription option, the subscription reporting does not generate usage metrics. Workaround: Subscription reporting will support Object Store layer type in the next release. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices.) No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 June 30, 2021 (extended) Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way. · Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after this deprecation period. · Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before this date so your workflows continue to work. · HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after this date. · Examples of old and new Catalog HRN formats: · Old (without OrgID/realm): hrn:here:data:::my-catalog · New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation Summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 June 30, 2021 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations after this deprecation period. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before the deprecation period end. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 Deprecation Summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Stream throughput configuration changes from MB/s to KB/s 2.19 September 2020 March 31, 2021 Deprecation Summary: Support for stream layers with configurations in MBps is deprecated and will no longer be supported in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 7 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation Summary: The \" kubernetes_namespace \" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \" namespace \" metric. The label_values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label_values(metric, label) The datasource \" <Realm>-master-prometheus-datasource \" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 8 Additional support to help distinguish Blob API versions in Lookup API responses 2.22 December 2020 June 30, 2021 Deprecation Summary: Because multiple versions of different Data APIs exist, it's important that your automated workflows that request service endpoints from Lookup API are updated to select the right baseUrls for the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions in responses over the next 6 months, starting January 2021. To prevent downtime, update your workflow automation during this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version.", "date": "2021-01-25"},
{"website": "Here", "title": "New Features Added to Six APIs", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/new-features-added-to-six-apis", "abstract": "We are excited to announce many new features added to some of our popular APIs. The enhancements span across a variety of business needs such as front-end development, routing scenarios, and improved data and search. All the features mentioned in this post are available today by using the latest release of each respective API. Let’s explore what is new per API… New in Vector Tiles API The Vector Tile API is a service that allows graphical tiles to be requested – usually from a tile service platform such as HERE Maps API for JavaScript , Mapbox , or Harp.gl to name a few. The latest release now supports the following: Client-side map customization supported by the HERE map style editor , enabling simplified design and management of a map’s “look and feel” Client-side object identification to allow interaction with map content Support for multiple political views - Support to produce higher resolution maps For more information, please check out the Vector Tiles API guide . New in Geocoding & Search API Not too long ago, we consolidated our Geocoding API and Places API into our new Geocoding and Search API . With this API, you can request data through geocoding (forward and backwards) and via search criteria. In addition to overall improvements to coverage and data accuracy, the main new feature is with regard to geocoding – it now recognized Points of Interest (POI), matches them, and returns the address and a matching place! For more information, please check out the Geocoding & Search API guide . New in Routing API Our Routing API provides services to support custom navigation between two or more locations. In addition to overall performance and quality improvements to core routing algorithm, the latest release now supports the following: Two-Wheeler routing using specific road segment and adopted speed profiles Charge aware EV routing finding fastest routes considering optimized charging stops Taxi mode using Taxi specific lanes and access regulations For more information, please check out the Routing API guide . New in Intermodal Routing API The Intermodal Routing API offers an innovative and smart routing experience. This is possible when the consolidated public transit offer is intertwined with external mobility services dynamically scattered in urban areas. This scenario opens a wide set of ready-to-use mobility options to quickly and better navigate between a given pair of locations. Here are the additional benefits now available: The API now returns transit only and intermodal routes in one response, and are compared from a duration, number of transfers and cost perspective to provide the most effective commuting experience Support for additional mobility modes - by integrating public GBFS (General Bikeshare Feed Specification) feed, which is providing real-time information of hundreds of bicycle sharing systems around the world Flexible combination of transit with micro-mobility options to cover first and last mile Taxi/e-hailing mobility that allows intermodal combination of Taxi and Transit For more information, please check out the Intermodal Routing API guide . New in Matrix Routing API The Matrix Routing API is a service that calculates routing matrices. A routing matrix is a matrix with rows labeled by origins and columns by destinations. Each entry of the matrix is travel time or distance from the origin to the destination. New features include: Support for up to 10,000 origins and 10,000 destinations Support for new routing modes: o Two-Wheeler routing o Bicycle routing For more information, please check out the Matrix Routing API guide . New in Transit API The Transit API allows discovery of public transit options, to request public transit routes and transit related information. Here are the new features which improve functionality: Station Search now supports access points data, so it is possible to search for stations’ specific exits and gates (useful for pick-up or drop-off use case) New improved iteration of Service Alerts feature For more information, please check out the Transit API guide . Summary We encourage developers to evaluate the new features discussed in the post. If you are new to HERE APIs, please sign up for a freemium account to start exploring our location services APIs today!", "date": "2021-02-02"},
{"website": "Here", "title": "Working with Tour Planning", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/working-with-tour-planning", "abstract": "Welcome to a (hopefully) gentle introduction to HERE Tour Planning. Tour Planning is an incredibly powerful API, and as such, requires a good deal of... wait for it... planning. In this post I'll introduce you to the API and it's components, go over the items you'll need to be able to use it, and share a simple example. Do note that Tour Planning is not currently part of our freemium plan, so to use it, you'll need to contact us. You may also request a timed evaluation. So what exactly is tour planning? At a high level, tour planning helps you manage a set of one more more vehicles (also called a fleet) that need to do certain jobs. These jobs may have restrictions on what time they can be done as well as what order. You can imagine a package delivery company having this problem every day. They have ten vehicles. Each vehicle has a cost for it's operation. They have one hundred deliveries to make, many with specific times. How would you create a plan such that all packages are delivered, on time, at the cheapest price, and even account for traffic? This is where the tour planning API will help. The API can even consider changes to an existing plan. Lost a vehicle due to a breakdown? You can modify an existing plan to get new results. As mentioned above, making use of this API requires quite a bit of planning ahead of time. Some of the information you'll need for a typical API call includes: The makeup of your fleet, which includes the cost of vehicle operation, the times the vehicle is available, as well as where the vehicle starts it's shift and where it needs to be when done. Your fleet will be specified both as a set of vehicle types as well as the total number of each type. Next, you will need to define the jobs that must be accomplished. This includes the type of job (like making a delivery or picking up an item), locations, how much time is available at that location, what times the job can be accomplished, what order the jobs must be made in, and how important a job is compared to another. The tour planning developer guide contains full documentation for making requests and is further supported by an API guide as well. Before getting started, one of the most important things to know is that tour planning supports both synchronous and asynchronous API calls. As you can imagine, the complexity of the work necessary to solve a tour planning problem can be quite high. In order to maintain the performance of the API itself, synchronous calls will have limits on jobs and fleet sizes. Luckily, you'll get a clear error from the response if you go over those limits. (At the time this post was written, the documentation for synchronous requests specifies a limit of 250 jobs and 35 vehicle types.) For asynchronous calls , the API will return an identifier that lets you then poll for the status at an interval of your choosing. When the work is done, you can then download the solution. After determining what kind of call you will need to make, you begin by defining the problem. As described above, the problem consists of two portions. The first is the plan, which is a formal list of jobs that need to be done. Jobs will consist of the following properties: location duration (how much time is spent at the location) demand (a free form value that lets you define custom capacities for your fleet, like the ability to hold a certain number of people or pieces of hardware) Along with these properties, you can additionally specify times for makling a step as well as your own specific skills and tags associated with the job. Jobs are also associated with a few specific types - deliveries, pickups, and an instance of doing both. Finally, you can name jobs which makes it easier to work with the response. The next aspect of the problem is the fleet. Again, don't overthink this - your fleet of vehicles could be a fleet of one. A fleet is a set of vehicle types where each type consists of: An identifier The cost to use the vehicle Time shifts the vehicle is available. Size capacity As well as whether or not the type is a car or truck. Additional properties are also supported. As with jobs, you can include metadata to make it easier to work with the result data, but do not send private and identifying type information like license plate numbers. Finally you'll have an amount for each type. This is quite a bit to consider, but the documentation has a specific page just for discussing the problem , and again, the API reference will go deeper into the properties and required values. Once the problem is submitted and sent to the API, you then get to work with your solution. Solutions consist of: Statistics covering cost, distance travelled, duration, and a break down of times spent doing driving, serving jobs, and so forth. A list of \"tours\" which represent a vehicle type, stops that need to be made, and specific statistics about that tour. You also, potentially, get a list of jobs that could not be completed. As with the problem definition, there's a great documentation that goes into detail about the solution. All in all, the problem definition is where you'll spend the bulk of your time. Once it's defined, and once you have a proper understanding of the result, it's pretty trivial to make a call. Here's an example of a synchronous call in a simple Node.js script. It only has one car so it's incredibly trivial, but its illustrative of the \"shape\" of how you would use the API. require('dotenv').config();\n\nconst fetch = require('node-fetch');\nconst KEY = process.env.KEY;\n\nconst body = {\n  \"plan\": {\n    \"jobs\": [\n      {\n        \"id\": \"myJob\",\n        \"places\": {\n          \"deliveries\": [\n            {\n              \"location\": {\"lat\": 52.46642, \"lng\": 13.28124},\n              \"times\": [[\"2020-07-04T10:00:00.000Z\",\"2020-07-04T12:00:00.000Z\"]],\n              \"duration\": 180,\n              \"demand\": [0]\n            }\n          ]\n        }\n      },\n      {\n        \"id\": \"myJob2\",\n        \"places\": {\n          \"deliveries\": [\n            {\n              \"location\": {\"lat\": 53.46642, \"lng\": 13.10124},\n              \"times\": [[\"2020-07-04T10:00:00.000Z\",\"2020-07-04T12:00:00.000Z\"]],\n              \"duration\": 180,\n              \"demand\": [0]\n            }\n          ]\n        }\n      },\n    ]\n  },\n  \"fleet\": {\n    \"types\": [\n      {\n        \"id\": \"myVehicle\",\n        \"profile\": \"normal_car\",\n        \"costs\": {\n          \"distance\": 0.0002,\n          \"time\": 0.004806,\n          \"fixed\": 22\n        },\n        \"shifts\": [{\n          \"start\": {\n            \"time\": \"2020-07-04T09:00:00Z\",\n            \"location\": {\"lat\": 52.52568, \"lng\": 13.45345}\n          },\n          \"end\": {\n            \"time\": \"2020-07-04T18:00:00Z\",\n            \"location\": {\"lat\": 52.52568, \"lng\": 13.45345}\n          }\n        }],\n        \"capacity\": [10],\n        \"amount\": 1\n      }\n    ],\n    \"profiles\": [{\n      \"name\": \"normal_car\",\n      \"type\": \"car\"\n     }]\n  }\n};\n\nfetch('https://tourplanning.hereapi.com/v2/problems?apikey='+KEY, {\n    method:'POST', \n    body:JSON.stringify(body),\n    headers: {\n        'Content-Type':'application/json',\n        'Content-Accepts':'application/json'\n    }\n}).then(res => res.json())\n.then(res => {\n    console.log(JSON.stringify(res, null, '\\t'));\n}); As you can see, nearly all of the code is the definition of the problem. Of course, in a real application you would do more with the solution than just dump it out to the console. Here's how the result looks: {\n    \"statistic\": {\n        \"cost\": 153.383426,\n        \"distance\": 270731,\n        \"duration\": 16071,\n        \"times\": {\n            \"driving\": 15711,\n            \"serving\": 360,\n            \"waiting\": 0,\n            \"break\": 0\n        }\n    },\n    \"tours\": [\n        {\n            \"vehicleId\": \"myVehicle_1\",\n            \"typeId\": \"myVehicle\",\n            \"stops\": [\n                {\n                    \"location\": {\n                        \"lat\": 52.52568,\n                        \"lng\": 13.45345\n                    },\n                    \"time\": {\n                        \"arrival\": \"2020-07-04T09:31:17Z\",\n                        \"departure\": \"2020-07-04T09:31:17Z\"\n                    },\n                    \"load\": [\n                        0\n                    ],\n                    \"activities\": [\n                        {\n                            \"jobId\": \"departure\",\n                            \"type\": \"departure\"\n                        }\n                    ]\n                },\n                {\n                    \"location\": {\n                        \"lat\": 52.46642,\n                        \"lng\": 13.28124\n                    },\n                    \"time\": {\n                        \"arrival\": \"2020-07-04T10:00:00Z\",\n                        \"departure\": \"2020-07-04T10:03:00Z\"\n                    },\n                    \"load\": [\n                        0\n                    ],\n                    \"activities\": [\n                        {\n                            \"jobId\": \"myJob\",\n                            \"type\": \"delivery\"\n                        }\n                    ]\n                },\n                {\n                    \"location\": {\n                        \"lat\": 53.46642,\n                        \"lng\": 13.10124\n                    },\n                    \"time\": {\n                        \"arrival\": \"2020-07-04T11:58:11Z\",\n                        \"departure\": \"2020-07-04T12:01:11Z\"\n                    },\n                    \"load\": [\n                        0\n                    ],\n                    \"activities\": [\n                        {\n                            \"jobId\": \"myJob2\",\n                            \"type\": \"delivery\"\n                        }\n                    ]\n                },\n                {\n                    \"location\": {\n                        \"lat\": 52.52568,\n                        \"lng\": 13.45345\n                    },\n                    \"time\": {\n                        \"arrival\": \"2020-07-04T13:59:08Z\",\n                        \"departure\": \"2020-07-04T13:59:08Z\"\n                    },\n                    \"load\": [\n                        0\n                    ],\n                    \"activities\": [\n                        {\n                            \"jobId\": \"arrival\",\n                            \"type\": \"arrival\"\n                        }\n                    ]\n                }\n            ],\n            \"statistic\": {\n                \"cost\": 153.38342600000001,\n                \"distance\": 270731,\n                \"duration\": 16071,\n                \"times\": {\n                    \"driving\": 15711,\n                    \"serving\": 360,\n                    \"waiting\": 0,\n                    \"break\": 0\n                }\n            }\n        }\n    ]\n} Yep, that's a lot of data for a simple job. As your problem grows into more real world scenarios, you can expect the size of the result to grow accordingly. We hope this introduction gets you excited about the power of this API. We're definitely understand how complex this API is and we're currently making updates to the documentation to make things a bit easier to use. For a more academic look at the problem, you can read Wikipedia's detailed entry on what's called the \"vehicle routing problem\" . (Warning - expect some high level math!)", "date": "2021-02-08"},
{"website": "Here", "title": "January 2021 Release Notes", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/jan-2021-release-notes-0-0-0-0", "abstract": "Welcome to the latest release notes for the HERE Location Services. The first one in 2021 which will hopefully see a brighter and safer year for everyone. Here's what's new: These releases include updates of: Routing API, Geocoding and Search API, Route Matching API, Advanced Datasets API, Maps API for JavaScript, Destination Weather API and HERE SDK for Android, iOS and Flutter. For detailed information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation and release notes on the Developer Portal . Reminder: IMPORTANT INFORMATION regarding new license terms for Location Services on Platform*: For some of our new Location Services made available on Platform , we have changed the Transaction definitions in your current contract with HERE. This will impact all existing Location Services customers that have a contract with a license term based on Transactions such as Location Mapping when they start using Location Services on Platform. By continuing to use the Location Services on Platform, you accept the new terms. The changes are the following: C ategory Feature Definition Previous Geocoder Autocomplete or Places Autosuggest No Charge New Geocoding and Search Autosuggest or Autocomplete One Transaction is counted for every 10 Requests Previous Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal max parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Intermodal Park and Ride One Transaction is counted for each returned alternative Intermodal Route(s) set by the Customer for the intermodal alternative ’ parameter in the API request.  If the system determines that there are no available Park and Ride routes, the Request is still counted as one Transaction New Vector Tiles One Transaction is counted for every 5 Requests Previous Isoline Routing One Transaction means one Request New Isoline Routing One Transaction equals each individual Isoline within an Isoline Request Large Scale Matrix Routing and Matrix Routing included in Routing API will be merged into Matrix Routing API V8 Previous Large Scale Matrix Routing One Transaction is counted for every 20 Elements in a Large-scale Matrix Routing API Request. The number of Elements equals the number of start points times the number of destination points. Large-Scale Matrix Routing Requests generating less than 100,000 individual elements are always counted as 5,000 Transactions New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more , the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 Previous Matrix Routing One Transaction is counted for each start point Request New Matrix Routing V8 • Small matrices, where either the number of Starting Points or number of Destination Points is Limited to 15x100 size ​and 100x1​ are calculated by multiplying the number of Starting Points by the number of Destination Points • Large matrices, where the number of Starting Points and number of Destination Points are more the number of Transactions is calculated by multiplying the greater of the number of Starting Points and the number of Destination Points by 15 New EV Charge Aware Routing Ten Transactions are counted for every Request *Location Services on Platform are the latest major releases such as Geocoding and Search API V7, Routing, Matrix Routing, Isoline Routing, Transit and Intermodal API´s V8 and Vector Tile API V2 HERE Location Services Routing ( Version 8. 18.0 + 8.20.1) Added a notice for using emergency gates. Added notices as an option for spans parameter. This can be used to get the actual locations of violated restrictions in truck routing. Added brand attribute to ChargingStationPlace. Added (Alpha) taxi and bus routing modes. Added routingZones to return s and spans parameters. Route Matching ( Version 8.0) New redesigned standalone service succeeding Route Matching of Fleet Telematics API. Following the same API spec as the other new services and using the same underlying map content from the HERE Platform. Advanced Datasets ( Version 8.0) New redesigned standalone service succeeding Advanced Datasets of Fleet Telematics API. Following the same API spec as the other new services and using the same underlying map content from the HERE Platform. Geocoding and Search ( Version 7. 6.1) Response API title enhancement : Clarifying the match for end users by adding matched names in parentheses to the title. MEX: Recognize name of cross street in Geocoder queries Major Places catalog update for Japan Additional content from Trip Advisor (standard attributes including opening hours, food types) Postal code search support for Japan Destination Weather (Version 3.0) Updated API structure to make it more consistent with other new HERE APIs. The Weather 1.0 API is marked as deprecated but will be supported going forward. Maps API for JavaScript ( Version 3.1.22.0) Improvements to the Japan style include: Changes to the rendering order between the railways and buildings. The style now uses the default system CJK fonts. Updates to the POI display Minor roads now consider \"toll\" and \"bridges\" attributes. Label priorities were changed to improve readability of the map. Train stations do not have duplicate labels. Rendering of the icons for the multimodal transit stations. The label positioning was changed to reduce the \"flickering\". New more easy way to set a political view to the map. Added the support of the Public Transit API v8 . HERE SDK for Android , iOS and Flutter  ( Version 4.6.1) Cancel animation. Simple FlyTo animation. Implement zone categories once format/types are available. Improve names of fields for Address struct. Expose access types . Implement new Location fields/constructor in iOS. All Location S ervices deliver map content updates every week .", "date": "2021-02-12"},
{"website": "Here", "title": "Rendering HERE map using Golang", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/rendering-here-map-using-golang", "abstract": "Golang has been on the rise in the last 4 years, tech giants and Multinational corporations (MNCs) are adopting it. Things like easy to learn, concurrency, quality tools, speedy execution of tasks and ease of maintenance makes Go a very popular programming language. This blog post is a quick tutorial on how to create a web application in Golang and show a HERE map. Let us get started! Prerequisites Your machine should have Golang installed (you can get it from here ) and if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you signed up, you can generate your free API key and get 250.000 free transactions every month. Building the Front End Before we dive in to the Golang code, let us set up the front end. A HTML file will be required to show the map on the browser. For this, create an HTML file and name it as “map.html”. <!DOCTYPE html>\n<html> \n    <head> \n        <title>HERE Map</title>          \n        <meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" /> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\"></script> \n        <script type=\"text/javascript\" src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\"></script> \n        <link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/> \n    </head> \n    <body> \n      <div style=\"width: 100vw; height: 100vh\" id=\"mapContainer\"></div>\n    </body> \n    <script> \n        var platform = new H.service.Platform({ \n            apikey: \"HERE_API_KEY\"    \n        }); \n\n\t\tconst lat = 52.5; \n\t\tconst lng = 13.4; \n\n        // Obtain the default map types from the platform object: \n        var defaultLayers = platform.createDefaultLayers(); \n\n        // Your current position \n        var myPosition = {lat: lat, lng: lng}; \n\n        // Instantiate (and display) a map object: \n        var map = new H.Map( \n            document.getElementById('mapContainer'), \n            defaultLayers.vector.normal.map, \n            { \n                zoom: 11, \n                center: myPosition \n            }); \n\n        var ui = H.ui.UI.createDefault(map, defaultLayers, 'en-US'); \n        var mapEvents = new H.mapevents.MapEvents(map); \n        var behavior = new H.mapevents.Behavior(mapEvents); \n\n        const marker = new H.map.Marker({lat: lat, lng: lng}); \n\n        map.addObject(marker); \n\n        marker.addEventListener('tap', function(evt) { \n        \n        // Create an info bubble object at a specific geographic location: \n        var bubble = new H.ui.InfoBubble({ lng: lng, lat: lat }, { \n                content: '<p>Golang</p>' \n             }); \n        // Add info bubble to the UI: \n        ui.addBubble(bubble); \n\n    const marker = new H.map.Marker({lat: lat, lng: lng});\n      map.addObject(marker);\n  }); \n    </script> \n</html> Copy and paste above code in ‘ map.html ’. If you look at the code closely, you will notice a variable is missing value, namely ‘ apikey ’. You can acquire the API KEY from developer portal, all you need to do is sign up for a Freemium account. The code uses HERE Maps API . The detailed explanation and information on above code can be found here . You can check the front end by opening ‘map.html’ in a browser. Working on Go Web Server We need to open the map.html file with Go As a web application, and for that we need to have a web server. Go language lets you create a web server. The best and the quickest way to get started is with net/http package . With few lines of code, you can build a Go web server. package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc MapPage(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"HERE Map\")\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", MapPage)\n    http.ListenAndServe(\":8080\", nil)\n} Save the above code as “server.go” and type ‘go run server.go’ in terminal or command prompt to start the server. Once the server is running, open web browser and navigate to the address “localhost:8080” and you will see “HERE Map”. Till now, we have not passed the HTML file to Go server code. Let us do that. package main\n\nimport (\n    \"html/template\"\n    \"log\"\n    \"net/http\"\n)\n\nfunc MapPage(w http.ResponseWriter, r *http.Request) {\n    // fmt.Fprintf(w, \"HERE Map\")\n\n    t, err := template.ParseFiles(\"map.html\")\n    if err != nil {                           \n        log.Print(\"template parsing error: \", err)\n    }\n    err = t.Execute(w, nil)\n    if err != nil {        \n        log.Print(\"template executing error: \", err)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", MapPage)\n    http.ListenAndServe(\":8080\", nil)\n} In the above code, make sure you comment “ fmt.Fprintf(w, \"HERE Map\") ” or else you won't be able to see the map. You will also notice we have html/template package in the import, it allows us to interact with our HTML file. We also have log package for logging any error we may encounter. We have also handled any possible error (either because of template parsing or execution) in the MapPage function. Running the Application To run the code, type and enter ‘go run server.go’ in the terminal or command prompt. When server.go is executed and we navigate to localhost:8080 in the browser, the page displays a map with a marker. And if any error occurs it will be logged.", "date": "2021-02-03"},
{"website": "Here", "title": "Oh the places you'll go (and how you get there...)", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/oh-the-places-youll-go-and-how-you-get-there", "abstract": "We've discussed various aspects of our routing APIs here in the past, as well as news about new features such as our new electric vehicle routing support. With the additions, updates, and other changes to our platform over the past few months, we thought it would be nice to provide an overview of the various type of routing features available to developers. Instead of taking an \"API first\" approach, instead we'll break it down by feature and explain the APIs that back them up. Ready? Let's get started! How do I drive from one point to another? The simplest of all requests - how to drive from one point to another. This makes use of the basic HERE routing API . You provide a starting and end location and that's it. You can ask for a summary back which will cover the time and distance travelled, or you can ask for more detailed information which can include turn by turn directions. Here's an example of the most basic routing: Calculate a Route What if I want to drive from one point to another at a certain time? Building on the last example, you can also ask for a route at a particular time. In this case, HERE uses historical traffic data to estimate how other vehicles will impact your route. We've got a specific example of this for you: Begin Route At Different Times What if I want to go from one point to another and not take (just) a car? Our routing API supports multimodal transportation. From cars, scooters, or trucks, to journeys by bike and on foot. This can get rather complex and our API handles it all. Take bicycle routing as an example. Our API will literally handle knowing that when you bike uphill, you go slower. It will even recognize that a route may be quicker if you walk your bike the wrong way on a one-way road. Going from one point to another and stopping along the way? Another typical routing problem is going from your origin to a destination and then stopping somewhere, perhaps multiple somewheres. Our routing API supports providing \"waypoints\" which define places to stop along the route. Yep, we've got an example of that: Route Via Intermediate Waypoint Note that a more advanced use case would be a route with multiple waypoints that you need to get to in the \"best\" order in terms of time or distance, or to perhaps make deliveries and pickups. For that we've got tour planning , we'll talk a bit more about that later. Trucks are special, right? Absolutely. Trucks may have to use different routes based on their size, weight, and possibly hazardous materials. Our routing API lets you specify the characteristics of your truck and then plans it's route to abide by legal rules regulating where the truck can drive. It even handles cases where a truck can't physically make certain tight turns. Here's more about truck routing: Truck Routing What about public transit? Another interesting use case is including public transit as part of your route. This is where Intermodal routing comes into play. It lets you add routes that may mix public transit, taxis, walking, and more. Surprise surprise, but we've got a demo and example of this as well : Calculate a Park and Ride Route Can I skip the toll roads? Another aspect of routing is avoiding certain things, such as toll roads, tunnels, or ferries. You may even want to avoid a geographic region, like a city. In our routing APIs, we call this avoidance. When requesting a route, you can ask for things to avoid. What's great is that if you ask to avoid a particular factor, but it's impossible to get to the destination, the API will at least attempt to minimize that factor for you. This is much better than returning no route at all. Unfortunately we don't have a demo of that. Wait, of course we do: Avoidance Can routing handle electric vehicles? Absolutely. Announced a few short weeks ago, our routing API has deep support for managing electric vehicle (EV) routing needs. You can specify various indicators (how much your vehicle is charged, how long it takes to recharge), and the routing API will handle including charging stops along the way. EV routing has a good introduction in the developer guide and our blog recently shared an introduction to the feature. You can also test this feature out using our powerful online tool . This will be especially helpful when it comes to configuring the various parameters required to use EV vehicles in the API. What if I don't know where I want to go, just how far I can go? You're talking about \"isoline\" routing, which is routing that determines exactly how far you can go in a certain amount of time or within a given distance. This may be easier if shown graphically. In the image below, you can see where a car can travel starting in Berlin and driving for three thousand meters. In this case the result was based on the time the API was called, but you can absolutely specify different times to see the impact of traffic (for time-based isoline routing anyway). What if I manage a fleet of vehicles and have to plan routes for all of them? For large scale routing, we offer matrix routing , which lets you plan routes for up to ten thousand origin and destinations. As you can imagine, this requires a lot of work and therefore the API can be used in both synchronous and asynchronous modes, letting you create a request and then poll for updates later. We've got a number of different use cases with examples for you to dig further. My driver took a long time to deliver a package, what can I do? Here's an interesting use case. You've got a planned route for a truck from one point to another and it's supposed to take a certain amount of time. You discover later that the truck actually took twice as much time as anticipated. Was a route diversion to blame? If you tracked the vehicle's actual route, you can use the route matching API to compare routes and get deep analytics. This can do things like finding speeding violations and missed waypoints. I've got to make multiple stops, what's the best route? For one of our final, and most complex use cases, we come to tour planning . At a high level, tour planning takes in a set of inputs that cover the types of vehicles in a fleet, their capacities, and a set of jobs with requirements involving deliveries, pick ups, and times. The API can take this input and in return, give you a \"best\" plan to use your fleet to meet the needs of the jobs. If you want to see more about this API, we recently published an article that gives a somewhat gentle introduction to the service: Working with Tour Planning Routing - Going Deeper We hope this review of the routing features gives you an idea of both the breadth and depth of our routing options. Be sure to sign up today for a freemium account and start building today!", "date": "2021-02-17"},
{"website": "Here", "title": "How to Add a Trusted Domain", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-to-add-a-trusted-domain", "abstract": "Security requirements vary based on a number of factors. For example, developers are provided options on how to go about implementation. Developers can choose between authentication types regarding developer access to our APIs and SDKs.  Another option to improve overall security with our APIs is how to mark a domain as trusted , which is the topic of this post. What is a Trusted Domain? Put simply, a trusted domain is considered an acceptable source for making API calls with your credentials. By adding one or more trusted domain names, a developer is establishing where API calls can be trusted from . To phrase it another way, if a trusted domain is the source of the API call, the request will be allowed. The contrast is also true - if the source of an API call comes from a domain not found in the list of trusted domains, the call will fail. Managing Trusted Domains Trusted domains are managed in the developer portal where developer credentials are also managed. In the screen capture below, the area in the red rectangle is where one would get started: As shown above, the default setting is no trusted domain exists yet. When there is no list, it means any domain can freely make calls with the associated developer credentials. Once the decision is made to add a trusted domain, you will see the following options: With the checkbox now enabled, domain names can be added or removed using the plus and minus buttons. To add a domain, enter domain names with the following format: example.com www.example.com app.example.com The following examples are *not* valid: http://www.example.com example.* example.com?foo=bar The first invalid example includes the HTTP protocol which is not needed. The second invalid example makes the assumption that wildcards are supported (they are not). The third invalid example contains a querystring which is not a way to uniquely identify a domain. You can add up to 20 domains in the list. Note! Once you have entered *any* domain in the list, all *other* sources making requests using your credentials will fail (which is the desired outcome). Also keep in mind it can take up to a full hour for any modifications to the list (including it's creation) to take effect.", "date": "2021-02-09"},
{"website": "Here", "title": "What's New in Maps API for JavaScript?", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/whats-new-in-maps-api-for-javascript", "abstract": "A number of new features have been added to the recent update of our Maps API for JavaScript. In addition to various performance and quality enhancements, there are some features we would like to highlight that you might also benefit from now. This post is going to cover the following: Improvements to vector tile rendering Integration of public transit options Better support for popular developer environments Applications to explore using Maps API for JavaScript Improvements to Vector Tile Rendering We want to spotlight some notable improvements to the Vector Tile API, which is accessible from the Maps API for JavaScript , when a map is initialized with vector tile layers. Support for country specific road shields A “road shield” is how we identify major roads or highways. In the following screen captures, the road shields shown are specific to their respective countries. Developers get access to this feature by default. Border of USA and Mexico                          Tunisia and Sicily Simplificatio n to render political views It’s not every day one can say a political view has been simplified. However, when it comes to map rendering, we’ve made it easy to establish potentially disputed boundaries and how you want them to appear in your solutions. The image below is the international view (default) of South Patagonia. The dashed border indicates a current border dispute. If a developer wants to show the border from the perspective of one country specifically, a request can be made to show that. For more information, see how to use the geopolitical views . Integration of the Public Transit Options The Public Transit API (V8 ) allows you to use agency data, external services and data collected by HERE to discover public transit options and request public transit routes and transit-related information. This API is now accessible from the Maps API for JavaScript via H.servicer.publicTransit class, making it easier for developers to quickly integrate public transit options into their solutions. Support for Popular Developer Environments It is now easier to use Maps API for JavaScript in various environments. Jupyter – AWS SageMaker makes use of Jupyter Notebooks in the machine learning process. With the l aunch of HERE Maps Widget for Jupyter , it’s easier to establish a link to the Maps API for JavaScript in that environment . Prior to the widget release, it was more cumbersome and timely to utilize location services within a Jupyter Notebook. React – With the popularity of React , we have improved our documentation for setup and best practices All in one location, developers can quickly discover how to configure environment, add static map component, and how to use common features, and how to make the map interactive. Applications to Explore Using Maps API for JavaScript If you would like to explore some examples of maps built using the Maps API for JavaScript , please check out the following: Do you live in a “15-minute” city? An interactive map which allows a user to see if a location has essential living needs within a 15 minute walking or driving distance. COVID-19 response and vaccination policy tracker A map with a global view of countries response to COVID-19 and what level of vaccination policy is in affect. Summary As more updates are made available, we’ll be sure to keep you posted. In the meantime, we invite developers to evaluate these new features and if you’re new to HERE APIs, please sign up for a freemium account and start playing with our location services APIs today!", "date": "2021-03-01"},
{"website": "Here", "title": "March 2021 Release Notes", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/march-2021-release-notes", "abstract": "W e are pleased to inform you about the new releases of the HERE Location Services in March 2021. These releases include updates of: Routing API, Matrix Routing API, Geocoding and Search API, Vector Tile API, Map API for Java Script and HERE SDK for Android , iOS and Flutter . For information about the major improvements of the HERE Location Services, see the sections below. You will find all API documentation and release notes on the Developer Portal . HERE Location Services Routing Version 8.21.1 - 8.21.5 Enabled response compression (HTTP Content-Encoding) Beta label removed from EV Routing Return street names in all available languages Added optional origin parameter to getRoutesByHandle Added support for route import (alpha) Allows to create a route from a sequence of trace points Matrix Routing Version 8.3.0 + 8.4.0 Added (Alpha) taxi mode support Increased matrix size limit for Flexible mode sync requests. Now allowing matrix sizes up to 15 x 100 or 100 x 1 (Previous limit allowed matrix sizes up to 15 x 15, 1 x 100, or 100 x 1) Geocoding and Search Version 7. 6.4 All endpoints: Increased coverage of GBR postal codes Geocode: Improved matching of Russia compound house number formats Geocode: Improved behavior for address queries that contain noise. The tolerance for the overall queryScore has been increased for cases with high enough individual fieldScores Geocode: In Russia, the Geocoder now prefers Point Address fallbacks to alpha-numeric house numbers in situations where the query house number is numeric but does not exist in map content. Before, the Geocoder chose an interpolated location. This could lead to results up to a few hundred meters away from the destination Geocode: Tolerate common Russia prefix to the house number \" dom \"/\" дом \" (meaning \"house\"). The Geocoder now recognizes the prefix and tolerates it without any scoring penalty Vector Tile API Version 2.1.3 Configurability Phase 1: Map Layers can be removed from the vector data Maps API for Java Script Version 3.1.24.0 Support to the Interactive Map Layer service was added Fly-to animation is greatly improved by using parabolic curves and dynamic easing functions setLookAtData with animation supports also bounding box (WEBGL engine only) HERE SDK for Android , iOS and Flutter Version 4.6.4 Set routing option to always split roundabouts Keep Miami style as default Api to read mapview surface size (and updates to it) Advanced FlyTo with orientation and target distance Pause and resume download on app runtime Render the maneuver arrow on route. Version 4.7.0 Support of public transit routing (online) Rendering of road shields Support for political views Configurable FlyTo animations (bow animation) New (beta) of HERE's brand new Oslo map style (as you know it from the new WeGo app) Major enhancements of maploader functionality (pause, resume, multiple and parallel downloads) Enhanced lane assistance (bus lanes, bicycle lanes, access restrictions) Support of special speed situations ( e.g. time dependent speed limits) Maneuver arrow rendering on road during Navigation Navigation support for big roundabouts (explicit exit maneuvers) Offline search along the route Indoor pedestrian routing All Location S ervices deliver map content updates every week .", "date": "2021-04-16"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.24 release", "author": ["Jeanus Ko"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.24-release-0", "abstract": "Highlights Upload your data to Object Store layers using Hadoop FS We have added two new tutorials explaining how to publish data to Object Store layers in a distributed fashion using Hadoop FS. One shows how to do this from Spark and an other one shows how to do this in standalone mode . Typically, you would use one or the other when writing data to an Object Store layer that you have stored in AWS S3 or Microsoft Azure. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue: In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limit. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the uses in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Known issue: In support of the Object Store layer type, a newer version of the Blob API (blob v2) is available in production. The availability of this newer Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Because multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you intend to work with. To support existing workflows until you can correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue: The \"Upload data\" button in your Layer UI under \"More\" is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue: The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of index-layer data isn't supported yet. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Marketplace (Not available in China) Added: You can edit or cancel a previously set subscription deactivation due date by going to an active subscription detail page and click on \"Change expiry date\". Added: You can view a list of your invited customers on your provider listing view until the invitations are accepted. Known issue: When adding an Interactive Map layer to a Marketplace catalog and offer with a subscription option, the subscription reporting doesn't generate usage metrics. Workaround: Subscription reporting will support Interactive Map layer type in future releases. Known issue: When adding an Object Store layer to a Marketplace catalog and offer with a subscription option, the subscription reporting does not generate usage metrics. Workaround: Subscription reporting will support Object Store layer type in future releases. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices.) No. Feature summary Deprecation period announced (platform release) Deprecation period announced (month) Deprecation period end 1 OrgID added to catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 June 30, 2021 (extended) Deprecation summary: Catalog HRNs without OrgID will no longer be supported in any way. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after this deprecation period. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before this date so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after this date. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 June 30, 2021 Deprecation summary: For security reasons, the platform will start validating schema reference changes in layer configurations after this deprecation period. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before the deprecation period end. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for pipelines 2.17 July 2020 February 1, 2021 Deprecation summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 pipeline_jobs_canceled metric in pipeline status dashboard 2.17 July 2020 February 1, 2021 Deprecation summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Stream throughput configuration changes from MBps to kBps 2.19 September 2020 March 31, 2021 Deprecation summary: Support for stream layers with configurations in MBps is deprecated and will no longer be supported in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 7 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation summary: The \"kubernetes_namespace\" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \"namespace\" metric. The label _ values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label _ values(metric, label) The datasource \"<Realm>-master-prometheus-datasource\" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 8 Additional support to help distinguish Blob API versions in Lookup API responses 2.22 December 2020 June 30, 2021 Deprecation summary: Because multiple versions of different Data APIs exist, it's important that your automated workflows that request service endpoints from Lookup API are updated to select the right baseUrls for the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions in responses over the next 6 months, starting January 2021. To prevent downtime, update your workflow automation during this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version.", "date": "2021-02-17"},
{"website": "Here", "title": "Reverse Geocoding a location using Golang", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/reverse-geocoding-a-location-using-golang", "abstract": "Across the globe and for a variety of business reasons, billions of devices are collecting GPS data. That data is usually a set of unique numbers representing geographic coordinates of a location. These numbers are known as latitude and longitude and they each represent a specific point, somewhere on earth. To make more sense of it, we need to resolve it into the closest street address. In order to do exactly this, we use the reverse Geocode endpoint of the HERE Geocoding and Search API . Lets say you are trying to understand the geographical coordinates; 48.2181679, 16.3899064. Once you pass them through the API, it gives us the nearest address, which is \"Heinestraße 42, 1020 Vienna, Austria\". In this blog post we are going to use the reverse geocoding feature of the HERE Geocoding and Search API and the Go programming language . Prerequisites Your machine should have Golang installed (you can get it from here ) and if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you have signed up, you can generate your free API key and get 250.000 free transactions every month. Working with Reverse Geocoding Endpoint The reverse geocoding endpoint of the Geocoding and Search API helps in finding the nearest possible address to a specific geographic coordinate. All you need is to append the latitude and longitude values with your API key to the endpoint URL. https://revgeocode.search.hereapi.com/v1/revgeocode\n?at=12.98022751,77.60104064\n&apikey=YOUR_API_KEY The apikey is from the Freemium account generated on the developer portal and the value of at is latitude and longitude value separated by a comma. The REST API returns a JSON response containing nearest address along with additional details. {\n  \"items\": [\n    {\n      \"title\": \"Creativity\",\n      \"id\": \"here:pds:place:356jx7ps-6b18784695c70f5001df83da965f2570\",\n      \"resultType\": \"place\",\n      \"address\": {\n        \"label\": \"Creativity, Shivajinagar, Bengaluru 560001, India\",\n        \"countryCode\": \"IND\",\n        \"countryName\": \"India\",\n        \"stateCode\": \"KA\",\n        \"state\": \"Karnataka\",\n        \"county\": \"Bengaluru\",\n        \"city\": \"Bengaluru\",\n        \"district\": \"Shivajinagar\",\n        \"postalCode\": \"560001\"\n      },\n      \"position\": {\n        \"lat\": 12.98023,\n        \"lng\": 77.60094\n      },\n      \"access\": [\n        {\n          \"lat\": 12.98022,\n          \"lng\": 77.60093\n        }\n      ],\n      \"distance\": 11,\n      \"categories\": [\n        {\n          \"id\": \"800-8200-0174\",\n          \"name\": \"Школа\",\n          \"primary\": true\n        }\n      ]\n    }\n  ]\n} From the above response, all we need is the value associated with ‘title’. It is the nearest address to the latitude longitude pair. Parsing JSON Response using Golang To extract the address from the JSON response, we first need to make the API call programmatically. Then parse the response to take out a specific value. We are using “net/http” to access the core go http functionality and make HTTP request. // File name: final.go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"net/http\"\n)\n\nvar apikey = \"YOUR_API_KEY\"\nvar latitude = 42.36399\nvar longitude = -71.05493\nvar address string\n\nfunc main() {\n    url := \"https://revgeocode.search.hereapi.com/v1/revgeocode?apiKey=\" + apikey + \"&at=\" + fmt.Sprint(latitude) + \",\" + fmt.Sprint(longitude)\n\n    res, err := http.Get(url)\n    if err != nil {\n        log.Fatalln(err)\n    }\n    body, err := ioutil.ReadAll(res.Body)\n    if err != nil {\n        log.Fatalln(err)\n    }\n\n    fmt.Println(string(body))\n} When you provide your API key above (var apikey value) and run the code. go run final.go You will get the complete JSON response. {\"items\":[{\"title\":\"25 Parmenter St, Boston, MA 02113-2306, United States\",\"id\":\"here:af:streetsection:vuwDn8KJgOmAHcM1iubqIA:CgcIBCDgs7IhEAEaAjI1\",\"resultType\":\"houseNumber\",\"houseNumberType\":\"PA\",\"address\":{\"label\":\"25 Parmenter St, Boston, MA 02113-2306,\nUnited States\",\"countryCode\":\"USA\",\"countryName\":\"United States\",\"stateCode\":\"MA\",\"state\":\"Massachusetts\",\"county\":\"Suffolk\",\"city\":\"Boston\",\"district\":\"North End\",\"street\":\"Parmenter St\",\"postalCode\":\"02113-2306\",\"houseNumber\":\"25\"},\"position\":{\"lat\":42.36408,\"lng\":-71.0549},\"access\":[{\"lat\":42.36391,\"lng\":-71.05507}],\"distance\":10,\"mapView\":{\"west\":-71.05556,\"south\":42.36367,\"east\":-71.05466,\"north\":42.36411}}]} We need to take out the value associated with ‘title’ as it will be our address. Let us do that by adding a struct above main function. type output struct {\n    Items []struct {\n        Title string `json:\"title\"`\n    } `json:\"items\"`\n} We have added a struct called output , which contains minimal required fields to acquire address. We have mapped JSON response in a struct which Go can understand. If you want to explore it more, I will suggest looking at JSON to go converter . Next, we have to iterate through the response data and take out required values. Add following code inside main function, below “ fmt.Println(string(body)) ” var data output\n    json.Unmarshal(body, &data)\n    // fmt.Println(data)\n    for _, add := range data.Items {\n        address = add.Title\n        fmt.Printf(address)\n    } To convert JSON data into Go objects, we make use of ‘Unmarshal’ method. On running the code, we get the address “25 Parmenter St, Boston, MA 02113-2306, United States” Creating Go web server What makes location data so interesting is that we can visualize it on a map and do whole bunch of other stuff with it. Now, we have all the values needed (latitude, longitude, address, API key) to show our address on a map in a browser. We need to run Go as a web server. Golang lets you create a web server with net/http package . Add following lines at the bottom of main function. http.HandleFunc(\"/\", MapPage)\n    log.Fatal(http.ListenAndServe(\":8080\", nil)) We are calling a new function, MapPage and also listening/serving on localhost at 8080 port. To show the address on a map, we will be passing latitude, longitude, address and API key to the HTML page (create map.html file in the same place as final.go file). This will be handled by MapPage function and a new struct, namely, MapValues . //Add it above main function\ntype MapValues struct {\n    API       string\n    Latitude  float64\n    Longitude float64\n    Address   string\n} //Add it below main function\nfunc MapPage(w http.ResponseWriter, r *http.Request) {\n    Values := MapValues{\n        API:       apikey,\n        Latitude:  latitude,\n        Longitude: longitude,\n        Address:   address,\n    }\n    t, err := template.ParseFiles(\"map.html\") //parse the html file homepage.html\n    if err != nil {                           // if there is an error\n        log.Print(\"template parsing error: \", err) // log it\n    }\n    err = t.Execute(w, Values) //execute the template and pass it the HomePageVars struct to fill in the gaps\n    if err != nil {            // if there is an error\n        log.Print(\"template executing error: \", err) //log it\n    }\n} The above code is passing values to map.html file and handling a bunch of errors in process. Creating HERE Map in HTML and JavaScript A HTML file with JavaScript code is enough to plot a beautiful looking map. The file name is map.html. <html>  \n<head>\n<meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-core.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-service.js\"type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-mapevents.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"https://js.api.here.com/v3/3.1/mapsjs-ui.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<link rel=\"stylesheet\" type=\"text/css\"href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\" />\n</head>\n  \n<body style='margin: 0'>\n<div style=\"width: 100%; height: 100%\" id=\"mapContainer\"></div>\n\n<script>\t\n      // Initialize the platform object:\n      var platform = new H.service.Platform({\n        'apikey': '{{apikey}}'\n      });\n\t  \n\t   const lat = {{latitude}};\n\t   const lon = {{longitude}};\n\t\n\t// Obtain the default map types from the platform object\n      var maptypes = platform.createDefaultLayers();\n\n      // Initialize a map:\n      var map = new H.Map(\n        document.getElementById('mapContainer'),\n        maptypes.raster.terrain.map,\n        {\n          zoom: 17,\n          center: { lat: lat, lng: lon }  \n        });\n\t\t\n\t// Enable the event system on the map instance:\n\t  var mapEvents = new H.mapevents.MapEvents(map);\n\t\n\t// Instantiate the default behavior, providing the mapEvents object:\n\t var behavior = new H.mapevents.Behavior(mapEvents);\n\n\t//window.addEventListener('resize',()=> get.ViewProt().resize())\n\tvar marker = new H.map.Marker({ lat: lat, lng: lon });\n\t\t\n\t// Add the marker to the map:\n\tmap.addObject(marker);\n\t\n\t// Create the default UI:\n\tvar ui = H.ui.UI.createDefault(map, maptypes);\n\t\n\t// Add event listener to the marker:\n\tmarker.addEventListener('tap', function(evt) {\n    \n\t\t// Create an info bubble object at a specific geographic location:\n\t\tvar bubble = new H.ui.InfoBubble({ lng: lon, lat: lat }, {\n                content: '<p> <h4>Address:</h4>{{address}}</p>'\n             });\n\n\t\t// Add info bubble to the UI:\n\t\tui.addBubble(bubble);\n\t});\t\n\n</script>\n</body>\n</html> The code plots the latitude and longitude on a map and shows a marker on the location. When the marker is clicked, a box pops up, showing the address we input. The detailed information of Map API can be found here and of Marker, here . Complete Golang code // File name: final.go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n)\n\nvar apikey = \"YOUR_API_KEY\"\nvar latitude = 42.36399\nvar longitude = -71.05493\nvar address string\n\ntype output struct {\n\tItems []struct {\n\t\tTitle string `json:\"title\"`\n\t} `json:\"items\"`\n}\n\ntype MapValues struct {\n\tAPI       string\n\tLatitude  float64\n\tLongitude float64\n\tAddress   string\n}\n\nfunc main() {\n\turl := \"https://revgeocode.search.hereapi.com/v1/revgeocode?apiKey=\" + apikey + \"&at=\" + fmt.Sprint(latitude) + \",\" + fmt.Sprint(longitude)\n\n\tres, err := http.Get(url)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// fmt.Println(string(body))\n\tvar data output\n\tjson.Unmarshal(body, &data)\n\t// fmt.Println(data)\n\tfor _, add := range data.Items {\n\t\taddress = add.Title\n\t\tfmt.Printf(address)\n\t}\n\n\thttp.HandleFunc(\"/\", MapPage)\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n}\n\nfunc MapPage(w http.ResponseWriter, r *http.Request) {\n\tValues := MapValues{\n\t\tAPI:       apikey,\n\t\tLatitude:  latitude,\n\t\tLongitude: longitude,\n\t\tAddress:   address,\n\t}\n\tt, err := template.ParseFiles(\"map.html\") //parse the html file homepage.html\n\tif err != nil {                           // if there is an error\n\t\tlog.Print(\"template parsing error: \", err) // log it\n\t}\n\terr = t.Execute(w, Values) //execute the template and pass it the HomePageVars struct to fill in the gaps\n\tif err != nil {            // if there is an error\n\t\tlog.Print(\"template executing error: \", err) //log it\n\t}\n} Running the code Run the code using any IDE that supports Go like Visual Studio Code or else simple use command prompt or terminal to execute the code. go run final.go Copy the address http://localhost:8080 and paste it in the browser application. When you click on marker, the address passed in the code will pop up!", "date": "2021-02-25"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.25 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.25-release", "abstract": "Highlights Visualize non-HERE-tiled data It is now possible to view partitions from generically tiled versioned and volatile layers in Data Inspector. So far, only HERE-tiled partitions could be visualized. Go to the partition list view and choose \"view on the map\" in the context menu of the partition. (This does require a valid rendering plugin in the layer's schema, or GeoJSON as the layer's data format.) Manage your organization's pipelines and pipeline templates Organization admins can now manage all the pipelines and pipeline templates within their Org and perform all the actions that the original pipeline author can perform, including but not limited to: Deactivate, cancel or delete a pipeline created by anybody within the Org Delete a pipeline template created by anybody within the Org Activate a pipeline created by anybody within the Org Data Validation Library removed from Data SDK for Java & Scala The Data Validation Library (DVL), which was deprecated earlier, has now been removed from the HERE Data SDK for Java & Scala 2.25 package. It had the purpose of enabling scalable and efficient testing and validation of versioned catalogs on the platform. While it abstracted the underlying distributed processing on Spark and Data API, knowledge of the underlying Data Processing Library (DPL) as well as data partitioning was required. To lower the entry barrier for new platform developers, we followed a more lightweight approach, providing a new data validation module which integrates popular testing frameworks such as Cucumber, Junit and ScalaTest, allowing test engineers to write the tests without any previous knowledge of the DPL, concepts of partitioning or map compilation. This is achieved by separation of the test-data extraction phase from the test scenarios, which are executed in parallel on each self-contained test-data partition. Only the test-extraction phase requires knowledge of DPL features and underlying catalog structure. Once created, it can be used by test engineers without platform experience for implementation of numerous tests. The new module pragmatically computes metrics inside the test scenarios and does the assessment based on a predicate on the aggregated metrics satisfying the vast majority of testing use cases. The data validation module in the DPL covers the functionality of the DVL and was released in the Data SDK for Java & Scala 2.20 release. If you have use cases for data validation, please use this module going forward. See the Data Processing Library documentation for more information about this module. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue : In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limit. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the users in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Known issue: In support of the Object Store layer type, a newer version of the Blob API (blob v2) is available in production. The availability of this newer Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Because multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you intend to work with. To support existing workflows until you can correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue : The \"Upload data\" button available via \"More\" within the versioned layer details page is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue : The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of data is not yet supported inside HERE Workspace for the following layer types: index, object store and interactive map. Pipelines Added: All Pipeline APIs now accept UUID or HRN of pipelines and pipeline templates as path parameter. Added: HRNs for Pipeline and Pipeline Template now include the Realm name to help in quickly identifying the realm of the Pipeline and Pipeline Template. Added: Organization admins can now manage all the pipelines and pipeline templates within their Org and perform all the actions that the original pipeline author can perform, including but not limited to. For details see the highlights section above. Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Content Fixed: We fixed the GeoJSON rendering plugin that visualizes HERE Weather data with the Data Inspector. The plugin includes a number of adjustable filters for visibility, precipitation, wind (speed + direction) and temperature, so that you can focus on the weather type that you’re interested in. This plugin is a great example of how you can add simple arrows on a map to indicate a direction. You can explore the weather visualization here: https://platform.here.com/data/hrn:here:data::olp-here:live-weather-eu/latest-data/inspect . Marketplace (Not available in China) Fixed: Subscription reporting now works (i.e. usage metrics are generated) for object store layers when added to catalogs in Marketplace. Known issue: When adding an Interactive Map layer to a Marketplace catalog and offer with a subscription option, the subscription reporting doesn't generate usage metrics. Workaround: Subscription reporting will support Interactive Map layer type in future releases. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices. No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 June 30, 2021 (extended) Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after this deprecation period. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before this date so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after this date. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation Summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 June 30, 2021 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations after this deprecation period. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before the deprecation period end. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 (past due) Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 (past due) Deprecation Summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Stream throughput configuration changes from MB/s to KB/s 2.19 September 2020 March 31, 2021 Deprecation Summary: Support for stream layers with configurations in MBps is deprecated and will no longer be supported in six months or by March 31, 2021. After March 31, 2021 only kBps throughput configurations will be supported. This means that Data Client Library and CLI versions included in SDK 2.18 and earlier can no longer be used to create stream layers because these versions do not support configuring stream layers in KB/s. 7 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation Summary: The \" kubernetes_namespace \" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \" namespace \" metric. The label_values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label_values(metric, label) The datasource \" <Realm>-master-prometheus-datasource \" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 8 Additional support to help distinguish Blob API versions in Lookup API responses 2.22 December 2020 June 30, 2021 Deprecation Summary: Because multiple versions of different Data APIs exist, it's important that your automated workflows that request service endpoints from Lookup API are updated to select the right baseUrls for the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions in responses over the next 6 months, starting January 2021. To prevent downtime, update your workflow automation during this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version.", "date": "2021-03-17"},
{"website": "Here", "title": "Determining a Reachable Area with Isoline Routing on Android", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/determining-a-reachable-area-with-isoline-routing-on-android", "abstract": "Isoline Routing, which allows you to define which area is reachable for you under certain constraints such as time or remaining battery, has long been a favorite in our developer community. We are happy to report that this feature is now also available in our new HERE SDKs for Android, iOS and Flutter. In this blog post, I will walk you through determining a reachable area using Isoline Routing with the HERE SDK for Android (Explore Edition). Let’s get started! Isoline Routing uses the same RoutingEngine you would use for a standard routing call. However, instead of calling calculateRoute () on an instance of RoutingEngine , we call calculateIsoline () instead. This method takes a GeoCoordinate (the center of the isoline), an instance of IsolineOptions and a callback function as parameters. Before we set all these up, let’s initializing the RoutingEngine itself. try {\n    routingEngine = new RoutingEngine();\n} catch (InstantiationException e) {\n    throw new RuntimeException(\"Intialization of RoutingEngine failed: \" + e.error.name());\n} To determine a reachable area isoline for us, the routing engine needs information on how to calculate this area. First it needs to know the range type. Isoline routing supports three different range types. Time (in seconds), i.e., which area can I reach if I drive for a certain amount of time? Distance (in meters), i.e., which area can I reach if I drive for a certain distance? Battery charge (in Watts), i.e., which area can I reach with my current battery level? Second, it needs to know a range or ranges. These are the specific range values in time, seconds, or Watts, depending on which mode you have chosen. You can either provide a single value or multiple values. If you choose the latter, the routing engine will return a reachable area for each value provided. Third, you need to select a calculation mode. Isoline routing is a computationally intensive operation, so depending on your use case, you should choose an appropriate mode. The engine provides a balanced mode, a performance mode, or a quality mode. For example, if your application is for visualization purposes only, performance mode may be right for you. If you’re not sure, you can choose the balanced mode. Similarly, the isoline polygons returned by routing engine can potentially contain a large number of individual points. This could lead to a degraded performance during visualization. To counteract this, you can provide a maximum number of points to be used by the polygons. In most cases the default value is fine but keep this in mind if you are running into performance issues. All the information above is encapsulated in an IsolineOptions.Calculation object, which we can create as follows. In this example, we are using a time-based range and a balanced calculation mode. Setting maxPoints to null results in a default option for the number of points in the polygon shapes. List<Integer> rangeValues = Collecttions.singletonList(900);\nInteger maxPoints = null;\nIsolineOptions.Calculation calculationOptions =\n        new IsolineOptions.Calculation(IsolineRangeType.TIME_IN_SECONDS, rangeValues, IsolineCalculationMode.BALANCED, maxPoints; Now that we have determined how to calculate the reachable area, we also need to determine which transport mode it should consider. We currently support car, truck, EV car, and EV truck. The Android SDK provides an object to encapsulate options for each of these modes ( CarOptions , EVCarOptions , TruckOptions , EVTruckOptions ). For our example, we are using a standard car, as the default values for CarOptions work just fine and we don’t need to adjust any additional details (such as a consumption model or battery specifications for electric vehicles). Finally, we create an IsolineOptions object to wrap all the information we have collected above, and we are ready to start routing! IsolineOptions isolineOptions = new IsolineOptions(calculationOptions, new CarOptions()); To do so, we call calculateIsoline () and provide our starting waypoint as a GeoCoordinate , our IsolineOptions object and a callback function. routingEngine.calculateIsoline(new Waypoint(new GeoCoordinates(52.530932, 13.384915)), isolineOptions, new CalculateIsolineCallback() {\n    @override\n    public void onIsolineCalculated(RoutingError routingError, List<Isoline> list) {\n        if (routingError != null) {\n            //handle error\n            return;\n        }\n    }\n}); As a final step we want to handle the response and visualize the resulting isoline on a map. The response consists of a list of Isoline objects, which in turn contain a list of GeoPolygons representing the reachable area. First, we iterate over the list of isolines. Remember, that depending on many ranges you have provided, you will get a corresponding number of isolines. Then we iterate over the list of polygons in each Isoline , create a MapPolygon object for each and add it to the map. Take note that a reachable area may consists of multiple polygons, for example where an island is reachable by ferry. Make sure you display all polygons, not just the first one. The end result should look like this. Feel free to experiment with multiple ranges, different range types and different transport modes. Check out the full documentation for more details!", "date": "2021-03-19"},
{"website": "Here", "title": "Rendering HERE Map using Ruby on Rails", "author": ["Vidhan Bhonsle"], "link": "https://developer.here.com/blog/rendering-here-map-using-ruby-on-rails", "abstract": "Introduction Web application development has evolved over the course of time. The major reason is the emergence of new frameworks in different languages. It gives developers the freedom of creating websites without any hassle. One such open-source server-side web application framework is Ruby on Rails (or Rails) that is written in the Ruby programming language. Ruby is an interpreted scripting language known for quick and easy object-oriented programming. In this blog, we are going to create a web application that will show a HERE map on a browser. Let us get started! Prerequisite Your machine should have Ruby language and Ruby on Rails framework on it for implementing web applications. And if you haven't done so yet, you will need to sign up for a Freemium account on developer.here.com . Once you signed up, you can generate your free API key and get 250.000 free transactions every month. Before moving to the coding part, make sure you have Ruby and rails on your machine. Run following commands on command prompt or terminal: ruby -v rails -v If you are getting version numbers as a response for both the commands, then we are good to move forward, else you need to install them properly. Creating a new app The first thing required is to create an application, to generate it, run this line in your terminal or command prompt: rails new map_app The command will successfully generate a new application, map_app and if you investigate, you will find a lot of files and folders inside it. Navigate to the new directory by running the command: cd map_app We can run our application, by entering: rails s This command starts our application, you can view it by opening a browser and entering http://localhost:3000 . You should see a welcome page. Editing welcome page When we go to http://localhost:3000 we see the Rails welcome page. We are going to change this default page to our own page. To do so, we need to generate a new controller called maps. Run this line in your command prompt or terminal to generate a new controller. rails g controller maps This command should have created a bunch of files for us. At this point, we usually decide whether we need an IDE or use any text editor for coding. I prefer an IDE, hence using Visual Studio Code. Open file maps_controller.rb located in apps/controllers folder. apps/controller/maps_controller.rb We will define our home page here. The file contains MapsController class which inherits from the Applicationcontroller class. We will define a public method named “index” class MapsController < ApplicationController\n\n    def index\n    end    \n\nend Next, we need to define a route. Routing is a way to redirect incoming requests to controllers and actions. We have already created a controller. All we need to do is define it in routes.rg file located inside the config folder. config/routes.rb Add ‘root to:'pages#index'’ lines to the file Rails.application.routes.draw do\n\n  root to: 'maps#index'\n\nend pages#index calls the MapsController and its public method index. Where hash symbol (#) represents a method. Now, we need to create a template, a page that will ultimately show a map. Go to app/views/maps and create a index.html.erb file. In this file, we can write HTML and Embedded Ruby code. app/views/maps/index.html.erb Write a simple code to see how it works. <h1> HERE Maps </h1> Open http://localhost:3000 in the browser, you should see “HERE Maps” instead of the Rails welcome page. Our very basic template is ready. From here on, we can start introducing new things. Let us edit the template to show a map. <html>\n<head>\n<meta name=\"viewport\" charset=\"UTF-8\" content=\"initial-scale=1.0, width=device-width\" />\n<%= javascript_include_tag 'https://js.api.here.com/v3/3.1/mapsjs-core.js' %>\n<%= javascript_include_tag 'https://js.api.here.com/v3/3.1/mapsjs-service.js' %>\n<%= javascript_include_tag 'https://js.api.here.com/v3/3.1/mapsjs-ui.js' %>\n<%= javascript_include_tag 'https://js.api.here.com/v3/3.1/mapsjs-mapevents.js' %> \n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://js.api.here.com/v3/3.1/mapsjs-ui.css\"/>\n\n</head>\n<body>\n<div style=\"width: 100vw; height: 100vh\" id=\"mapContainer\"></div>\n<%= javascript_pack_tag 'my_js' %>\n</body>\n</html> Add the above HTML code in index.html.erb file. The javascript_pack_tag helps in importing a specific JS file, in our scenario, my_js. Adding JavaScript We need to add a JavaScript file in the packs' directory. The javascript_pack_tag should also refer to the name of the JavaScript file you created. Create a JavaScript file named my_js.js in the app/javascript/packs directory app/javascript/packs directory/my_js.js var platform = new H.service.Platform({ \n    apikey: \"HERE_API_KEY\"    \n}); \n\nconst lat = 52.5; \nconst lng = 13.4; \n\n// Obtain the default map types from the platform object: \nvar defaultLayers = platform.createDefaultLayers(); \n\n// Your current position \nvar myPosition = {lat: lat, lng: lng}; \n\n// Instantiate (and display) a map object: \nvar map = new H.Map( \n    document.getElementById('mapContainer'), \n    defaultLayers.vector.normal.map, \n    { \n        zoom: 11, \n        center: myPosition \n    }); \n\nvar ui = H.ui.UI.createDefault(map, defaultLayers, 'en-US'); \nvar mapEvents = new H.mapevents.MapEvents(map); \nvar behavior = new H.mapevents.Behavior(mapEvents); \n\nconst marker = new H.map.Marker({lat: lat, lng: lng}); \n\nmap.addObject(marker); \n\nmarker.addEventListener('tap', function(evt) { \n\n// Create an info bubble object at a specific geographic location: \nvar bubble = new H.ui.InfoBubble({ lng: lng, lat: lat }, { \n        content: ' Ruby on Rails ' \n     }); \n// Add info bubble to the UI: \nui.addBubble(bubble); \n\nconst marker = new H.map.Marker({lat: lat, lng: lng});\nmap.addObject(marker);\n}); In the above code, you need to provide your API key in place of HERE_API_KEY. Open http://localhost:3000 and you will get a HERE map with a marker over Berlin, Germany. You can change the lat and lng value in the my_js.js file to get the location of your choice. This concludes our blog on rendering HERE maps using Ruby on Rails. Now you have all the ingredients to quickly build a location-based web application.", "date": "2021-04-19"},
{"website": "Here", "title": "HERE Workspace & Marketplace 2.26 release", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/here-workspace-marketplace-2.26-release", "abstract": "Highlights Improved platform resource management using platform projects Fine-grained access control to resources in a project: Use the Command Line Interface (CLI) to apply pre-configured platform policies or create and apply custom policies to manage fine-grained access to platform project resources by project members (apps, users, groups). For example, a pre-configured platform policy would allow you to give a member of your project access to all catalogs in your project with read-only access. If you need a project member to have read-only access to a single, specific catalog in your project, you can create and apply a custom policy for that. Sharing pipeline templates between projects: Use the CLI to share your project's pipeline templates with other projects in your realm and to link pipeline templates from other projects to your own project. Introducing HERE Data SDK for Python v2.0 A new improved HERE Data SDK for Python v2.0 is now available which has been refactored for easier use. This SDK allows for exploration, analysis, and visualization of HERE data in your own environment, accelerating your analysis and machine learning on large-scale location data. Installation and use is now easier as you can pick and choose which packages are relevant for your use. An improved HERE Data SDK for Python V2 Developer Guide now includes a usage guide section with code examples for the various packages and operations supported. Packages include: HERE Platform: Includes all core operations for interacting with HERE platform catalogs, layers, projects, and schemas HERE Geotiles: Includes support methods for tile/partition calculations in different tiling schemes HERE Inspector: Component to visualize and inspect geometric objects from within Jupyter using ipyleaflet HERE GeoPandas Adaptor: Adapts the functionality of HERE Platform and HERE Geotiles for seamless use with pandas/GeoPandas data structures Reduced cache warmup time in Flink pipelines when using Optimized Map for Location Library We implemented a content-based improvement as part of the overall processing performance enhancements we are working on. Since version 2170 (World), 69 (Japan) and 24 (China) of the Optimised Map for Location Library (OMLL), the geometry layer contains more pre-computed data in order to reduce the map loading time. In many cases this results in approximately 10% reduced OMLL cache warmup time in Flink pipelines. Monetize your external service via HERE Marketplace API Proxy Server The Marketplace API Proxy Service has launched . Enhancements in this release include a US location for the proxy server as well as performance improvements to minimize latency added by the proxy server. You can monetize an external service via the HERE Marketplace external API proxy while the service continues to run in your own environment. Contact your account representative to learn more. Changes, additions and known issues SDKs and tools To see details of all changes to the CLI , Data SDKs for Python , TypeScript , C++ , Java and Scala as well as to the Data Inspector Library , visit the HERE platform changelog . Web and portal Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue : In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Projects and access management Known issue : A set number of access tokens (~250) is available for each app or user. Depending on the number of resources included, this number may be smaller. Workaround: Create a new app or user if you reach the limit. Known issue: A set number of permissions is allowed for each app or user in the system across all services. This will be reduced depending on the inclusion of resources and types of permissions. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the users in a pipeline group only to those who should have full control over the pipeline. Known issue : When updating permissions, it can take up to an hour for the changes to take effect. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace, not the Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project that are intended for use in both Workspace and Marketplace. Data Known issue: In support of the Object Store layer type, a newer version of the Blob API (blob v2) is available in production. The availability of this newer Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Because multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you intend to work with. To support existing workflows until you can correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue : The \"Upload data\" button available via \"More\" within the versioned layer details page is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue : The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to s chema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of data is not yet supported inside HERE Workspace for the following layer types: index, object store and interactive map. Pipelines Deprecation reminder: The batch-2.0.0 environment will soon be removed as its deprecation period has ended. It would be best to migrate your batch pipelines to the batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. Added: Read-only permissions were added to the pipeline template's permission model to enable sharing of pipeline templates between projects. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Marketplace (Not available in China) Known issue: When adding an Interactive Map layer to a Marketplace catalog and offer with a subscription option, the subscription reporting doesn't generate usage metrics. Workaround: Subscription reporting will support Interactive Map layer type in future releases. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace. Summary of active deprecation notices This lists only deprecation notices for APIs that are not part of the HERE platform changelog . For those APIs that are covered by the changelog you can filter by ' deprecated ' to list all deprecation notices. No. Feature Summary Deprecation Period Announced (Platform Release) Deprecation Period Announced (Month) Deprecation Period End 1 OrgID added to Catalog HRN (RoW) 2.9 (ROW) 2.10 (China) November 2019 June 30, 2021 (extended) Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way. · Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after this deprecation period. · Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before this date so your workflows continue to work. · HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after this date. · Examples of old and new Catalog HRN formats: · Old (without OrgID/realm): hrn:here:data:::my-catalog · New (with OrgID/realm): hrn:here:data::OrgID:my-catalog 2 Batch-2.0.0 run-time environment for Pipelines 2.12 February 2020 August 19, 2020 (past due) Deprecation Summary: The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . 3 Schema validation to be added 2.13 March 2020 June 30, 2021 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations after this deprecation period. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before the deprecation period end. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. 4 Stream-2.0.0 run-time environment for Pipelines 2.17 July 2020 February 1, 2021 (past due) Deprecation Summary: Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . 5 ‘pipeline_jobs_canceled’ metric in Pipeline Status Dashboard 2.17 July 2020 February 1, 2021 (past due) Deprecation Summary: The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. 6 Monitoring stability improvements 2.20 October 2020 April 30, 2021 Deprecation Summary: The \" kubernetes_namespace \" metric has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this metric to use the \" namespace \" metric. The label_values(label) function has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboard queries using this function to use label_values(metric, label) The datasource \" <Realm>-master-prometheus-datasource \" has been deprecated and will be supported until April 30, 2021. Update all Grafana dashboards using this datasource to use the Primary datasource. 7 Additional support to help distinguish Blob API versions in Lookup API responses 2.22 December 2020 June 30, 2021 Deprecation Summary: Because multiple versions of different Data APIs exist, it's important that your automated workflows that request service endpoints from Lookup API are updated to select the right baseUrls for the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions in responses over the next 6 months, starting January 2021. To prevent downtime, update your workflow automation during this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version.", "date": "2021-04-21"},
{"website": "Here", "title": "Data API - changes, deprecations and known issues", "author": ["Jeff Henning"], "link": "https://developer.here.com/blog/data-api-changes-deprecations-and-known-issues", "abstract": "Summary of changes May 2021 Added: Rate limits are now in place for interactive map layers. Learn more here: Data Limits and Cost Updated: Ingest API has been updated to support CORS (cross-origin requests and data transfers) to support integrations with browser-based applications. Learn more here: Ingest API February 2021 Added: Upload your data to Object Store layers using Hadoop FS We have added two new tutorials explaining how to publish data to Object Store layers in a distributed fashion using Hadoop FS. One shows how to do this from Spark and an other one shows how to do this in standalone mode . Typically, you would use one or the other when writing data to an Object Store layer that you have stored in AWS S3 or Microsoft Azure. January 2021 Added: A new Interactive Map layer type is available to store and manipulate data on a feature level (not available in China with this release) For those of you familiar with HERE Data Hub as a storage/service solution available via the HERE Developer Portal , this new interactive map layer introduces that same storage concept to HERE Workspace where you can work with data at a more granular feature level, modifying individual geofeatures or even feature properties instead of full partitions. You can also request different tiling schemas at the time of request, including quadkey/Virtual Earth, Web Mercator, OSGEO Tile Map Service and HEREtile. This release includes integration support via API only with integrated visualization capabilities forthcoming. This feature is not yet available in China. Learn more about this interactive map layer storage solution here Create a layer . Fixed: The blobfs library has been updated to correctly list both directories and files. You can now successfully read a single file from an Object Store layer using the blobfs library without including the respective directory path in the request. December 2020 Added: A new Object Store layer type is available to store objects without requiring HERE partitions HERE Workspace now supports Object Storage as a new layer type . Read, write, update, delete and list objects stored in Object Store layers via any of the Data interfaces with exception of the Portal. Portal support, including a file system view and data inspection/visualization, will be delivered at a later time. A Hadoop File System interface-based connector is also provided with this solution in the form of a new component of the Data Client Library. This library enables you to access data stored in this layer via any tooling which supports HDFS. The combined solution of storage + library enables you to store objects in HERE Workspace without requiring HERE partitions and reduces custom code necessary to access your stored data from outside HERE Workspace. Note: The rollout of this new storage type introduces a new version of the Blob API (data-blob-v2). In order to leverage Object Storage directly via API, you must use this new version. The preexisting API (data-blob-v1) will continue to exist. See more information here . Changed: The Data Stream API and the Data Client Library are now integrated with OAUTH2. OAUTH2 mitigates the need for Kafka data producers and consumers to restart whenever authentication tokens are refreshed, which was the case with the prior version of authentication. Such restarts can drive data duplication in streaming data workflows, therefore this update is intended to address that issue. October 2020 Changed: Change layer configurations after a layer is created to correct mistakes without needing to delete and recreate the layer It is now possible to edit certain layer configurations after a layer has been created and even after the parent catalog as been marked as \"Marketplace Ready\". This change was made to ease certain changes, mostly to the advantage of developers when making configuration mistakes during layer creation or who want to change the configuration during CI/CD testing. It is important to note that making certain layer configuration changes after data is stored in the layer and/or after the parent catalog is available in Marketplace is very risky and can lead to irrecoverable impacts on data. Such changes should be made with great caution and understanding of the ramifications. Learn more here . The following configurations are now mutable via API, Data Client Library and CLI after a layer has been created: Stream layer configurations: Throughput, retention (TTL), content type, content encoding (compression) and schema association. Index layer configurations: Retention (TTL) and schema association Versioned layer configurations: Schema association Volatile layer configuration changes as well as support for this functionality via the Portal will be delivered in a future release. September 2020 Performance: Set granular Stream layer throughput configurations to optimize performance and cost Set more granular stream layer throughput configurations so that you can better optimize your stream layer storage based on your use case and budget needs.  When creating a Stream layer, you are only charged for the \"In\" throughput.  With this release, you can create new Stream layers with \"In\" throughput in 100 KB/s increments.  Please see more specific details about this change here . Note: G oing forward and in order to maintain backward compatibility with older Data Client Library versions, you will see Stream throughput numbers in MB/s and rounded down when requesting layer configuration information using older clients.  Example:  If you are using a Data Client Library version less than the latest version released with this HERE Workspace release AND you request Stream layer throughput configuration AND you set your Stream layer \"In\" throughput to 100 KB/s, you will see a response of \"0\".  This response is explained in HERE Workspace documentation here .  Conversely, If you are using the latest SDK version available with this release, you will see the accurate \"In\" throughput of 100 KB/s for this example. Please, take note of the corresponding deprecation announcement at the end of these release notes. Added: You can upload data directly from your local machine to a data layer using the \"Upload data\" button in the data layer user interface. July 2020 Added: Use Direct Kafka metrics to better monitor and debug streaming data workflows. Underlying Kafka Producer, Kafka Consumer \"Fetch\" and Direct Kafka connectivity related metrics are now accessible via the Data Client Library for data workflows with Flink and when using the Direct Kafka connector type (only). These metrics can be used to create custom dashboards in Grafana. Underlying Kafka Consumer metrics are also available for programmatic retrieval. With these metrics, you have more information to help you monitor and debug any of your streaming data workflows using Direct Kafka. Learn more here . Added: Add Stream layers to multi-region configured catalogs as an additional data loss mitigation strategy This release supports adding Stream layers to multi-region catalogs. With this addition, it is possible to include Versioned, Volatile and Stream storage layers to multi-region catalogs. Catalogs can be configured to be multi-region upon initial catalog configuration/creation. Data stored in multi-region catalogs is replicated to a second region mitigating data loss in the event the primary region experiences a downtime event. Note: Additional charges apply: Storage charges double when storing data in a second region. Data I/O charges increase 2.5 to 4 times, depending on the size of the objects you’re uploading: less for fewer large objects, more for many small objects. This is due to the validation HERE performs to ensure successful replication. Learn more about multi-region catalogs and associated costs here . Fixed: Issues with Metadata Storage billing were resolved where Metadata Storage tied to the use of Versioned and Index layers was not being charged / appearing on customer invoices. This fix will result in those charges now correctly appearing on invoices. Note that no storage costs have increased; associated increases in invoices are simply due to these charges now getting billed correctly. May 2020 Added: Parallelize stream data consumption. Setting a partition parallelization parameter for Stream layers is supported via the Data Client Library and the CLI, making this configuration now possible across the following Data interfaces in total (API, Portal, CLI, Data Client Library). This granular control can help you scale your stream data consumption per your use case needs by enabling more data consumers to consume your stream data in parallel. Summary of currently active deprecation notices Feature Summary: OrgID added to catalog HRN (RoW) Deprecation period announced: November 2019 Deprecation period end: June 30, 2021 (extended) Deprecation Summary: Catalog HRNs without OrgID will no longer be supported in any way. Referencing catalogs and all other interactions with REST APIs using the old HRN format without OrgID OR by CatalogID will stop working after this deprecation period. Please ensure all HRN references in your code are updated to use Catalog HRNs with OrgID before this date so your workflows continue to work. HRN duplication to ensure backward compatibility of Catalog version dependencies resolution will no longer be supported after this date. Examples of old and new Catalog HRN formats: Old (without OrgID/realm): hrn:here:data:::my-catalog New (with OrgID/realm): hrn:here:data::OrgID:my-catalog Feature Summary: Schema validation to be added Deprecation period announced: March 2020 Deprecation period end: June 30, 2021 Deprecation Summary: For security reasons, the platform will start validating schema reference changes in layer configurations after this deprecation period. Schema validation will check if the user or application trying to make a layer configuration change has at least read access to the existing schema associated with that layer (i.e., a user or application cannot reference or use a schema they do not have access to). If the user or application does not have access to a schema associated with any layer after this date, attempts to update configurations of that layer will fail until the schema association or permissions are corrected. Make sure all layers refer only to real, current schemas - or have no schema reference at all - before the deprecation period end. It's possible to use the Config API to remove or change schemas associated with layers to resolve these invalid schema/layer associations. Also, any CI/CD jobs referencing non-existent or inaccessible schemas need to be updated by this date, or they will fail. Feature Summary: Additional support to help distinguish Blob API versions in Lookup API responses Deprecation period announced: December 2020 Deprecation period end: June 30, 2021 Deprecation Summary: Because multiple versions of different Data APIs exist, it's important that your automated workflows that request service endpoints from Lookup API are updated to select the right baseUrls for the right API and API version you are working with. As some existing customer workflow automation is not yet updated to select the right baseUrls from the Lookup API responses, the Look Up API will return multiple Blob API V1 baseUrls in various positions in responses over the next 6 months, starting January 2021. To prevent downtime, update your workflow automation during this deprecation period to select the right baseUrl from Lookup API responses based on the right API and API version. Summary of current known issues Known issue: In support of the Object Store layer type, a newer version of the Blob API (blob v2) is available in production. The availability of this newer Blob API version can impact existing workflows if developers use Lookup API to get a list of all provided endpoints for a given resource BUT do not select the right baseUrl based on the right API and API version. Because multiple versions of the same API exist, Lookup API responses will include specific URLs per API version. Workaround: Always select the right baseUrl from Lookup API responses based on the API and API version that you intend to work with. To support existing workflows until you can correct your API selection logic, the Lookup API will return multiple Blob API v1 baseUrls in various positions in responses for the next 6 months, starting January 2021. Please see the deprecation summary at the end of these release notes for more information. Known issue : The \"Upload data\" button available via \"More\" within the versioned layer details page is hidden when the \"Content encoding\" field in the layer is set to \"gzip\". Workaround: Files (including .zip files) can still be uploaded and downloaded as long as the \"Content encoding\" field is set to \"Uncompressed\". Known issue: The changes released with 2.9 (RoW) and with 2.10 (China) - for adding OrgIDs to catalog HRNs - and with 2.10 (Global) - for adding OrgIDs to schema HRNs - could impact any use case (CI/CD or other) where comparisons are made between HRNs used by various workflow dependencies.  For example, requests to compare HRNs that a pipeline is using with those to which a group, user or app has permissions will result in errors if the comparison is expecting results to match the old HRN construct. With this change, data APIs will return only the new HRN construct, which includes the OrgID, e.g. olp-here…, so a comparison between the old HRN and the new HRN will fail. Reading from and writing to catalogs using old HRNs will continue to work until this functionality is deprecated (see deprecation notice summary). Referencing old schema HRNs will continue to work indefinitely. Workaround: Update any workflows comparing HRNs to perform the comparison against the new HRN construct, including the OrgID. Known issue : Searching for a schema in the platform portal using the old HRN construct returns only the latest version of the schema. The portal won't show older versions associated with the old HRN. Workaround: Search for schemas using the new HRN construct, or look up older versions of schemas using the old HRN construct in the CLI. Known issue : Visualization of data is not yet supported inside HERE Workspace for the following layer types: index, object store and interactive map.", "date": "2021-05-19"},
{"website": "Here", "title": "HERE Developer Offerings for the Non-Developer", "author": ["Raymond Camden"], "link": "https://developer.here.com/blog/here-developer-offerings-for-the-non-developer", "abstract": "HERE has an incredibly powerful set of tools for developers, but what if you’re not a developer, or just not very familiar with developer terms? Well, with you in mind, we’re presenting an overview of our developer offerings, specifically written for non-developers. How It's Done Nearly all (with some notable exceptions we'll cover below) of our services are API based. API (Application Programming Interface) is a way for one computer to speak to another. You can think of it as a computer saying, \"I offer information about the weather, you simply need to tell me your zip code.\" A developer reads that and then knows how to write code to send a zip code to the other computer. This is all done via network calls so that that one side doesn't need to know how the other side is built. This means if your company is a Java shop, Python, .Net, or any other language, it simply won't matter. When your developer's code makes the request, the computer responds in such a way that the data can be consumed on your platform. The end result is your environment becoming stronger, as it utilizes the power of HERE technology. What Can Be Done We'll link to a full list of our services towards the end of this article, but in broad strokes, our APIs cover: Geocoding - the process of turning an address into a precise latitude and longitude. You can also reverse this by asking what's at a precise location. Search - given a location, what can be found near by? Our search services have incredibly deep layers of filtering. For example, you can search for Asian food, or maybe you want Chinese food specifically, or actually what you want is Jiangsu cuisine. Routing - essentially how to go from one place to another, but our routing services can support many different types of routing, perhaps even some you've never heard of. We recently covered this on our developer blog. Fleet Telematics - services related to companies that need to manage multiple vehicles. Live Sense - support for enabling real time detection of obstacles. Useful for automated vehicles. Tour Planning - helps find the best routes for fleets of vehicles doing deliveries with unique constraints. Traffic - reports on current data conditions and can estimate future conditions based on past data Weather - important information for routing - will it be raining when you get there? That's a broad look at our APIs, but there's other aspects to our offerings as well. Powerful Web-based Mapping We refer to this as our JavaScript Maps product, but you can think of it as maps for the web. Our beautiful maps have multiple styling options as well as full support for customization. Want to render your locations on a map? You can do that. Want to render a route for the user from their location to the closest store? Also possible. And these are just a few of the options available. Our maps product works in all browsers and supports every possible user interaction. We even support non-interactive maps. They can be featured as simple images that can be used in emails or display-enabled voice assistants. All of this is backed by yet another API that gives you access to particular map tile information for complete customization. Powerful Web-based Map Building Sticking with a theme that’s closely connected to the last section of this post, we’d also like to discuss HERE Studio . HERE Studio lets developers and non-developers alike use a simple web interface to build interactive maps that can be shared with others. If you've got existing data and need to quickly render it on a map, HERE Studio makes it as simple as you can imagine. Once you've designed your map, you can then share a link to it or get the embed code for use on your web site. HERE Studio has a powerful free tier with some nice options at the paid level. Data Storage (More exciting than it sounds!) As we said above, HERE Studio lets you upload data to create beautiful interactive maps. Where does that data go? Data Hub is our geospatial cloud database solution. There are plenty of places to store data online, but what makes Data Hub especially attractive is its fine-tuned geospatial APIs. So along with just simple \"storage\" of your data you also have the ability find out, \"which features are close to this location\" or \"If I go on a route from A to B, which of my features will be nearby?\" Basically, imagine a database built for the world of mapping. Mobile Support To compliment the APIs and products we've shared above, we also have great support for both iOS and Android. Our mobile SDKs make it easy to add integration into your native mobile applications and there are multiple versions of every SDK, each meeting different needs. (Please note: we recently added Flutter support as well!) Additional Options (and where to go next...) So there we have it! This post covered some of the high level items available to developers but there's even more of course. For example, HERE is supported on AWS, Azure, MuleSoft, and and SAP. These integrations help simplify the process of working with HERE and if you are already on those platforms, your developers will have an easier time adding support for location related applications. To learn more (or if you simply want your developer to get started right away), head over to https://developer.here.com and sign up for a free account today!", "date": "2021-02-25"},
{"website": "Here", "title": "May 2021 Release Announcement", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/may-2021-release-announcement", "abstract": "Highlights New aligned release communication covering all HERE platform products For better discoverability of new features across the platform, we are bringing together the release announcements covering Location Services, HERE SDK, Workspace, Studio, and Marketplace . We will typically publish the blog announcement and send the email in the third week of the month. Location Service customers may notice that the time frame we report about has shifted. In the past, we communicated changes that happened in the last calendar month. In the revamped communication we report important changes since the last announcement. Workspace and Marketplace customers will notice that the announcement versioning that they may have become accustomed to will be dropped. We will simply call it by the name of the month. The Data SDK for Java and Scala will continue to carry that version numbering for the purpose of dependency management in form of the Bill Of Materials (BOMs) files. You will also notice that we have slimmed down the announcement to focus on the big changes. From now on, detailed changes, deprecations, and known issues of Data API, Pipeline API, and Marketplace will be published in separate release notes. Like for all the other APIs, you can find links to these release notes at the end of this post. Improve localization in your client via the new HERE HD GNSS Positioning & HERE A GNSS Positioning API The new HERE GNSS Service is offered for various types of client devices to make it possible for them to: Shorten the time needed to get the first GNSS-based position estimate both in online and offline mode. Achieve continuous position tracking with much weaker signal levels both in online and offline mode. Reduce power consumption by reducing the time it takes to calculate the current position both in online and offline mode. Improve the overall GNSS position estimate accuracy to sub-meter range in online mode. Inspect 3D data and inspect multiple layers at the same time Data Inspector, the platform's tool used to inspect data exactly as it is stored in our versioned and volatile layers, and its accompanying Data Inspector Library, which allows you to configure the tool for embedding in your own web applications, is adding two new features. It now supports visualizations in 3D, which means that the map can be tilted. Further, the user can choose to project all 3D attributes, like elevation, height and altitude, to be represented by GeoJSON's altitude (for example through the use of the rendering plugin) and viewed in 3D-space. Also new in Data Inspector is the ability to show multiple layers. You can now add multiple versioned or volatile layers so that you can compare different data sources visually on the map. You may also import local partition layers or local GeoJSON files as an extra layer. Every layer will automatically be assigned a different color, which then can be customized by the user. Try out 3D and multi-layer support on https://platform.here.com/data-inspector . Find a route indoors with HERE Maps API for JavaScript The HERE Maps API for JavaScript supports the integration of Venue Maps for map display. With the latest release, the integration of indoor routing enables the calculation of the route within private and public venues. Read more ... Browse and subscribe to HERE Map Content in Marketplace M arketplace Consumers can now browse and subscribe to HERE map content. Once entitlements are granted, Marketplace Consumers can download this content through the Download Center on the HERE Platform. Changes, additions, deprecations, and known issues This blog post focuses on highlights. However, a lot more has happened since our last announcement. Our APIs, SDKs, and tools publish their detailed API level changes in form of changelogs or release notes. For the recent changes, refer to the corresponding changelog or release notes directly: HERE Map Rendering HERE Map Tile API HERE Vector Tile API HERE Map Image API HERE Maps API for JavaScript HERE Geocding & Search HERE Geocoding & Search API HERE Batch Geocoder API HERE Routing HERE Routing API HERE Isoline Routing API HERE Matrix Routing API HERE Waypoints Sequence API HERE Route Matching API HERE Advanced Datasets API HERE Real-time Traffic HERE Traffic API HERE Transit HERE Public Transit API HERE Intermodal Routing API HERE Positioning HERE Network Positioning API HERE HD GNSS Positioning & HERE A GNSS Positioning API HERE SDK for Android Explore Edition Navigate Edition Premium Edition Lite Edition HERE SDK for IOS Explore Edition Navigate Edition Premium Edition Lite Edition HERE SDK for Flutter Explore Edition Navigate Edition Data API Pipeline API Marketplace Tools CLI Data Inspector Library Data SDKs Data SDKs for Java & Scala Data SDKs for Python , Data SDKs for TypeScript Data SDKs for C++", "date": "2021-05-20"},
{"website": "Here", "title": "Electric Vehicle Features in the HERE SDKs for Android, iOS, and Flutter", "author": ["Richard Süselbeck"], "link": "https://developer.here.com/blog/electric-vehicle-features-in-the-here-sdks-for-android-ios-and-flutter", "abstract": "It’s been over a year now since we released the latest version of the HERE SDKs for iOS, Android, and Flutter. Since then, we’ve added even more cool new features and capabilities. Today I want to highlight some of those features, specifically those focused on use cases for electric vehicles. In this blog post we will look at how to: Using the routing feature for electric vehicles Determine the reachable area of an electric vehicle given a remaining range or battery charge Search for charging stations along a route Before we get started, I want to point out that you can see all of these features in action in our “EVRouting” example in on GitHub . Go ahead and grab this for a running demo plus full code of everything we will be talking about below. Electric Vehicle Routing Let’s get started with the Routing API. A call to the Routing API in EV mode is fundamentally the same as any other call to the Routing API, except that we are using an EVCarOptions object to define the vehicle parameters. This does turn out to be a little more involved than usually, as there are quite a few parameters we can set. Here’s an example for setting the parameters in EVCarOptions . (Note that this example is for Android, but all the features discussed here are also available on the HERE SDKs for Flutter and iOS.) EVCarOptions evCarOptions = new EVCarOptions();\n\nevCarOptions.consumptionModel.ascentConsumptionInWattHoursPerMeter = 9;\nevCarOptions.consumptionModel.descentRecoveryInWattHoursPerMeter = 4.3;\nevCarOptions.consumptionModel.freeFlowSpeedTable = new HashMap<Integer, Double>() {{\n    put(0, 0.239);\n    put(27, 0.239);\n    put(60, 0.196);\n    put(90, 0.238);\n}};\n\nevCarOptions.ensureReachability = true;\n\nevCarOptions.routeOptions.optimizationMode = OptimizationMode.FASTEST;\nevCarOptions.routeOptions.alternatives = 0;\nevCarOptions.batterySpecifications.connectorTypes =\n        new ArrayList<ChargingConnectorType>(Arrays.asList(ChargingConnectorType.TESLA,\n                ChargingConnectorType.IEC_62196_TYPE_1_COMBO, ChargingConnectorType.IEC_62196_TYPE_2_COMBO));\nevCarOptions.batterySpecifications.totalCapacityInKilowattHours = 80.0;\nevCarOptions.batterySpecifications.initialChargeInKilowattHours = 10.0;\nevCarOptions.batterySpecifications.targetChargeInKilowattHours = 72.0;\nevCarOptions.batterySpecifications.chargingCurve = new HashMap<Double, Double>() {{\n    put(0.0, 239.0);\n    put(64.0, 111.0);\n    put(72.0, 1.0);\n}}; The first three parameters are required to make any EV routing call. The free flow table defines the energy consumption of the vehicle as a curve using pairs of speed (km/h) and consumption (Wh/m) values. In addition, the ascent consumption and descent recovery values indicate what effect inclines have on the battery (in Wh/m). By default, the Routing API will assume that you have enough charge to reach any given destination. Given that range anxiety and charging infrastructure are still issues, we may also want to take the vehicles battery charge and the location of compatible charging points into account. That why thingsget interesting when you turn on ensureReachability . With this parameter, the Routing API will automatically route you to charging points where necessary and even take the charging time into account when calculating arrival time. Neat! However, when using this feature, you must provide some additional parameters. These include the total capacity of the battery (in kWh), the charging connector types available on the vehicle, and a battery charging curve. This curve is provided as a list of charging rate (in kW), charge level (in kWh) pairs. In addition, you must provide an initial charge level and a target charge level. These are the respective battery charge levels at the first and last waypoints. (Providing a target charge level ensures you don’t strand your users at their destination with an empty battery.) Check out the SDK documentation for full details on these parameters. The API Reference of the underlying Routing REST API can also be helpful. EV Reachability The range of EVs remains a major concern, both when purchasing and using electric vehicles. The Isoline Routing feature of the SDKs allows you to calculate the area an EV can reach given a current battery level. Let’s say you are in the city center Berlin and you want to calculate which area you can potentially reach with an energy budget of 400 Wh. Once again, using Isoline Routing based on battery charge is very similar to making a standard Isoline Routing call. In fact, you can check out my recent blog post on Isoline Routing with Android for details on how to do this. The only thing we need to change is the range type in the calculation options and provide an appropriate value for battery charge. Here’s a complete example of how to call the Isoline Routing feature with a consumption-based range type. List<Integer> rangeValues = Collections.singletonList(400);\n\nInteger maxPoints = null;\nIsolineOptions.Calculation calculationOptions =\n        new IsolineOptions.Calculation(IsolineRangeType.CONSUMPTION_IN_WATT_HOURS, rangeValues, IsolineCalculationMode.BALANCED, maxPoints);\nIsolineOptions isolineOptions = new IsolineOptions(calculationOptions, getEVCarOptions());\n\nroutingEngine.calculateIsoline(new Waypoint(startGeoCoordinates), isolineOptions, new CalculateIsolineCallback() {\n    @Override\n    public void onIsolineCalculated(RoutingError routingError, List<Isoline> list) {\n        if (routingError != null) {\n            showDialog(\"Error while calculating reachable area:\", routingError.toString());\n            return;\n        }\n\n        Isoline isoline = list.get(0);\n\n        for (GeoPolygon geoPolygon : isoline.getPolygons()) {\n            Color fillColor = Color.valueOf(0, 0.56f, 0.54f, 0.5f); // RGBA\n            MapPolygon mapPolygon = new MapPolygon(geoPolygon, fillColor);\n            mapView.getMapScene().addMapPolygon(mapPolygon);\n            mapPolygons.add(mapPolygon);\n        }\n    }\n}); Note that this example shows how to visualize the reachable area on the map, however you can also use the result to match the area against a list of possible customers in a delivery use case, to find charging stations inside the area, and much more. Charging Stations Along a Route As we’ve seen above, the Routing API will automatically search for charging points along a route and even integrate them into the route for you if necessary. However, what if we have a given route and want to search for charging points manually? That is where the Search feature of the SDK comes in handy. In addition to searching near a given location, or within a bounding box, it also allows us to search along a GeoCorridor . This corridor can be defined by a GeoPolyline and a radius (in meters). Of course, this is useful for everything from gas stations to restaurants, but in the example below we will search for charging points. int radiusInMeters = 200;\nGeoCorridor routeCorridor = new GeoCorridor(route.getPolyline(), radiusInMeters);\nTextQuery textQuery = new TextQuery(\"charging station\", routeCorridor,\n        mapView.getCamera().getState().targetCoordinates);\n\nint maxItems = 30;\nSearchOptions searchOptions = new SearchOptions(LanguageCode.EN_US, maxItems);\nsearchEngine.search(textQuery, searchOptions, new SearchCallback() {\n    @Override\n    public void onSearchCompleted(SearchError searchError, List<Place> items) {\n        if (searchError != null) {\n            if (searchError == SearchError.POLYLINE_TOO_LONG) {                        \n                Log.d(\"Search\", \"Route too long or route corridor radius too small.\");\n            } else {\n                Log.d(\"Search\", \"No charging stations found along the route. Error: \" + searchError);\n            }\n            return;\n        }\n        \n        Log.d(\"Search\",\"Search along route found \" + items.size() + \" charging stations:\");\n        for (Place place : items) {\n            if (chargingStationsIDs.contains(place.getId())) {\n                Log.d(\"Search\", \"Skipping: This charging station was already required to reach the destination.\");\n            } else {\n        \n                addCircleMapMarker(place.getGeoCoordinates(), R.drawable.charging);\n                Log.d(\"Search\", place.getAddress().addressText);\n            }\n        }\n    }\n}); First, we define a GeoCorridor by providing our route as a polyline (which we could get from the Routing API or any other data source) and the search radius of 200m. This means that we will only search for results which are no more than 200 meters away from our route. Then we simply provide this corridor as a search area for a TextQuery and make a normal search request using this query. I’ll close with another reminder to check out the “EVRouting” example on GitHub . Also check out our Routing API Demo Client . While this uses the underlying REST API and not the SDK directly, it is a great way to experiment with the various charge and battery parameters, visualize the curves, and see how they affect the routing results.", "date": "2021-05-18"},
{"website": "Here", "title": "Marketplace - changes and known issues", "author": ["Torsten Linz"], "link": "https://developer.here.com/blog/marketplace-changes-and-known-issues", "abstract": "Summary of changes April 2021 Added: Monetize your external service via HERE Marketplace API Proxy Server The Marketplace API Proxy Service has launched. Enhancements in this release include a US location for the proxy server as well as performance improvements to minimize latency added by the proxy server. You can monetize an external service via the HERE Marketplace external API proxy while the service continues to run in your own environment. Contact your account representative to learn more. March 2021 Fixed: Subscription reporting now works (i.e. usage metrics are generated) for object store layers when added to catalogs in Marketplace. February 2021 Added: You can edit or cancel a previously set subscription deactivation due date by going to an active subscription detail page and click on \"Change expiry date\". Added: You can view a list of your invited customers on your provider listing view until the invitations are accepted. May 2020 Added: You can offer a service listing that is hosted in your own environment to HERE Marketplace consumers by integrating with our External Service Gateway. Contact your account manager to learn more. Summary of current known issues Known issue: When adding an Interactive Map layer to a Marketplace catalog and offer with a subscription option, the subscription reporting doesn't generate usage metrics. Workaround: Subscription reporting will support Interactive Map layer type in future releases. Known issue : There is no throttling for the beta version of the External Service Gateway. When the system is overloaded, the service slows down for everyone reading from the External Service Gateway. Workaround : Contact HERE support for help. Known issue : When the Technical Accounting component is busy, the server can lose usage metrics. Workaround: If you suspect you're losing usage metrics, contact HERE support to get help with rerunning queries and validating data. Known issue : Projects and all resources in a project are designed for use only in HERE Workspace and not available for use in HERE Marketplace. For example, a catalog created in a platform project can only be used in that project. It can't be marked as \"Marketplace-ready\" nor be listed in the Marketplace. Workaround: Don't create catalogs in a project if intended only for use in the Marketplace.", "date": "2021-05-20"},
{"website": "Here", "title": "Pipeline API - changes, deprecations and known issues", "author": ["Jorge Zapata"], "link": "https://developer.here.com/blog/pipeline-api-changes-deprecations-and-known-issues", "abstract": "Summary of changes April 2021 Added: Read-only permissions were added to the pipeline template's permission model to enable sharing of pipeline templates between projects. March 2021 Added: Manage your organization's pipelines and pipeline templates Organization admins can now manage all the pipelines and pipeline templates within their Org and perform all the actions that the original pipeline author can perform, including but not limited to: Deactivate, cancel or delete a pipeline created by anybody within the Org Delete a pipeline template created by anybody within the Org Activate a pipeline created by anybody within the Org Added: All Pipeline APIs now accept UUID or HRN of pipelines and pipeline templates as path parameter. Added: HRNs for Pipeline and Pipeline Template now include the Realm name to help in quickly identifying the realm of the Pipeline and Pipeline Template. August 2020 Added: Ensure business continuity with Multi-region setup for Pipelines For a pipeline that requires minimum downtime, use the Multi-region option while creating the pipeline version so that when the primary region fails, the pipeline version gets automatically transferred to the secondary region. Just switch on the Multi-region option within the Web Portal or use the \"--multi-region\" flag via the CLI. Note: For a pipeline to work successfully in the secondary region, the input and output catalogs used by the pipeline should be available in the secondary region. Note: For a Stream pipeline to successfully utilize the multi-region option, it's important to enable Checkpointing within the code to allow Flink to take a periodic Savepoint while running the pipeline in the primary region. When the primary region fails, the last available Savepoint is used to restart the pipeline in the secondary region. Note: For a Batch pipeline, the Spark History details are also transferred during a region failure. Note: The state of an on-demand Batch pipeline is not transferred and it will need to be manually re-activated. July 2020 Added: Develop Stream Pipelines with Apache Flink 1.10.1 for better control over the memory configuration of Workers. A new Stream-3.0.0 run-time environment with Apache Flink 1.10.1 is now available for creating Stream pipelines. With Stream-3.0.0, the Memory Model of Task Managers has changed in order to provide more control over the memory configuration of the Workers of a Stream pipeline. Include version 2.17 of the HERE Data SDK for Java & Scala in your pipeline project to start developing with this new environment and choose Stream-3.0.0 as the run-time environment while creating a pipeline version. Deprecated: The Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . June 2020 Performance: Reduced Stream Pipeline downtime during Upgrade and Restart. The downtime experienced during a Stream pipeline's Upgrade or Restart has been reduced to under 30 seconds, delivering a 50% improvement that is important for critical stream processing. Summary of currently active deprecation notices Deprecated: Batch-2.0.0 run-time environment for pipelines (Deprecation period announced: February 2020 / Deprecation period end: August 19, 2020 (past due)) The deprecation period is over and Batch-2.0.0 will be removed soon. Pipelines still using it will be canceled. Migrate your batch pipelines to the Batch-2.1.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating a batch pipeline to the new Batch-2.1.0 run-time environment, see Migrate Pipeline to new Run-time Environment . Deprecated: Stream-2.0.0 run-time environment for pipelines (Deprecation period announced: July 2020 / Deprecation period end: February 1, 2021 (past due)) Stream-2.0.0 (with Apache Flink 1.7.1) run-time environment is now deprecated. Existing stream pipelines that use the Stream-2.0.0 run-time environment will continue to operate normally until February 1, 2021. During this time, Stream-2.0.0 run-time environment will receive security patches only. For this period, to continue developing pipelines with the Stream-2.0.0 environment, use platform SDK 2.16 or older. After February 1, 2021, the Stream-2.0.0 run-time environment will be removed and pipelines using it will be canceled. Migrate your stream pipelines to the new Stream-3.0.0 run-time environment to benefit from the latest functionality and improvements. For more details about migrating an existing stream pipeline to the new Stream-3.0.0 run-time environment, see Migrate Pipeline to new Run-time Environment . For general support for Apache Flink, please see Stream Pipelines - Apache Flink Support FAQ . Deprecated: pipeline_jobs_canceled metric in pipeline status dashboard (Deprecation period announced: July 2020 / Deprecation period end: February 1, 2021 (past due)) The pipeline_jobs_canceled metric used in the pipeline status dashboard is now deprecated because it was tied to the pause functionality and caused confusion. The metric and its explanation will be available to use until February 1, 2021. Thereafter, the metric will be removed. Summary of current known issues Known issue: Pipeline templates can't be deleted from the platform portal UI. Workaround: Use the CLI or API to delete pipeline templates. Known issue: In the platform portal, new jobs and operations are not automatically added to the list of jobs and operations for a pipeline version when the list is open for viewing. Workaround: Refresh the \"Jobs\" and \"Operations\" pages to see the latest job or operation in the list. Known issue : A pipeline failure or exception can sometimes take several minutes to respond. Known issue : Pipelines can still be activated after a catalog is deleted. Workaround: The pipeline will fail when it starts running and show an error message about the missing catalog. Find the missing catalog or use a different one. Known issue : If several pipelines are consuming data from the same stream layer and belong to the same group (pipeline permissions are managed through a group), then each pipeline will only receive a subset of the messages from the stream. This is because, by default, the pipelines share the same application ID. Workaround: Use the Data Client Library to configure your pipelines so they consume from a single stream. If your pipelines/apps use the Direct Kafka connector, you can specify a Kafka Consumer group ID per pipeline/application.  If the Kafka consumer group IDs are unique, the pipelines/apps can consume all the messages from the stream. If your pipelines use the HTTP connector, create a new group for each pipeline/app, each with its own app ID. Known issue : All users and apps in a group are granted permissions to perform all actions on any pipeline associated with that group. There's no support for users or apps with limited permissions. For example, you can't have a role that is limited to viewing pipeline statuses, but not starting and stopping a pipeline. Workaround: Limit the users in a pipeline group only to those who should have full control over the pipeline.", "date": "2021-05-20"},
{"website": "Here", "title": "How Movingdots Enriches Telematics Solution Using HERE", "author": ["Michael Palermo"], "link": "https://developer.here.com/blog/how-movingdots-enriches-location-data-using-here", "abstract": "Telematics technologies are used in many applications today, such as simple navigation support, supply chain, and fleet management. Many vertical solutions take advantage of telematics. This post will spotlight Movingdots and their modular end-to-end telematics app solution for developing usage-based motor insurance products. Specifically, we will focus on how the solution leverages location services from HERE to enrich the experience. First, let's get a little history on Movingdots . Founded in 1999 in Berne, Germany, Movingdots became a pioneer in the German telematics industry. Since 2015, the company is a fully owned and operated subsidiary of Swiss Re and serves as its technology hub in the automotive and mobility space. In the early days, Movingdots used reverse geocoding in their fleet solution, enriching raw coordinates with address data visualized on a map. Matrix routing was also used for route optimization. In 2013, Movingdots entered the telematics space and started ingesting road types. After the acquisition by Swiss Re , Movingdots began the development of Coloride . Coloride is a modular end-to-end telematics app solution for developing usage-based motor insurance products. By collecting data from drivers' smartphones, Coloride calculates a driver score which is based on four components: Distraction monitors aspects of the driver's use of phone Speeding tracks time where speed limit exceeded and deltas Maneuvers tracks a wide range of simple and complex maneuvers Context observes time of day, traffic, urban vs. non-urban areas The score can be used to engage users with a flexible, module-based gamification approach to use the app more and be a safer driver. We recently asked Andreas Oellien, Head of Operations and Application Management at Movingdots to share a few details about their use of HERE location services in their solutions. For example, which of our APIs were used to help create the street visual in the screen capture below: The answer we received offered a sneak peek at a code sample they use which contributes to making the above visualization possible. The following python call makes use of HERE's route matching API : def get_RME_response2(GPSFile, attributesRME=\"LINK_ATTRIBUTE_FCn(PHYSICAL_NUM_LANES,TO_REF_NUM_LANES,FROM_REF_NUM_LANES,URBAN,LANE_CATEGORY,DIVIDER,DIVIDER_LEGAL,INTERSECTION_CATEGORY,SPEED_CATEGORY,FUNCTIONAL_CLASS,PAVED,PRIVATE,RAMP,CONTROLLED_ACCESS,ROUTE_TYPES,ISO_COUNTRY_CODE),ROAD_GEOM_FCn(LONG_HAUL,BRIDGE,TUNNEL),ROAD_ADMIN_FCn(ADMIN_PLACE_IDS,POSTAL_CODES,ISO_COUNTRY_CODE)\"):\n headersRME = {'Content-type': 'application/binary'}\n baseUrlRME = \"https://rme.api.here.com/2/matchroute.json?app_id=\" + app_id + \"&app_code=\" + app_code\n attributesRME1 = \"&routemode=car&attributes=\" + attributesRME\n urlRME1 = baseUrlRME + attributesRME1\n responseRME1 = requests.post(urlRME1, data=GPSFile, headers=headersRME)\n responseObjRME1 = responseRME1.json()\n \n return responseObjRME1 The above code makes it possible to keep the tracked coordinates visually precise on the roads. We also asked Andreas about how they factored user privacy in their design, and he replied: \"We act as a service provider and provide our customers with pseudonymized data only. In our infrastructure, position data and data enriched by HERE are strictly separated from personal data and stored in different storages. Position data is therefore only associated to unique UserIDs, which the customer would not be able to resolve in the end.\" Andreas' tips for developers: \"A general tip for developers is to create a login for the HERE developer portal so to get full access to documentation and, through the portal, be able to test all the APIs available and start coding.\" Movingdots uses several HERE APIs to help make their solution successful. Check out which HERE APIs could make your solution a successful app or service. Don't hesitate to get started today!", "date": "2021-05-17"}
]